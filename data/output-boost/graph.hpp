
  static two_bit_color_type white() { return two_bit_white; }

  static two_bit_color_type gray()  { return two_bit_gray; }

  static two_bit_color_type green() { return two_bit_green; }

  static two_bit_color_type black() { return two_bit_black; }


  explicit two_bit_color_map(std::size_t n, const IndexMap& index = IndexMap())
    : n(n), index(index), data(new unsigned char[(n + elements_per_char - 1) / elements_per_char])
  {
    // Fill to white
    std::fill(data.get(), data.get() + (n + elements_per_char - 1) / elements_per_char, 0);
  }


template<typename IndexMap>
inline two_bit_color_type
get(const two_bit_color_map<IndexMap>& pm, 
    typename property_traits<IndexMap>::key_type key) 
{
  BOOST_STATIC_CONSTANT(int, elements_per_char = two_bit_color_map<IndexMap>::elements_per_char);
  typename property_traits<IndexMap>::value_type i = get(pm.index, key);
  BOOST_ASSERT ((std::size_t)i < pm.n);
  std::size_t byte_num = i / elements_per_char;
  std::size_t bit_position = ((i % elements_per_char) * 2);
  return two_bit_color_type((pm.data.get()[byte_num] >> bit_position) & 3);
}


template<typename IndexMap>
inline void
put(const two_bit_color_map<IndexMap>& pm, 
    typename property_traits<IndexMap>::key_type key,
    two_bit_color_type value)
{
  BOOST_STATIC_CONSTANT(int, elements_per_char = two_bit_color_map<IndexMap>::elements_per_char);
  typename property_traits<IndexMap>::value_type i = get(pm.index, key);
  BOOST_ASSERT ((std::size_t)i < pm.n);
  BOOST_ASSERT (value >= 0 && value < 4);
  std::size_t byte_num = i / elements_per_char;
  std::size_t bit_position = ((i % elements_per_char) * 2);
    pm.data.get()[byte_num] =
      (unsigned char)
        ((pm.data.get()[byte_num] & ~(3 << bit_position))
         | (value << bit_position));
}


template<typename IndexMap>
inline two_bit_color_map<IndexMap>
make_two_bit_color_map(std::size_t n, const IndexMap& index_map)
{
  return two_bit_color_map<IndexMap>(n, index_map);
}


    small_world_iterator() : gen(0) {}


    reference operator*() const { return current; }

    pointer operator->() const { return &current; }


    small_world_iterator& operator++()
    {
      target = (target + 1) % n;
      if (target == (source + k/2 + 1) % n) {
        ++source;
        if (allow_self_loops) target = source;
        else target = (source + 1) % n;
      }
      current.first = source;

      uniform_01<RandomGenerator, double> rand01(*gen);
      uniform_int<vertices_size_type> rand_vertex_gen(0, n-1);
      double x = rand01();
      *gen = rand01.base(); // GRRRR
      if (x < prob) {
        vertices_size_type lower = (source + n - k/2) % n;
        vertices_size_type upper = (source + k/2) % n;
        do {
          current.second = rand_vertex_gen(*gen);
        } while ((current.second >= lower && current.second <= upper)
                 || (upper < lower
                     && (current.second >= lower || current.second <= upper)));
      } else {
        current.second = target;
      }
      return *this;
    }


    small_world_iterator operator++(int)
    {
      small_world_iterator temp(*this);
      ++(*this);
      return temp;
    }


    bool operator==(const small_world_iterator& other) const
    {
      if (!gen && other.gen) return other == *this;
      else if (gen && !other.gen) return source == n;
      else if (!gen && !other.gen) return true;
      return source == other.source && target == other.target;
    }


    bool operator!=(const small_world_iterator& other) const
    { return !(*this == other); }

    void next()
    {
      uniform_int<vertices_size_type> rand_vertex(0, n-1);
      current.first = rand_vertex(*gen);
      do {
        current.second = rand_vertex(*gen);
      } while (current.first == current.second && !allow_self_loops);
    }

        compare_multiplicity(Invariant1 invariant1, size_type* multiplicity)
          : invariant1(invariant1), multiplicity(multiplicity) { }

        bool operator()(const vertex1_t& x, const vertex1_t& y) const {
          return multiplicity[invariant1(x)] < multiplicity[invariant1(y)];
        }

        record_dfs_order(std::vector<vertex1_t>& v, std::vector<edge1_t>& e) 
          : vertices(v), edges(e) { }

    
        void discover_vertex(vertex1_t v, const Graph1&) const {
          vertices.push_back(v);
        }

        void examine_edge(edge1_t e, const Graph1&) const {
          edges.push_back(e);
        }

        edge_cmp(const Graph1& G1, DFSNumMap dfs_num)
          : G1(G1), dfs_num(dfs_num) { }

        bool operator()(const edge1_t& e1, const edge1_t& e2) const {
          using namespace std;
          int u1 = dfs_num[source(e1,G1)], v1 = dfs_num[target(e1,G1)];
          int u2 = dfs_num[source(e2,G1)], v2 = dfs_num[target(e2,G1)];
          int m1 = (max)(u1, v1);
          int m2 = (max)(u2, v2);
          // lexicographical comparison 
          return std::make_pair(m1, std::make_pair(u1, v1))
            < std::make_pair(m2, std::make_pair(u2, v2));
        }

      isomorphism_algo(const Graph1& G1, const Graph2& G2, IsoMapping f,
                       Invariant1 invariant1, Invariant2 invariant2, std::size_t max_invariant,
                       IndexMap1 index_map1, IndexMap2 index_map2)
        : G1(G1), G2(G2), f(f), invariant1(invariant1), invariant2(invariant2),
          max_invariant(max_invariant),
          index_map1(index_map1), index_map2(index_map2)
      {
        in_S_vec.resize(num_vertices(G1));
        in_S = make_safe_iterator_property_map
          (in_S_vec.begin(), in_S_vec.size(), index_map2
#ifdef BOOST_NO_STD_ITERATOR_TRAITS
           , in_S_vec.front()
#endif /* BOOST_NO_STD_ITERATOR_TRAITS */
           );
      }

    
      bool test_isomorphism()
      {
        // reset isomapping
        BGL_FORALL_VERTICES_T(v, G1, Graph1)
          f[v] = graph_traits<Graph2>::null_vertex();
          
        {
          std::vector<invar1_value> invar1_array;
          BGL_FORALL_VERTICES_T(v, G1, Graph1)
            invar1_array.push_back(invariant1(v));
          sort(invar1_array);
        
          std::vector<invar2_value> invar2_array;
          BGL_FORALL_VERTICES_T(v, G2, Graph2)
            invar2_array.push_back(invariant2(v));
          sort(invar2_array);
          if (! equal(invar1_array, invar2_array))
            return false;
        }
        
        std::vector<vertex1_t> V_mult;
        BGL_FORALL_VERTICES_T(v, G1, Graph1)
          V_mult.push_back(v);
        {
          std::vector<size_type> multiplicity(max_invariant, 0);
          BGL_FORALL_VERTICES_T(v, G1, Graph1)
            ++multiplicity.at(invariant1(v));
          sort(V_mult, compare_multiplicity(invariant1, &multiplicity[0]));
        }
        
        std::vector<default_color_type> color_vec(num_vertices(G1));
        safe_iterator_property_map<std::vector<default_color_type>::iterator,
                                   IndexMap1
#ifdef BOOST_NO_STD_ITERATOR_TRAITS
                                   , default_color_type, default_color_type&
#endif /* BOOST_NO_STD_ITERATOR_TRAITS */
                                   >
          color_map(color_vec.begin(), color_vec.size(), index_map1);
        record_dfs_order dfs_visitor(dfs_vertices, ordered_edges);
        typedef color_traits<default_color_type> Color;
        for (vertex_iter u = V_mult.begin(); u != V_mult.end(); ++u) {
          if (color_map[*u] == Color::white()) {
            dfs_visitor.start_vertex(*u, G1);
            depth_first_visit(G1, *u, dfs_visitor, color_map);
          }
        }
        // Create the dfs_num array and dfs_num_map
        dfs_num_vec.resize(num_vertices(G1));
        dfs_num = make_safe_iterator_property_map(dfs_num_vec.begin(),
                                                  dfs_num_vec.size(), 
                                                  index_map1
#ifdef BOOST_NO_STD_ITERATOR_TRAITS
                                                  , dfs_num_vec.front()
#endif /* BOOST_NO_STD_ITERATOR_TRAITS */
                                                  );
        size_type n = 0;
        for (vertex_iter v = dfs_vertices.begin(); v != dfs_vertices.end(); ++v)
          dfs_num[*v] = n++;
        
        sort(ordered_edges, edge_cmp(G1, dfs_num));
        
    
        int dfs_num_k = -1;
        return this->match(ordered_edges.begin(), dfs_num_k);
      }


      bool match(edge_iter iter, int dfs_num_k)
      {
        std::vector<match_continuation> k;
        typedef typename graph_traits<Graph2>::vertex_iterator vertex_iterator;
        std::pair<vertex_iterator, vertex_iterator> G2_verts(vertices(G2));
        typedef typename graph_traits<Graph2>::adjacency_iterator adjacency_iterator;
        std::pair<adjacency_iterator, adjacency_iterator> fi_adj;
        vertex1_t i, j;

        recur:
        if (iter != ordered_edges.end()) {
          i = source(*iter, G1);
          j = target(*iter, G1);
          if (dfs_num[i] > dfs_num_k) {
            G2_verts = vertices(G2);
            while (G2_verts.first != G2_verts.second) {
              {
                vertex2_t u = *G2_verts.first;
                vertex1_t kp1 = dfs_vertices[dfs_num_k + 1];
                if (invariant1(kp1) == invariant2(u) && in_S[u] == false) {
                  {
                    f[kp1] = u;
                    in_S[u] = true;
                    num_edges_on_k = 0;
                    
                    match_continuation new_k;
                    new_k.position = match_continuation::pos_G2_vertex_loop;
                    new_k.G2_verts = G2_verts;
                    new_k.iter = iter;
                    new_k.dfs_num_k = dfs_num_k;
                    k.push_back(new_k);
                    ++dfs_num_k;
                    goto recur;
                  }
                }
              }
G2_loop_k:    ++G2_verts.first;
            }
               
          }
          else if (dfs_num[j] > dfs_num_k) {
            {
              vertex1_t vk = dfs_vertices[dfs_num_k];
              num_edges_on_k -= 
                count_if(adjacent_vertices(f[vk], G2), make_indirect_pmap(in_S));
                  
              for (int jj = 0; jj < dfs_num_k; ++jj) {
                vertex1_t j = dfs_vertices[jj];
                num_edges_on_k -= count(adjacent_vertices(f[j], G2), f[vk]);
              }
            }
                
            if (num_edges_on_k != 0)
              goto return_point_false;
            fi_adj = adjacent_vertices(f[i], G2);
            while (fi_adj.first != fi_adj.second) {
              {
                vertex2_t v = *fi_adj.first;
                if (invariant2(v) == invariant1(j) && in_S[v] == false) {
                  f[j] = v;
                  in_S[v] = true;
                  num_edges_on_k = 1;
                  BOOST_USING_STD_MAX();
                  int next_k = max BOOST_PREVENT_MACRO_SUBSTITUTION(dfs_num_k, max BOOST_PREVENT_MACRO_SUBSTITUTION(dfs_num[i], dfs_num[j]));
                  match_continuation new_k;
                  new_k.position = match_continuation::pos_fi_adj_loop;
                  new_k.fi_adj = fi_adj;
                  new_k.iter = iter;
                  new_k.dfs_num_k = dfs_num_k;
                  ++iter;
                  dfs_num_k = next_k;
                  k.push_back(new_k);
                  goto recur;
                }
              }
fi_adj_loop_k:++fi_adj.first;
            }
          }
          else {
            if (container_contains(adjacent_vertices(f[i], G2), f[j])) {
              ++num_edges_on_k;
              match_continuation new_k;
              new_k.position = match_continuation::pos_dfs_num;
              k.push_back(new_k);
              ++iter;
              goto recur;
            }
                
          }
        } else 
          goto return_point_true;
        goto return_point_false;
    
        {
          return_point_true: return true;

          return_point_false:
          if (k.empty()) return false;
          const match_continuation& this_k = k.back();
          switch (this_k.position) {
            case match_continuation::pos_G2_vertex_loop: {G2_verts = this_k.G2_verts; iter = this_k.iter; dfs_num_k = this_k.dfs_num_k; k.pop_back(); in_S[*G2_verts.first] = false; i = source(*iter, G1); j = target(*iter, G1); goto G2_loop_k;}
            case match_continuation::pos_fi_adj_loop: {fi_adj = this_k.fi_adj; iter = this_k.iter; dfs_num_k = this_k.dfs_num_k; k.pop_back(); in_S[*fi_adj.first] = false; i = source(*iter, G1); j = target(*iter, G1); goto fi_adj_loop_k;}
            case match_continuation::pos_dfs_num: {k.pop_back(); goto return_point_false;}
            default: {
              BOOST_ASSERT(!"Bad position");
#ifdef UNDER_CE
              exit(-1);
#else
              abort();
#endif
            }
          }
        }
      }


    
    template <typename Graph, typename InDegreeMap>
    void compute_in_degree(const Graph& g, InDegreeMap in_degree_map)
    {
      BGL_FORALL_VERTICES_T(v, g, Graph)
        put(in_degree_map, v, 0);

      BGL_FORALL_VERTICES_T(u, g, Graph)
        BGL_FORALL_ADJ_T(u, v, g, Graph)
        put(in_degree_map, v, get(in_degree_map, v) + 1);
    }


    degree_vertex_invariant(const InDegreeMap& in_degree_map, const Graph& g)
      : m_in_degree_map(in_degree_map),
        m_max_vertex_in_degree(0),
        m_max_vertex_out_degree(0),
        m_g(g) {
      BGL_FORALL_VERTICES_T(v, g, Graph) {
        m_max_vertex_in_degree =
          (std::max)(m_max_vertex_in_degree, get(m_in_degree_map, v));
        m_max_vertex_out_degree =
          (std::max)(m_max_vertex_out_degree, out_degree(v, g));
      }
    }


    size_type operator()(vertex_t v) const {
      return (m_max_vertex_in_degree + 1) * out_degree(v, m_g)
        + get(m_in_degree_map, v);
    }

    size_type max BOOST_PREVENT_MACRO_SUBSTITUTION () const { 
      return (m_max_vertex_in_degree + 1) * (m_max_vertex_out_degree + 1);
    }

  template <typename Graph>
  size_t count_vertices(const Graph& g)
  {
      size_t n = 0;
      BGL_FORALL_VERTICES_T(v, g, Graph) {(void)v; ++n;}
      return n;
  }


  template <typename Graph1, typename Graph2, typename IsoMapping, 
    typename Invariant1, typename Invariant2,
    typename IndexMap1, typename IndexMap2>
  bool isomorphism(const Graph1& G1, const Graph2& G2, IsoMapping f, 
                   Invariant1 invariant1, Invariant2 invariant2, 
                   std::size_t max_invariant,
                   IndexMap1 index_map1, IndexMap2 index_map2)

  {
    // Graph requirements
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph1> ));
    BOOST_CONCEPT_ASSERT(( EdgeListGraphConcept<Graph1> ));
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph2> ));
    //BOOST_CONCEPT_ASSERT(( BidirectionalGraphConcept<Graph2> ));
    
    typedef typename graph_traits<Graph1>::vertex_descriptor vertex1_t;
    typedef typename graph_traits<Graph2>::vertex_descriptor vertex2_t;
    typedef typename graph_traits<Graph1>::vertices_size_type size_type;
    
    // Vertex invariant requirement
    BOOST_CONCEPT_ASSERT(( AdaptableUnaryFunctionConcept<Invariant1,
      size_type, vertex1_t> ));
    BOOST_CONCEPT_ASSERT(( AdaptableUnaryFunctionConcept<Invariant2,
      size_type, vertex2_t> ));
    
    // Property map requirements
    BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<IsoMapping, vertex1_t> ));
    typedef typename property_traits<IsoMapping>::value_type IsoMappingValue;
    BOOST_STATIC_ASSERT((is_convertible<IsoMappingValue, vertex2_t>::value));
    
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<IndexMap1, vertex1_t> ));
    typedef typename property_traits<IndexMap1>::value_type IndexMap1Value;
    BOOST_STATIC_ASSERT((is_convertible<IndexMap1Value, size_type>::value));
    
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<IndexMap2, vertex2_t> ));
    typedef typename property_traits<IndexMap2>::value_type IndexMap2Value;
    BOOST_STATIC_ASSERT((is_convertible<IndexMap2Value, size_type>::value));
    
    if (count_vertices(G1) != count_vertices(G2))
      return false;
    if (count_vertices(G1) == 0 && count_vertices(G2) == 0)
      return true;
    
    detail::isomorphism_algo<Graph1, Graph2, IsoMapping, Invariant1,
      Invariant2, IndexMap1, IndexMap2> 
      algo(G1, G2, f, invariant1, invariant2, max_invariant, 
           index_map1, index_map2);
    return algo.test_isomorphism();
  }

  
    template <typename Graph1, typename Graph2, 
      typename IsoMapping, 
      typename IndexMap1, typename IndexMap2,
      typename P, typename T, typename R>
    bool isomorphism_impl(const Graph1& G1, const Graph2& G2, 
                          IsoMapping f, IndexMap1 index_map1, IndexMap2 index_map2,
                          const bgl_named_params<P,T,R>& params)
    {
      std::vector<std::size_t> in_degree1_vec(num_vertices(G1));
      typedef safe_iterator_property_map<std::vector<std::size_t>::iterator,
                                         IndexMap1
#ifdef BOOST_NO_STD_ITERATOR_TRAITS
                                         , std::size_t, std::size_t&
#endif /* BOOST_NO_STD_ITERATOR_TRAITS */
                                         > InDeg1;
      InDeg1 in_degree1(in_degree1_vec.begin(), in_degree1_vec.size(), index_map1);
      compute_in_degree(G1, in_degree1);

      std::vector<std::size_t> in_degree2_vec(num_vertices(G2));
      typedef safe_iterator_property_map<std::vector<std::size_t>::iterator, 
                                         IndexMap2
#ifdef BOOST_NO_STD_ITERATOR_TRAITS
                                         , std::size_t, std::size_t&
#endif /* BOOST_NO_STD_ITERATOR_TRAITS */
                                         > InDeg2;
      InDeg2 in_degree2(in_degree2_vec.begin(), in_degree2_vec.size(), index_map2);
      compute_in_degree(G2, in_degree2);

      degree_vertex_invariant<InDeg1, Graph1> invariant1(in_degree1, G1);
      degree_vertex_invariant<InDeg2, Graph2> invariant2(in_degree2, G2);

      return isomorphism(G1, G2, f,
                         choose_param(get_param(params, vertex_invariant1_t()), invariant1),
                         choose_param(get_param(params, vertex_invariant2_t()), invariant2),
                         choose_param(get_param(params, vertex_max_invariant_t()), (invariant2.max)()),
                         index_map1, index_map2
                         );  
    }

      make_degree_invariant(const G& g, const Index& index): g(g), index(index) {}

      result_type operator()() const {
        prop_map_type pm = make_shared_array_property_map(num_vertices(g), degree_size_type(), index);
        compute_in_degree(g, pm);
        return result_type(pm, g);
      }

        template <typename ArgPack>
        bool operator()(const Graph1& g1, const Graph2& g2, const ArgPack& arg_pack) const {
          using namespace boost::graph::keywords;
          typedef typename boost::detail::override_const_property_result<ArgPack, tag::vertex_index1_map, boost::vertex_index_t, Graph1>::type index1_map_type;
          typedef typename boost::detail::override_const_property_result<ArgPack, tag::vertex_index2_map, boost::vertex_index_t, Graph2>::type index2_map_type;
          index1_map_type index1_map = boost::detail::override_const_property(arg_pack, _vertex_index1_map, g1, boost::vertex_index);
          index2_map_type index2_map = boost::detail::override_const_property(arg_pack, _vertex_index2_map, g2, boost::vertex_index);
          typedef typename graph_traits<Graph2>::vertex_descriptor vertex2_t;
          typename std::vector<vertex2_t>::size_type n = (typename std::vector<vertex2_t>::size_type)num_vertices(g1);
          std::vector<vertex2_t> f(n);
          typename boost::parameter::lazy_binding<
                     ArgPack,
                     tag::vertex_invariant1,
                     boost::detail::make_degree_invariant<Graph1, index1_map_type> >::type
            invariant1 =
              arg_pack[_vertex_invariant1 || boost::detail::make_degree_invariant<Graph1, index1_map_type>(g1, index1_map)];
          typename boost::parameter::lazy_binding<
                     ArgPack,
                     tag::vertex_invariant2,
                     boost::detail::make_degree_invariant<Graph2, index2_map_type> >::type
            invariant2 =
              arg_pack[_vertex_invariant2 || boost::detail::make_degree_invariant<Graph2, index2_map_type>(g2, index2_map)];
          return boost::isomorphism
                   (g1, g2,
                    choose_param(arg_pack[_isomorphism_map | boost::param_not_found()],
                                 make_shared_array_property_map(num_vertices(g1), vertex2_t(), index1_map)),
                    invariant1,
                    invariant2,
                    arg_pack[_vertex_max_invariant | (invariant2.max)()],
                    index1_map,
                    index2_map);
        }











  template<typename Graph1, typename Graph2, typename IsoMap>
  inline bool verify_isomorphism(const Graph1& g1, const Graph2& g2, IsoMap iso_map)
  {
#if 0
    // problematic for filtered_graph!
    if (num_vertices(g1) != num_vertices(g2) || num_edges(g1) != num_edges(g2))
      return false;
#endif
  
    BGL_FORALL_EDGES_T(e1, g1, Graph1) {
      bool found_edge = false;
      BGL_FORALL_EDGES_T(e2, g2, Graph2) {
        if (source(e2, g2) == get(iso_map, source(e1, g1)) &&
            target(e2, g2) == get(iso_map, target(e1, g1))) {
          found_edge = true;
        }
      }
    
      if (!found_edge)
        return false;
    }
  
    return true;
  }

  template<typename VertexListGraph, typename PositionMap, typename Radius>
  void 
  circle_graph_layout(const VertexListGraph& g, PositionMap position,
                      Radius radius)
  {
    BOOST_STATIC_ASSERT (property_traits<PositionMap>::value_type::dimensions >= 2);
    const double pi = boost::math::constants::pi<double>();

#ifndef BOOST_NO_STDC_NAMESPACE
    using std::sin;
    using std::cos;
#endif // BOOST_NO_STDC_NAMESPACE

    typedef typename graph_traits<VertexListGraph>::vertices_size_type 
      vertices_size_type;

    vertices_size_type n = num_vertices(g);
    
    vertices_size_type i = 0;
    double two_pi_over_n = 2. * pi / n;
    BGL_FORALL_VERTICES_T(v, g, VertexListGraph) {
      position[v][0] = radius * cos(i * two_pi_over_n);
      position[v][1] = radius * sin(i * two_pi_over_n);
      ++i;
    }
  }


template<typename Topology,
         typename Graph, typename PositionMap>
void
random_graph_layout
 (const Graph& g, PositionMap position_map,
  const Topology& topology)
{
  BGL_FORALL_VERTICES_T(v, g, Graph) {
    put(position_map, v, topology.random_point());
  }
}

      time_stamper_with_vertex_vector(TimeMap timeMap, VertexVector& v,
                                      TimeT& t)
        : timeStamper_(timeMap, t), v_(v) { }


      template<class Graph>
      void
      operator()(const typename property_traits<TimeMap>::key_type& v,
                 const Graph& g)
      {
        timeStamper_(v, g);
        v_[timeStamper_.m_time] = v;
      }

    template<class TimeMap, class VertexVector, class TimeT, class Tag>
    time_stamper_with_vertex_vector<TimeMap, VertexVector, TimeT, Tag>
    stamp_times_with_vertex_vector(TimeMap timeMap, VertexVector& v, TimeT& t,
                                   Tag)
    {
      return time_stamper_with_vertex_vector<TimeMap, VertexVector, TimeT,
                                             Tag>(timeMap, v, t);
    }

      dominator_visitor(const Graph& g, const Vertex& entry,
                        DomTreePredMap domTreePredMap)
        : semi_(num_vertices(g)),
          ancestor_(num_vertices(g), graph_traits<Graph>::null_vertex()),
          samedom_(ancestor_),
          best_(semi_),
          semiMap_(make_iterator_property_map(semi_.begin(),
                                              get(vertex_index, g))),
          ancestorMap_(make_iterator_property_map(ancestor_.begin(),
                                                  get(vertex_index, g))),
          bestMap_(make_iterator_property_map(best_.begin(),
                                              get(vertex_index, g))),
          buckets_(num_vertices(g)),
          bucketMap_(make_iterator_property_map(buckets_.begin(),
                                                get(vertex_index, g))),
          entry_(entry),
          domTreePredMap_(domTreePredMap),
          numOfVertices_(num_vertices(g)),
          samedomMap(make_iterator_property_map(samedom_.begin(),
                                                get(vertex_index, g)))
      {
      }


      void
      operator()(const Vertex& n, const TimeMap& dfnumMap,
                 const PredMap& parentMap, const Graph& g)
      {
        if (n == entry_) return;

        const Vertex p(get(parentMap, n));
        Vertex s(p);

        // 1. Calculate the semidominator of n,
        // based on the semidominator thm.
        // * Semidominator thm. : To find the semidominator of a node n,
        //   consider all predecessors v of n in the CFG (Control Flow Graph).
        //  - If v is a proper ancestor of n in the spanning tree
        //    (so dfnum(v) < dfnum(n)), then v is a candidate for semi(n)
        //  - If v is a non-ancestor of n (so dfnum(v) > dfnum(n))
        //    then for each u that is an ancestor of v (or u = v),
        //    Let semi(u) be a candidate for semi(n)
        //   of all these candidates, the one with lowest dfnum is
        //   the semidominator of n.

        // For each predecessor of n
        typename graph_traits<Graph>::in_edge_iterator inItr, inEnd;
        for (boost::tie(inItr, inEnd) = in_edges(n, g); inItr != inEnd; ++inItr)
          {
            const Vertex v = source(*inItr, g);
            // To deal with unreachable nodes
            if (get(dfnumMap, v) < 0 || get(dfnumMap, v) >= numOfVertices_)
              continue;

            Vertex s2;
            if (get(dfnumMap, v) <= get(dfnumMap, n))
              s2 = v;
            else
              s2 = get(semiMap_, ancestor_with_lowest_semi_(v, dfnumMap));

            if (get(dfnumMap, s2) < get(dfnumMap, s))
              s = s2;
          }
        put(semiMap_, n, s);

        // 2. Calculation of n's dominator is deferred until
        // the path from s to n has been linked into the forest
        get(bucketMap_, s).push_back(n);
        get(ancestorMap_, n) = p;
        get(bestMap_, n) = n;

        // 3. Now that the path from p to v has been linked into
        // the spanning forest, these lines calculate the dominator of v,
        // based on the dominator thm., or else defer the calculation
        // until y's dominator is known
        // * Dominator thm. : On the spanning-tree path below semi(n) and
        //   above or including n, let y be the node
        //   with the smallest-numbered semidominator. Then,
        //
        //  idom(n) = semi(n) if semi(y)=semi(n) or
        //            idom(y) if semi(y) != semi(n)
        typename std::deque<Vertex>::iterator buckItr;
        for (buckItr = get(bucketMap_, p).begin();
             buckItr != get(bucketMap_, p).end();
             ++buckItr)
          {
            const Vertex v(*buckItr);
            const Vertex y(ancestor_with_lowest_semi_(v, dfnumMap));
            if (get(semiMap_, y) == get(semiMap_, v))
              put(domTreePredMap_, v, p);
            else
              put(samedomMap, v, y);
          }

        get(bucketMap_, p).clear();
      }

      const Vertex
      ancestor_with_lowest_semi_(const Vertex& v, const TimeMap& dfnumMap)
      {
        const Vertex a(get(ancestorMap_, v));

        if (get(ancestorMap_, a) != graph_traits<Graph>::null_vertex())
          {
            const Vertex b(ancestor_with_lowest_semi_(a, dfnumMap));

            put(ancestorMap_, v, get(ancestorMap_, a));

            if (get(dfnumMap, get(semiMap_, b)) <
                get(dfnumMap, get(semiMap_, get(bestMap_, v))))
              put(bestMap_, v, b);
          }

        return get(bestMap_, v);
      }

  template<class Graph, class IndexMap, class TimeMap, class PredMap,
           class VertexVector, class DomTreePredMap>
  void
  lengauer_tarjan_dominator_tree_without_dfs
    (const Graph& g,
     const typename graph_traits<Graph>::vertex_descriptor& entry,
     const IndexMap& /*indexMap*/,
     TimeMap dfnumMap, PredMap parentMap, VertexVector& verticesByDFNum,
     DomTreePredMap domTreePredMap)
  {
    // Typedefs and concept check
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename graph_traits<Graph>::vertices_size_type VerticesSizeType;

    BOOST_CONCEPT_ASSERT(( BidirectionalGraphConcept<Graph> ));

    const VerticesSizeType numOfVertices = num_vertices(g);
    if (numOfVertices == 0) return;

    // 1. Visit each vertex in reverse post order and calculate sdom.
    detail::dominator_visitor<Graph, IndexMap, TimeMap, PredMap, DomTreePredMap>
      visitor(g, entry, domTreePredMap);

    VerticesSizeType i;
    for (i = 0; i < numOfVertices; ++i)
      {
        const Vertex u(verticesByDFNum[numOfVertices - 1 - i]);
        if (u != graph_traits<Graph>::null_vertex())
          visitor(u, dfnumMap, parentMap, g);
      }

    // 2. Now all the deferred dominator calculations,
    // based on the second clause of the dominator thm., are performed
    for (i = 0; i < numOfVertices; ++i)
      {
        const Vertex n(verticesByDFNum[i]);

        if (n == entry || n == graph_traits<Graph>::null_vertex())
          continue;

        Vertex u = get(visitor.samedomMap, n);
        if (u != graph_traits<Graph>::null_vertex())
          {
            put(domTreePredMap, n, get(domTreePredMap, u));
          }
      }
  }

  template<class Graph, class IndexMap, class TimeMap, class PredMap,
           class VertexVector, class DomTreePredMap>
  void
  lengauer_tarjan_dominator_tree
    (const Graph& g,
     const typename graph_traits<Graph>::vertex_descriptor& entry,
     const IndexMap& indexMap,
     TimeMap dfnumMap, PredMap parentMap, VertexVector& verticesByDFNum,
     DomTreePredMap domTreePredMap)
  {
    // Typedefs and concept check
    typedef typename graph_traits<Graph>::vertices_size_type VerticesSizeType;

    BOOST_CONCEPT_ASSERT(( BidirectionalGraphConcept<Graph> ));

    // 1. Depth first visit
    const VerticesSizeType numOfVertices = num_vertices(g);
    if (numOfVertices == 0) return;

    VerticesSizeType time =
      (std::numeric_limits<VerticesSizeType>::max)();
    std::vector<default_color_type>
      colors(numOfVertices, color_traits<default_color_type>::white());
    depth_first_visit
      (g, entry,
       make_dfs_visitor
         (make_pair(record_predecessors(parentMap, on_tree_edge()),
                    detail::stamp_times_with_vertex_vector
                      (dfnumMap, verticesByDFNum, time, on_discover_vertex()))),
       make_iterator_property_map(colors.begin(), indexMap));

    // 2. Run main algorithm.
    lengauer_tarjan_dominator_tree_without_dfs(g, entry, indexMap, dfnumMap,
                                               parentMap, verticesByDFNum,
                                               domTreePredMap);
  }

  template<class Graph, class DomTreePredMap>
  void
  lengauer_tarjan_dominator_tree
    (const Graph& g,
     const typename graph_traits<Graph>::vertex_descriptor& entry,
     DomTreePredMap domTreePredMap)
  {
    // typedefs
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename graph_traits<Graph>::vertices_size_type VerticesSizeType;
    typedef typename property_map<Graph, vertex_index_t>::const_type IndexMap;
    typedef
      iterator_property_map<typename std::vector<VerticesSizeType>::iterator,
                            IndexMap> TimeMap;
    typedef
      iterator_property_map<typename std::vector<Vertex>::iterator, IndexMap>
      PredMap;

    // Make property maps
    const VerticesSizeType numOfVertices = num_vertices(g);
    if (numOfVertices == 0) return;

    const IndexMap indexMap = get(vertex_index, g);

    std::vector<VerticesSizeType> dfnum(numOfVertices, 0);
    TimeMap dfnumMap(make_iterator_property_map(dfnum.begin(), indexMap));

    std::vector<Vertex> parent(numOfVertices,
                               graph_traits<Graph>::null_vertex());
    PredMap parentMap(make_iterator_property_map(parent.begin(), indexMap));

    std::vector<Vertex> verticesByDFNum(parent);

    // Run main algorithm
    lengauer_tarjan_dominator_tree(g, entry,
                                   indexMap, dfnumMap, parentMap,
                                   verticesByDFNum, domTreePredMap);
  }

  template<class Graph, class IndexMap, class DomTreePredMap>
  void
  iterative_bit_vector_dominator_tree
    (const Graph& g,
     const typename graph_traits<Graph>::vertex_descriptor& entry,
     const IndexMap& indexMap,
     DomTreePredMap domTreePredMap)
  {
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename graph_traits<Graph>::vertex_iterator vertexItr;
    typedef typename graph_traits<Graph>::vertices_size_type VerticesSizeType;
    typedef
      iterator_property_map<typename std::vector< std::set<Vertex> >::iterator,
                            IndexMap> vertexSetMap;

    BOOST_CONCEPT_ASSERT(( BidirectionalGraphConcept<Graph> ));

    // 1. Finding dominator
    // 1.1. Initialize
    const VerticesSizeType numOfVertices = num_vertices(g);
    if (numOfVertices == 0) return;

    vertexItr vi, viend;
    boost::tie(vi, viend) = vertices(g);
    const std::set<Vertex> N(vi, viend);

    bool change = true;

    std::vector< std::set<Vertex> > dom(numOfVertices, N);
    vertexSetMap domMap(make_iterator_property_map(dom.begin(), indexMap));
    get(domMap, entry).clear();
    get(domMap, entry).insert(entry);

    while (change)
      {
        change = false;
        for (boost::tie(vi, viend) = vertices(g); vi != viend; ++vi)
          {
            if (*vi == entry) continue;

            std::set<Vertex> T(N);

            typename graph_traits<Graph>::in_edge_iterator inItr, inEnd;
            for (boost::tie(inItr, inEnd) = in_edges(*vi, g); inItr != inEnd; ++inItr)
              {
                const Vertex p = source(*inItr, g);

                std::set<Vertex> tempSet;
                std::set_intersection(T.begin(), T.end(),
                                      get(domMap, p).begin(),
                                      get(domMap, p).end(),
                                      std::inserter(tempSet, tempSet.begin()));
                T.swap(tempSet);
              }

            T.insert(*vi);
            if (T != get(domMap, *vi))
              {
                change = true;
                get(domMap, *vi).swap(T);
              }
          } // end of for (boost::tie(vi, viend) = vertices(g)
      } // end of while(change)

    // 2. Build dominator tree
    for (boost::tie(vi, viend) = vertices(g); vi != viend; ++vi)
      get(domMap, *vi).erase(*vi);

    Graph domTree(numOfVertices);

    for (boost::tie(vi, viend) = vertices(g); vi != viend; ++vi)
      {
        if (*vi == entry) continue;

        // We have to iterate through copied dominator set
        const std::set<Vertex> tempSet(get(domMap, *vi));
        typename std::set<Vertex>::const_iterator s;
        for (s = tempSet.begin(); s != tempSet.end(); ++s)
          {
            typename std::set<Vertex>::iterator t;
            for (t = get(domMap, *vi).begin(); t != get(domMap, *vi).end(); )
              {
        typename std::set<Vertex>::iterator old_t = t;
        ++t; // Done early because t may become invalid
                if (*old_t == *s) continue;
                if (get(domMap, *s).find(*old_t) != get(domMap, *s).end())
                  get(domMap, *vi).erase(old_t);
              }
          }
      }

    for (boost::tie(vi, viend) = vertices(g); vi != viend; ++vi)
      {
        if (*vi != entry && get(domMap, *vi).size() == 1)
          {
            Vertex temp = *get(domMap, *vi).begin();
            put(domTreePredMap, *vi, temp);
          }
      }
  }


  template<class Graph, class DomTreePredMap>
  void
  iterative_bit_vector_dominator_tree
    (const Graph& g,
     const typename graph_traits<Graph>::vertex_descriptor& entry,
     DomTreePredMap domTreePredMap)
  {
    typename property_map<Graph, vertex_index_t>::const_type
      indexMap = get(vertex_index, g);

    iterative_bit_vector_dominator_tree(g, entry, indexMap, domTreePredMap);
  }

      V operator()(U, V v) const { return v; }


    template <class Graph, class P, class T, class R, class Weight>
    inline void
    prim_mst_impl(const Graph& G,
                  typename graph_traits<Graph>::vertex_descriptor s,
                  const bgl_named_params<P,T,R>& params,
                  Weight)
    {
      typedef typename property_traits<Weight>::value_type W;
      std::less<W> compare;
      detail::_project2nd<W,W> combine;
      dijkstra_shortest_paths(G, s, params.distance_compare(compare).
                              distance_combine(combine));
    }


  template <class VertexListGraph, class DijkstraVisitor, 
            class PredecessorMap, class DistanceMap,
            class WeightMap, class IndexMap>
  inline void
  prim_minimum_spanning_tree
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s, 
     PredecessorMap predecessor, DistanceMap distance, WeightMap weight, 
     IndexMap index_map,
     DijkstraVisitor vis)
  {
    typedef typename property_traits<WeightMap>::value_type W;
    std::less<W> compare;
    detail::_project2nd<W,W> combine;
    dijkstra_shortest_paths(g, s, predecessor, distance, weight, index_map,
                            compare, combine, (std::numeric_limits<W>::max)(), 0,
                            vis);
  }


  template <class VertexListGraph, class PredecessorMap,
            class P, class T, class R>
  inline void prim_minimum_spanning_tree
    (const VertexListGraph& g,
     PredecessorMap p_map,
     const bgl_named_params<P,T,R>& params)
  {
    detail::prim_mst_impl
      (g, 
       choose_param(get_param(params, root_vertex_t()), *vertices(g).first), 
       params.predecessor_map(p_map),
       choose_const_pmap(get_param(params, edge_weight), g, edge_weight));
  }


  template <class VertexListGraph, class PredecessorMap>
  inline void prim_minimum_spanning_tree
    (const VertexListGraph& g, PredecessorMap p_map)
  {
    detail::prim_mst_impl
      (g, *vertices(g).first, predecessor_map(p_map).
       weight_map(get(edge_weight, g)),
       get(edge_weight, g));
  }

  template<typename Graph, typename T>
  T
  operator()(typename graph_traits<Graph>::edge_descriptor,
             T k,
             T d,
             const Graph&) const
  {
    return d * d / k;
  }

  template<typename Graph, typename T>
  T
  operator()(typename graph_traits<Graph>::vertex_descriptor,
             typename graph_traits<Graph>::vertex_descriptor,
             T k,
             T d,
             const Graph&) const
  {
    return k * k / d;
  }


  linear_cooling(std::size_t iterations)
    : temp(T(iterations) / T(10)), step(0.1) { }


  T operator()()
  {
    T old_temp = temp;
    temp -= step;
    if (temp < T(0)) temp = T(0);
    return old_temp;
  }

  template<typename Graph, typename ApplyForce >
  void operator()(const Graph& g, ApplyForce apply_force)
  {
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
    vertex_iterator v, end;
    for (boost::tie(v, end) = vertices(g); v != end; ++v) {
      vertex_iterator u = v;
      for (++u; u != end; ++u) {
        apply_force(*u, *v);
        apply_force(*v, *u);
      }
    }
  }


  template<typename Graph>
  explicit
  grid_force_pairs(const Topology& topology,
                   PositionMap position, const Graph& g)
    : topology(topology), position(position)
  {
    two_k = 2. * this->topology.volume(this->topology.extent()) / std::sqrt((double)num_vertices(g));
  }


  template<typename Graph, typename ApplyForce >
  void operator()(const Graph& g, ApplyForce apply_force)
  {
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef std::list<vertex_descriptor> bucket_t;
    typedef std::vector<bucket_t> buckets_t;

    std::size_t columns = std::size_t(topology.extent()[0] / two_k + 1.);
    std::size_t rows = std::size_t(topology.extent()[1] / two_k + 1.);
    buckets_t buckets(rows * columns);
    vertex_iterator v, v_end;
    for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
      std::size_t column =
        std::size_t((get(position, *v)[0] + topology.extent()[0] / 2) / two_k);
      std::size_t row    =
        std::size_t((get(position, *v)[1] + topology.extent()[1] / 2) / two_k);

      if (column >= columns) column = columns - 1;
      if (row >= rows) row = rows - 1;
      buckets[row * columns + column].push_back(*v);
    }

    for (std::size_t row = 0; row < rows; ++row)
      for (std::size_t column = 0; column < columns; ++column) {
        bucket_t& bucket = buckets[row * columns + column];
        typedef typename bucket_t::iterator bucket_iterator;
        for (bucket_iterator u = bucket.begin(); u != bucket.end(); ++u) {
          // Repulse vertices in this bucket
          bucket_iterator v = u;
          for (++v; v != bucket.end(); ++v) {
            apply_force(*u, *v);
            apply_force(*v, *u);
          }

          std::size_t adj_start_row = row == 0? 0 : row - 1;
          std::size_t adj_end_row = row == rows - 1? row : row + 1;
          std::size_t adj_start_column = column == 0? 0 : column - 1;
          std::size_t adj_end_column = column == columns - 1? column : column + 1;
          for (std::size_t other_row = adj_start_row; other_row <= adj_end_row;
               ++other_row)
            for (std::size_t other_column = adj_start_column;
                 other_column <= adj_end_column; ++other_column)
              if (other_row != row || other_column != column) {
                // Repulse vertices in this bucket
                bucket_t& other_bucket
                  = buckets[other_row * columns + other_column];
                for (v = other_bucket.begin(); v != other_bucket.end(); ++v) {
                  double dist =
                    topology.distance(get(position, *u), get(position, *v));
                  if (dist < two_k) apply_force(*u, *v);
                }
              }
        }
      }
  }


template<typename PositionMap, typename Topology, typename Graph>
inline grid_force_pairs<Topology, PositionMap>
make_grid_force_pairs
  (const Topology& topology,
   const PositionMap& position, const Graph& g)
{ return grid_force_pairs<Topology, PositionMap>(topology, position, g); }


template<typename Graph, typename PositionMap, typename Topology>
void
scale_graph(const Graph& g, PositionMap position, const Topology& topology,
            typename Topology::point_type upper_left, typename Topology::point_type lower_right)
{
  if (num_vertices(g) == 0) return;

  typedef typename Topology::point_type Point;
  typedef typename Topology::point_difference_type point_difference_type;

  // Find min/max ranges
  Point min_point = get(position, *vertices(g).first), max_point = min_point;
  BGL_FORALL_VERTICES_T(v, g, Graph) {
    min_point = topology.pointwise_min(min_point, get(position, v));
    max_point = topology.pointwise_max(max_point, get(position, v));
  }

  Point old_origin = topology.move_position_toward(min_point, 0.5, max_point);
  Point new_origin = topology.move_position_toward(upper_left, 0.5, lower_right);
  point_difference_type old_size = topology.difference(max_point, min_point);
  point_difference_type new_size = topology.difference(lower_right, upper_left);

  // Scale to bounding box provided
  BGL_FORALL_VERTICES_T(v, g, Graph) {
    point_difference_type relative_loc = topology.difference(get(position, v), old_origin);
    relative_loc = (relative_loc / old_size) * new_size;
    put(position, v, topology.adjust(new_origin, relative_loc));
  }
}

  template<typename Topology, typename PropMap, typename Vertex>
  void 
  maybe_jitter_point(const Topology& topology,
                     const PropMap& pm, Vertex v,
                     const typename Topology::point_type& p2)
  {
    double too_close = topology.norm(topology.extent()) / 10000.;
    if (topology.distance(get(pm, v), p2) < too_close) {
      put(pm, v, 
          topology.move_position_toward(get(pm, v), 1./200,
                                        topology.random_point()));
    }
  }


    fr_apply_force(const Topology& topology,
                   const PositionMap& position,
                   const DisplacementMap& displacement,
                   RepulsiveForce repulsive_force, double k, const Graph& g)
      : topology(topology), position(position), displacement(displacement),
        repulsive_force(repulsive_force), k(k), g(g)
    { }


    void operator()(vertex_descriptor u, vertex_descriptor v)
    {
      if (u != v) {
        // When the vertices land on top of each other, move the
        // first vertex away from the boundaries.
        maybe_jitter_point(topology, position, u, get(position, v));

        double dist = topology.distance(get(position, u), get(position, v));
        typename Topology::point_difference_type dispv = get(displacement, v);
        if (dist == 0.) {
          for (std::size_t i = 0; i < Point::dimensions; ++i) {
            dispv[i] += 0.01;
          }
        } else {
          double fr = repulsive_force(u, v, k, dist, g);
          dispv += (fr / dist) *
                   topology.difference(get(position, v), get(position, u));
        }
        put(displacement, v, dispv);
      }
    }


template<typename Topology, typename Graph, typename PositionMap, 
         typename AttractiveForce, typename RepulsiveForce,
         typename ForcePairs, typename Cooling, typename DisplacementMap>
void
fruchterman_reingold_force_directed_layout
 (const Graph&    g,
  PositionMap     position,
  const Topology& topology,
  AttractiveForce attractive_force,
  RepulsiveForce  repulsive_force,
  ForcePairs      force_pairs,
  Cooling         cool,
  DisplacementMap displacement)
{
  typedef typename Topology::point_type Point;
  typedef typename graph_traits<Graph>::vertex_iterator   vertex_iterator;
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  typedef typename graph_traits<Graph>::edge_iterator     edge_iterator;

  double volume = topology.volume(topology.extent());

  // assume positions are initialized randomly
  double k = pow(volume / num_vertices(g), 1. / (double)(Topology::point_difference_type::dimensions));

  detail::fr_apply_force<Topology, PositionMap, DisplacementMap,
                         RepulsiveForce, Graph>
    apply_force(topology, position, displacement, repulsive_force, k, g);

  do {
    // Calculate repulsive forces
    vertex_iterator v, v_end;
    for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v)
      put(displacement, *v, typename Topology::point_difference_type());
    force_pairs(g, apply_force);

    // Calculate attractive forces
    edge_iterator e, e_end;
    for (boost::tie(e, e_end) = edges(g); e != e_end; ++e) {
      vertex_descriptor v = source(*e, g);
      vertex_descriptor u = target(*e, g);

      // When the vertices land on top of each other, move the
      // first vertex away from the boundaries.
      ::boost::detail::maybe_jitter_point(topology, position, u, get(position, v));

      typename Topology::point_difference_type delta =
        topology.difference(get(position, v), get(position, u));
      double dist = topology.distance(get(position, u), get(position, v));
      double fa = attractive_force(*e, k, dist, g);

      put(displacement, v, get(displacement, v) - (fa / dist) * delta);
      put(displacement, u, get(displacement, u) + (fa / dist) * delta);
    }

    if (double temp = cool()) {
      // Update positions
      BGL_FORALL_VERTICES_T (v, g, Graph) {
        BOOST_USING_STD_MIN();
        BOOST_USING_STD_MAX();
        double disp_size = topology.norm(get(displacement, v));
        put(position, v, topology.adjust(get(position, v), get(displacement, v) * (min BOOST_PREVENT_MACRO_SUBSTITUTION (disp_size, temp) / disp_size)));
        put(position, v, topology.bound(get(position, v)));
      }
    } else {
      break;
    }
  } while (true);
}

    template<typename Topology, typename Graph, typename PositionMap, 
             typename AttractiveForce, typename RepulsiveForce,
             typename ForcePairs, typename Cooling,
             typename Param, typename Tag, typename Rest>
    static void
    run(const Graph&    g,
        PositionMap     position,
        const Topology& topology,
        AttractiveForce attractive_force,
        RepulsiveForce  repulsive_force,
        ForcePairs      force_pairs,
        Cooling         cool,
        DisplacementMap displacement,
        const bgl_named_params<Param, Tag, Rest>&)
    {
      fruchterman_reingold_force_directed_layout
        (g, position, topology, attractive_force, repulsive_force,
         force_pairs, cool, displacement);
    }

    template<typename Topology, typename Graph, typename PositionMap, 
             typename AttractiveForce, typename RepulsiveForce,
             typename ForcePairs, typename Cooling,
             typename Param, typename Tag, typename Rest>
    static void
    run(const Graph&    g,
        PositionMap     position,
        const Topology& topology,
        AttractiveForce attractive_force,
        RepulsiveForce  repulsive_force,
        ForcePairs      force_pairs,
        Cooling         cool,
        param_not_found,
        const bgl_named_params<Param, Tag, Rest>& params)
    {
      typedef typename Topology::point_difference_type PointDiff;
      std::vector<PointDiff> displacements(num_vertices(g));
      fruchterman_reingold_force_directed_layout
        (g, position, topology, attractive_force, repulsive_force,
         force_pairs, cool,
         make_iterator_property_map
         (displacements.begin(),
          choose_const_pmap(get_param(params, vertex_index), g,
                            vertex_index),
          PointDiff()));
    }


template<typename Topology, typename Graph, typename PositionMap, typename Param,
         typename Tag, typename Rest>
void
fruchterman_reingold_force_directed_layout
  (const Graph&    g,
   PositionMap     position,
   const Topology& topology,
   const bgl_named_params<Param, Tag, Rest>& params)
{
  typedef typename get_param_type<vertex_displacement_t, bgl_named_params<Param,Tag,Rest> >::type D;

  detail::fr_force_directed_layout<D>::run
    (g, position, topology, 
     choose_param(get_param(params, attractive_force_t()),
                  square_distance_attractive_force()),
     choose_param(get_param(params, repulsive_force_t()),
                  square_distance_repulsive_force()),
     choose_param(get_param(params, force_pairs_t()),
                  make_grid_force_pairs(topology, position, g)),
     choose_param(get_param(params, cooling_t()),
                  linear_cooling<double>(100)),
     get_param(params, vertex_displacement_t()),
     params);
}


template<typename Topology, typename Graph, typename PositionMap>
void
fruchterman_reingold_force_directed_layout
  (const Graph&    g,
   PositionMap     position,
   const Topology& topology)
{
  fruchterman_reingold_force_directed_layout
    (g, position, topology,
     attractive_force(square_distance_attractive_force()));
}


  inline bool intersects(double x1, double y1,
                         double x2, double y2,
                         double a1, double b1,
                         double a2, double b2,
                         double epsilon = 0.000001
                         )
  {

    if (x1 - x2 == 0)
      {
        std::swap(x1,a1);
        std::swap(y1,b1);
        std::swap(x2,a2);
        std::swap(y2,b2);
      }

    if (x1 - x2 == 0)
      {
        BOOST_USING_STD_MAX();
        BOOST_USING_STD_MIN();

        //two vertical line segments
        double min_y = min BOOST_PREVENT_MACRO_SUBSTITUTION(y1,y2);
        double max_y = max BOOST_PREVENT_MACRO_SUBSTITUTION(y1,y2);
        double min_b = min BOOST_PREVENT_MACRO_SUBSTITUTION(b1,b2);
        double max_b = max BOOST_PREVENT_MACRO_SUBSTITUTION(b1,b2);
        if ((max_y > max_b && max_b > min_y) ||
            (max_b > max_y && max_y > min_b)
            )
          return true;
        else
          return false;
      }

    double x_diff = x1 - x2;
    double y_diff = y1 - y2;
    double a_diff = a2 - a1;
    double b_diff = b2 - b1;

    double beta_denominator = b_diff - (y_diff/((double)x_diff)) * a_diff;

    if (beta_denominator == 0)
      {
        //parallel lines
        return false;
      }

    double beta = (b2 - y2 - (y_diff/((double)x_diff)) * (a2 - x2)) / 
      beta_denominator;
    double alpha = (a2 - x2 - beta*(a_diff))/x_diff;

    double upper_bound = 1 - epsilon;
    double lower_bound = 0 + epsilon;

    return (beta < upper_bound && beta > lower_bound && 
            alpha < upper_bound && alpha > lower_bound);

  }



  template <typename Graph, 
            typename GridPositionMap, 
            typename VertexIndexMap
            >
  bool is_straight_line_drawing(const Graph& g, 
                                GridPositionMap drawing, 
                                VertexIndexMap
                                )
  {

    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator_t;
    typedef typename graph_traits<Graph>::edge_descriptor edge_t;
    typedef typename graph_traits<Graph>::edge_iterator edge_iterator_t;
    typedef typename graph_traits<Graph>::edges_size_type e_size_t;
    typedef typename graph_traits<Graph>::vertices_size_type v_size_t;

    typedef std::size_t x_coord_t;
    typedef std::size_t y_coord_t;
    typedef boost::tuple<edge_t, x_coord_t, y_coord_t> edge_event_t;
    typedef typename std::vector< edge_event_t > edge_event_queue_t;

    typedef tuple<y_coord_t, y_coord_t, x_coord_t, x_coord_t> active_map_key_t;
    typedef edge_t active_map_value_t;
    typedef std::map< active_map_key_t, active_map_value_t > active_map_t;
    typedef typename active_map_t::iterator active_map_iterator_t;


    edge_event_queue_t edge_event_queue;
    active_map_t active_edges;

    edge_iterator_t ei, ei_end;
    for(boost::tie(ei,ei_end) = edges(g); ei != ei_end; ++ei)
      {
        edge_t e(*ei);
        vertex_t s(source(e,g));
        vertex_t t(target(e,g));
        edge_event_queue.push_back
          (make_tuple(e, 
                      static_cast<std::size_t>(drawing[s].x),
                      static_cast<std::size_t>(drawing[s].y)
                      )
           );
        edge_event_queue.push_back
          (make_tuple(e,
                      static_cast<std::size_t>(drawing[t].x),
                      static_cast<std::size_t>(drawing[t].y)
                      )
           );
      }

    // Order by edge_event_queue by first, then second coordinate 
    // (bucket_sort is a stable sort.)
    bucket_sort(edge_event_queue.begin(), edge_event_queue.end(),
                property_map_tuple_adaptor<edge_event_t, 2>()
                );
    
    bucket_sort(edge_event_queue.begin(), edge_event_queue.end(),
                property_map_tuple_adaptor<edge_event_t, 1>()
                );

    typedef typename edge_event_queue_t::iterator event_queue_iterator_t;
    event_queue_iterator_t itr_end = edge_event_queue.end();
    for(event_queue_iterator_t itr = edge_event_queue.begin(); 
        itr != itr_end; ++itr
        )
      {
        edge_t e(get<0>(*itr));
        vertex_t source_v(source(e,g));
        vertex_t target_v(target(e,g));
        if (drawing[source_v].y > drawing[target_v].y)
          std::swap(source_v, target_v);

        active_map_key_t key(get(drawing, source_v).y,
                             get(drawing, target_v).y,
                             get(drawing, source_v).x,
                             get(drawing, target_v).x
                             );

        active_map_iterator_t a_itr = active_edges.find(key);
        if (a_itr == active_edges.end())
          {
            active_edges[key] = e;
          }
        else
          {
            active_map_iterator_t before, after;
            if (a_itr == active_edges.begin())
              before = active_edges.end();
            else
              before = prior(a_itr);
            after = boost::next(a_itr);

            if (before != active_edges.end())
              {
                
                edge_t f = before->second;
                vertex_t e_source(source(e,g));
                vertex_t e_target(target(e,g));
                vertex_t f_source(source(f,g));
                vertex_t f_target(target(f,g));

                if (intersects(drawing[e_source].x, 
                               drawing[e_source].y,
                               drawing[e_target].x,
                               drawing[e_target].y,
                               drawing[f_source].x, 
                               drawing[f_source].y,
                               drawing[f_target].x,
                               drawing[f_target].y
                               )
                    )
                  return false;
              }

            if (after != active_edges.end())
              {
                
                edge_t f = after->second;
                vertex_t e_source(source(e,g));
                vertex_t e_target(target(e,g));
                vertex_t f_source(source(f,g));
                vertex_t f_target(target(f,g));

                if (intersects(drawing[e_source].x, 
                               drawing[e_source].y,
                               drawing[e_target].x,
                               drawing[e_target].y,
                               drawing[f_source].x, 
                               drawing[f_source].y,
                               drawing[f_target].x,
                               drawing[f_target].y
                               )
                    )
                  return false;
              }

            active_edges.erase(a_itr);

          }
      }

    return true;
    
  }



  template <typename Graph, typename GridPositionMap>
  bool is_straight_line_drawing(const Graph& g, GridPositionMap drawing)
  {
    return is_straight_line_drawing(g, drawing, get(vertex_index,g));
  }

  r_c_shortest_paths_label
  ( const unsigned long n, 
    const Resource_Container& rc = Resource_Container(), 
    const r_c_shortest_paths_label* const pl = 0, 
    const typename graph_traits<Graph>::edge_descriptor& ed = 
      graph_traits<Graph>::edge_descriptor(), 
    const typename graph_traits<Graph>::vertex_descriptor& vd = 
      graph_traits<Graph>::vertex_descriptor() )
  : num( n ), 
    cumulated_resource_consumption( rc ), 
    p_pred_label( pl ), 
    pred_edge( ed ), 
    resident_vertex( vd ), 
    b_is_dominated( false ), 
    b_is_processed( false )
  {}

  r_c_shortest_paths_label& operator=( const r_c_shortest_paths_label& other )
  {
    if( this == &other )
      return *this;
    this->~r_c_shortest_paths_label();
    new( this ) r_c_shortest_paths_label( other );
    return *this;
  }


template<class Graph, class Resource_Container>
inline bool operator==
( const r_c_shortest_paths_label<Graph, Resource_Container>& l1, 
  const r_c_shortest_paths_label<Graph, Resource_Container>& l2 )
{
  return 
    l1.cumulated_resource_consumption == l2.cumulated_resource_consumption;
}


template<class Graph, class Resource_Container>
inline bool operator!=
( const r_c_shortest_paths_label<Graph, Resource_Container>& l1, 
  const r_c_shortest_paths_label<Graph, Resource_Container>& l2 )
{
  return 
    !( l1 == l2 );
}


template<class Graph, class Resource_Container>
inline bool operator<
( const r_c_shortest_paths_label<Graph, Resource_Container>& l1, 
  const r_c_shortest_paths_label<Graph, Resource_Container>& l2 )
{
  return 
    l1.cumulated_resource_consumption < l2.cumulated_resource_consumption;
}


template<class Graph, class Resource_Container>
inline bool operator>
( const r_c_shortest_paths_label<Graph, Resource_Container>& l1, 
  const r_c_shortest_paths_label<Graph, Resource_Container>& l2 )
{
  return 
    l2.cumulated_resource_consumption < l1.cumulated_resource_consumption;
}


template<class Graph, class Resource_Container>
inline bool operator<=
( const r_c_shortest_paths_label<Graph, Resource_Container>& l1, 
  const r_c_shortest_paths_label<Graph, Resource_Container>& l2 )
{
  return 
    l1 < l2 || l1 == l2;
}


template<class Graph, class Resource_Container>
inline bool operator>=
( const r_c_shortest_paths_label<Graph, Resource_Container>& l1, 
  const r_c_shortest_paths_label<Graph, Resource_Container>& l2 )
{
  return l2 < l1 || l1 == l2;
}

  ks_smart_pointer( T* ptt = 0 ) : pt( ptt ) {}

  ks_smart_pointer( const ks_smart_pointer& other ) : pt( other.pt ) {}

  ks_smart_pointer& operator=( const ks_smart_pointer& other )
    { pt = other.pt; return *this; }

  ~ks_smart_pointer() {}

  T& operator*() const { return *pt; }

  T* operator->() const { return pt; }

  T* get() const { return pt; }

  operator T*() const { return pt; }

template<class Graph, 
         class VertexIndexMap, 
         class EdgeIndexMap, 
         class Resource_Container, 
         class Resource_Extension_Function, 
         class Dominance_Function, 
         class Label_Allocator, 
         class Visitor>
void r_c_shortest_paths_dispatch
( const Graph& g, 
  const VertexIndexMap& vertex_index_map, 
  const EdgeIndexMap& /*edge_index_map*/, 
  typename graph_traits<Graph>::vertex_descriptor s, 
  typename graph_traits<Graph>::vertex_descriptor t, 
  // each inner vector corresponds to a pareto-optimal path
  std::vector
    <std::vector
      <typename graph_traits
        <Graph>::edge_descriptor> >& pareto_optimal_solutions, 
  std::vector
    <Resource_Container>& pareto_optimal_resource_containers, 
  bool b_all_pareto_optimal_solutions, 
  // to initialize the first label/resource container 
  // and to carry the type information
  const Resource_Container& rc, 
  Resource_Extension_Function& ref, 
  Dominance_Function& dominance, 
  // to specify the memory management strategy for the labels
  Label_Allocator /*la*/, 
  Visitor vis )
{
  pareto_optimal_resource_containers.clear();
  pareto_optimal_solutions.clear();

  unsigned long i_label_num = 0;
  typedef 
    typename 
      Label_Allocator::template rebind
        <r_c_shortest_paths_label
          <Graph, Resource_Container> >::other LAlloc;
  LAlloc l_alloc;
  typedef 
    ks_smart_pointer
      <r_c_shortest_paths_label<Graph, Resource_Container> > Splabel;
  std::priority_queue<Splabel, std::vector<Splabel>, std::greater<Splabel> > 
    unprocessed_labels;

  bool b_feasible = true;
  r_c_shortest_paths_label<Graph, Resource_Container>* first_label = 
    l_alloc.allocate( 1 );
  l_alloc.construct
    ( first_label, 
      r_c_shortest_paths_label
        <Graph, Resource_Container>( i_label_num++, 
                                     rc, 
                                     0, 
                                     typename graph_traits<Graph>::
                                       edge_descriptor(), 
                                     s ) );

  Splabel splabel_first_label = Splabel( first_label );
  unprocessed_labels.push( splabel_first_label );
  std::vector<std::list<Splabel> > vec_vertex_labels( num_vertices( g ) );
  vec_vertex_labels[vertex_index_map[s]].push_back( splabel_first_label );
  std::vector<typename std::list<Splabel>::iterator> 
    vec_last_valid_positions_for_dominance( num_vertices( g ) );
  for( int i = 0; i < static_cast<int>( num_vertices( g ) ); ++i )
    vec_last_valid_positions_for_dominance[i] = vec_vertex_labels[i].begin();
  std::vector<int> vec_last_valid_index_for_dominance( num_vertices( g ), 0 );
  std::vector<bool> 
    b_vec_vertex_already_checked_for_dominance( num_vertices( g ), false );
  while( !unprocessed_labels.empty()  && vis.on_enter_loop(unprocessed_labels, g) )
  {
    Splabel cur_label = unprocessed_labels.top();
    unprocessed_labels.pop();
    vis.on_label_popped( *cur_label, g );
    // an Splabel object in unprocessed_labels and the respective Splabel 
    // object in the respective list<Splabel> of vec_vertex_labels share their 
    // embedded r_c_shortest_paths_label object
    // to avoid memory leaks, dominated 
    // r_c_shortest_paths_label objects are marked and deleted when popped 
    // from unprocessed_labels, as they can no longer be deleted at the end of 
    // the function; only the Splabel object in unprocessed_labels still 
    // references the r_c_shortest_paths_label object
    // this is also for efficiency, because the else branch is executed only 
    // if there is a chance that extending the 
    // label leads to new undominated labels, which in turn is possible only 
    // if the label to be extended is undominated
    if( !cur_label->b_is_dominated )
    {
      int i_cur_resident_vertex_num = cur_label->resident_vertex;
      std::list<Splabel>& list_labels_cur_vertex = 
        vec_vertex_labels[i_cur_resident_vertex_num];
      if( static_cast<int>( list_labels_cur_vertex.size() ) >= 2 
          && vec_last_valid_index_for_dominance[i_cur_resident_vertex_num] 
               < static_cast<int>( list_labels_cur_vertex.size() ) )
      {
        typename std::list<Splabel>::iterator outer_iter = 
          list_labels_cur_vertex.begin();
        bool b_outer_iter_at_or_beyond_last_valid_pos_for_dominance = false;
        while( outer_iter != list_labels_cur_vertex.end() )
        {
          Splabel cur_outer_splabel = *outer_iter;
          typename std::list<Splabel>::iterator inner_iter = outer_iter;
          if( !b_outer_iter_at_or_beyond_last_valid_pos_for_dominance 
              && outer_iter == 
                   vec_last_valid_positions_for_dominance
                     [i_cur_resident_vertex_num] )
            b_outer_iter_at_or_beyond_last_valid_pos_for_dominance = true;
          if( !b_vec_vertex_already_checked_for_dominance
                [i_cur_resident_vertex_num] 
              || b_outer_iter_at_or_beyond_last_valid_pos_for_dominance )
          {
            ++inner_iter;
          }
          else
          {
            inner_iter = 
              vec_last_valid_positions_for_dominance
                [i_cur_resident_vertex_num];
            ++inner_iter;
          }
          bool b_outer_iter_erased = false;
          while( inner_iter != list_labels_cur_vertex.end() )
          {
            Splabel cur_inner_splabel = *inner_iter;
            if( dominance( cur_outer_splabel->
                             cumulated_resource_consumption, 
                           cur_inner_splabel->
                             cumulated_resource_consumption ) )
            {
              typename std::list<Splabel>::iterator buf = inner_iter;
              ++inner_iter;
              list_labels_cur_vertex.erase( buf );
              if( cur_inner_splabel->b_is_processed )
              {
                l_alloc.destroy( cur_inner_splabel.get() );
                l_alloc.deallocate( cur_inner_splabel.get(), 1 );
              }
              else
                cur_inner_splabel->b_is_dominated = true;
              continue;
            }
            else
              ++inner_iter;
            if( dominance( cur_inner_splabel->
                             cumulated_resource_consumption, 
                           cur_outer_splabel->
                             cumulated_resource_consumption ) )
            {
              typename std::list<Splabel>::iterator buf = outer_iter;
              ++outer_iter;
              list_labels_cur_vertex.erase( buf );
              b_outer_iter_erased = true;
              if( cur_outer_splabel->b_is_processed )
              {
                l_alloc.destroy( cur_outer_splabel.get() );
                l_alloc.deallocate( cur_outer_splabel.get(), 1 );
              }
              else
                cur_outer_splabel->b_is_dominated = true;
              break;
            }
          }
          if( !b_outer_iter_erased )
            ++outer_iter;
        }
        if( static_cast<int>( list_labels_cur_vertex.size() ) > 1 )
          vec_last_valid_positions_for_dominance[i_cur_resident_vertex_num] = 
            (--(list_labels_cur_vertex.end()));
        else
          vec_last_valid_positions_for_dominance[i_cur_resident_vertex_num] = 
            list_labels_cur_vertex.begin();
        b_vec_vertex_already_checked_for_dominance
          [i_cur_resident_vertex_num] = true;
        vec_last_valid_index_for_dominance[i_cur_resident_vertex_num] = 
          static_cast<int>( list_labels_cur_vertex.size() ) - 1;
      }
    }
    if( !b_all_pareto_optimal_solutions && cur_label->resident_vertex == t )
    {
      // the devil don't sleep
      if( cur_label->b_is_dominated )
      {
        l_alloc.destroy( cur_label.get() );
        l_alloc.deallocate( cur_label.get(), 1 );
      }
      while( unprocessed_labels.size() )
      {
        Splabel l = unprocessed_labels.top();
        unprocessed_labels.pop();
        // delete only dominated labels, because nondominated labels are 
        // deleted at the end of the function
        if( l->b_is_dominated )
        {
          l_alloc.destroy( l.get() );
          l_alloc.deallocate( l.get(), 1 );
        }
      }
      break;
    }
    if( !cur_label->b_is_dominated )
    {
      cur_label->b_is_processed = true;
      vis.on_label_not_dominated( *cur_label, g );
      typename graph_traits<Graph>::vertex_descriptor cur_vertex = 
        cur_label->resident_vertex;
      typename graph_traits<Graph>::out_edge_iterator oei, oei_end;
      for( boost::tie( oei, oei_end ) = out_edges( cur_vertex, g ); 
           oei != oei_end; 
           ++oei )
      {
        b_feasible = true;
        r_c_shortest_paths_label<Graph, Resource_Container>* new_label = 
          l_alloc.allocate( 1 );
        l_alloc.construct( new_label, 
                           r_c_shortest_paths_label
                             <Graph, Resource_Container>
                               ( i_label_num++, 
                                 cur_label->cumulated_resource_consumption, 
                                 cur_label.get(), 
                                 *oei, 
                                 target( *oei, g ) ) );
        b_feasible = 
          ref( g, 
               new_label->cumulated_resource_consumption, 
               new_label->p_pred_label->cumulated_resource_consumption, 
               new_label->pred_edge );

        if( !b_feasible )
        {
          vis.on_label_not_feasible( *new_label, g );
          l_alloc.destroy( new_label );
          l_alloc.deallocate( new_label, 1 );
        }
        else
        {
          const r_c_shortest_paths_label<Graph, Resource_Container>& 
            ref_new_label = *new_label;
          vis.on_label_feasible( ref_new_label, g );
          Splabel new_sp_label( new_label );
          vec_vertex_labels[vertex_index_map[new_sp_label->resident_vertex]].
            push_back( new_sp_label );
          unprocessed_labels.push( new_sp_label );
        }
      }
    }
    else
    {
      vis.on_label_dominated( *cur_label, g );
      l_alloc.destroy( cur_label.get() );
      l_alloc.deallocate( cur_label.get(), 1 );
    }
  }
  std::list<Splabel> dsplabels = vec_vertex_labels[vertex_index_map[t]];
  typename std::list<Splabel>::const_iterator csi = dsplabels.begin();
  typename std::list<Splabel>::const_iterator csi_end = dsplabels.end();
  // if d could be reached from o
  if( !dsplabels.empty() )
  {
    for( ; csi != csi_end; ++csi )
    {
      std::vector<typename graph_traits<Graph>::edge_descriptor> 
        cur_pareto_optimal_path;
      const r_c_shortest_paths_label<Graph, Resource_Container>* p_cur_label = 
        (*csi).get();
      pareto_optimal_resource_containers.
        push_back( p_cur_label->cumulated_resource_consumption );
      while( p_cur_label->num != 0 )
      {
        cur_pareto_optimal_path.push_back( p_cur_label->pred_edge );
        p_cur_label = p_cur_label->p_pred_label;
      }
      pareto_optimal_solutions.push_back( cur_pareto_optimal_path );
      if( !b_all_pareto_optimal_solutions )
        break;
    }
  }

  int i_size = static_cast<int>( vec_vertex_labels.size() );
  for( int i = 0; i < i_size; ++i )
  {
    const std::list<Splabel>& list_labels_cur_vertex = vec_vertex_labels[i];
    csi_end = list_labels_cur_vertex.end();
    for( csi = list_labels_cur_vertex.begin(); csi != csi_end; ++csi )
    {
      l_alloc.destroy( (*csi).get() );
      l_alloc.deallocate( (*csi).get(), 1 );
    }
  }
}

  template<class Label, class Graph>
  void on_label_popped( const Label&, const Graph& ) {}

  template<class Label, class Graph>
  void on_label_feasible( const Label&, const Graph& ) {}

  template<class Label, class Graph>
  void on_label_not_feasible( const Label&, const Graph& ) {}

  template<class Label, class Graph>
  void on_label_dominated( const Label&, const Graph& ) {}

  template<class Label, class Graph>
  void on_label_not_dominated( const Label&, const Graph& ) {}

  template<class Queue, class Graph>             
  bool on_enter_loop(const Queue& queue, const Graph& graph) {return true;}

template<class Graph, 
         class VertexIndexMap, 
         class EdgeIndexMap, 
         class Resource_Container, 
         class Resource_Extension_Function, 
         class Dominance_Function, 
         class Label_Allocator, 
         class Visitor>
void r_c_shortest_paths
( const Graph& g, 
  const VertexIndexMap& vertex_index_map, 
  const EdgeIndexMap& edge_index_map, 
  typename graph_traits<Graph>::vertex_descriptor s, 
  typename graph_traits<Graph>::vertex_descriptor t, 
  // each inner vector corresponds to a pareto-optimal path
  std::vector<std::vector<typename graph_traits<Graph>::edge_descriptor> >& 
    pareto_optimal_solutions, 
  std::vector<Resource_Container>& pareto_optimal_resource_containers, 
  // to initialize the first label/resource container 
  // and to carry the type information
  const Resource_Container& rc, 
  const Resource_Extension_Function& ref, 
  const Dominance_Function& dominance, 
  // to specify the memory management strategy for the labels
  Label_Allocator la, 
  Visitor vis )
{
  r_c_shortest_paths_dispatch( g, 
                               vertex_index_map, 
                               edge_index_map, 
                               s, 
                               t, 
                               pareto_optimal_solutions, 
                               pareto_optimal_resource_containers, 
                               true, 
                               rc, 
                               ref, 
                               dominance, 
                               la, 
                               vis );
}

template<class Graph, 
         class Resource_Container, 
         class Resource_Extension_Function>
void check_r_c_path( const Graph& g, 
                     const std::vector
                       <typename graph_traits
                         <Graph>::edge_descriptor>& ed_vec_path, 
                     const Resource_Container& initial_resource_levels, 
                     // if true, computed accumulated final resource levels must 
                     // be equal to desired_final_resource_levels
                     // if false, computed accumulated final resource levels must 
                     // be less than or equal to desired_final_resource_levels
                     bool b_result_must_be_equal_to_desired_final_resource_levels, 
                     const Resource_Container& desired_final_resource_levels, 
                     Resource_Container& actual_final_resource_levels, 
                     const Resource_Extension_Function& ref, 
                     bool& b_is_a_path_at_all, 
                     bool& b_feasible, 
                     bool& b_correctly_extended, 
                     typename graph_traits<Graph>::edge_descriptor& 
                       ed_last_extended_arc )
{
  int i_size_ed_vec_path = static_cast<int>( ed_vec_path.size() );
  std::vector<typename graph_traits<Graph>::edge_descriptor> buf_path;
  if( i_size_ed_vec_path == 0 )
    b_feasible = true;
  else
  {
    if( i_size_ed_vec_path == 1 
        || target( ed_vec_path[0], g ) == source( ed_vec_path[1], g ) )
      buf_path = ed_vec_path;
    else
      for( int i = i_size_ed_vec_path - 1; i >= 0; --i )
        buf_path.push_back( ed_vec_path[i] );
    for( int i = 0; i < i_size_ed_vec_path - 1; ++i )
    {
      if( target( buf_path[i], g ) != source( buf_path[i + 1], g ) )
      {
        b_is_a_path_at_all = false;
        b_feasible = false;
        b_correctly_extended = false;
        return;
      }
    }
  }
  b_is_a_path_at_all = true;
  b_feasible = true;
  b_correctly_extended = false;
  Resource_Container current_resource_levels = initial_resource_levels;
  actual_final_resource_levels = current_resource_levels;
  for( int i = 0; i < i_size_ed_vec_path; ++i )
  {
    ed_last_extended_arc = buf_path[i];
    b_feasible = ref( g, 
                      actual_final_resource_levels, 
                      current_resource_levels, 
                      buf_path[i] );
    current_resource_levels = actual_final_resource_levels;
    if( !b_feasible )
      return;
  }
  if( b_result_must_be_equal_to_desired_final_resource_levels )
    b_correctly_extended = 
     actual_final_resource_levels == desired_final_resource_levels ? 
       true : false;
  else
  {
    if( actual_final_resource_levels < desired_final_resource_levels 
        || actual_final_resource_levels == desired_final_resource_levels )
      b_correctly_extended = true;
  }
}

    
    graph_as_tree_base(Graph& g, Node root) : _g(g), _root(root) { }

    graph_as_tree(Graph& g, Node root) : super(g, root) {  }

    
    graph_as_tree(Graph& g, Node root, ParentMap p) : super(g, root), _p(p) { 
      breadth_first_search(g, root, 
                           visitor(make_bfs_visitor
                   (record_predecessors(p, boost::on_tree_edge()))));
    }

    ParentMap parent_pa() const { return _p; }


  template <typename Graph, typename P, typename N, typename C, 
            typename Property, typename Key, typename Value>
  void
  put(Property p, const graph_as_tree<Graph,P,N,C>& g, const Key& k,
      const Value& val)
  {
    put(p, g._g, k, val);
  }

        inline vector_matrix(size_type n)
            : m_matrix(n, container_type(n))
        { }


        inline reference operator [](size_type n)
        { return m_matrix[n]; }


        inline const_reference operator [](size_type n) const
        { return m_matrix[n]; }

    exterior_property() { }

    exterior_property(const exterior_property&) { }

      biconnected_components_visitor
        (ComponentMap comp, std::size_t& c, 
         std::size_t& children_of_root, DiscoverTimeMap dtm,
         std::size_t& dfs_time, LowPointMap lowpt, PredecessorMap pred,
         OutputIterator out, Stack& S,
         ArticulationVector& is_articulation_point, IndexMap index_map,
         DFSVisitor vis)
          : comp(comp), c(c), children_of_root(children_of_root),
            dtm(dtm), dfs_time(dfs_time), lowpt(lowpt),
            pred(pred), out(out), S(S),
            is_articulation_point(is_articulation_point),
            index_map(index_map), vis(vis) { }


      template <typename Vertex, typename Graph>
      void initialize_vertex(const Vertex& u, Graph& g)
      {
        put(pred, u, u);
        vis.initialize_vertex(u, g);
      }


      template <typename Vertex, typename Graph>
      void start_vertex(const Vertex& u, Graph& g)
      {
        children_of_root = 0;
        vis.start_vertex(u, g);
      }


      template <typename Vertex, typename Graph>
      void discover_vertex(const Vertex& u, Graph& g)
      {
        put(dtm, u, ++dfs_time);
        put(lowpt, u, get(dtm, u));
        vis.discover_vertex(u, g);
      }


      template <typename Edge, typename Graph>
      void examine_edge(const Edge& e, Graph& g)
      {
        vis.examine_edge(e, g);
      }


      template <typename Edge, typename Graph>
      void tree_edge(const Edge& e, Graph& g)
      {
        typename boost::graph_traits<Graph>::vertex_descriptor src = source(e, g);
        typename boost::graph_traits<Graph>::vertex_descriptor tgt = target(e, g);

        S.push(e);
        put(pred, tgt, src);
        if ( get(pred, src) == src ) {
          ++children_of_root;
        }
        vis.tree_edge(e, g);
      }


      template <typename Edge, typename Graph>
      void back_edge(const Edge& e, Graph& g)
      {
        BOOST_USING_STD_MIN();

        typename boost::graph_traits<Graph>::vertex_descriptor src = source(e, g);
        typename boost::graph_traits<Graph>::vertex_descriptor tgt = target(e, g);
        if ( tgt != get(pred, src) ) {
          S.push(e);
          put(lowpt, src,
              min BOOST_PREVENT_MACRO_SUBSTITUTION(get(lowpt, src),
                                                   get(dtm, tgt)));
        }
        vis.back_edge(e, g);
      }


      template <typename Edge, typename Graph>
      void forward_or_cross_edge(const Edge& e, Graph& g)
      {
        vis.forward_or_cross_edge(e, g);
      }


      template <typename Vertex, typename Graph>
      void finish_vertex(const Vertex& u, Graph& g)
      {
        BOOST_USING_STD_MIN();
        Vertex parent = get(pred, u);
        if (parent == u) { // Root of tree is special
          is_articulation_point[get(index_map, u)] = (children_of_root > 1);
        } else {
          put(lowpt, parent,
              min BOOST_PREVENT_MACRO_SUBSTITUTION(get(lowpt, parent),
                                                 get(lowpt, u)));
          if ( get(lowpt, u) >= get(dtm, parent) ) {
            is_articulation_point[get(index_map, parent)] = true;
            while ( get(dtm, source(S.top(), g)) >= get(dtm, u) ) {
              put(comp, S.top(), c);
              S.pop();
            }
            BOOST_ASSERT (source(S.top(), g) == parent);
            BOOST_ASSERT (target(S.top(), g) == u);
            put(comp, S.top(), c);
            S.pop();
            ++c;
          }
        }
        if ( is_articulation_point[get(index_map, u)] ) {
          *out++ = u;
        }
        vis.finish_vertex(u, g);
      }

    static default_color_type white() { return white_color; }

    static default_color_type gray() { return gray_color; }

    static default_color_type green() { return green_color; }

    static default_color_type red() { return red_color; }

    static default_color_type black() { return black_color; }

  inline default_color_type white(default_color_type) { return white_color; }

  inline default_color_type gray(default_color_type) { return gray_color; }

  inline default_color_type green(default_color_type) { return green_color; }

  inline default_color_type red(default_color_type) { return red_color; }

  inline default_color_type black(default_color_type) { return black_color; }

    degree_property_map(const Graph& g) : m_g(g) { }

    value_type operator[](const key_type& v) const {
      return degree(v, m_g);
    }

  template <typename Graph>
  inline degree_property_map<Graph>
  make_degree_map(const Graph& g) {
    return degree_property_map<Graph>(g);
  }

template<typename Graph>
inline typename graph_property<Graph, graph_bundle_t>::type&
get_property(Graph& g) {
  return get_property(g, graph_bundle);
}


template<typename Graph>
inline typename graph_property<Graph, graph_bundle_t>::type const&
get_property(const Graph& g) {
  return get_property(g, graph_bundle);
}

  template<class Distance>
  typename Distance::value_type RLS_depth(Distance& d)
  {
    typename Distance::value_type h_s = 0;
    typename Distance::iterator iter;
    
    for (iter = d.begin(); iter != d.end(); ++iter)
      {
        if(*iter > h_s)
          {
            h_s = *iter;
          }
      }
    
    return h_s;
  }

  template<class Distance, class my_int>
  typename Distance::value_type RLS_max_width(Distance& d, my_int depth)
  {

      typedef typename Distance::value_type Degree;
    
      //Searching for the maximum width of a level
      std::vector<Degree> dummy_width(depth+1, 0);
      typename std::vector<Degree>::iterator my_it;
      typename Distance::iterator iter;
      Degree w_max = 0;
      
      for (iter = d.begin(); iter != d.end(); ++iter)
      {
          dummy_width[*iter]++;
      }
      
      for(my_it = dummy_width.begin(); my_it != dummy_width.end(); ++my_it)
      {
          if(*my_it > w_max) w_max = *my_it;
      }
      
      return w_max;
      
  }

  template <class Graph, class ColorMap, class DegreeMap> 
  typename graph_traits<Graph>::vertex_descriptor 
  sloan_start_end_vertices(Graph& G, 
                           typename graph_traits<Graph>::vertex_descriptor &s, 
                           ColorMap color, 
                           DegreeMap degree)
  {
    typedef typename property_traits<DegreeMap>::value_type Degree;
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename std::vector< typename graph_traits<Graph>::vertices_size_type>::iterator vec_iter;
    typedef typename graph_traits<Graph>::vertices_size_type size_type;
    
    typedef typename property_map<Graph, vertex_index_t>::const_type VertexID;
    
    s = *(vertices(G).first);
    Vertex e = s;
    Vertex i;
    Degree my_degree = get(degree, s ); 
    Degree dummy, h_i, h_s, w_i, w_e;
    bool new_start = true;
    Degree maximum_degree = 0;
    
    //Creating a std-vector for storing the distance from the start vertex in dist
    std::vector<typename graph_traits<Graph>::vertices_size_type> dist(num_vertices(G), 0);

    //Wrap a property_map_iterator around the std::iterator
    boost::iterator_property_map<vec_iter, VertexID, size_type, size_type&> dist_pmap(dist.begin(), get(vertex_index, G));
    
    //Creating a property_map for the indices of a vertex
    typename property_map<Graph, vertex_index_t>::type index_map = get(vertex_index, G);
    
    //Creating a priority queue
    typedef indirect_cmp<DegreeMap, std::greater<Degree> > Compare;
    Compare comp(degree);
    std::priority_queue<Vertex, std::vector<Vertex>, Compare> degree_queue(comp);
    
    //step 1
    //Scan for the vertex with the smallest degree and the maximum degree
    typename graph_traits<Graph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(G); ui != ui_end; ++ui)
    {
      dummy = get(degree, *ui);
      
      if(dummy < my_degree)
      {
        my_degree = dummy;
        s = *ui;
      }
      
      if(dummy > maximum_degree)
      {
        maximum_degree = dummy;
      }
    }
    //end 1
    
    do{  
      new_start = false;     //Setting the loop repetition status to false
      
      //step 2
      //initialize the the disance std-vector with 0
      for(typename std::vector<typename graph_traits<Graph>::vertices_size_type>::iterator iter = dist.begin(); iter != dist.end(); ++iter) *iter = 0;
      
      //generating the RLS (rooted level structure)
      breadth_first_search
        (G, s, visitor
         (
           make_bfs_visitor(record_distances(dist_pmap, on_tree_edge() ) )
           )
          );
      
      //end 2
      
      //step 3
      //calculating the depth of the RLS
      h_s = RLS_depth(dist);
      
      //step 4
      //pushing one node of each degree in an ascending manner into degree_queue
      std::vector<bool> shrink_trace(maximum_degree, false);
      for (boost::tie(ui, ui_end) = vertices(G); ui != ui_end; ++ui)
      {
        dummy = get(degree, *ui);
        
        if( (dist[index_map[*ui]] == h_s ) && ( !shrink_trace[ dummy ] ) )
        {
          degree_queue.push(*ui);
          shrink_trace[ dummy ] = true;
        }
      }
      
      //end 3 & 4

      
      // step 5
      // Initializing w
      w_e = (std::numeric_limits<Degree>::max)();
      //end 5
      
      
      //step 6
      //Testing for termination
      while( !degree_queue.empty() )
      {
        i = degree_queue.top();       //getting the node with the lowest degree from the degree queue
        degree_queue.pop();           //ereasing the node with the lowest degree from the degree queue
        
        //generating a RLS          
        for(typename std::vector<typename graph_traits<Graph>::vertices_size_type>::iterator iter = dist.begin(); iter != dist.end(); ++iter) *iter = 0;
        
        breadth_first_search
          (G, i, boost::visitor
           (
             make_bfs_visitor(record_distances(dist_pmap, on_tree_edge() ) )
             )
            );
        
        //Calculating depth and width of the rooted level
        h_i = RLS_depth(dist);
        w_i = RLS_max_width(dist, h_i);
        
        //Testing for termination
        if( (h_i > h_s) && (w_i < w_e) ) 
        {
          h_s = h_i;
          s = i;
          while(!degree_queue.empty()) degree_queue.pop();
          new_start = true;         
        }
        else if(w_i < w_e)
        { 
          w_e = w_i;
          e = i;
        }
      }
      //end 6
        
    }while(new_start);
    
    return e;
  }

  template <class Graph, class OutputIterator,
            class ColorMap, class DegreeMap,
            class PriorityMap, class Weight>
  OutputIterator
  sloan_ordering(Graph& g,
                 typename graph_traits<Graph>::vertex_descriptor s,
                 typename graph_traits<Graph>::vertex_descriptor e,
                 OutputIterator permutation, 
                 ColorMap color, 
                 DegreeMap degree, 
                 PriorityMap priority, 
                 Weight W1, 
                 Weight W2)
  {
    //typedef typename property_traits<DegreeMap>::value_type Degree;
    typedef typename property_traits<PriorityMap>::value_type Degree;
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename std::vector<typename graph_traits<Graph>::vertices_size_type>::iterator vec_iter;
    typedef typename graph_traits<Graph>::vertices_size_type size_type;

    typedef typename property_map<Graph, vertex_index_t>::const_type VertexID;

    
    //Creating a std-vector for storing the distance from the end vertex in it
    typename std::vector<typename graph_traits<Graph>::vertices_size_type> dist(num_vertices(g), 0);
    
    //Wrap a property_map_iterator around the std::iterator
    boost::iterator_property_map<vec_iter, VertexID, size_type, size_type&> dist_pmap(dist.begin(), get(vertex_index, g)); 
    
    breadth_first_search
      (g, e, visitor
       (
           make_bfs_visitor(record_distances(dist_pmap, on_tree_edge() ) )
        )
       );
    
    //Creating a property_map for the indices of a vertex
    typename property_map<Graph, vertex_index_t>::type index_map = get(vertex_index, g);
    
    //Sets the color and priority to their initial status
    Degree cdeg;    
    typename graph_traits<Graph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui)
    {
        put(color, *ui, Color::white());
        cdeg=get(degree, *ui)+1;
        put(priority, *ui, W1*dist[index_map[*ui]]-W2*cdeg );  
    }
    
    //Priority list
    typedef indirect_cmp<PriorityMap, std::greater<Degree> > Compare;
    Compare comp(priority);
    std::list<Vertex> priority_list;

    //Some more declarations
    typename graph_traits<Graph>::out_edge_iterator ei, ei_end, ei2, ei2_end;
    Vertex u, v, w;

    put(color, s, Color::green());      //Sets the color of the starting vertex to gray
    priority_list.push_front(s);                 //Puts s into the priority_list
    
    while ( !priority_list.empty() ) 
    {  
      priority_list.sort(comp);         //Orders the elements in the priority list in an ascending manner
      
      u = priority_list.front();           //Accesses the last element in the priority list
      priority_list.pop_front();               //Removes the last element in the priority list
      
      if(get(color, u) == Color::green() )
      {
        //for-loop over all out-edges of vertex u
        for (boost::tie(ei, ei_end) = out_edges(u, g); ei != ei_end; ++ei) 
        {
          v = target(*ei, g);
          
          put( priority, v, get(priority, v) + W2 ); //updates the priority
          
          if (get(color, v) == Color::white() )      //test if the vertex is inactive
          {
            put(color, v, Color::green() );        //giving the vertex a preactive status
            priority_list.push_front(v);                     //writing the vertex in the priority_queue
          }           
        }
      }
      
      //Here starts step 8
      *permutation++ = u;                      //Puts u to the first position in the permutation-vector
      put(color, u, Color::black() );          //Gives u an inactive status
      
      //for loop over all the adjacent vertices of u
      for (boost::tie(ei, ei_end) = out_edges(u, g); ei != ei_end; ++ei) {
        
        v = target(*ei, g);     
        
        if (get(color, v) == Color::green() ) {      //tests if the vertex is inactive
          
          put(color, v, Color::red() );        //giving the vertex an active status
          put(priority, v, get(priority, v)+W2);  //updates the priority        
          
          //for loop over alll adjacent vertices of v
          for (boost::tie(ei2, ei2_end) = out_edges(v, g); ei2 != ei2_end; ++ei2) {
            w = target(*ei2, g);
            
            if(get(color, w) != Color::black() ) {     //tests if vertex is postactive
              
              put(priority, w, get(priority, w)+W2);  //updates the priority
              
              if(get(color, w) == Color::white() ){
                
                put(color, w, Color::green() );   // gives the vertex a preactive status
                priority_list.push_front(w);           // puts the vertex into the priority queue
                
              } //end if
              
            } //end if
            
          } //end for
          
        } //end if
        
      } //end for
      
    } //end while
    
    
    return permutation;
  }

  template <class Graph, class OutputIterator,
            class ColorMap, class DegreeMap,
            class PriorityMap>
  OutputIterator
  sloan_ordering(Graph& g,
                 typename graph_traits<Graph>::vertex_descriptor s,
                 typename graph_traits<Graph>::vertex_descriptor e,
                 OutputIterator permutation, 
                 ColorMap color, 
                 DegreeMap degree, 
                 PriorityMap priority)
  {
    return sloan_ordering(g, s, e, permutation, color, degree, priority, WEIGHT1, WEIGHT2); 
  }

 


  template < class Graph, class OutputIterator, 
             class Color, class Degree,
             class Priority, class Weight>
  inline OutputIterator
  sloan_ordering(Graph& G, 
                 OutputIterator permutation, 
                 Color color, 
                 Degree degree, 
                 Priority priority, 
                 Weight W1, 
                 Weight W2 )
  {
    typedef typename boost::graph_traits<Graph>::vertex_descriptor Vertex;
    
    Vertex s, e;
    e = sloan_start_end_vertices(G, s, color, degree);
    
    return sloan_ordering(G, s, e, permutation, color, degree, priority, W1, W2);
  }

  template < class Graph, class OutputIterator, 
             class Color, class Degree,
             class Priority >
  inline OutputIterator
  sloan_ordering(Graph& G, 
                 OutputIterator permutation, 
                 Color color, 
                 Degree degree, 
                 Priority priority)
  { 
    return sloan_ordering(G, permutation, color, degree, priority, WEIGHT1, WEIGHT2);
  }


  template <typename Graph, typename VertexIndexMap>
  typename graph_traits<Graph>::vertices_size_type
  ith_bandwidth(typename graph_traits<Graph>::vertex_descriptor i,
                const Graph& g,
                VertexIndexMap index)
  {
    BOOST_USING_STD_MAX();
    using std::abs;
    typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
    vertices_size_type b = 0;
    typename graph_traits<Graph>::out_edge_iterator e, end;
    for (boost::tie(e, end) = out_edges(i, g); e != end; ++e) {
      int f_i = get(index, i);
      int f_j = get(index, target(*e, g));
      b = max BOOST_PREVENT_MACRO_SUBSTITUTION (b, vertices_size_type(abs(f_i - f_j)));
    }
    return b;
  }


  template <typename Graph>
  typename graph_traits<Graph>::vertices_size_type
  ith_bandwidth(typename graph_traits<Graph>::vertex_descriptor i,
                const Graph& g)
  {
    return ith_bandwidth(i, g, get(vertex_index, g));
  }


  template <typename Graph, typename VertexIndexMap>
  typename graph_traits<Graph>::vertices_size_type
  bandwidth(const Graph& g, VertexIndexMap index)
  {
    BOOST_USING_STD_MAX();
    using std::abs;
    typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
    vertices_size_type b = 0;
    typename graph_traits<Graph>::edge_iterator i, end;
    for (boost::tie(i, end) = edges(g); i != end; ++i) {
      int f_i = get(index, source(*i, g));
      int f_j = get(index, target(*i, g));
      b = max BOOST_PREVENT_MACRO_SUBSTITUTION (b, vertices_size_type(abs(f_i - f_j)));
    }
    return b;
  }


  template <typename Graph>
  typename graph_traits<Graph>::vertices_size_type
  bandwidth(const Graph& g)
  {
    return bandwidth(g, get(vertex_index, g));
  }


  template <typename Graph, typename VertexIndexMap>
  typename graph_traits<Graph>::vertices_size_type
  edgesum(const Graph& g, VertexIndexMap index_map)
  {
    typedef typename graph_traits<Graph>::vertices_size_type size_type;
    typedef typename detail::numeric_traits<size_type>::difference_type diff_t;
    size_type sum = 0;
    typename graph_traits<Graph>::edge_iterator i, end;
    for (boost::tie(i, end) = edges(g); i != end; ++i) {
      diff_t f_u = get(index_map, source(*i, g));
      diff_t f_v = get(index_map, target(*i, g));
      using namespace std; // to call abs() unqualified
      sum += abs(f_u - f_v);
    }
    return sum;
  }

  template <typename Graph, typename DijkstraVisitor,
            typename PredecessorMap, typename DistanceMap,
            typename WeightMap, typename VertexIndexMap,
            typename DistanceCompare, typename DistanceWeightCombine,
            typename DistanceInfinity, typename DistanceZero>
  void dijkstra_shortest_paths_no_color_map_no_init
    (const Graph& graph,
     typename graph_traits<Graph>::vertex_descriptor start_vertex,
     PredecessorMap predecessor_map,
     DistanceMap distance_map,
     WeightMap weight_map,
     VertexIndexMap index_map,
     DistanceCompare distance_compare,
     DistanceWeightCombine distance_weight_combine,
     DistanceInfinity distance_infinity,
     DistanceZero distance_zero,
     DijkstraVisitor visitor)
  {
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename property_traits<DistanceMap>::value_type Distance;
    typedef typename property_traits<WeightMap>::value_type Weight;
    
    typedef indirect_cmp<DistanceMap, DistanceCompare> DistanceIndirectCompare;
    DistanceIndirectCompare
      distance_indirect_compare(distance_map, distance_compare);
  
    // Choose vertex queue type
#if BOOST_GRAPH_DIJKSTRA_USE_RELAXED_HEAP
    typedef relaxed_heap<Vertex, DistanceIndirectCompare, VertexIndexMap>
      VertexQueue;
    VertexQueue vertex_queue(num_vertices(graph),
                             distance_indirect_compare,
                             index_map);
#else
    // Default - use d-ary heap (d = 4)
    typedef
      detail::vertex_property_map_generator<Graph, VertexIndexMap, std::size_t>
      IndexInHeapMapHelper;
    typedef typename IndexInHeapMapHelper::type IndexInHeapMap;
    typedef
      d_ary_heap_indirect<Vertex, 4, IndexInHeapMap, DistanceMap, DistanceCompare>
      VertexQueue;
  
    boost::scoped_array<std::size_t> index_in_heap_map_holder;
    IndexInHeapMap index_in_heap =
      IndexInHeapMapHelper::build(graph, index_map,
                                  index_in_heap_map_holder);  
    VertexQueue vertex_queue(distance_map, index_in_heap, distance_compare);
#endif
  
    // Add vertex to the queue
    vertex_queue.push(start_vertex);
  
    // Starting vertex will always be the first discovered vertex
    visitor.discover_vertex(start_vertex, graph);
  
    while (!vertex_queue.empty()) {
      Vertex min_vertex = vertex_queue.top();
      vertex_queue.pop();
      
      visitor.examine_vertex(min_vertex, graph);
  
      // Check if any other vertices can be reached
      Distance min_vertex_distance = get(distance_map, min_vertex);
      
      if (!distance_compare(min_vertex_distance, distance_infinity)) {
        // This is the minimum vertex, so all other vertices are unreachable
        return;
      }
  
      // Examine neighbors of min_vertex
      typedef typename graph_traits<Graph>::edge_descriptor Edge;
      BGL_FORALL_OUTEDGES_T(min_vertex, current_edge, graph, Graph) {
        visitor.examine_edge(current_edge, graph);
        
        // Check if the edge has a negative weight
        if (distance_compare(get(weight_map, current_edge), distance_zero)) {
          boost::throw_exception(negative_edge());
        }
  
        // Extract the neighboring vertex and get its distance
        Vertex neighbor_vertex = target(current_edge, graph);
        Distance neighbor_vertex_distance = get(distance_map, neighbor_vertex);
        bool is_neighbor_undiscovered = 
          !distance_compare(neighbor_vertex_distance, distance_infinity);

        // Attempt to relax the edge
        bool was_edge_relaxed = relax(current_edge, graph, weight_map,
          predecessor_map, distance_map,
          distance_weight_combine, distance_compare);
  
        if (was_edge_relaxed) {
          visitor.edge_relaxed(current_edge, graph);
          if (is_neighbor_undiscovered) {
            visitor.discover_vertex(neighbor_vertex, graph);
            vertex_queue.push(neighbor_vertex);
          } else {
            vertex_queue.update(neighbor_vertex);
          }
        } else {
          visitor.edge_not_relaxed(current_edge, graph);
        }
  
      } // end out edge iteration
  
      visitor.finish_vertex(min_vertex, graph);
    } // end while queue not empty
  }

  template <typename Graph, typename DijkstraVisitor,
            typename PredecessorMap, typename DistanceMap,
            typename WeightMap, typename VertexIndexMap,
            typename DistanceCompare, typename DistanceWeightCombine,
            typename DistanceInfinity, typename DistanceZero>
  void dijkstra_shortest_paths_no_color_map
    (const Graph& graph,
     typename graph_traits<Graph>::vertex_descriptor start_vertex,
     PredecessorMap predecessor_map,
     DistanceMap distance_map,
     WeightMap weight_map,
     VertexIndexMap index_map,
     DistanceCompare distance_compare,
     DistanceWeightCombine distance_weight_combine,
     DistanceInfinity distance_infinity,
     DistanceZero distance_zero,
     DijkstraVisitor visitor)
  {
    // Initialize vertices
    BGL_FORALL_VERTICES_T(current_vertex, graph, Graph) {
      visitor.initialize_vertex(current_vertex, graph);
      
      // Default all distances to infinity
      put(distance_map, current_vertex, distance_infinity);
  
      // Default all vertex predecessors to the vertex itself
      put(predecessor_map, current_vertex, current_vertex);
    }
  
    // Set distance for start_vertex to zero
    put(distance_map, start_vertex, distance_zero);
  
    // Pass everything on to the no_init version
    dijkstra_shortest_paths_no_color_map_no_init(graph,
      start_vertex, predecessor_map, distance_map, weight_map,
      index_map, distance_compare, distance_weight_combine,
      distance_infinity, distance_zero, visitor);
  }

    template <typename Graph, typename DistanceMap, typename WeightMap,
              typename VertexIndexMap, typename Params>
    inline void
    dijkstra_no_color_map_dispatch2
      (const Graph& graph,
       typename graph_traits<Graph>::vertex_descriptor start_vertex,
       DistanceMap distance_map, WeightMap weight_map,
       VertexIndexMap index_map, const Params& params)
    {
      // Default for predecessor map
      dummy_property_map predecessor_map;

      typedef typename property_traits<DistanceMap>::value_type DistanceType;
      DistanceType inf =
        choose_param(get_param(params, distance_inf_t()),
                     (std::numeric_limits<DistanceType>::max)());
      dijkstra_shortest_paths_no_color_map
        (graph, start_vertex,
         choose_param(get_param(params, vertex_predecessor), predecessor_map),
         distance_map, weight_map, index_map,
         choose_param(get_param(params, distance_compare_t()),
                      std::less<DistanceType>()),
         choose_param(get_param(params, distance_combine_t()),
                      closed_plus<DistanceType>(inf)),
         inf,
         choose_param(get_param(params, distance_zero_t()),
                      DistanceType()),
         choose_param(get_param(params, graph_visitor),
                      make_dijkstra_visitor(null_visitor())));
    }


    template <typename Graph, typename DistanceMap, typename WeightMap,
              typename IndexMap, typename Params>
    inline void
    dijkstra_no_color_map_dispatch1
      (const Graph& graph,
       typename graph_traits<Graph>::vertex_descriptor start_vertex,
       DistanceMap distance_map, WeightMap weight_map,
       IndexMap index_map, const Params& params)
    {
      // Default for distance map
      typedef typename property_traits<WeightMap>::value_type DistanceType;
      typename std::vector<DistanceType>::size_type
        vertex_count = is_default_param(distance_map) ? num_vertices(graph) : 1;
        
      std::vector<DistanceType> default_distance_map(vertex_count);

      detail::dijkstra_no_color_map_dispatch2
        (graph, start_vertex, choose_param(distance_map,
         make_iterator_property_map(default_distance_map.begin(), index_map,
                                    default_distance_map[0])),
         weight_map, index_map, params);
    }

  template <typename Graph, typename Param, typename Tag, typename Rest>
  inline void
  dijkstra_shortest_paths_no_color_map
    (const Graph& graph,
     typename graph_traits<Graph>::vertex_descriptor start_vertex,
     const bgl_named_params<Param, Tag, Rest>& params)
  {
    // Default for edge weight and vertex index map is to ask for them
    // from the graph. Default for the visitor is null_visitor.
    detail::dijkstra_no_color_map_dispatch1
      (graph, start_vertex,
       get_param(params, vertex_distance),
       choose_const_pmap(get_param(params, edge_weight), graph, edge_weight),
       choose_const_pmap(get_param(params, vertex_index), graph, vertex_index),
       params);
  }


      bipartite_visitor_error (Vertex a, Vertex b) :
        witnesses (a, b)
      {

      }


      const char* what () const throw ()
      {
        return "Graph is not bipartite.";
      }


      bipartition_colorize (PartitionMap partition_map) :
        partition_map_ (partition_map)
      {

      }


      template <typename Edge, typename Graph>
      void operator() (Edge e, const Graph& g)
      {
        typedef typename graph_traits <Graph>::vertex_descriptor vertex_descriptor_t;
        typedef color_traits <typename property_traits <PartitionMap>::value_type> color_traits;

        vertex_descriptor_t source_vertex = source (e, g);
        vertex_descriptor_t target_vertex = target (e, g);
        if (get (partition_map_, source_vertex) == color_traits::white ())
          put (partition_map_, target_vertex, color_traits::black ());
        else
          put (partition_map_, target_vertex, color_traits::white ());
      }


    template <typename PartitionMap>
    inline bipartition_colorize <PartitionMap> colorize_bipartition (PartitionMap partition_map)
    {
      return bipartition_colorize <PartitionMap> (partition_map);
    }


      bipartition_check (PartitionMap partition_map) :
        partition_map_ (partition_map)
      {

      }


      template <typename Edge, typename Graph>
      void operator() (Edge e, const Graph& g)
      {
        typedef typename graph_traits <Graph>::vertex_descriptor vertex_descriptor_t;

        vertex_descriptor_t source_vertex = source (e, g);
        vertex_descriptor_t target_vertex = target (e, g);
        if (get (partition_map_, source_vertex) == get (partition_map_, target_vertex))
          throw bipartite_visitor_error <vertex_descriptor_t> (source_vertex, target_vertex);
      }


    template <typename PartitionMap>
    inline bipartition_check <PartitionMap> check_bipartition (PartitionMap partition_map)
    {
      return bipartition_check <PartitionMap> (partition_map);
    }


  template <typename Graph, typename IndexMap, typename PartitionMap>
  bool is_bipartite (const Graph& graph, const IndexMap index_map, PartitionMap partition_map)
  {
    /// General types and variables
    typedef typename property_traits <PartitionMap>::value_type partition_color_t;
    typedef typename graph_traits <Graph>::vertex_descriptor vertex_descriptor_t;
    typedef typename graph_traits <Graph>::vertex_iterator vertex_iterator_t;

    /// Declare dfs visitor
    //    detail::empty_recorder recorder;
    //    typedef detail::bipartite_visitor <PartitionMap, detail::empty_recorder> dfs_visitor_t;
    //    dfs_visitor_t dfs_visitor (partition_map, recorder);


    /// Call dfs
    try
    {
      depth_first_search (graph, vertex_index_map (index_map).visitor (make_dfs_visitor (std::make_pair (
          detail::colorize_bipartition (partition_map), std::make_pair (detail::check_bipartition (partition_map),
              put_property (partition_map, color_traits <partition_color_t>::white (), on_start_vertex ()))))));
    }
    catch (detail::bipartite_visitor_error <vertex_descriptor_t> error)
    {
      return false;
    }

    return true;
  }


  template <typename Graph, typename IndexMap>
  bool is_bipartite (const Graph& graph, const IndexMap index_map)
  {
    typedef one_bit_color_map <IndexMap> partition_map_t;
    partition_map_t partition_map (num_vertices (graph), index_map);

    return is_bipartite (graph, index_map, partition_map);
  }


  template <typename Graph>
  bool is_bipartite (const Graph& graph)
  {
    return is_bipartite (graph, get (vertex_index, graph));
  }


  template <typename Graph, typename IndexMap, typename PartitionMap, typename OutputIterator>
  OutputIterator find_odd_cycle (const Graph& graph, const IndexMap index_map, PartitionMap partition_map,
      OutputIterator result)
  {
    /// General types and variables
    typedef typename property_traits <PartitionMap>::value_type partition_color_t;
    typedef typename graph_traits <Graph>::vertex_descriptor vertex_descriptor_t;
    typedef typename graph_traits <Graph>::vertex_iterator vertex_iterator_t;
    vertex_iterator_t vertex_iter, vertex_end;

    /// Declare predecessor map
    typedef std::vector <vertex_descriptor_t> predecessors_t;
    typedef iterator_property_map <typename predecessors_t::iterator, IndexMap, vertex_descriptor_t,
        vertex_descriptor_t&> predecessor_map_t;

    predecessors_t predecessors (num_vertices (graph), graph_traits <Graph>::null_vertex ());
    predecessor_map_t predecessor_map (predecessors.begin (), index_map);

    /// Initialize predecessor map
    for (boost::tie (vertex_iter, vertex_end) = vertices (graph); vertex_iter != vertex_end; ++vertex_iter)
    {
      put (predecessor_map, *vertex_iter, *vertex_iter);
    }

    /// Call dfs
    try
    {
      depth_first_search (graph, vertex_index_map (index_map).visitor (make_dfs_visitor (std::make_pair (
          detail::colorize_bipartition (partition_map), std::make_pair (detail::check_bipartition (partition_map),
              std::make_pair (put_property (partition_map, color_traits <partition_color_t>::white (),
                  on_start_vertex ()), record_predecessors (predecessor_map, on_tree_edge ())))))));
    }
    catch (detail::bipartite_visitor_error <vertex_descriptor_t> error)
    {
      typedef std::vector <vertex_descriptor_t> path_t;

      path_t path1, path2;
      vertex_descriptor_t next, current;

      /// First path
      next = error.witnesses.first;
      do
      {
        current = next;
        path1.push_back (current);
        next = predecessor_map[current];
      }
      while (current != next);

      /// Second path
      next = error.witnesses.second;
      do
      {
        current = next;
        path2.push_back (current);
        next = predecessor_map[current];
      }
      while (current != next);

      /// Find beginning of common suffix
      std::pair <typename path_t::iterator, typename path_t::iterator> mismatch = detail::reverse_mismatch (
          std::make_pair (path1.begin (), path1.end ()), std::make_pair (path2.begin (), path2.end ()));

      /// Copy the odd-length cycle
      result = std::copy (path1.begin (), mismatch.first + 1, result);
      return std::reverse_copy (path2.begin (), mismatch.second, result);
    }

    return result;
  }


  template <typename Graph, typename IndexMap, typename OutputIterator>
  OutputIterator find_odd_cycle (const Graph& graph, const IndexMap index_map, OutputIterator result)
  {
    typedef one_bit_color_map <IndexMap> partition_map_t;
    partition_map_t partition_map (num_vertices (graph), index_map);

    return find_odd_cycle (graph, index_map, partition_map, result);
  }


  template <typename Graph, typename OutputIterator>
  OutputIterator find_odd_cycle (const Graph& graph, OutputIterator result)
  {
    return find_odd_cycle (graph, get (vertex_index, graph), result);
  }


    template<class Graph,class Tag>
    typename graph_property_iter_range<Graph,Tag>::type
    get_property_iter_range_kind(Graph& graph, const Tag& tag, 
                                 const vertex_property_tag& )
    {
      typedef typename graph_property_iter_range<Graph,Tag>::iterator iter;
      return std::make_pair(iter(vertices(graph).first, get(tag, graph)),
                            iter(vertices(graph).second, get(tag, graph)));
    }


    template<class Graph,class Tag>
    typename graph_property_iter_range<Graph,Tag>::const_type
    get_property_iter_range_kind(const Graph& graph, const Tag& tag, 
                                 const vertex_property_tag& )
    {
      typedef typename graph_property_iter_range<Graph,Tag>
        ::const_iterator iter;
      return std::make_pair(iter(vertices(graph).first, get(tag, graph)),
                            iter(vertices(graph).second, get(tag, graph)));
    }



    template<class Graph,class Tag>
    typename graph_property_iter_range<Graph,Tag>::type
    get_property_iter_range_kind(Graph& graph, const Tag& tag, 
                                 const edge_property_tag& )
    {
      typedef typename graph_property_iter_range<Graph,Tag>::iterator iter;
      return std::make_pair(iter(edges(graph).first, get(tag, graph)),
                            iter(edges(graph).second, get(tag, graph)));
    }


    template<class Graph,class Tag>
    typename graph_property_iter_range<Graph,Tag>::const_type
    get_property_iter_range_kind(const Graph& graph, const Tag& tag, 
                                 const edge_property_tag& )
    {
      typedef typename graph_property_iter_range<Graph,Tag>
        ::const_iterator iter;
      return std::make_pair(iter(edges(graph).first, get(tag, graph)),
                            iter(edges(graph).second, get(tag, graph)));
    }


  template<class Graph, class Tag>
  typename graph_property_iter_range<Graph, Tag>::type
  get_property_iter_range(Graph& graph, const Tag& tag)
  {
    typedef typename property_kind<Tag>::type Kind;
    return detail::get_property_iter_range_kind(graph, tag, Kind());
  }


  template<class Graph, class Tag>
  typename graph_property_iter_range<Graph, Tag>::const_type
  get_property_iter_range(const Graph& graph, const Tag& tag)
  {
    typedef typename property_kind<Tag>::type Kind;
    return detail::get_property_iter_range_kind(graph, tag, Kind());
  }

    leda_graph_data_map(GraphPtr g) : m_g(g) { }

    template <class NodeOrEdge>
    DataRef operator[](NodeOrEdge x) const { return (*m_g)[x]; }

    leda_edge_property_map(EdgeMapPtr a) : m_array(a) { }

    ERef operator[](leda::edge n) const { return (*m_array)[n]; }

  explicit n_iterations(std::size_t n) : n(n) { }


  template<typename RankMap, typename Graph>
  bool 
  operator()(const RankMap&, const Graph&)
  {
    return n-- == 0;
  }

  template<typename Graph, typename RankMap, typename RankMap2>
  void page_rank_step(const Graph& g, RankMap from_rank, RankMap2 to_rank,
                      typename property_traits<RankMap>::value_type damping,
                      incidence_graph_tag)
  {
    typedef typename property_traits<RankMap>::value_type rank_type;

    // Set new rank maps 
    BGL_FORALL_VERTICES_T(v, g, Graph) put(to_rank, v, rank_type(1 - damping));

    BGL_FORALL_VERTICES_T(u, g, Graph) {
      rank_type u_rank_out = damping * get(from_rank, u) / out_degree(u, g);
      BGL_FORALL_ADJ_T(u, v, g, Graph)
        put(to_rank, v, get(to_rank, v) + u_rank_out);
    }
  }


  template<typename Graph, typename RankMap, typename RankMap2>
  void page_rank_step(const Graph& g, RankMap from_rank, RankMap2 to_rank,
                      typename property_traits<RankMap>::value_type damping,
                      bidirectional_graph_tag)
  {
    typedef typename property_traits<RankMap>::value_type damping_type;
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      typename property_traits<RankMap>::value_type rank(0);
      BGL_FORALL_INEDGES_T(v, e, g, Graph)
        rank += get(from_rank, source(e, g)) / out_degree(source(e, g), g);
      put(to_rank, v, (damping_type(1) - damping) + damping * rank);
    }
  }


template<typename Graph, typename RankMap, typename Done, typename RankMap2>
void
page_rank(const Graph& g, RankMap rank_map, Done done, 
          typename property_traits<RankMap>::value_type damping,
          typename graph_traits<Graph>::vertices_size_type n,
          RankMap2 rank_map2
          BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, vertex_list_graph_tag))
{
  typedef typename property_traits<RankMap>::value_type rank_type;

  rank_type initial_rank = rank_type(rank_type(1) / n);
  BGL_FORALL_VERTICES_T(v, g, Graph) put(rank_map, v, initial_rank);

  bool to_map_2 = true;
  while ((to_map_2 && !done(rank_map, g)) ||
         (!to_map_2 && !done(rank_map2, g))) {
    typedef typename graph_traits<Graph>::traversal_category category;

    if (to_map_2) {
      detail::page_rank_step(g, rank_map, rank_map2, damping, category());
    } else {
      detail::page_rank_step(g, rank_map2, rank_map, damping, category());
    }
    to_map_2 = !to_map_2;
  }

  if (!to_map_2) {
    BGL_FORALL_VERTICES_T(v, g, Graph) put(rank_map, v, get(rank_map2, v));
  }
}


template<typename Graph, typename RankMap, typename Done>
void
page_rank(const Graph& g, RankMap rank_map, Done done, 
          typename property_traits<RankMap>::value_type damping,
          typename graph_traits<Graph>::vertices_size_type n)
{
  typedef typename property_traits<RankMap>::value_type rank_type;

  std::vector<rank_type> ranks2(num_vertices(g));
  page_rank(g, rank_map, done, damping, n,
            make_iterator_property_map(ranks2.begin(), get(vertex_index, g)));
}


template<typename Graph, typename RankMap, typename Done>
inline void
page_rank(const Graph& g, RankMap rank_map, Done done, 
          typename property_traits<RankMap>::value_type damping = 0.85)
{
  page_rank(g, rank_map, done, damping, num_vertices(g));
}


template<typename Graph, typename RankMap>
inline void
page_rank(const Graph& g, RankMap rank_map)
{
  page_rank(g, rank_map, n_iterations(20));
}

template<typename MutableGraph>
void
remove_dangling_links(MutableGraph& g
                      BOOST_GRAPH_ENABLE_IF_MODELS_PARM(MutableGraph, 
                                                        vertex_list_graph_tag))
{
  typename graph_traits<MutableGraph>::vertices_size_type old_n;
  do {
    old_n = num_vertices(g);

    typename graph_traits<MutableGraph>::vertex_iterator vi, vi_end;
    for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; /* in loop */) {
      typename graph_traits<MutableGraph>::vertex_descriptor v = *vi++;
      if (out_degree(v, g) == 0) {
        clear_vertex(v, g);
        remove_vertex(v, g);
      }
    }
  } while (num_vertices(g) < old_n);
}

      static Desc convert(const Desc& d, const Graph&) {return d;}

      static Desc convert(const reverse_graph_edge_descriptor<Desc>& d, const Graph& g) {
        return get(edge_underlying, g, d);
      }

      static Desc convert(const Desc& d) {return d;}

      static reverse_graph_edge_descriptor<Desc> convert(const Desc& d) {
        return reverse_graph_edge_descriptor<Desc>(d);
      }

      static reverse_graph_edge_descriptor<Desc> convert(const reverse_graph_edge_descriptor<Desc>& d) {
        return d;
      }

      edge_copier(const Graph1& g1, Graph2& g2)
        : edge_all_map1(get(edge_all, g1)), 
          edge_all_map2(get(edge_all, g2)) { }


      template <typename Edge1, typename Edge2>
      void operator()(const Edge1& e1, Edge2& e2) const {
        put(edge_all_map2, e2, get(edge_all_map1, add_reverse_edge_descriptor<Edge1, Graph1>::convert(e1)));
      }

    template <typename Graph1, typename Graph2>
    inline edge_copier<Graph1,Graph2>
    make_edge_copier(const Graph1& g1, Graph2& g2)
    {
      return edge_copier<Graph1,Graph2>(g1, g2);
    }

      vertex_copier(const Graph1& g1, Graph2& g2)
        : vertex_all_map1(get(vertex_all, g1)), 
          vertex_all_map2(get(vertex_all, g2)) { }


      template <typename Vertex1, typename Vertex2>
      void operator()(const Vertex1& v1, Vertex2& v2) const {
        put(vertex_all_map2, v2, get(vertex_all_map1, v1));
      }

    template <typename Graph1, typename Graph2>
    inline vertex_copier<Graph1,Graph2>
    make_vertex_copier(const Graph1& g1, Graph2& g2)
    {
      return vertex_copier<Graph1,Graph2>(g1, g2);
    }

      template <typename Graph, typename MutableGraph, 
        typename CopyVertex, typename CopyEdge, typename IndexMap,
        typename Orig2CopyVertexIndexMap>
      static void apply(const Graph& g_in, MutableGraph& g_out, 
                        CopyVertex copy_vertex, CopyEdge copy_edge,
                        Orig2CopyVertexIndexMap orig2copy, IndexMap)
      {
        typedef remove_reverse_edge_descriptor<Graph, typename graph_traits<Graph>::edge_descriptor> cvt;
        typename graph_traits<Graph>::vertex_iterator vi, vi_end;
        for (boost::tie(vi, vi_end) = vertices(g_in); vi != vi_end; ++vi) {
          typename graph_traits<MutableGraph>::vertex_descriptor
            new_v = add_vertex(g_out);
          put(orig2copy, *vi, new_v);
          copy_vertex(*vi, new_v);
        }
        typename graph_traits<Graph>::edge_iterator ei, ei_end;
        for (boost::tie(ei, ei_end) = edges(g_in); ei != ei_end; ++ei) {
          typename graph_traits<MutableGraph>::edge_descriptor new_e;
          bool inserted;
          boost::tie(new_e, inserted) = add_edge(get(orig2copy, source(*ei, g_in)), 
                                                 get(orig2copy, target(*ei, g_in)),
                                                 g_out);
          copy_edge(cvt::convert(*ei, g_in), new_e);
        }
      }

      template <typename Graph, typename MutableGraph, 
        typename CopyVertex, typename CopyEdge, typename IndexMap,
        typename Orig2CopyVertexIndexMap>
      static void apply(const Graph& g_in, MutableGraph& g_out, 
                        CopyVertex copy_vertex, CopyEdge copy_edge,
                        Orig2CopyVertexIndexMap orig2copy, IndexMap)
      {
        typedef remove_reverse_edge_descriptor<Graph, typename graph_traits<Graph>::edge_descriptor> cvt;
        typename graph_traits<Graph>::vertex_iterator vi, vi_end;
        for (boost::tie(vi, vi_end) = vertices(g_in); vi != vi_end; ++vi) {
          typename graph_traits<MutableGraph>::vertex_descriptor
            new_v = add_vertex(g_out);
          put(orig2copy, *vi, new_v);
          copy_vertex(*vi, new_v);
        }
        for (boost::tie(vi, vi_end) = vertices(g_in); vi != vi_end; ++vi) {
          typename graph_traits<Graph>::out_edge_iterator ei, ei_end;
          for (boost::tie(ei, ei_end) = out_edges(*vi, g_in); ei != ei_end; ++ei) {
            typename graph_traits<MutableGraph>::edge_descriptor new_e;
            bool inserted;
            boost::tie(new_e, inserted) = add_edge(get(orig2copy, source(*ei, g_in)), 
                                                   get(orig2copy, target(*ei, g_in)),
                                                   g_out);
            copy_edge(cvt::convert(*ei, g_in), new_e);
          }
        }
      }

      template <typename Graph, typename MutableGraph, 
        typename CopyVertex, typename CopyEdge, typename IndexMap,
        typename Orig2CopyVertexIndexMap>
      static void apply(const Graph& g_in, MutableGraph& g_out, 
                        CopyVertex copy_vertex, CopyEdge copy_edge,
                        Orig2CopyVertexIndexMap orig2copy,
                        IndexMap index_map)
      {
        typedef remove_reverse_edge_descriptor<Graph, typename graph_traits<Graph>::edge_descriptor> cvt;
        typedef color_traits<default_color_type> Color;
        std::vector<default_color_type> 
          color(num_vertices(g_in), Color::white());
        typename graph_traits<Graph>::vertex_iterator vi, vi_end;
        for (boost::tie(vi, vi_end) = vertices(g_in); vi != vi_end; ++vi) {
          typename graph_traits<MutableGraph>::vertex_descriptor
            new_v = add_vertex(g_out);
          put(orig2copy, *vi, new_v);
          copy_vertex(*vi, new_v);
        }
        for (boost::tie(vi, vi_end) = vertices(g_in); vi != vi_end; ++vi) {
          typename graph_traits<Graph>::out_edge_iterator ei, ei_end;
          for (boost::tie(ei, ei_end) = out_edges(*vi, g_in); ei != ei_end; ++ei) {
            typename graph_traits<MutableGraph>::edge_descriptor new_e;
            bool inserted;
            if (color[get(index_map, target(*ei, g_in))] == Color::white()) {
              boost::tie(new_e, inserted) = add_edge(get(orig2copy, source(*ei,g_in)),
                                                     get(orig2copy, target(*ei,g_in)),
                                                     g_out);
              copy_edge(cvt::convert(*ei, g_in), new_e);
            }
          }
          color[get(index_map, *vi)] = Color::black();
        }
      }

        static result_type apply(const P& p, const G1&, G2&)
        { return p; }

        static result_type apply(const P&, const G1& g1, G2& g2) { 
          return result_type(g1, g2);
        }

    template <typename Param, typename G1, typename G2>
    typename detail::choose_edge_copier_helper<Param,G1,G2>::result_type
    choose_edge_copier(const Param& params, const G1& g_in, G2& g_out)
    {
      typedef typename 
        detail::choose_edge_copier_helper<Param,G1,G2>::type Choice;
      return Choice::apply(params, g_in, g_out);
    }

        static result_type apply(const P&, const G1& g1, G2& g2) { 
          return result_type(g1, g2);
        }

    template <typename Param, typename G1, typename G2>
    typename detail::choose_vertex_copier_helper<Param,G1,G2>::result_type
    choose_vertex_copier(const Param& params, const G1& g_in, G2& g_out)
    {
      typedef typename 
        detail::choose_vertex_copier_helper<Param,G1,G2>::type Choice;
      return Choice::apply(params, g_in, g_out);
    }



  template <typename VertexListGraph, typename MutableGraph>
  void copy_graph(const VertexListGraph& g_in, MutableGraph& g_out)
  {
    if (num_vertices(g_in) == 0)
      return;
    typedef typename graph_traits<MutableGraph>::vertex_descriptor vertex_t;
    std::vector<vertex_t> orig2copy(num_vertices(g_in));
    typedef typename detail::choose_graph_copy<VertexListGraph>::type 
      copy_impl;
    copy_impl::apply
      (g_in, g_out, 
       detail::make_vertex_copier(g_in, g_out), 
       detail::make_edge_copier(g_in, g_out), 
       make_iterator_property_map(orig2copy.begin(), 
                                  get(vertex_index, g_in), orig2copy[0]),
       get(vertex_index, g_in)
       );
  }


  template <typename VertexListGraph, typename MutableGraph, 
    class P, class T, class R>
  void copy_graph(const VertexListGraph& g_in, MutableGraph& g_out, 
                  const bgl_named_params<P, T, R>& params)
  {
    typename std::vector<T>::size_type n;
      n = is_default_param(get_param(params, orig_to_copy_t()))
        ? num_vertices(g_in) : 1;
    if (n == 0)
      return;
    std::vector<BOOST_DEDUCED_TYPENAME graph_traits<MutableGraph>::vertex_descriptor> 
      orig2copy(n);

    typedef typename detail::choose_graph_copy<VertexListGraph>::type 
      copy_impl;
    copy_impl::apply
      (g_in, g_out,
       detail::choose_vertex_copier(get_param(params, vertex_copy_t()), 
                                    g_in, g_out),
       detail::choose_edge_copier(get_param(params, edge_copy_t()), 
                                  g_in, g_out),
       choose_param(get_param(params, orig_to_copy_t()),
                    make_iterator_property_map
                    (orig2copy.begin(), 
                     choose_const_pmap(get_param(params, vertex_index), 
                                 g_in, vertex_index), orig2copy[0])),
       choose_const_pmap(get_param(params, vertex_index), g_in, vertex_index)
       );
  }

      graph_copy_visitor(NewGraph& graph, Copy2OrigIndexMap c,
                         CopyVertex cv, CopyEdge ce)
        : g_out(graph), orig2copy(c), copy_vertex(cv), copy_edge(ce) { }


      template <class Vertex, class Graph>
      typename graph_traits<NewGraph>::vertex_descriptor copy_one_vertex(Vertex u) const {
        typename graph_traits<NewGraph>::vertex_descriptor
          new_u = add_vertex(g_out);
        put(orig2copy, u, new_u);
        copy_vertex(u, new_u);
        return new_u;
      }

      
      template <class Edge, class Graph>
      void tree_edge(Edge e, const Graph& g_in) const {
        // For a tree edge, the target vertex has not been copied yet.
        typename graph_traits<NewGraph>::edge_descriptor new_e;
        bool inserted;
        boost::tie(new_e, inserted) = add_edge(get(orig2copy, source(e, g_in)), 
                                               this->copy_one_vertex(target(e, g_in)),
                                               g_out);
        copy_edge(e, new_e);
      }

      
      template <class Edge, class Graph>
      void non_tree_edge(Edge e, const Graph& g_in) const {
        // For a non-tree edge, the target vertex has already been copied.
        typename graph_traits<NewGraph>::edge_descriptor new_e;
        bool inserted;
        boost::tie(new_e, inserted) = add_edge(get(orig2copy, source(e, g_in)), 
                                               get(orig2copy, target(e, g_in)),
                                               g_out);
        copy_edge(e, new_e);
      }


    template <typename Graph, typename MutableGraph, 
              typename CopyVertex, typename CopyEdge, 
              typename Orig2CopyVertexIndexMap, typename Params>
    typename graph_traits<MutableGraph>::vertex_descriptor
    copy_component_impl
      (const Graph& g_in, 
       typename graph_traits<Graph>::vertex_descriptor src,
       MutableGraph& g_out, 
       CopyVertex copy_vertex, CopyEdge copy_edge,
       Orig2CopyVertexIndexMap orig2copy,
       const Params& params)
    {
      graph_copy_visitor<MutableGraph, Orig2CopyVertexIndexMap, 
        CopyVertex, CopyEdge> vis(g_out, orig2copy, copy_vertex, copy_edge);
      typename graph_traits<MutableGraph>::vertex_descriptor src_copy
        = vis.copy_one_vertex(src);
      breadth_first_search(g_in, src, params.visitor(vis));
      return src_copy;
    }

  template <typename IncidenceGraph, typename MutableGraph, 
           typename P, typename T, typename R>
  typename graph_traits<MutableGraph>::vertex_descriptor
  copy_component(IncidenceGraph& g_in, 
                 typename graph_traits<IncidenceGraph>::vertex_descriptor src,
                 MutableGraph& g_out, 
                 const bgl_named_params<P, T, R>& params)
  {
    typename std::vector<T>::size_type n;
      n = is_default_param(get_param(params, orig_to_copy_t()))
        ? num_vertices(g_in) : 1;
    std::vector<typename graph_traits<IncidenceGraph>::vertex_descriptor> 
      orig2copy(n);
    
    return detail::copy_component_impl
      (g_in, src, g_out,
       detail::choose_vertex_copier(get_param(params, vertex_copy_t()), 
                                    g_in, g_out),
       detail::choose_edge_copier(get_param(params, edge_copy_t()), 
                                  g_in, g_out),
       choose_param(get_param(params, orig_to_copy_t()),
                    make_iterator_property_map
                    (orig2copy.begin(), 
                     choose_pmap(get_param(params, vertex_index), 
                                 g_in, vertex_index), orig2copy[0])),
       params
       );
  }


  template <typename IncidenceGraph, typename MutableGraph>
  typename graph_traits<MutableGraph>::vertex_descriptor
  copy_component(IncidenceGraph& g_in, 
                 typename graph_traits<IncidenceGraph>::vertex_descriptor src,
                 MutableGraph& g_out)
  {
    std::vector<typename graph_traits<IncidenceGraph>::vertex_descriptor> 
      orig2copy(num_vertices(g_in));
    
    return detail::copy_component_impl
      (g_in, src, g_out,
       make_vertex_copier(g_in, g_out), 
       make_edge_copier(g_in, g_out), 
       make_iterator_property_map(orig2copy.begin(), 
                                  get(vertex_index, g_in), orig2copy[0]),
       bgl_named_params<char,char>('x') // dummy param object
       );
  }


    template <class Graph, class OutputIterator, 
              class Rank, class Parent, class Weight>
    void
    kruskal_mst_impl(const Graph& G, 
                     OutputIterator spanning_tree_edges, 
                     Rank rank, Parent parent, Weight weight)
    {
      if (num_vertices(G) == 0) return; // Nothing to do in this case
      typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
      typedef typename graph_traits<Graph>::edge_descriptor Edge;
      BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
      BOOST_CONCEPT_ASSERT(( EdgeListGraphConcept<Graph> ));
      BOOST_CONCEPT_ASSERT(( OutputIteratorConcept<OutputIterator, Edge> ));
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<Rank, Vertex> ));
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<Parent, Vertex> ));
      BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<Weight, Edge> ));
      typedef typename property_traits<Weight>::value_type W_value;
      typedef typename property_traits<Rank>::value_type R_value;
      typedef typename property_traits<Parent>::value_type P_value;
      BOOST_CONCEPT_ASSERT(( ComparableConcept<W_value> ));
      BOOST_CONCEPT_ASSERT(( ConvertibleConcept<P_value, Vertex> ));
      BOOST_CONCEPT_ASSERT(( IntegerConcept<R_value> ));

      disjoint_sets<Rank, Parent>  dset(rank, parent);

      typename graph_traits<Graph>::vertex_iterator ui, uiend;
      for (boost::tie(ui, uiend) = vertices(G); ui != uiend; ++ui)
        dset.make_set(*ui);

      typedef indirect_cmp<Weight, std::greater<W_value> > weight_greater;
      weight_greater wl(weight);
      std::priority_queue<Edge, std::vector<Edge>, weight_greater> Q(wl);
      /*push all edge into Q*/
      typename graph_traits<Graph>::edge_iterator ei, eiend;
      for (boost::tie(ei, eiend) = edges(G); ei != eiend; ++ei) 
        Q.push(*ei);

      while (! Q.empty()) {
        Edge e = Q.top();
        Q.pop();
        Vertex u = dset.find_set(source(e, G));
        Vertex v = dset.find_set(target(e, G));
        if ( u != v ) {
          *spanning_tree_edges++ = e;
          dset.link(u, v);
        }
      }
    }


  template <class Graph, class OutputIterator>
  inline void 
  kruskal_minimum_spanning_tree(const Graph& g,
                                OutputIterator spanning_tree_edges)
  {
    typedef typename graph_traits<Graph>::vertices_size_type size_type;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef typename property_map<Graph, vertex_index_t>::type index_map_t;
    if (num_vertices(g) == 0) return; // Nothing to do in this case
    typename graph_traits<Graph>::vertices_size_type
      n = num_vertices(g);
    std::vector<size_type> rank_map(n);
    std::vector<vertex_t> pred_map(n);

    detail::kruskal_mst_impl
      (g, spanning_tree_edges, 
       make_iterator_property_map(rank_map.begin(), get(vertex_index, g), rank_map[0]),
       make_iterator_property_map(pred_map.begin(), get(vertex_index, g), pred_map[0]),
       get(edge_weight, g));
  }


  template <class Graph, class OutputIterator, class P, class T, class R>
  inline void
  kruskal_minimum_spanning_tree(const Graph& g,
                                OutputIterator spanning_tree_edges, 
                                const bgl_named_params<P, T, R>& params)
  {
    typedef typename graph_traits<Graph>::vertices_size_type size_type;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    if (num_vertices(g) == 0) return; // Nothing to do in this case
    typename graph_traits<Graph>::vertices_size_type n;
    n = is_default_param(get_param(params, vertex_rank))
                                   ? num_vertices(g) : 1;
    std::vector<size_type> rank_map(n);
    n = is_default_param(get_param(params, vertex_predecessor))
                                   ? num_vertices(g) : 1;
    std::vector<vertex_t> pred_map(n);
    
    detail::kruskal_mst_impl
      (g, spanning_tree_edges, 
       choose_param
       (get_param(params, vertex_rank), 
        make_iterator_property_map
        (rank_map.begin(), 
         choose_pmap(get_param(params, vertex_index), g, vertex_index), rank_map[0])),
       choose_param
       (get_param(params, vertex_predecessor), 
        make_iterator_property_map
        (pred_map.begin(), 
         choose_const_pmap(get_param(params, vertex_index), g, vertex_index), 
         pred_map[0])),
       choose_const_pmap(get_param(params, edge_weight), g, edge_weight));
  }

    template <class Graph>
    inline typename graph_traits<Graph>::degree_size_type
    possible_edges(const Graph& g, std::size_t k, directed_tag)
    {
        BOOST_CONCEPT_ASSERT(( GraphConcept<Graph> ));
        typedef typename graph_traits<Graph>::degree_size_type T;
        return T(k) * (T(k) - 1);
    }

    template <class Graph>
    inline typename graph_traits<Graph>::degree_size_type
    count_edges(const Graph& g,
                typename graph_traits<Graph>::vertex_descriptor u,
                typename graph_traits<Graph>::vertex_descriptor v,
                directed_tag)

    {
        BOOST_CONCEPT_ASSERT(( AdjacencyMatrixConcept<Graph> ));
        return (lookup_edge(u, v, g).second ? 1 : 0) +
                (lookup_edge(v, u, g).second ? 1 : 0);
    }

    template <class Graph>
    inline typename graph_traits<Graph>::degree_size_type
    count_edges(const Graph& g,
                typename graph_traits<Graph>::vertex_descriptor u,
                typename graph_traits<Graph>::vertex_descriptor v,
                undirected_tag)
    {
        BOOST_CONCEPT_ASSERT(( AdjacencyMatrixConcept<Graph> ));
        return lookup_edge(u, v, g).second ? 1 : 0;
    }


template <typename Graph, typename Vertex>
inline typename graph_traits<Graph>::degree_size_type
num_paths_through_vertex(const Graph& g, Vertex v)
{
    BOOST_CONCEPT_ASSERT(( AdjacencyGraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::directed_category Directed;
    typedef typename graph_traits<Graph>::adjacency_iterator AdjacencyIterator;

    // TODO: There should actually be a set of neighborhood functions
    // for things like this (num_neighbors() would be great).

    AdjacencyIterator i, end;
    boost::tie(i, end) = adjacent_vertices(v, g);
    std::size_t k = std::distance(i, end);
    return detail::possible_edges(g, k, Directed());
}


template <typename Graph, typename Vertex>
inline typename graph_traits<Graph>::degree_size_type
num_triangles_on_vertex(const Graph& g, Vertex v)
{
    BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<Graph> ));
    BOOST_CONCEPT_ASSERT(( AdjacencyGraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::degree_size_type Degree;
    typedef typename graph_traits<Graph>::directed_category Directed;
    typedef typename graph_traits<Graph>::adjacency_iterator AdjacencyIterator;

    // TODO: I might be able to reduce the requirement from adjacency graph
    // to incidence graph by using out edges.

    Degree count(0);
    AdjacencyIterator i, j, end;
    for(boost::tie(i, end) = adjacent_vertices(v, g); i != end; ++i) {
        for(j = boost::next(i); j != end; ++j) {
            count += detail::count_edges(g, *i, *j, Directed());
        }
    }
    return count;
}


template <typename T, typename Graph, typename Vertex>
inline T
clustering_coefficient(const Graph& g, Vertex v)
{
    T zero(0);
    T routes = T(num_paths_through_vertex(g, v));
    return (routes > zero) ?
        T(num_triangles_on_vertex(g, v)) / routes : zero;
}


template <typename Graph, typename Vertex>
inline double
clustering_coefficient(const Graph& g, Vertex v)
{ return clustering_coefficient<double>(g, v); }


template <typename Graph, typename ClusteringMap>
inline typename property_traits<ClusteringMap>::value_type
all_clustering_coefficients(const Graph& g, ClusteringMap cm)
{
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename graph_traits<Graph>::vertex_iterator VertexIterator;
    BOOST_CONCEPT_ASSERT(( WritablePropertyMapConcept<ClusteringMap,Vertex> ));
    typedef typename property_traits<ClusteringMap>::value_type Coefficient;

    Coefficient sum(0);
    VertexIterator i, end;
    for(boost::tie(i, end) = vertices(g); i != end; ++i) {
        Coefficient cc = clustering_coefficient<Coefficient>(g, *i);
        put(cm, *i, cc);
        sum += cc;
    }
    return sum / Coefficient(num_vertices(g));
}


template <typename Graph, typename ClusteringMap>
inline typename property_traits<ClusteringMap>::value_type
mean_clustering_coefficient(const Graph& g, ClusteringMap cm)
{
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename graph_traits<Graph>::vertex_iterator VertexIterator;
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<ClusteringMap,Vertex> ));
    typedef typename property_traits<ClusteringMap>::value_type Coefficient;

    Coefficient cc(0);
    VertexIterator i, end;
    for(boost::tie(i, end) = vertices(g); i != end; ++i) {
        cc += get(cm, *i);
    }
    return cc / Coefficient(num_vertices(g));
}


    template<typename Graph, 
             typename VertexToVertexMap, 
             typename VertexTo1DCoordMap>
    void accumulate_offsets(typename graph_traits<Graph>::vertex_descriptor v,
                            std::size_t offset,
                            const Graph& g,
                            VertexTo1DCoordMap x,
                            VertexTo1DCoordMap delta_x,
                            VertexToVertexMap left,
                            VertexToVertexMap right)
    {
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
      // Suggestion of explicit stack from Aaron Windsor to avoid system stack
      // overflows.
      typedef std::pair<vertex_descriptor, std::size_t> stack_entry;
      std::stack<stack_entry> st;
      st.push(stack_entry(v, offset));
      while (!st.empty()) {
        vertex_descriptor v = st.top().first;
        std::size_t offset = st.top().second;
        st.pop();
        if (v != graph_traits<Graph>::null_vertex()) {
          x[v] += delta_x[v] + offset;
          st.push(stack_entry(left[v], x[v]));
          st.push(stack_entry(right[v], x[v]));
        }
      }
    }






  template<typename Graph, 
           typename PlanarEmbedding, 
           typename ForwardIterator, 
           typename GridPositionMap,
           typename VertexIndexMap>
  void chrobak_payne_straight_line_drawing(const Graph& g, 
                                           PlanarEmbedding embedding, 
                                           ForwardIterator ordering_begin,
                                           ForwardIterator ordering_end,
                                           GridPositionMap drawing,
                                           VertexIndexMap vm
                                           )
  {

    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef typename graph_traits<Graph>::edge_descriptor edge_t;
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator_t;
    typedef typename PlanarEmbedding::value_type::const_iterator 
      edge_permutation_iterator_t;
    typedef typename graph_traits<Graph>::vertices_size_type v_size_t;
    typedef std::vector<vertex_t> vertex_vector_t;
    typedef std::vector<v_size_t> vsize_vector_t;
    typedef std::vector<bool> bool_vector_t;
    typedef boost::iterator_property_map
      <typename vertex_vector_t::iterator, VertexIndexMap> 
      vertex_to_vertex_map_t;
    typedef boost::iterator_property_map
      <typename vsize_vector_t::iterator, VertexIndexMap> 
      vertex_to_vsize_map_t;
    typedef boost::iterator_property_map
      <typename bool_vector_t::iterator, VertexIndexMap> 
      vertex_to_bool_map_t;

    vertex_vector_t left_vector(num_vertices(g), 
                                graph_traits<Graph>::null_vertex()
                                );
    vertex_vector_t right_vector(num_vertices(g), 
                                 graph_traits<Graph>::null_vertex()
                                 );
    vsize_vector_t seen_as_right_vector(num_vertices(g), 0);
    vsize_vector_t seen_vector(num_vertices(g), 0);
    vsize_vector_t delta_x_vector(num_vertices(g),0);
    vsize_vector_t y_vector(num_vertices(g));
    vsize_vector_t x_vector(num_vertices(g),0);
    bool_vector_t installed_vector(num_vertices(g),false);

    vertex_to_vertex_map_t left(left_vector.begin(), vm);
    vertex_to_vertex_map_t right(right_vector.begin(), vm);
    vertex_to_vsize_map_t seen_as_right(seen_as_right_vector.begin(), vm);
    vertex_to_vsize_map_t seen(seen_vector.begin(), vm);
    vertex_to_vsize_map_t delta_x(delta_x_vector.begin(), vm);
    vertex_to_vsize_map_t y(y_vector.begin(), vm);
    vertex_to_vsize_map_t x(x_vector.begin(), vm);
    vertex_to_bool_map_t installed(installed_vector.begin(), vm);

    v_size_t timestamp = 1;
    vertex_vector_t installed_neighbors;

    ForwardIterator itr = ordering_begin;
    vertex_t v1 = *itr; ++itr;
    vertex_t v2 = *itr; ++itr;
    vertex_t v3 = *itr; ++itr;

    delta_x[v2] = 1; 
    delta_x[v3] = 1;
    
    y[v1] = 0;
    y[v2] = 0;
    y[v3] = 1;

    right[v1] = v3;
    right[v3] = v2;

    installed[v1] = installed[v2] = installed[v3] = true;

    for(ForwardIterator itr_end = ordering_end; itr != itr_end; ++itr)
      {
        vertex_t v = *itr;

        // First, find the leftmost and rightmost neighbor of v on the outer 
        // cycle of the embedding. 
        // Note: since we're moving clockwise through the edges adjacent to v, 
        // we're actually moving from right to left among v's neighbors on the
        // outer face (since v will be installed above them all) looking for 
        // the leftmost and rightmost installed neigbhors

        vertex_t leftmost = graph_traits<Graph>::null_vertex();
        vertex_t rightmost = graph_traits<Graph>::null_vertex();

        installed_neighbors.clear();

        vertex_t prev_vertex = graph_traits<Graph>::null_vertex();
        edge_permutation_iterator_t pi, pi_end;
        pi_end = embedding[v].end();
        for(pi = embedding[v].begin(); pi != pi_end; ++pi)
          {
            vertex_t curr_vertex = source(*pi,g) == v ? 
              target(*pi,g) : source(*pi,g);
            
            // Skip any self-loops or parallel edges
            if (curr_vertex == v || curr_vertex == prev_vertex)
                continue;

            if (installed[curr_vertex])
              {
                seen[curr_vertex] = timestamp;

                if (right[curr_vertex] != graph_traits<Graph>::null_vertex())
                  {
                    seen_as_right[right[curr_vertex]] = timestamp;
                  }
                installed_neighbors.push_back(curr_vertex);
              }

            prev_vertex = curr_vertex;
          }

        typename vertex_vector_t::iterator vi, vi_end;
        vi_end = installed_neighbors.end();
        for(vi = installed_neighbors.begin(); vi != vi_end; ++vi)
          {
            if (right[*vi] == graph_traits<Graph>::null_vertex() || 
                seen[right[*vi]] != timestamp
                )
              rightmost = *vi;
            if (seen_as_right[*vi] != timestamp)
              leftmost = *vi;
          }

        ++timestamp;

        //stretch gaps
        ++delta_x[right[leftmost]];
        ++delta_x[rightmost];

        //adjust offsets
        std::size_t delta_p_q = 0;
        vertex_t stopping_vertex = right[rightmost];
        for(vertex_t temp = right[leftmost]; temp != stopping_vertex; 
            temp = right[temp]
            )
          {
            delta_p_q += delta_x[temp];
          }

        delta_x[v] = ((y[rightmost] + delta_p_q) - y[leftmost])/2;
        y[v] = y[leftmost] + delta_x[v];
        delta_x[rightmost] = delta_p_q - delta_x[v];
        
        bool leftmost_and_rightmost_adjacent = right[leftmost] == rightmost;
        if (!leftmost_and_rightmost_adjacent)
          delta_x[right[leftmost]] -= delta_x[v];

        //install v
        if (!leftmost_and_rightmost_adjacent)
          {
            left[v] = right[leftmost];
            vertex_t next_to_rightmost;
            for(vertex_t temp = leftmost; temp != rightmost; 
                temp = right[temp]
                )
              {
                next_to_rightmost = temp;
              }

            right[next_to_rightmost] = graph_traits<Graph>::null_vertex();
          }
        else
          {
            left[v] = graph_traits<Graph>::null_vertex();
          }

        right[leftmost] = v;
        right[v] = rightmost;
        installed[v] = true;

      }

    graph::detail::accumulate_offsets
      (*ordering_begin,0,g,x,delta_x,left,right);

    vertex_iterator_t vi, vi_end;
    for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
      {
        vertex_t v(*vi);
        drawing[v].x = x[v];
        drawing[v].y = y[v];
      }

  }





  template<typename Graph, 
           typename PlanarEmbedding, 
           typename ForwardIterator, 
           typename GridPositionMap>
  inline void chrobak_payne_straight_line_drawing(const Graph& g, 
                                                  PlanarEmbedding embedding, 
                                                  ForwardIterator ord_begin,
                                                  ForwardIterator ord_end,
                                                  GridPositionMap drawing
                                                  )
  {
    chrobak_payne_straight_line_drawing(g, 
                                        embedding, 
                                        ord_begin, 
                                        ord_end, 
                                        drawing, 
                                        get(vertex_index,g)
                                        );
  }

  template <class Graph, class RandomNumGen>
  typename graph_traits<Graph>::vertex_descriptor
  random_vertex(Graph& g, RandomNumGen& gen)
  {
    if (num_vertices(g) > 1) {
    #if BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT(0x581))
      std::size_t n = std::random( num_vertices(g) );
    #else
      uniform_int<> distrib(0, num_vertices(g)-1);
      variate_generator<RandomNumGen&, uniform_int<> > rand_gen(gen, distrib);
      std::size_t n = rand_gen();
    #endif
      typename graph_traits<Graph>::vertex_iterator
        i = vertices(g).first;
      return *(boost::next(i, n));
    } else
      return *vertices(g).first;
  }


  template <class Graph, class RandomNumGen>
  typename graph_traits<Graph>::edge_descriptor
  random_edge(Graph& g, RandomNumGen& gen) {
    if (num_edges(g) > 1) {
    #if BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT(0x581))
      typename graph_traits<Graph>::edges_size_type
        n = std::random( num_edges(g) );
    #else
      uniform_int<> distrib(0, num_edges(g)-1);
      variate_generator<RandomNumGen&, uniform_int<> > rand_gen(gen, distrib);
      typename graph_traits<Graph>::edges_size_type
        n = rand_gen();
    #endif
      typename graph_traits<Graph>::edge_iterator
        i = edges(g).first;
      return *(boost::next(i, n));
    } else
      return *edges(g).first;
  }


  template <typename Graph, typename RandomNumGen>
  typename graph_traits<Graph>::edge_descriptor
  random_out_edge(Graph& g, typename graph_traits<Graph>::vertex_descriptor src, RandomNumGen& gen) {
    typedef typename graph_traits<Graph>::degree_size_type degree_size_type;
    typedef boost::uniform_int<degree_size_type> ui_type;
    ui_type ui(0, out_degree(src, g) - 1);
    boost::variate_generator<RandomNumGen&, ui_type>
      variate(gen, ui);
    typename graph_traits<Graph>::out_edge_iterator it = out_edges(src, g).first;
    std::advance(it, variate());
    return *it;
  }


  template <typename Graph, typename WeightMap, typename RandomNumGen>
  typename graph_traits<Graph>::edge_descriptor
  weighted_random_out_edge(Graph& g, typename graph_traits<Graph>::vertex_descriptor src, WeightMap weight, RandomNumGen& gen) {
    typedef graph_traits<Graph> gt;
    typedef typename gt::vertex_descriptor vertex_descriptor;
    typedef typename property_traits<WeightMap>::value_type weight_type;
    weight_type weight_sum(0);
    BGL_FORALL_OUTEDGES_T(src, e, g, Graph) {weight_sum += get(weight, e);}
    typedef boost::uniform_real<> ur_type;
    ur_type ur(0, weight_sum);
    boost::variate_generator<RandomNumGen&, ur_type>
      variate(gen, ur);
    weight_type chosen_weight = variate();
    BGL_FORALL_OUTEDGES_T(src, e, g, Graph) {
      weight_type w = get(weight, e);
      if (chosen_weight < w) {
        return e;
      } else {
        chosen_weight -= w;
      }
    }
    BOOST_ASSERT (false); // Should not get here
  }

      template<class V1, class V2>
      void operator()(const V1&, const V2&) const {}


  template <typename MutableGraph, class RandNumGen>
  void generate_random_graph1
    (MutableGraph& g,
     typename graph_traits<MutableGraph>::vertices_size_type V,
     typename graph_traits<MutableGraph>::vertices_size_type E,
     RandNumGen& gen,
     bool allow_parallel = true,
     bool self_edges = false)
  {
    typedef graph_traits<MutableGraph> Traits;
    typedef typename Traits::edge_descriptor edge_t;
    typedef typename Traits::vertices_size_type v_size_t;
    typedef typename Traits::edges_size_type e_size_t;
    typedef typename Traits::vertex_descriptor vertex_descriptor;

    // When parallel edges are not allowed, we create a new graph which
    // does not allow parallel edges, construct it and copy back.
    // This is not efficient if 'g' already disallow parallel edges,
    // but that's task for later.
    if (!allow_parallel) {

      typedef typename boost::graph_traits<MutableGraph>::directed_category dir;
      typedef typename mpl::if_<is_convertible<dir, directed_tag>,
          directedS, undirectedS>::type select;
      adjacency_list<setS, vecS, select> g2;
      generate_random_graph1(g2, V, E, gen, true, self_edges);

      copy_graph(g2, g, vertex_copy(detail::dummy_property_copier()).
                        edge_copy(detail::dummy_property_copier()));

    } else {

      for (v_size_t i = 0; i < V; ++i)
        add_vertex(g);

      e_size_t not_inserted_counter = 0; /* Number of edge insertion failures */
      e_size_t num_vertices_squared = num_vertices(g) * num_vertices(g);
      for (e_size_t j = 0; j < E; /* Increment in body */) {
        vertex_descriptor a = random_vertex(g, gen), b;
        do {
          b = random_vertex(g, gen);
        } while (self_edges == false && a == b);
        edge_t e; bool inserted;
        boost::tie(e, inserted) = add_edge(a, b, g);
        if (inserted) {
          ++j;
        } else {
          ++not_inserted_counter;
        }
        if (not_inserted_counter >= num_vertices_squared) {
          return; /* Rather than looping forever on complete graph */
        }
      }
    }
  }


  template <typename MutableGraph, class RandNumGen>
  void generate_random_graph
    (MutableGraph& g,
     typename graph_traits<MutableGraph>::vertices_size_type V,
     typename graph_traits<MutableGraph>::vertices_size_type E,
     RandNumGen& gen,
     bool allow_parallel = true,
     bool self_edges = false)
  {
      generate_random_graph1(g, V, E, gen, allow_parallel, self_edges);
  }


  template <typename MutableGraph, typename RandNumGen,
            typename VertexOutputIterator, typename EdgeOutputIterator>
  void generate_random_graph
    (MutableGraph& g,
     typename graph_traits<MutableGraph>::vertices_size_type V,
     typename graph_traits<MutableGraph>::vertices_size_type E,
     RandNumGen& gen,
     VertexOutputIterator vertex_out,
     EdgeOutputIterator edge_out,
     bool self_edges = false)
  {
    typedef graph_traits<MutableGraph> Traits;
    typedef typename Traits::vertices_size_type v_size_t;
    typedef typename Traits::edges_size_type e_size_t;
    typedef typename Traits::vertex_descriptor vertex_t;
    typedef typename Traits::edge_descriptor edge_t;

    for (v_size_t i = 0; i < V; ++i)
      *vertex_out++ = add_vertex(g);

    e_size_t not_inserted_counter = 0; /* Number of edge insertion failures */
    e_size_t num_vertices_squared = num_vertices(g) * num_vertices(g);
    for (e_size_t j = 0; j < E; /* Increment in body */) {
      vertex_t a = random_vertex(g, gen), b;
      do {
        b = random_vertex(g, gen);
      } while (self_edges == false && a == b);
      edge_t e; bool inserted;
      boost::tie(e, inserted) = add_edge(a, b, g);
      if (inserted) {
        *edge_out++ = std::make_pair(source(e, g), target(e, g));
        ++j;
      } else {
        ++not_inserted_counter;
      }
      if (not_inserted_counter >= num_vertices_squared) {
        return; /* Rather than looping forever on complete graph */
      }
    }
  }


    template<class Property, class G, class RandomGenerator>
    void randomize_property(G& g, RandomGenerator& rg,
                            Property, vertex_property_tag)
    {
      typename property_map<G, Property>::type pm = get(Property(), g);
      typename graph_traits<G>::vertex_iterator vi, ve;
      for (boost::tie(vi, ve) = vertices(g); vi != ve; ++vi) {
        pm[*vi] = rg();
      }
    }


    template<class Property, class G, class RandomGenerator>
    void randomize_property(G& g, RandomGenerator& rg,
                            Property, edge_property_tag)
    {
      typename property_map<G, Property>::type pm = get(Property(), g);
      typename graph_traits<G>::edge_iterator ei, ee;
      for (boost::tie(ei, ee) = edges(g); ei != ee; ++ei) {
        pm[*ei] = rg();
      }
    }


  template<class Property, class G, class RandomGenerator>
  void randomize_property(G& g, RandomGenerator& rg)
  {
    detail::randomize_property
        (g, rg, Property(), typename property_kind<Property>::type());
  }


    result_type operator ()(distance_type d, const Graph&)
    {
        BOOST_CONCEPT_ASSERT(( NumericValueConcept<DistanceType> ));
        BOOST_CONCEPT_ASSERT(( NumericValueConcept<ResultType> ));
        BOOST_CONCEPT_ASSERT(( AdaptableUnaryFunctionConcept<Reciprocal,ResultType,ResultType> ));
        return (d == base_type::infinite_distance())
            ? base_type::zero_result()
            : rec(result_type(d));
    }


template <typename Graph, typename DistanceMap>
inline closeness_measure<
        Graph, typename property_traits<DistanceMap>::value_type, double,
        detail::reciprocal<double> >
measure_closeness(const Graph&, DistanceMap)
{
    typedef typename property_traits<DistanceMap>::value_type Distance;
    return closeness_measure<Graph, Distance, double, detail::reciprocal<double> >();
}


template <typename T, typename Graph, typename DistanceMap>
inline closeness_measure<
        Graph, typename property_traits<DistanceMap>::value_type, T,
        detail::reciprocal<T> >
measure_closeness(const Graph&, DistanceMap)
{
    typedef typename property_traits<DistanceMap>::value_type Distance;
    return closeness_measure<Graph, Distance, T, detail::reciprocal<T> >();
}


template <typename T, typename Graph, typename DistanceMap, typename Reciprocal>
inline closeness_measure<
        Graph, typename property_traits<DistanceMap>::value_type, T,
        Reciprocal>
measure_closeness(const Graph&, DistanceMap)
{
    typedef typename property_traits<DistanceMap>::value_type Distance;
    return closeness_measure<Graph, Distance, T, Reciprocal>();
}


template <typename Graph,
          typename DistanceMap,
          typename Measure,
          typename Combinator>
inline typename Measure::result_type
closeness_centrality(const Graph& g,
                     DistanceMap dist,
                     Measure measure,
                     Combinator combine)
{
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<DistanceMap,Vertex> ));
    typedef typename property_traits<DistanceMap>::value_type Distance;
    BOOST_CONCEPT_ASSERT(( NumericValueConcept<Distance> ));
    BOOST_CONCEPT_ASSERT(( DistanceMeasureConcept<Measure,Graph> ));

    Distance n = detail::combine_distances(g, dist, combine, Distance(0));
    return measure(n, g);
}


template <typename Graph, typename DistanceMap, typename Measure>
inline typename Measure::result_type
closeness_centrality(const Graph& g, DistanceMap dist, Measure measure)
{
    BOOST_CONCEPT_ASSERT(( GraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<DistanceMap,Vertex> ));
    typedef typename property_traits<DistanceMap>::value_type Distance;

    return closeness_centrality(g, dist, measure, std::plus<Distance>());
}


template <typename Graph, typename DistanceMap>
inline double closeness_centrality(const Graph& g, DistanceMap dist)
{ return closeness_centrality(g, dist, measure_closeness(g, dist)); }


template <typename T, typename Graph, typename DistanceMap>
inline T closeness_centrality(const Graph& g, DistanceMap dist)
{ return closeness_centrality(g, dist, measure_closeness<T>(g, dist)); }


template <typename Graph,
          typename DistanceMatrixMap,
          typename CentralityMap,
          typename Measure>
inline void
all_closeness_centralities(const Graph& g,
                           DistanceMatrixMap dist,
                           CentralityMap cent,
                           Measure measure)
{
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<DistanceMatrixMap,Vertex> ));
    typedef typename property_traits<DistanceMatrixMap>::value_type DistanceMap;
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<DistanceMap,Vertex> ));
    BOOST_CONCEPT_ASSERT(( WritablePropertyMapConcept<CentralityMap,Vertex> ));
    typedef typename property_traits<DistanceMap>::value_type Distance;
    typedef typename property_traits<CentralityMap>::value_type Centrality;

    typename graph_traits<Graph>::vertex_iterator i, end;
    for(boost::tie(i, end) = vertices(g); i != end; ++i) {
        DistanceMap dm = get(dist, *i);
        Centrality c = closeness_centrality(g, dm, measure);
        put(cent, *i, c);
    }
}


template <typename Graph,
          typename DistanceMatrixMap,
          typename CentralityMap>
inline void
all_closeness_centralities(const Graph& g,
                            DistanceMatrixMap dist,
                            CentralityMap cent)
{
    BOOST_CONCEPT_ASSERT(( GraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<DistanceMatrixMap,Vertex> ));
    typedef typename property_traits<DistanceMatrixMap>::value_type DistanceMap;
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<DistanceMap,Vertex> ));
    typedef typename property_traits<DistanceMap>::value_type Distance;
    typedef typename property_traits<CentralityMap>::value_type Result;

    all_closeness_centralities(g, dist, cent, measure_closeness<Result>(g, DistanceMap()));
}


    out_directed_plod_iterator() : gen(0), at_end(true) { }


    reference operator*() const { return current; }

    pointer operator->() const { return &current; }


    out_directed_plod_iterator& operator++()
    { 
      using std::pow;

      uniform_int<std::size_t> x(0, n-1);

      // Continue stepping through source nodes until the
      // (out)degree is > 0
      while (degree == 0) {
        // Step to the next source node. If we've gone past the
        // number of nodes we're responsible for, we're done.
        if (++current.first >= n) {
          at_end = true;
          return *this;
        }

        std::size_t xv = x(*gen);
        degree = (xv == 0? 0 : std::size_t(beta * pow(xv, -alpha)));      
      }

      do {
        current.second = x(*gen);
      } while (current.first == current.second && !allow_self_loops);
      --degree;

      return *this;
    }


    out_directed_plod_iterator operator++(int)
    {
      out_directed_plod_iterator temp(*this);
      ++(*this);
      return temp;
    }


    bool operator==(const out_directed_plod_iterator& other) const
    { 
      return at_end == other.at_end; 
    }


    bool operator!=(const out_directed_plod_iterator& other) const
    { 
      return !(*this == other); 
    }


    undirected_plod_iterator() 
      : gen(0), out_degrees(), degrees_left(0), allow_self_loops(false) { }


    reference operator*() const { return current; }

    pointer operator->() const { return &current; }


    undirected_plod_iterator& operator++()
    { 
      next();
      return *this;
    }


    undirected_plod_iterator operator++(int)
    {
      undirected_plod_iterator temp(*this);
      ++(*this);
      return temp;
    }


    bool operator==(const undirected_plod_iterator& other) const
    { 
      return degrees_left == other.degrees_left; 
    }


    bool operator!=(const undirected_plod_iterator& other) const
    { return !(*this == other); }

    void next()
    {
      std::size_t source, target;
      while (true) {
        /* We may get to the point where we can't actually find any
           new edges, so we just add some random edge and set the
           degrees left = 0 to signal termination. */
        if (out_degrees->size() < 2) {
          uniform_int<std::size_t> x(0, n-1);
          current.first  = x(*gen);
          do {
            current.second = x(*gen);
          } while (current.first == current.second && !allow_self_loops);
          degrees_left = 0;
          out_degrees->clear();
          return;
        }

        uniform_int<std::size_t> x(0, out_degrees->size()-1);

        // Select source vertex
        source = x(*gen);
        if ((*out_degrees)[source].second == 0) {
          (*out_degrees)[source] = out_degrees->back();
          out_degrees->pop_back();
          continue;
        } 

        // Select target vertex
        target = x(*gen);
        if ((*out_degrees)[target].second == 0) {
          (*out_degrees)[target] = out_degrees->back();
          out_degrees->pop_back();
          continue;
        } else if (source != target 
                   || (allow_self_loops && (*out_degrees)[source].second > 2)) {
          break;
        }
      }

      // Update degree counts
      --(*out_degrees)[source].second;
      --degrees_left;
      --(*out_degrees)[target].second;
      --degrees_left;
      current.first  = (*out_degrees)[source].first;
      current.second = (*out_degrees)[target].first;
    }

    plod_iterator() : inherited() { }

      edge_descriptor() { }

      edge_descriptor(const detail::dummy_constructor&) { }

      bool operator==(const edge_descriptor&) const { return false; }

      bool operator!=(const edge_descriptor&) const { return false; }


    static vertex_descriptor null_vertex() {return vertex_descriptor();}

  template <typename V, typename D, typename P, typename B>
  V source(const typename incidence_graph_archetype<V,D,P,B>::edge_descriptor&,
           const incidence_graph_archetype<V,D,P,B>& )
  {
    return V(static_object<detail::dummy_constructor>::get());
  }

  template <typename V, typename D, typename P, typename B>
  V target(const typename incidence_graph_archetype<V,D,P,B>::edge_descriptor&,
           const incidence_graph_archetype<V,D,P,B>& )
  {
    return V(static_object<detail::dummy_constructor>::get());
  }


  template <typename G, typename P, typename V, typename Key>
  void
  put(P p, property_graph_archetype<G, P, V>& g, 
      const Key& key, const V& value)
  {
    typedef typename boost::property_map<property_graph_archetype<G, P, V>, P>::type Map;
    Map pmap = get(p, g);
    put(pmap, key, value);
  }

    color_value_archetype() { }

    color_value_archetype(detail::dummy_constructor) { }

    bool operator==(const color_value_archetype& ) const { return true; }

    bool operator!=(const color_value_archetype& ) const { return true; }

    static color_value_archetype white()
    { 
      return color_value_archetype
        (static_object<detail::dummy_constructor>::get()); 
    }

    static color_value_archetype gray()
    {
      return color_value_archetype
        (static_object<detail::dummy_constructor>::get()); 
    }

    static color_value_archetype black()
    {
      return color_value_archetype
        (static_object<detail::dummy_constructor>::get()); 
    }

    void push(const T&) {}

    void pop() {}

    T& top() { return static_object<T>::get(); }

    const T& top() const { return static_object<T>::get(); }

    bool empty() const { return true; }


  explicit sort_edge_by_origin( Graph& g ) : g(g) {}
 

  inline bool operator()( edge_type a, edge_type b ) {
    return source( a, g ) == source( b, g ) ? target( a, g ) < target( b, g ) :
      source( a, g ) < source( b, g );
  }


  explicit equal_edge( Graph& g ) : g(g) {}
 

  inline bool operator()( edge_type a, edge_type b ) {
    return source( a, g ) == source( b, g ) &&
      target( a, g ) == target( b, g );
  }


template<typename Graph>
unsigned long num_dup_edges( Graph& g ) {
  typedef typename graph_traits<Graph>::edge_iterator e_iterator_type;
  typedef typename graph_traits<Graph>::edge_descriptor edge_type;

  std::list<edge_type> all_edges;
  
  BGL_FORALL_EDGES_T( e, g, Graph ) {
    all_edges.push_back( e );
  }
    
  sort_edge_by_origin<Graph> cmp1( g );
  all_edges.sort( cmp1 );
  equal_edge<Graph> cmp2( g );
  all_edges.unique( cmp2 );

  return num_edges( g ) - all_edges.size();
}


template <
    typename Graph, typename GraphTR, typename G_to_TR_VertexMap,
    typename VertexIndexMap
>
BOOST_CONCEPT_REQUIRES(
                      ((VertexListGraphConcept< Graph >))
                      ((IncidenceGraphConcept< Graph >))
                      ((MutableGraphConcept< GraphTR >))
                      ((ReadablePropertyMapConcept< VertexIndexMap,
                          typename graph_traits<Graph>::vertex_descriptor >))
                      ((Integer< typename
                          property_traits< VertexIndexMap >::value_type >))
                      ((LvaluePropertyMapConcept< G_to_TR_VertexMap,
                          typename graph_traits<Graph>::vertex_descriptor >)),
                       (void))
transitive_reduction(const Graph& g, GraphTR& tr,
                     G_to_TR_VertexMap g_to_tr_map,
                     VertexIndexMap g_index_map )
{
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename graph_traits<Graph>::vertex_iterator VertexIterator;
    typedef typename std::vector<Vertex>::size_type size_type;

    std::vector<Vertex> topo_order;
    topological_sort(g, std::back_inserter(topo_order));

    std::vector<size_type> topo_number_storage(num_vertices(g));

    iterator_property_map<size_type*, VertexIndexMap,
    size_type, size_type&> topo_number( &topo_number_storage[0], g_index_map );

    {
        typename std::vector<Vertex>::reverse_iterator it = topo_order.rbegin();
        size_type n = 0;
        for(; it != topo_order.rend(); ++it,++n ) {
            topo_number[ *it ] = n;
        }
    }

    std::vector< std::vector< bool > > edge_in_closure(num_vertices(g),
                                            std::vector<bool>( num_vertices(g), false));
    {
        typename std::vector<Vertex>::reverse_iterator it = topo_order.rbegin();
            for( ; it != topo_order.rend(); ++it ) {
            g_to_tr_map[*it] = add_vertex(tr);
        }
    }

    typename std::vector<Vertex>::iterator
        it = topo_order.begin(),
        end = topo_order.end();
    for( ; it != end; ++it ) {
        size_type i = topo_number[ *it ];
        edge_in_closure[i][i] = true;
        std::vector<Vertex> neighbors;

        //I have to collect the successors of *it and traverse them in
        //ascending topological order. I didn't know a better way, how to
        //do that. So what I'm doint is, collection the successors of *it here
        {
            typename Graph::out_edge_iterator oi,oi_end;
            for( boost::tie(oi, oi_end) = out_edges( *it, g ); oi != oi_end; ++oi ) {
                neighbors.push_back( target( *oi, g ) );
            }
        }

        {
            //and run through all vertices in topological order
            typename std::vector<Vertex>::reverse_iterator
                rit = topo_order.rbegin(),
                rend = topo_order.rend();
            for(; rit != rend; ++rit ) {
                //looking if they are successors of *it
                if( std::find( neighbors.begin(), neighbors.end(), *rit) != neighbors.end() ) {
                    size_type j = topo_number[ *rit ];
                    if( not edge_in_closure[i][j] ) {
                    for(size_type k = j; k < num_vertices(g); ++k) {
                        if( not edge_in_closure[i][k] ) {
                        //here we need edge_in_closure to be in topological order,
                        edge_in_closure[i][k] = edge_in_closure[j][k];
                        }
                    }
                    //therefore we only access edge_in_closure only through
                    //topo_number property_map
                    add_edge(g_to_tr_map[*it], g_to_tr_map[*rit], tr);
                    } //if ( not edge_in_
                } //if (find (
            } //for( typename vector<Vertex>::reverse_iterator
        } // {

    } //for( typename vector<Vertex>::iterator

}

    void constraints()
    {
      BOOST_CONCEPT_ASSERT(( CopyConstructibleConcept<Heuristic> ));
      h(u);
    }

    astar_heuristic() {}

    CostType operator()(Vertex u) { return static_cast<CostType>(0); }

    void constraints()
    {
      BOOST_CONCEPT_ASSERT(( CopyConstructibleConcept<Visitor> ));
      vis.initialize_vertex(u, g);
      vis.discover_vertex(u, g);
      vis.examine_vertex(u, g);
      vis.examine_edge(e, g);
      vis.edge_relaxed(e, g);
      vis.edge_not_relaxed(e, g);
      vis.black_target(e, g);
      vis.finish_vertex(u, g);
    }

    astar_visitor() {}

    astar_visitor(Visitors vis)
      : bfs_visitor<Visitors>(vis) {}


    template <class Edge, class Graph>
    void edge_relaxed(Edge e, const Graph& g) {
      invoke_visitors(this->m_vis, e, g, on_edge_relaxed());
    }

    template <class Edge, class Graph>
    void edge_not_relaxed(Edge e, const Graph& g) {
      invoke_visitors(this->m_vis, e, g, on_edge_not_relaxed());
    }

    template <class Edge, class Graph>
    void tree_edge(Edge e, const Graph& g) {}

    template <class Edge, class Graph>
    void non_tree_edge(Edge e, const Graph& g) {}

  template <class Visitors>
  astar_visitor<Visitors>
  make_astar_visitor(Visitors vis) {
    return astar_visitor<Visitors>(vis);
  }


      astar_bfs_visitor(AStarHeuristic h, UniformCostVisitor vis,
                        UpdatableQueue& Q, PredecessorMap p,
                        CostMap c, DistanceMap d, WeightMap w,
                        ColorMap col, BinaryFunction combine,
                        BinaryPredicate compare, C zero)
        : m_h(h), m_vis(vis), m_Q(Q), m_predecessor(p), m_cost(c),
          m_distance(d), m_weight(w), m_color(col),
          m_combine(combine), m_compare(compare), m_zero(zero) {}



      template <class Vertex, class Graph>
      void initialize_vertex(Vertex u, const Graph& g) {
        m_vis.initialize_vertex(u, g);
      }

      template <class Vertex, class Graph>
      void discover_vertex(Vertex u, const Graph& g) {
        m_vis.discover_vertex(u, g);
      }

      template <class Vertex, class Graph>
      void examine_vertex(Vertex u, const Graph& g) {
        m_vis.examine_vertex(u, g);
      }

      template <class Vertex, class Graph>
      void finish_vertex(Vertex u, const Graph& g) {
        m_vis.finish_vertex(u, g);
      }

      template <class Edge, class Graph>
      void examine_edge(Edge e, const Graph& g) {
        if (m_compare(get(m_weight, e), m_zero))
          BOOST_THROW_EXCEPTION(negative_edge());
        m_vis.examine_edge(e, g);
      }

      template <class Edge, class Graph>
      void non_tree_edge(Edge, const Graph&) {}




      template <class Edge, class Graph>
      void tree_edge(Edge e, const Graph& g) {
        using boost::get;
        bool m_decreased =
          relax(e, g, m_weight, m_predecessor, m_distance,
                m_combine, m_compare);

        if(m_decreased) {
          m_vis.edge_relaxed(e, g);
          put(m_cost, target(e, g),
              m_combine(get(m_distance, target(e, g)),
                        m_h(target(e, g))));
        } else
          m_vis.edge_not_relaxed(e, g);
      }



      template <class Edge, class Graph>
      void gray_target(Edge e, const Graph& g) {
        using boost::get;
        bool m_decreased =
          relax(e, g, m_weight, m_predecessor, m_distance,
                m_combine, m_compare);

        if(m_decreased) {
          put(m_cost, target(e, g),
              m_combine(get(m_distance, target(e, g)),
                        m_h(target(e, g))));
          m_Q.update(target(e, g));
          m_vis.edge_relaxed(e, g);
        } else
          m_vis.edge_not_relaxed(e, g);
      }



      template <class Edge, class Graph>
      void black_target(Edge e, const Graph& g) {
        using boost::get;
        bool m_decreased =
          relax(e, g, m_weight, m_predecessor, m_distance,
                m_combine, m_compare);

        if(m_decreased) {
          m_vis.edge_relaxed(e, g);
          put(m_cost, target(e, g),
              m_combine(get(m_distance, target(e, g)),
                        m_h(target(e, g))));
          m_Q.push(target(e, g));
          put(m_color, target(e, g), Color::gray());
          m_vis.black_target(e, g);
        } else
          m_vis.edge_not_relaxed(e, g);
      }




  template <typename VertexListGraph, typename AStarHeuristic,
            typename AStarVisitor, typename PredecessorMap,
            typename CostMap, typename DistanceMap,
            typename WeightMap, typename ColorMap,
            typename VertexIndexMap,
            typename CompareFunction, typename CombineFunction,
            typename CostInf, typename CostZero>
  inline void
  astar_search_no_init
    (const VertexListGraph &g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     AStarHeuristic h, AStarVisitor vis,
     PredecessorMap predecessor, CostMap cost,
     DistanceMap distance, WeightMap weight,
     ColorMap color, VertexIndexMap index_map,
     CompareFunction compare, CombineFunction combine,
     CostInf /*inf*/, CostZero zero)
  {
    typedef typename graph_traits<VertexListGraph>::vertex_descriptor
      Vertex;
    typedef boost::vector_property_map<std::size_t, VertexIndexMap> IndexInHeapMap;
    IndexInHeapMap index_in_heap(index_map);
    typedef d_ary_heap_indirect<Vertex, 4, IndexInHeapMap, CostMap, CompareFunction>
      MutableQueue;
    MutableQueue Q(cost, index_in_heap, compare);

    detail::astar_bfs_visitor<AStarHeuristic, AStarVisitor,
        MutableQueue, PredecessorMap, CostMap, DistanceMap,
        WeightMap, ColorMap, CombineFunction, CompareFunction>
      bfs_vis(h, vis, Q, predecessor, cost, distance, weight,
              color, combine, compare, zero);

    breadth_first_visit(g, s, Q, bfs_vis, color);
  }

      A operator()(const std::pair<A, B>& p) const {return p.first;}


  template <typename VertexListGraph, typename AStarHeuristic,
            typename AStarVisitor, typename PredecessorMap,
            typename CostMap, typename DistanceMap,
            typename WeightMap,
            typename CompareFunction, typename CombineFunction,
            typename CostInf, typename CostZero>
  inline void
  astar_search_no_init_tree
    (const VertexListGraph &g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     AStarHeuristic h, AStarVisitor vis,
     PredecessorMap predecessor, CostMap cost,
     DistanceMap distance, WeightMap weight,
     CompareFunction compare, CombineFunction combine,
     CostInf /*inf*/, CostZero zero)
  {
    typedef typename graph_traits<VertexListGraph>::vertex_descriptor
      Vertex;
    typedef typename property_traits<DistanceMap>::value_type Distance;
    typedef d_ary_heap_indirect<
              std::pair<Distance, Vertex>,
              4,
              null_property_map<std::pair<Distance, Vertex>, std::size_t>,
              function_property_map<graph_detail::select1st<Distance, Vertex>, std::pair<Distance, Vertex> >,
              CompareFunction>
      MutableQueue;
    MutableQueue Q(
      make_function_property_map<std::pair<Distance, Vertex> >(graph_detail::select1st<Distance, Vertex>()),
      null_property_map<std::pair<Distance, Vertex>, std::size_t>(),
      compare);

    vis.discover_vertex(s, g);
    Q.push(std::make_pair(get(cost, s), s));
    while (!Q.empty()) {
      Vertex v;
      Distance v_rank;
      boost::tie(v_rank, v) = Q.top();
      Q.pop();
      vis.examine_vertex(v, g);
      BGL_FORALL_OUTEDGES_T(v, e, g, VertexListGraph) {
        Vertex w = target(e, g);
        vis.examine_edge(e, g);
        Distance e_weight = get(weight, e);
        if (compare(e_weight, zero))
          BOOST_THROW_EXCEPTION(negative_edge());
        bool decreased =
          relax(e, g, weight, predecessor, distance,
                combine, compare);
        Distance w_d = combine(get(distance, v), e_weight);
        if (decreased) {
          vis.edge_relaxed(e, g);
          Distance w_rank = combine(get(distance, w), h(w));
          put(cost, w, w_rank);
          vis.discover_vertex(w, g);
          Q.push(std::make_pair(w_rank, w));
        } else {
          vis.edge_not_relaxed(e, g);
        }
      }
      vis.finish_vertex(v, g);
    }
  }

  template <typename VertexListGraph, typename AStarHeuristic,
            typename AStarVisitor, typename PredecessorMap,
            typename CostMap, typename DistanceMap,
            typename WeightMap, typename VertexIndexMap,
            typename ColorMap,
            typename CompareFunction, typename CombineFunction,
            typename CostInf, typename CostZero>
  inline void
  astar_search
    (const VertexListGraph &g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     AStarHeuristic h, AStarVisitor vis,
     PredecessorMap predecessor, CostMap cost,
     DistanceMap distance, WeightMap weight,
     VertexIndexMap index_map, ColorMap color,
     CompareFunction compare, CombineFunction combine,
     CostInf inf, CostZero zero)
  {

    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;
    typename graph_traits<VertexListGraph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
      put(color, *ui, Color::white());
      put(distance, *ui, inf);
      put(cost, *ui, inf);
      put(predecessor, *ui, *ui);
      vis.initialize_vertex(*ui, g);
    }
    put(distance, s, zero);
    put(cost, s, h(s));

    astar_search_no_init
      (g, s, h, vis, predecessor, cost, distance, weight,
       color, index_map, compare, combine, inf, zero);

  }

  template <typename VertexListGraph, typename AStarHeuristic,
            typename AStarVisitor, typename PredecessorMap,
            typename CostMap, typename DistanceMap,
            typename WeightMap,
            typename CompareFunction, typename CombineFunction,
            typename CostInf, typename CostZero>
  inline void
  astar_search_tree
    (const VertexListGraph &g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     AStarHeuristic h, AStarVisitor vis,
     PredecessorMap predecessor, CostMap cost,
     DistanceMap distance, WeightMap weight,
     CompareFunction compare, CombineFunction combine,
     CostInf inf, CostZero zero)
  {

    typename graph_traits<VertexListGraph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
      put(distance, *ui, inf);
      put(cost, *ui, inf);
      put(predecessor, *ui, *ui);
      vis.initialize_vertex(*ui, g);
    }
    put(distance, s, zero);
    put(cost, s, h(s));

    astar_search_no_init_tree
      (g, s, h, vis, predecessor, cost, distance, weight,
       compare, combine, inf, zero);

  }

  template <typename VertexListGraph,
            typename AStarHeuristic,
            typename P, typename T, typename R>
  void
  astar_search
    (const VertexListGraph &g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     AStarHeuristic h, const bgl_named_params<P, T, R>& params)
  {
    using namespace boost::graph::keywords;
    typedef bgl_named_params<P, T, R> params_type;
    BOOST_GRAPH_DECLARE_CONVERTED_PARAMETERS(params_type, params)

    // Distance type is the value type of the distance map if there is one,
    // otherwise the value type of the weight map.
    typedef
      typename detail::override_const_property_result<
                 arg_pack_type, tag::weight_map, edge_weight_t, VertexListGraph>::type
      weight_map_type;
    typedef typename boost::property_traits<weight_map_type>::value_type W;
    typedef
      typename detail::map_maker<VertexListGraph, arg_pack_type, tag::distance_map, W>::map_type
      distance_map_type;
    typedef typename boost::property_traits<distance_map_type>::value_type D;
    const D inf = arg_pack[_distance_inf || detail::get_max<D>()];

    astar_search
      (g, s, h,
       arg_pack[_visitor | make_astar_visitor(null_visitor())],
       arg_pack[_predecessor_map | dummy_property_map()],
       detail::make_property_map_from_arg_pack_gen<tag::rank_map, D>(D())(g, arg_pack),
       detail::make_property_map_from_arg_pack_gen<tag::distance_map, W>(W())(g, arg_pack),
       detail::override_const_property(arg_pack, _weight_map, g, edge_weight),
       detail::override_const_property(arg_pack, _vertex_index_map, g, vertex_index),
       detail::make_color_map_from_arg_pack(g, arg_pack),
       arg_pack[_distance_compare | std::less<D>()],
       arg_pack[_distance_combine | closed_plus<D>(inf)],
       inf,
       arg_pack[_distance_zero | D()]);
  }

  template <typename VertexListGraph,
            typename AStarHeuristic,
            typename P, typename T, typename R>
  void
  astar_search_tree
    (const VertexListGraph &g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     AStarHeuristic h, const bgl_named_params<P, T, R>& params)
  {
    using namespace boost::graph::keywords;
    typedef bgl_named_params<P, T, R> params_type;
    BOOST_GRAPH_DECLARE_CONVERTED_PARAMETERS(params_type, params)

    // Distance type is the value type of the distance map if there is one,
    // otherwise the value type of the weight map.
    typedef
      typename detail::override_const_property_result<
                 arg_pack_type, tag::weight_map, edge_weight_t, VertexListGraph>::type
      weight_map_type;
    typedef typename boost::property_traits<weight_map_type>::value_type W;
    typedef
      typename detail::map_maker<VertexListGraph, arg_pack_type, tag::distance_map, W>::map_type
      distance_map_type;
    typedef typename boost::property_traits<distance_map_type>::value_type D;
    const D inf = arg_pack[_distance_inf || detail::get_max<D>()];

    astar_search_tree
      (g, s, h,
       arg_pack[_visitor | make_astar_visitor(null_visitor())],
       arg_pack[_predecessor_map | dummy_property_map()],
       detail::make_property_map_from_arg_pack_gen<tag::rank_map, D>(D())(g, arg_pack),
       detail::make_property_map_from_arg_pack_gen<tag::distance_map, W>(W())(g, arg_pack),
       detail::override_const_property(arg_pack, _weight_map, g, edge_weight),
       arg_pack[_distance_compare | std::less<D>()],
       arg_pack[_distance_combine | closed_plus<D>(inf)],
       inf,
       arg_pack[_distance_zero | D()]);
  }


  template <typename VertexListGraph,
            typename AStarHeuristic,
            typename P, typename T, typename R>
  void
  astar_search_no_init
    (const VertexListGraph &g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     AStarHeuristic h, const bgl_named_params<P, T, R>& params)
  {
    using namespace boost::graph::keywords;
    typedef bgl_named_params<P, T, R> params_type;
    BOOST_GRAPH_DECLARE_CONVERTED_PARAMETERS(params_type, params)
    typedef
      typename detail::override_const_property_result<
                 arg_pack_type, tag::weight_map, edge_weight_t, VertexListGraph>::type
               weight_map_type;
    typedef typename boost::property_traits<weight_map_type>::value_type D;
    const D inf = arg_pack[_distance_inf || detail::get_max<D>()];
    astar_search_no_init
      (g, s, h,
       arg_pack[_visitor | make_astar_visitor(null_visitor())],
       arg_pack[_predecessor_map | dummy_property_map()],
       detail::make_property_map_from_arg_pack_gen<tag::rank_map, D>(D())(g, arg_pack),
       detail::make_property_map_from_arg_pack_gen<tag::distance_map, D>(D())(g, arg_pack),
       detail::override_const_property(arg_pack, _weight_map, g, edge_weight),
       detail::make_color_map_from_arg_pack(g, arg_pack),
       detail::override_const_property(arg_pack, _vertex_index_map, g, vertex_index),
       arg_pack[_distance_compare | std::less<D>()],
       arg_pack[_distance_combine | closed_plus<D>(inf)],
       inf,
       arg_pack[_distance_zero | D()]);
  }


  template <typename VertexListGraph,
            typename AStarHeuristic,
            typename P, typename T, typename R>
  void
  astar_search_no_init_tree
    (const VertexListGraph &g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     AStarHeuristic h, const bgl_named_params<P, T, R>& params)
  {
    using namespace boost::graph::keywords;
    typedef bgl_named_params<P, T, R> params_type;
    BOOST_GRAPH_DECLARE_CONVERTED_PARAMETERS(params_type, params)
    typedef
      typename detail::override_const_property_result<
                 arg_pack_type, tag::weight_map, edge_weight_t, VertexListGraph>::type
               weight_map_type;
    typedef typename boost::property_traits<weight_map_type>::value_type D;
    const D inf = arg_pack[_distance_inf || detail::get_max<D>()];
    astar_search_no_init_tree
      (g, s, h,
       arg_pack[_visitor | make_astar_visitor(null_visitor())],
       arg_pack[_predecessor_map | dummy_property_map()],
       detail::make_property_map_from_arg_pack_gen<tag::rank_map, D>(D())(g, arg_pack),
       detail::make_property_map_from_arg_pack_gen<tag::distance_map, D>(D())(g, arg_pack),
       detail::override_const_property(arg_pack, _weight_map, g, edge_weight),
       arg_pack[_distance_compare | std::less<D>()],
       arg_pack[_distance_combine | closed_plus<D>(inf)],
       inf,
       arg_pack[_distance_zero | D()]);
  }


inline time_type get_time()
{
  return MPI_Wtime();
}


inline std::string print_time(time_type t)
{
  std::ostringstream out;
  out << std::setiosflags(std::ios::fixed) << std::setprecision(2) << t;
  return out.str();
}


template<class Archive, class OEL, class VL, class D, 
     class VP, class EP, class GP, class EL>
inline void save(
    Archive & ar,
    const boost::adjacency_list<OEL,VL,D,VP,EP,GP,EL> &graph,
    const unsigned int /* file_version */
){
  typedef adjacency_list<OEL,VL,D,VP,EP,GP,EL> Graph;
  typedef typename graph_traits<Graph>::vertex_descriptor Vertex;

  int V = num_vertices(graph);
  int E = num_edges(graph);
  ar << BOOST_SERIALIZATION_NVP(V);
  ar << BOOST_SERIALIZATION_NVP(E);

  // assign indices to vertices
  std::map<Vertex,int> indices;
  int num = 0;
  BGL_FORALL_VERTICES_T(v, graph, Graph) {
    indices[v] = num++;
    ar << serialization::make_nvp("vertex_property", get(vertex_all_t(), graph, v) );
  }
  
  // write edges
  BGL_FORALL_EDGES_T(e, graph, Graph) {
    ar << serialization::make_nvp("u" , indices[source(e,graph)]);
    ar << serialization::make_nvp("v" , indices[target(e,graph)]);
    ar << serialization::make_nvp("edge_property", get(edge_all_t(), graph, e) );
  }

  ar << serialization::make_nvp("graph_property", get_property(graph, graph_all_t()) );
}



template<class Archive, class OEL, class VL, class D,
     class VP, class EP, class GP, class EL>
inline void load(
    Archive & ar,
    boost::adjacency_list<OEL,VL,D,VP,EP,GP,EL> &graph,
    const unsigned int /* file_version */
){
  typedef adjacency_list<OEL,VL,D,VP,EP,GP,EL> Graph;
  typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
  typedef typename graph_traits<Graph>::edge_descriptor Edge;

  unsigned int V;
  ar >> BOOST_SERIALIZATION_NVP(V);
  unsigned int E;
  ar >> BOOST_SERIALIZATION_NVP(E);
  
  std::vector<Vertex> verts(V);
  int i = 0;
  while(V-- > 0){
    Vertex v = add_vertex(graph);
    verts[i++] = v;
    ar >> serialization::make_nvp("vertex_property", get(vertex_all_t(), graph, v) );
  }
  while(E-- > 0){
    int u; int v;
    ar >> BOOST_SERIALIZATION_NVP(u);
    ar >> BOOST_SERIALIZATION_NVP(v);
    Edge e; bool inserted;
    boost::tie(e,inserted) = add_edge(verts[u], verts[v], graph);
    ar >> serialization::make_nvp("edge_property", get(edge_all_t(), graph, e) );
  }
  ar >> serialization::make_nvp("graph_property", get_property(graph, graph_all_t()) );
}


template<class Archive, class OEL, class VL, class D, class VP, class EP, class GP, class EL>
inline void serialize(
    Archive & ar,
    boost::adjacency_list<OEL,VL,D,VP,EP,GP,EL> &graph,
    const unsigned int file_version
){
    boost::serialization::split_free(ar, graph, file_version);
}

    void constraints() {
      BOOST_CONCEPT_ASSERT(( CopyConstructibleConcept<Visitor> ));
      vis.initialize_vertex(u, g);
      vis.discover_vertex(u, g);
      vis.examine_vertex(u, g);
      vis.examine_out_edge(e, g);
      vis.examine_in_edge(e, g);
      vis.tree_out_edge(e, g);
      vis.tree_in_edge(e, g);
      vis.non_tree_out_edge(e, g);
      vis.non_tree_in_edge(e, g);
      vis.gray_target(e, g);
      vis.black_target(e, g);
      vis.gray_source(e, g);
      vis.black_source(e, g);
      vis.finish_vertex(u, g);
    }

    neighbor_bfs_visitor(Visitors vis = Visitors()) : m_vis(vis) { }


    template <class Vertex, class Graph>
    void initialize_vertex(Vertex u, Graph& g) {
      invoke_visitors(m_vis, u, g, on_initialize_vertex());      
    }

    template <class Vertex, class Graph>
    void discover_vertex(Vertex u, Graph& g) {
      invoke_visitors(m_vis, u, g, on_discover_vertex());      
    }

    template <class Vertex, class Graph>
    void examine_vertex(Vertex u, Graph& g) {
      invoke_visitors(m_vis, u, g, on_examine_vertex());
    }

    template <class Edge, class Graph>
    void examine_out_edge(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_examine_edge());
    }

    template <class Edge, class Graph>
    void tree_out_edge(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_tree_edge());      
    }

    template <class Edge, class Graph>
    void non_tree_out_edge(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_non_tree_edge());
    }

    template <class Edge, class Graph>
    void gray_target(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_gray_target());
    }

    template <class Edge, class Graph>
    void black_target(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_black_target());
    }

    template <class Edge, class Graph>
    void examine_in_edge(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_examine_edge());
    }

    template <class Edge, class Graph>
    void tree_in_edge(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_tree_edge());      
    }

    template <class Edge, class Graph>
    void non_tree_in_edge(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_non_tree_edge());
    }

    template <class Edge, class Graph>
    void gray_source(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_gray_target());
    }

    template <class Edge, class Graph>
    void black_source(Edge e, Graph& g) {
      invoke_visitors(m_vis, e, g, on_black_target());
    }

    template <class Vertex, class Graph>
    void finish_vertex(Vertex u, Graph& g) {
      invoke_visitors(m_vis, u, g, on_finish_vertex());      
    }


  template <class Visitors>
  neighbor_bfs_visitor<Visitors>
  make_neighbor_bfs_visitor(Visitors vis) {
    return neighbor_bfs_visitor<Visitors>(vis);
  }


    template <class BidirectionalGraph, class Buffer, class BFSVisitor, 
              class ColorMap>
    void neighbor_bfs_impl
      (const BidirectionalGraph& g, 
       typename graph_traits<BidirectionalGraph>::vertex_descriptor s, 
       Buffer& Q, BFSVisitor vis, ColorMap color)

    {
      BOOST_CONCEPT_ASSERT(( BidirectionalGraphConcept<BidirectionalGraph> ));
      typedef graph_traits<BidirectionalGraph> GTraits;
      typedef typename GTraits::vertex_descriptor Vertex;
      typedef typename GTraits::edge_descriptor Edge;
      BOOST_CONCEPT_ASSERT(( 
        NeighborBFSVisitorConcept<BFSVisitor, BidirectionalGraph> ));
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<ColorMap, Vertex> ));
      typedef typename property_traits<ColorMap>::value_type ColorValue;
      typedef color_traits<ColorValue> Color;
      
      put(color, s, Color::gray());
      vis.discover_vertex(s, g);
      Q.push(s);
      while (! Q.empty()) {
        Vertex u = Q.top();
        Q.pop(); // pop before push to avoid problem if Q is priority_queue.
        vis.examine_vertex(u, g);

        typename GTraits::out_edge_iterator ei, ei_end;
        for (boost::tie(ei, ei_end) = out_edges(u, g); ei != ei_end; ++ei) {
          Edge e = *ei;
          vis.examine_out_edge(e, g);
          Vertex v = target(e, g);
          ColorValue v_color = get(color, v);
          if (v_color == Color::white()) {
            vis.tree_out_edge(e, g);
            put(color, v, Color::gray());
            vis.discover_vertex(v, g);
            Q.push(v);
          } else {
            vis.non_tree_out_edge(e, g);
            if (v_color == Color::gray())
              vis.gray_target(e, g);
            else
              vis.black_target(e, g);
          }
        } // for out-edges

        typename GTraits::in_edge_iterator in_ei, in_ei_end;
        for (boost::tie(in_ei, in_ei_end) = in_edges(u, g); 
             in_ei != in_ei_end; ++in_ei) {
          Edge e = *in_ei;
          vis.examine_in_edge(e, g);
          Vertex v = source(e, g);
          ColorValue v_color = get(color, v);
          if (v_color == Color::white()) {
            vis.tree_in_edge(e, g);
            put(color, v, Color::gray());
            vis.discover_vertex(v, g);
            Q.push(v);
          } else {
            vis.non_tree_in_edge(e, g);
            if (v_color == Color::gray())
              vis.gray_source(e, g);
            else
              vis.black_source(e, g);
          }
        } // for in-edges

        put(color, u, Color::black());
        vis.finish_vertex(u, g);
      } // while
    }


    
    template <class VertexListGraph, class ColorMap, class BFSVisitor,
      class P, class T, class R>
    void neighbor_bfs_helper
      (VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s,
       ColorMap color, 
       BFSVisitor vis,
       const bgl_named_params<P, T, R>& params)
    {
      typedef graph_traits<VertexListGraph> Traits;
      // Buffer default
      typedef typename Traits::vertex_descriptor Vertex;
      typedef boost::queue<Vertex> queue_t;
      queue_t Q;
      // Initialization
      typedef typename property_traits<ColorMap>::value_type ColorValue;
      typedef color_traits<ColorValue> Color;
      typename boost::graph_traits<VertexListGraph>::vertex_iterator i, i_end;
      for (boost::tie(i, i_end) = vertices(g); i != i_end; ++i) {
        put(color, *i, Color::white());
        vis.initialize_vertex(*i, g);
      }
      neighbor_bfs_impl
        (g, s, 
         choose_param(get_param(params, buffer_param_t()), boost::ref(Q)).get(),
         vis, color);
    }

      template <class VertexListGraph, class P, class T, class R>
      static void apply
      (VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s,
       const bgl_named_params<P, T, R>& params,
       ColorMap color)
      {
        neighbor_bfs_helper
          (g, s, color,
           choose_param(get_param(params, graph_visitor),
                        make_neighbor_bfs_visitor(null_visitor())),
           params);
      }

      template <class VertexListGraph, class P, class T, class R>
      static void apply
      (VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s,
       const bgl_named_params<P, T, R>& params,
       param_not_found)
      {
        std::vector<default_color_type> color_vec(num_vertices(g));
        null_visitor null_vis;
        
        neighbor_bfs_helper
          (g, s, 
           make_iterator_property_map
           (color_vec.begin(), 
            choose_const_pmap(get_param(params, vertex_index), 
                              g, vertex_index), color_vec[0]),
           choose_param(get_param(params, graph_visitor),
                        make_neighbor_bfs_visitor(null_vis)),
           params);
      }

  template <class VertexListGraph, class P, class T, class R>
  void neighbor_breadth_first_search
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     const bgl_named_params<P, T, R>& params)
  {
    // The graph is passed by *const* reference so that graph adaptors
    // (temporaries) can be passed into this function. However, the
    // graph is not really const since we may write to property maps
    // of the graph.
    VertexListGraph& ng = const_cast<VertexListGraph&>(g);
    typedef typename get_param_type< vertex_color_t, bgl_named_params<P,T,R> >::type C;
    detail::neighbor_bfs_dispatch<C>::apply(ng, s, params, 
                                            get_param(params, vertex_color));
  }


  template <class IncidenceGraph, class P, class T, class R>
  void neighbor_breadth_first_visit
    (IncidenceGraph& g,
     typename graph_traits<IncidenceGraph>::vertex_descriptor s,
     const bgl_named_params<P, T, R>& params)
  {
    typedef graph_traits<IncidenceGraph> Traits;
    // Buffer default
    typedef boost::queue<typename Traits::vertex_descriptor> queue_t;
    queue_t Q;

    detail::neighbor_bfs_impl
      (g, s,
       choose_param(get_param(params, buffer_param_t()), boost::ref(Q)).get(),
       choose_param(get_param(params, graph_visitor),
                    make_neighbor_bfs_visitor(null_visitor())),
       choose_pmap(get_param(params, vertex_color), g, vertex_color)
       );
  }


    template <typename IncidenceGraph, typename DFSVisitor, 
              typename VertexColorMap, typename EdgeColorMap>
    void undir_dfv_impl
      (const IncidenceGraph& g,
       typename graph_traits<IncidenceGraph>::vertex_descriptor u, 
       DFSVisitor& vis,
       VertexColorMap vertex_color,
       EdgeColorMap edge_color)
    {
      BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<IncidenceGraph> ));
      BOOST_CONCEPT_ASSERT(( DFSVisitorConcept<DFSVisitor, IncidenceGraph> ));
      typedef typename graph_traits<IncidenceGraph>::vertex_descriptor Vertex;
      typedef typename graph_traits<IncidenceGraph>::edge_descriptor Edge;
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<VertexColorMap,Vertex> ));
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<EdgeColorMap,Edge> ));
      typedef typename property_traits<VertexColorMap>::value_type ColorValue;
      typedef typename property_traits<EdgeColorMap>::value_type EColorValue;
      BOOST_CONCEPT_ASSERT(( ColorValueConcept<ColorValue> ));
      BOOST_CONCEPT_ASSERT(( ColorValueConcept<EColorValue> ));
      typedef color_traits<ColorValue> Color;
      typedef color_traits<EColorValue> EColor;
      typedef typename graph_traits<IncidenceGraph>::out_edge_iterator Iter;
      typedef std::pair<Vertex, std::pair<Iter, Iter> > VertexInfo;

      std::vector<VertexInfo> stack;

      put(vertex_color, u, Color::gray());
      vis.discover_vertex(u, g);
      stack.push_back(std::make_pair(u, out_edges(u, g)));
      while (!stack.empty()) {
        VertexInfo& back = stack.back();
        u = back.first;
        Iter ei, ei_end;
        boost::tie(ei, ei_end) = back.second;
        stack.pop_back();
        while (ei != ei_end) {
          Vertex v = target(*ei, g);
          vis.examine_edge(*ei, g);
          ColorValue v_color = get(vertex_color, v);
          EColorValue uv_color = get(edge_color, *ei);
          put(edge_color, *ei, EColor::black());
          if (v_color == Color::white()) {
            vis.tree_edge(*ei, g);
            stack.push_back(std::make_pair(u, std::make_pair(++ei, ei_end)));
            u = v;
            put(vertex_color, u, Color::gray());
            vis.discover_vertex(u, g);
            boost::tie(ei, ei_end) = out_edges(u, g);
          } else if (v_color == Color::gray()) {
            if (uv_color == EColor::white()) vis.back_edge(*ei, g);
            ++ei;
          } else { // if (v_color == Color::black())
            ++ei;
          }
        }
        put(vertex_color, u, Color::black());
        vis.finish_vertex(u, g);
      }
    }


  template <typename Graph, typename DFSVisitor, 
            typename VertexColorMap, typename EdgeColorMap, 
            typename Vertex>
  void
  undirected_dfs(const Graph& g, DFSVisitor vis, 
                 VertexColorMap vertex_color, EdgeColorMap edge_color,
                 Vertex start_vertex)
  {
    BOOST_CONCEPT_ASSERT(( DFSVisitorConcept<DFSVisitor, Graph> ));
    BOOST_CONCEPT_ASSERT(( EdgeListGraphConcept<Graph> ));

    typedef typename property_traits<VertexColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;

    typename graph_traits<Graph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
      put(vertex_color, *ui, Color::white());   vis.initialize_vertex(*ui, g);
    }
    typename graph_traits<Graph>::edge_iterator ei, ei_end;
    for (boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
      put(edge_color, *ei, Color::white());

    if (start_vertex != *vertices(g).first){ vis.start_vertex(start_vertex, g);
      detail::undir_dfv_impl(g, start_vertex, vis, vertex_color, edge_color);
    }

    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
      ColorValue u_color = get(vertex_color, *ui);
      if (u_color == Color::white()) {       vis.start_vertex(*ui, g);
        detail::undir_dfv_impl(g, *ui, vis, vertex_color, edge_color);
      }
    }
  }


  template <typename Graph, typename DFSVisitor, typename VertexColorMap,
    typename EdgeColorMap>
  void
  undirected_dfs(const Graph& g, DFSVisitor vis, 
                 VertexColorMap vertex_color, EdgeColorMap edge_color)
  {
    undirected_dfs(g, vis, vertex_color, edge_color, *vertices(g).first);
  }


      template <typename Graph, typename Vertex, 
                typename DFSVisitor, typename EdgeColorMap,
                typename P, typename T, typename R>
      static void
      apply(const Graph& g, DFSVisitor vis, Vertex start_vertex,
            const bgl_named_params<P, T, R>&,
            EdgeColorMap edge_color,
            VertexColorMap vertex_color)
      {
        undirected_dfs(g, vis, vertex_color, edge_color, start_vertex);
      }

      template <typename Graph, typename Vertex, typename DFSVisitor,
                typename EdgeColorMap,
                typename P, typename T, typename R>
      static void
      apply(const Graph& g, DFSVisitor vis, Vertex start_vertex,
            const bgl_named_params<P, T, R>& params,
            EdgeColorMap edge_color,
            param_not_found)
      {
        std::vector<default_color_type> color_vec(num_vertices(g));
        default_color_type c = white_color; // avoid warning about un-init
        undirected_dfs
          (g, vis, make_iterator_property_map
           (color_vec.begin(),
            choose_const_pmap(get_param(params, vertex_index),
                              g, vertex_index), c),
           edge_color,
           start_vertex);
      }

  template <typename Graph, typename P, typename T, typename R>
  void
  undirected_dfs(const Graph& g, 
                 const bgl_named_params<P, T, R>& params)
  {
    typedef typename get_param_type< vertex_color_t, bgl_named_params<P, T, R> >::type C;
    detail::udfs_dispatch<C>::apply
      (g,
       choose_param(get_param(params, graph_visitor),
                    make_dfs_visitor(null_visitor())),
       choose_param(get_param(params, root_vertex_t()),
                    *vertices(g).first),
       params,
       get_param(params, edge_color),
       get_param(params, vertex_color)
       );
  }

  

  template <typename IncidenceGraph, typename DFSVisitor, 
    typename VertexColorMap, typename EdgeColorMap>
  void undirected_depth_first_visit
    (const IncidenceGraph& g,
     typename graph_traits<IncidenceGraph>::vertex_descriptor u, 
     DFSVisitor vis, VertexColorMap vertex_color, EdgeColorMap edge_color)
  {
    detail::undir_dfv_impl(g, u, vis, vertex_color, edge_color);
  }


template <class Graph, class CapacityMap, class IndexMap>
void write_dimacs_max_flow(const Graph& g,
                         CapacityMap capacity, 
                         IndexMap idx,
                         typename graph_traits<Graph>::vertex_descriptor src,
                         typename graph_traits<Graph>::vertex_descriptor sink,
                         std::ostream& out)
{
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
  typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
  typedef typename graph_traits<Graph>::edges_size_type edges_size_type;
  typedef typename graph_traits<Graph>::edge_iterator edge_iterator;
   
  out << "c DIMACS max-flow file generated from boost::write_dimacs_max_flow" << std::endl;
  out << "p max " << num_vertices(g) << " " << num_edges(g) << std::endl; //print problem description "max" and number of verts and edges
  out << "n " << get(idx, src) + 1 << " s" << std::endl;; //say which one is source
  out << "n " << get(idx, sink) + 1 << " t" << std::endl; //say which one is sink
  
  //output the edges
  edge_iterator ei, e_end;
  for(boost::tie(ei,e_end) = edges(g); ei!=e_end; ++ei){
    out << "a " << idx[ source(*ei, g) ] + 1 << " " << idx[ target(*ei, g) ] + 1 << " " << get(capacity,*ei) << std::endl;
  }
}


    template <typename Graph>
    Graph make_K_5()
    {
      typename graph_traits<Graph>::vertex_iterator vi, vi_end, inner_vi;
      Graph K_5(5);
      for(boost::tie(vi,vi_end) = vertices(K_5); vi != vi_end; ++vi)
        for(inner_vi = next(vi); inner_vi != vi_end; ++inner_vi)
          add_edge(*vi, *inner_vi, K_5);
      return K_5;
    }



    template <typename Graph>
    Graph make_K_3_3()
    {
      typename graph_traits<Graph>::vertex_iterator 
        vi, vi_end, bipartition_start, inner_vi;
      Graph K_3_3(6);
      bipartition_start = next(next(next(vertices(K_3_3).first)));
      for(boost::tie(vi, vi_end) = vertices(K_3_3); vi != bipartition_start; ++vi)
        for(inner_vi= bipartition_start; inner_vi != vi_end; ++inner_vi)
          add_edge(*vi, *inner_vi, K_3_3);
      return K_3_3;
    }



    template <typename AdjacencyList, typename Vertex>
    void contract_edge(AdjacencyList& neighbors, Vertex u, Vertex v)
    {
      // Remove u from v's neighbor list
      neighbors[v].erase(std::remove(neighbors[v].begin(), 
                                     neighbors[v].end(), u
                                     ), 
                         neighbors[v].end()
                         );
      
      // Replace any references to u with references to v
      typedef typename AdjacencyList::value_type::iterator 
        adjacency_iterator_t;
      
      adjacency_iterator_t u_neighbor_end = neighbors[u].end();
      for(adjacency_iterator_t u_neighbor_itr = neighbors[u].begin();
          u_neighbor_itr != u_neighbor_end; ++u_neighbor_itr
          )
        {
          Vertex u_neighbor(*u_neighbor_itr);
          std::replace(neighbors[u_neighbor].begin(), 
                       neighbors[u_neighbor].end(), u, v
                       );
        }
      
      // Remove v from u's neighbor list
      neighbors[u].erase(std::remove(neighbors[u].begin(), 
                                     neighbors[u].end(), v
                                     ), 
                         neighbors[u].end()
                         );
      
      // Add everything in u's neighbor list to v's neighbor list
      std::copy(neighbors[u].begin(), 
                neighbors[u].end(), 
                std::back_inserter(neighbors[v])
                );
      
      // Clear u's neighbor list
      neighbors[u].clear();

    }





  template <typename Graph, typename ForwardIterator, typename VertexIndexMap>
  bool is_kuratowski_subgraph(const Graph& g,
                              ForwardIterator begin, 
                              ForwardIterator end, 
                              VertexIndexMap vm
                              )
  {

    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator_t;
    typedef typename graph_traits<Graph>::edge_descriptor edge_t;
    typedef typename graph_traits<Graph>::edges_size_type e_size_t;
    typedef typename graph_traits<Graph>::vertices_size_type v_size_t;
    typedef typename std::vector<vertex_t> v_list_t;
    typedef typename v_list_t::iterator v_list_iterator_t;
    typedef iterator_property_map
      <typename std::vector<v_list_t>::iterator, VertexIndexMap> 
      vertex_to_v_list_map_t;

    typedef adjacency_list<vecS, vecS, undirectedS> small_graph_t;

    detail::target_graph_t target_graph = detail::tg_k_3_3; //unless we decide otherwise later

    static small_graph_t K_5(detail::make_K_5<small_graph_t>());

    static small_graph_t K_3_3(detail::make_K_3_3<small_graph_t>());

    v_size_t n_vertices(num_vertices(g));
    v_size_t max_num_edges(3*n_vertices - 5);

    std::vector<v_list_t> neighbors_vector(n_vertices);
    vertex_to_v_list_map_t neighbors(neighbors_vector.begin(), vm);

    e_size_t count = 0;
    for(ForwardIterator itr = begin; itr != end; ++itr)
      {

        if (count++ > max_num_edges)
          return false;

        edge_t e(*itr);
        vertex_t u(source(e,g));
        vertex_t v(target(e,g));

        neighbors[u].push_back(v);
        neighbors[v].push_back(u);

      }


    for(v_size_t max_size = 2; max_size < 5; ++max_size)
      {

        vertex_iterator_t vi, vi_end;
        for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
          {
            vertex_t v(*vi);

            //a hack to make sure we don't contract the middle edge of a path
            //of four degree-3 vertices
            if (max_size == 4 && neighbors[v].size() == 3)
              {
                if (neighbors[neighbors[v][0]].size() +
                    neighbors[neighbors[v][1]].size() +
                    neighbors[neighbors[v][2]].size()
                    < 11 // so, it has two degree-3 neighbors
                    )
                  continue;
              }

            while (neighbors[v].size() > 0 && neighbors[v].size() < max_size)
              {
                // Find one of v's neighbors u such that v and u
                // have no neighbors in common. We'll look for such a 
                // neighbor with a naive cubic-time algorithm since the 
                // max size of any of the neighbor sets we'll consider 
                // merging is 3
                
                bool neighbor_sets_intersect = false;
                
                vertex_t min_u = graph_traits<Graph>::null_vertex();
                vertex_t u;
                v_list_iterator_t v_neighbor_end = neighbors[v].end();
                for(v_list_iterator_t v_neighbor_itr = neighbors[v].begin();
                    v_neighbor_itr != v_neighbor_end; 
                    ++v_neighbor_itr
                    )
                  {
                    neighbor_sets_intersect = false;
                    u = *v_neighbor_itr;
                    v_list_iterator_t u_neighbor_end = neighbors[u].end();
                    for(v_list_iterator_t u_neighbor_itr = 
                          neighbors[u].begin();
                        u_neighbor_itr != u_neighbor_end && 
                          !neighbor_sets_intersect; 
                        ++u_neighbor_itr
                        )
                      {
                        for(v_list_iterator_t inner_v_neighbor_itr = 
                              neighbors[v].begin();
                            inner_v_neighbor_itr != v_neighbor_end; 
                            ++inner_v_neighbor_itr
                            )
                          {
                            if (*u_neighbor_itr == *inner_v_neighbor_itr)
                              {
                                neighbor_sets_intersect = true;
                                break;
                              }
                          }
                        
                      }
                    if (!neighbor_sets_intersect &&
                        (min_u == graph_traits<Graph>::null_vertex() || 
                         neighbors[u].size() < neighbors[min_u].size())
                        )
                      {
                        min_u = u;
                      }
                        
                  }

                if (min_u == graph_traits<Graph>::null_vertex())
                  // Exited the loop without finding an appropriate neighbor of
                  // v, so v must be a lost cause. Move on to other vertices.
                  break;
                else
                  u = min_u;

                detail::contract_edge(neighbors, u, v);

              }//end iteration over v's neighbors

          }//end iteration through vertices v

        if (max_size == 3)
          {
            // check to see whether we should go on to find a K_5
            for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
              if (neighbors[*vi].size() == 4)
                {
                  target_graph = detail::tg_k_5;
                  break;
                }

            if (target_graph == detail::tg_k_3_3)
              break;
          }
        
      }//end iteration through max degree 2,3, and 4

    
    //Now, there should only be 5 or 6 vertices with any neighbors. Find them.
    
    v_list_t main_vertices;
    vertex_iterator_t vi, vi_end;
    
    for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
      {
        if (!neighbors[*vi].empty())
          main_vertices.push_back(*vi);
      }
    
    // create a graph isomorphic to the contracted graph to test 
    // against K_5 and K_3_3
    small_graph_t contracted_graph(main_vertices.size());
    std::map<vertex_t,typename graph_traits<small_graph_t>::vertex_descriptor> 
      contracted_vertex_map;
    
    typename v_list_t::iterator itr, itr_end;
    itr_end = main_vertices.end();
    typename graph_traits<small_graph_t>::vertex_iterator 
      si = vertices(contracted_graph).first;
    
    for(itr = main_vertices.begin(); itr != itr_end; ++itr, ++si)
      {
        contracted_vertex_map[*itr] = *si;
      }

    typename v_list_t::iterator jtr, jtr_end;
    for(itr = main_vertices.begin(); itr != itr_end; ++itr)
      {
        jtr_end = neighbors[*itr].end();
        for(jtr = neighbors[*itr].begin(); jtr != jtr_end; ++jtr)
          {
            if (get(vm,*itr) < get(vm,*jtr))
              {
                add_edge(contracted_vertex_map[*itr],
                         contracted_vertex_map[*jtr],
                         contracted_graph
                         );
              }
          }
      }
    
    if (target_graph == detail::tg_k_5)
      {
        return boost::isomorphism(K_5,contracted_graph);
      }
    else //target_graph == tg_k_3_3
      {
        return boost::isomorphism(K_3_3,contracted_graph);
      }
    
    
  }






  template <typename Graph, typename ForwardIterator>
  bool is_kuratowski_subgraph(const Graph& g, 
                              ForwardIterator begin, 
                              ForwardIterator end
                              )
  {
    return is_kuratowski_subgraph(g, begin, end, get(vertex_index,g));
  }

      explicit edge_or_side(T value) : value(value) {}

    template<typename Graph, typename DistanceMap, typename IndexMap, 
             typename T>
    T compute_edge_length(const Graph&, DistanceMap, IndexMap, 
                          edge_or_side<true, T> length)
    { return length.value; }

    template<typename Graph, typename DistanceMap, typename IndexMap, 
             typename T>
    T
    compute_edge_length(const Graph& g, DistanceMap distance, IndexMap index,
                        edge_or_side<false, T> length)
    {
      T result(0);

      typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;

      for (vertex_iterator ui = vertices(g).first, end = vertices(g).second;
           ui != end; ++ui) {
        vertex_iterator vi = ui;
        for (++vi; vi != end; ++vi) {
          T dij = distance[get(index, *ui)][get(index, *vi)];
          if (dij > result) result = dij;
        }
      }
      return length.value / result;
    }

      template <typename Vec>
      static Vec solve(double mat[1][1], Vec rhs) {
        return rhs / mat[0][0];
      }

      template <typename Vec>
      static Vec solve(double mat[2][2], Vec rhs) {
        double denom = mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];
        double x_num = rhs[0]    * mat[1][1] - rhs[1]    * mat[0][1];
        double y_num = mat[0][0] * rhs[1]    - mat[1][0] * rhs[0]   ;
        Vec result;
        result[0] = x_num / denom;
        result[1] = y_num / denom;
        return result;
      }

      template <typename Vec>
      static Vec solve(double mat[2][2], Vec rhs) {
        double denom = mat[0][0] * (mat[1][1] * mat[2][2] - mat[2][1] * mat[1][2])
                     - mat[1][0] * (mat[0][1] * mat[2][2] - mat[2][1] * mat[0][2])
                     + mat[2][0] * (mat[0][1] * mat[1][2] - mat[1][1] * mat[0][2]);
        double x_num = rhs[0]    * (mat[1][1] * mat[2][2] - mat[2][1] * mat[1][2])
                     - rhs[1]    * (mat[0][1] * mat[2][2] - mat[2][1] * mat[0][2])
                     + rhs[2]    * (mat[0][1] * mat[1][2] - mat[1][1] * mat[0][2]);
        double y_num = mat[0][0] * (rhs[1]    * mat[2][2] - rhs[2]    * mat[1][2])
                     - mat[1][0] * (rhs[0]    * mat[2][2] - rhs[2]    * mat[0][2])
                     + mat[2][0] * (rhs[0]    * mat[1][2] - rhs[1]    * mat[0][2]);
        double z_num = mat[0][0] * (mat[1][1] * rhs[2]    - mat[2][1] * rhs[1]   )
                     - mat[1][0] * (mat[0][1] * rhs[2]    - mat[2][1] * rhs[0]   )
                     + mat[2][0] * (mat[0][1] * rhs[1]    - mat[1][1] * rhs[0]   );
        Vec result;
        result[0] = x_num / denom;
        result[1] = y_num / denom;
        result[2] = z_num / denom;
        return result;
      }


      kamada_kawai_spring_layout_impl(
        const Topology& topology,
        const Graph& g, 
        PositionMap position,
        WeightMap weight, 
        EdgeOrSideLength edge_or_side_length,
        Done done,
        weight_type spring_constant,
        VertexIndexMap index,
        DistanceMatrix distance,
        SpringStrengthMatrix spring_strength,
        PartialDerivativeMap partial_derivatives)
        : topology(topology), g(g), position(position), weight(weight), 
          edge_or_side_length(edge_or_side_length), done(done),
          spring_constant(spring_constant), index(index), distance(distance),
          spring_strength(spring_strength), 
          partial_derivatives(partial_derivatives) {}

      deriv_type
      compute_partial_derivative(vertex_descriptor m, vertex_descriptor i)
      {
#ifndef BOOST_NO_STDC_NAMESPACE
        using std::sqrt;
#endif // BOOST_NO_STDC_NAMESPACE

        deriv_type result;
        if (i != m) {
          point_difference_type diff = topology.difference(position[m], position[i]);
          weight_type dist = topology.norm(diff);
          result = spring_strength[get(index, m)][get(index, i)] 
            * (diff - distance[get(index, m)][get(index, i)]/dist*diff);
        }

        return result;
      }

      deriv_type 
      compute_partial_derivatives(vertex_descriptor m)
      {
#ifndef BOOST_NO_STDC_NAMESPACE
        using std::sqrt;
#endif // BOOST_NO_STDC_NAMESPACE

        deriv_type result;

        // TBD: looks like an accumulate to me
        BGL_FORALL_VERTICES_T(i, g, Graph) {
          deriv_type deriv = compute_partial_derivative(m, i);
          result += deriv;
        }

        return result;
      }

      bool run()
      {
#ifndef BOOST_NO_STDC_NAMESPACE
        using std::sqrt;
#endif // BOOST_NO_STDC_NAMESPACE

        // Compute d_{ij} and place it in the distance matrix
        if (!johnson_all_pairs_shortest_paths(g, distance, index, weight, 
                                              weight_type(0)))
          return false;

        // Compute L based on side length (if needed), or retrieve L
        weight_type edge_length = 
          detail::graph::compute_edge_length(g, distance, index,
                                             edge_or_side_length);

        // std::cerr << "edge_length = " << edge_length << std::endl;
        
        // Compute l_{ij} and k_{ij}
        const weight_type K = spring_constant;
        vertex_iterator ui, end;
        for (ui = vertices(g).first, end = vertices(g).second; ui != end; ++ui) {
          vertex_iterator vi = ui;
          for (++vi; vi != end; ++vi) {
            weight_type dij = distance[get(index, *ui)][get(index, *vi)];
            if (dij == (std::numeric_limits<weight_type>::max)())
              return false;
            distance[get(index, *ui)][get(index, *vi)] = edge_length * dij;
            distance[get(index, *vi)][get(index, *ui)] = edge_length * dij;
            spring_strength[get(index, *ui)][get(index, *vi)] = K/(dij*dij);
            spring_strength[get(index, *vi)][get(index, *ui)] = K/(dij*dij);
          }
        }
        
        // Compute Delta_i and find max
        vertex_descriptor p = *vertices(g).first;
        weight_type delta_p(0);

        for (ui = vertices(g).first, end = vertices(g).second; ui != end; ++ui) {
          deriv_type deriv = compute_partial_derivatives(*ui);
          put(partial_derivatives, *ui, deriv);

          weight_type delta = topology.norm(deriv);

          if (delta > delta_p) {
            p = *ui;
            delta_p = delta;
          }
        }

        while (!done(delta_p, p, g, true)) {
          // The contribution p makes to the partial derivatives of
          // each vertex. Computing this (at O(n) cost) allows us to
          // update the delta_i values in O(n) time instead of O(n^2)
          // time.
          std::vector<deriv_type> p_partials(num_vertices(g));
          for (ui = vertices(g).first, end = vertices(g).second; ui != end; ++ui) {
            vertex_descriptor i = *ui;
            p_partials[get(index, i)] = compute_partial_derivative(i, p);
          }

          do {
            // For debugging, compute the energy value E
            double E = 0.;
            for (ui = vertices(g).first, end = vertices(g).second; ui != end; ++ui) {
              vertex_iterator vi = ui;
              for (++vi; vi != end; ++vi) {
                double dist = topology.distance(position[*ui], position[*vi]);
                weight_type k_ij = spring_strength[get(index,*ui)][get(index,*vi)];
                weight_type l_ij = distance[get(index, *ui)][get(index, *vi)];
                E += .5 * k_ij * (dist - l_ij) * (dist - l_ij);
              }
            }
            // std::cerr << "E = " << E << std::endl;

            // Compute the elements of the Jacobian
            // From
            // http://www.cs.panam.edu/~rfowler/papers/1994_kumar_fowler_A_Spring_UTPACSTR.pdf
            // with the bugs fixed in the off-diagonal case
            weight_type dE_d_d[Point::dimensions][Point::dimensions];
            for (std::size_t i = 0; i < Point::dimensions; ++i)
              for (std::size_t j = 0; j < Point::dimensions; ++j)
                dE_d_d[i][j] = 0.;
            for (ui = vertices(g).first, end = vertices(g).second; ui != end; ++ui) {
              vertex_descriptor i = *ui;
              if (i != p) {
                point_difference_type diff = topology.difference(position[p], position[i]);
                weight_type dist = topology.norm(diff);
                weight_type dist_squared = dist * dist;
                weight_type inv_dist_cubed = 1. / (dist_squared * dist);
                weight_type k_mi = spring_strength[get(index,p)][get(index,i)];
                weight_type l_mi = distance[get(index, p)][get(index, i)];
                for (std::size_t i = 0; i < Point::dimensions; ++i) {
                  for (std::size_t j = 0; j < Point::dimensions; ++j) {
                    if (i == j) {
                      dE_d_d[i][i] += k_mi * (1 + (l_mi * (diff[i] * diff[i] - dist_squared) * inv_dist_cubed));
                    } else {
                      dE_d_d[i][j] += k_mi * l_mi * diff[i] * diff[j] * inv_dist_cubed;
                      // dE_d_d[i][j] += k_mi * l_mi * sqrt(hypot(diff[i], diff[j])) * inv_dist_cubed;
                    }
                  }
                }
              }
            }

            deriv_type dE_d = get(partial_derivatives, p);

            // Solve dE_d_d * delta = -dE_d to get delta
            point_difference_type delta = -linear_solver<Point::dimensions>::solve(dE_d_d, dE_d);

            // Move p by delta
            position[p] = topology.adjust(position[p], delta);

            // Recompute partial derivatives and delta_p
            deriv_type deriv = compute_partial_derivatives(p);
            put(partial_derivatives, p, deriv);

            delta_p = topology.norm(deriv);
          } while (!done(delta_p, p, g, false));

          // Select new p by updating each partial derivative and delta
          vertex_descriptor old_p = p;
          for (ui = vertices(g).first, end = vertices(g).second; ui != end; ++ui) {
            deriv_type old_deriv_p = p_partials[get(index, *ui)];
            deriv_type old_p_partial = 
              compute_partial_derivative(*ui, old_p);
            deriv_type deriv = get(partial_derivatives, *ui);

            deriv += old_p_partial - old_deriv_p;

            put(partial_derivatives, *ui, deriv);
            weight_type delta = topology.norm(deriv);

            if (delta > delta_p) {
              p = *ui;
              delta_p = delta;
            }
          }
        }

        return true;
      }

  template<typename T> 
  inline detail::graph::edge_or_side<true, T>
  edge_length(T x) 
  { return detail::graph::edge_or_side<true, T>(x); }

  template<typename T> 
  inline detail::graph::edge_or_side<false, T>
  side_length(T x) 
  { return detail::graph::edge_or_side<false, T>(x); }

    layout_tolerance(const T& tolerance = T(0.001))
      : tolerance(tolerance), last_energy((std::numeric_limits<T>::max)()),
        last_local_energy((std::numeric_limits<T>::max)()) { }


    template<typename Graph>
    bool 
    operator()(T delta_p, 
               typename boost::graph_traits<Graph>::vertex_descriptor p,
               const Graph& g,
               bool global)
    {
      if (global) {
        if (last_energy == (std::numeric_limits<T>::max)()) {
          last_energy = delta_p;
          return false;
        }
          
        T diff = last_energy - delta_p;
        if (diff < T(0)) diff = -diff;
        bool done = (delta_p == T(0) || diff / last_energy < tolerance);
        last_energy = delta_p;
        return done;
      } else {
        if (last_local_energy == (std::numeric_limits<T>::max)()) {
          last_local_energy = delta_p;
          return delta_p == T(0);
        }
          
        T diff = last_local_energy - delta_p;
        bool done = (delta_p == T(0) || (diff / last_local_energy) < tolerance);
        last_local_energy = delta_p;
        return done;
      }
    }

  template<typename Topology, typename Graph, typename PositionMap, typename WeightMap,
           typename T, bool EdgeOrSideLength, typename Done,
           typename VertexIndexMap, typename DistanceMatrix,
           typename SpringStrengthMatrix, typename PartialDerivativeMap>
  bool 
  kamada_kawai_spring_layout(
    const Graph& g, 
    PositionMap position,
    WeightMap weight, 
    const Topology& topology,
    detail::graph::edge_or_side<EdgeOrSideLength, T> edge_or_side_length,
    Done done,
    typename property_traits<WeightMap>::value_type spring_constant,
    VertexIndexMap index,
    DistanceMatrix distance,
    SpringStrengthMatrix spring_strength,
    PartialDerivativeMap partial_derivatives)
  {
    BOOST_STATIC_ASSERT((is_convertible<
                           typename graph_traits<Graph>::directed_category*,
                           undirected_tag*
                         >::value));

    detail::graph::kamada_kawai_spring_layout_impl<
      Topology, Graph, PositionMap, WeightMap, 
      detail::graph::edge_or_side<EdgeOrSideLength, T>, Done, VertexIndexMap, 
      DistanceMatrix, SpringStrengthMatrix, PartialDerivativeMap>
      alg(topology, g, position, weight, edge_or_side_length, done, spring_constant,
          index, distance, spring_strength, partial_derivatives);
    return alg.run();
  }

  template<typename Topology, typename Graph, typename PositionMap, typename WeightMap,
           typename T, bool EdgeOrSideLength, typename Done, 
           typename VertexIndexMap>
  bool 
  kamada_kawai_spring_layout(
    const Graph& g, 
    PositionMap position,
    WeightMap weight, 
    const Topology& topology,
    detail::graph::edge_or_side<EdgeOrSideLength, T> edge_or_side_length,
    Done done,
    typename property_traits<WeightMap>::value_type spring_constant,
    VertexIndexMap index)
  {
    typedef typename property_traits<WeightMap>::value_type weight_type;

    typename graph_traits<Graph>::vertices_size_type n = num_vertices(g);
    typedef std::vector<weight_type> weight_vec;

    std::vector<weight_vec> distance(n, weight_vec(n));
    std::vector<weight_vec> spring_strength(n, weight_vec(n));
    std::vector<typename Topology::point_difference_type> partial_derivatives(n);

    return 
      kamada_kawai_spring_layout(
        g, position, weight, topology, edge_or_side_length, done, spring_constant, index,
        distance.begin(),
        spring_strength.begin(),
        make_iterator_property_map(partial_derivatives.begin(), index,
                                   typename Topology::point_difference_type()));
  }

  template<typename Topology, typename Graph, typename PositionMap, typename WeightMap,
           typename T, bool EdgeOrSideLength, typename Done>
  bool 
  kamada_kawai_spring_layout(
    const Graph& g, 
    PositionMap position,
    WeightMap weight, 
    const Topology& topology,
    detail::graph::edge_or_side<EdgeOrSideLength, T> edge_or_side_length,
    Done done,
    typename property_traits<WeightMap>::value_type spring_constant)
  {
    return kamada_kawai_spring_layout(g, position, weight, topology, edge_or_side_length,
                                      done, spring_constant, 
                                      get(vertex_index, g));
  }

  template<typename Topology, typename Graph, typename PositionMap, typename WeightMap,
           typename T, bool EdgeOrSideLength, typename Done>
  bool 
  kamada_kawai_spring_layout(
    const Graph& g, 
    PositionMap position,
    WeightMap weight, 
    const Topology& topology,
    detail::graph::edge_or_side<EdgeOrSideLength, T> edge_or_side_length,
    Done done)
  {
    typedef typename property_traits<WeightMap>::value_type weight_type;
    return kamada_kawai_spring_layout(g, position, weight, topology, edge_or_side_length,
                                      done, weight_type(1)); 
  }

  template<typename Topology, typename Graph, typename PositionMap, typename WeightMap,
           typename T, bool EdgeOrSideLength>
  bool 
  kamada_kawai_spring_layout(
    const Graph& g, 
    PositionMap position,
    WeightMap weight, 
    const Topology& topology,
    detail::graph::edge_or_side<EdgeOrSideLength, T> edge_or_side_length)
  {
    typedef typename property_traits<WeightMap>::value_type weight_type;
    return kamada_kawai_spring_layout(g, position, weight, topology, edge_or_side_length,
                                      layout_tolerance<weight_type>(),
                                      weight_type(1.0), 
                                      get(vertex_index, g));
  }

    local_property(T x) : value(x) { }


template <typename T>
inline local_property<T> local(T x)
{ return local_property<T>(x); }

    global_property(T x) : value(x) { }


template <typename T>
inline global_property<T> global(T x)
{ return global_property<T>(x); }

    subgraph()
        : m_parent(0), m_edge_counter(0)
    { }


    subgraph(const graph_property_type& p)
        : m_graph(p), m_parent(0), m_edge_counter(0)
    { }


    subgraph(vertices_size_type n, const graph_property_type& p = graph_property_type())
        : m_graph(n, p), m_parent(0), m_edge_counter(0), m_global_vertex(n)
    {
        typename Graph::vertex_iterator v, v_end;
        vertices_size_type i = 0;
        for(boost::tie(v, v_end) = vertices(m_graph); v != v_end; ++v)
            m_global_vertex[i++] = *v;
    }

    subgraph(const subgraph& x)
        : m_parent(x.m_parent), m_edge_counter(x.m_edge_counter)
        , m_global_vertex(x.m_global_vertex), m_global_edge(x.m_global_edge)
    {
        if(x.is_root())
        {
         m_graph = x.m_graph;
        }
        // Do a deep copy (recursive).
        // Only the root graph is copied, the subgraphs contain
        // only references to the global vertices they own.
        typename subgraph<Graph>::children_iterator i,i_end;
        boost::tie(i,i_end) = x.children();
        for(; i != i_end; ++i)
        {         
         subgraph<Graph> child = this->create_subgraph();
         child = *i;
         vertex_iterator vi,vi_end;   
         boost::tie(vi,vi_end) = vertices(*i);
         for (;vi!=vi_end;++vi)  
         {
          add_vertex(*vi,child);
         }
       }
    }



    ~subgraph() {
      for(typename ChildrenList::iterator i = m_children.begin();
          i != m_children.end(); ++i)
        {
            delete *i;
        }
    }

    static vertex_descriptor null_vertex()
    { return Traits::null_vertex(); }

    subgraph<Graph>& create_subgraph() {
        m_children.push_back(new subgraph<Graph>());
        m_children.back()->m_parent = this;
        return *m_children.back();
    }

    template <typename VertexIterator>
    subgraph<Graph>& create_subgraph(VertexIterator first, VertexIterator last) {
        m_children.push_back(new subgraph<Graph>());
        m_children.back()->m_parent = this;
        for(; first != last; ++first) {
            add_vertex(*first, *m_children.back());
        }
        return *m_children.back();
    }

    vertex_descriptor local_to_global(vertex_descriptor u_local) const
    { return is_root() ? u_local : m_global_vertex[u_local]; }


    vertex_descriptor global_to_local(vertex_descriptor u_global) const {
        vertex_descriptor u_local; bool in_subgraph;
        if (is_root()) return u_global;
        boost::tie(u_local, in_subgraph) = this->find_vertex(u_global);
        BOOST_ASSERT(in_subgraph == true);
        return u_local;
    }


    edge_descriptor local_to_global(edge_descriptor e_local) const
    { return is_root() ? e_local : m_global_edge[get(get(edge_index, m_graph), e_local)]; }


    edge_descriptor global_to_local(edge_descriptor e_global) const
    { return is_root() ? e_global : (*m_local_edge.find(get(get(edge_index, root().m_graph), e_global))).second; }


    edge_descriptor local_add_edge(vertex_descriptor u_local,
                                   vertex_descriptor v_local,
                                   edge_descriptor e_global)
    {
        edge_descriptor e_local;
        bool inserted;
        boost::tie(e_local, inserted) = add_edge(u_local, v_local, m_graph);
        put(edge_index, m_graph, e_local, m_edge_counter++);
        m_global_edge.push_back(e_global);
        m_local_edge[get(get(edge_index, this->root()), e_global)] = e_local;
        return e_local;
    }


template <typename G>
typename subgraph<G>::vertex_descriptor
add_vertex(typename subgraph<G>::vertex_descriptor u_global,
           subgraph<G>& g)
{
    BOOST_ASSERT(!g.is_root());
    typename subgraph<G>::vertex_descriptor u_local, v_global;
    typename subgraph<G>::edge_descriptor e_global;

    u_local = add_vertex(g.m_graph);
    g.m_global_vertex.push_back(u_global);
    g.m_local_vertex[u_global] = u_local;

    subgraph<G>& r = g.root();

    // remember edge global and local maps
    {
        typename subgraph<G>::out_edge_iterator ei, ei_end;
        for (boost::tie(ei, ei_end) = out_edges(u_global, r);
            ei != ei_end; ++ei) {
            e_global = *ei;
            v_global = target(e_global, r);
            if (g.find_vertex(v_global).second == true)
            g.local_add_edge(u_local, g.global_to_local(v_global), e_global);
        }
    }
    if (is_directed(g)) { // not necessary for undirected graph
        typename subgraph<G>::vertex_iterator vi, vi_end;
        typename subgraph<G>::out_edge_iterator ei, ei_end;
        for(boost::tie(vi, vi_end) = vertices(r); vi != vi_end; ++vi) {
            v_global = *vi;
            if (v_global == u_global)
                continue; // don't insert self loops twice!
            if (!g.find_vertex(v_global).second)
                continue; // not a subgraph vertex => try next one
            for(boost::tie(ei, ei_end) = out_edges(*vi, r); ei != ei_end; ++ei) {
                e_global = *ei;
                if(target(e_global, r) == u_global) {
                    g.local_add_edge(g.global_to_local(v_global), u_local, e_global);
                }
            }
        }
    }

    return u_local;
}


    subgraph_local_property_map()
    { }


    subgraph_local_property_map(GraphPtr g, Tag tag)
        : m_g(g), m_tag(tag)
    { }


    reference operator[](key_type e) const {
        // Get property map on the underlying graph.
        PropertyMap pmap = get(m_tag, m_g->m_graph);
        return pmap[e];
    }


template <typename G, typename Property, typename Key, typename Value>
void put(Property p, subgraph<G>& g, const Key& k, const Value& val) {
    typedef typename property_map< subgraph<G>, Property>::type PMap;
    PMap pmap(&g, p);
    pmap[k] = val;
}


    template <typename Path, typename Graph>
    inline void cycle(const Path& p, const Graph& g)
    { }

    min_max_cycle_visitor(std::size_t& min_, std::size_t& max_)
        : minimum(min_), maximum(max_)
    { }


    template <typename Path, typename Graph>
    inline void cycle(const Path& p, const Graph& g)
    {
        BOOST_USING_STD_MIN();
        BOOST_USING_STD_MAX();
        std::size_t len = p.size();
        minimum = min BOOST_PREVENT_MACRO_SUBSTITUTION (minimum, len);
        maximum = max BOOST_PREVENT_MACRO_SUBSTITUTION (maximum, len);
    }


inline min_max_cycle_visitor
find_min_max_cycle(std::size_t& min_, std::size_t& max_)
{ return min_max_cycle_visitor(min_, max_); }

    template <typename Graph, typename Path>
    inline bool
    is_vertex_in_path(const Graph&,
                        typename graph_traits<Graph>::vertex_descriptor v,
                        const Path& p)
    {
        return (std::find(p.begin(), p.end(), v) != p.end());
    }


    template <typename Graph, typename ClosedMatrix>
    inline bool
    is_path_closed(const Graph& g,
                    typename graph_traits<Graph>::vertex_descriptor u,
                    typename graph_traits<Graph>::vertex_descriptor v,
                    const ClosedMatrix& closed)
    {
        // the path from u to v is closed if v can be found in the list
        // of closed vertices associated with u.
        typedef typename ClosedMatrix::const_reference Row;
        Row r = closed[get(vertex_index, g, u)];
        if(find(r.begin(), r.end(), v) != r.end()) {
            return true;
        }
        return false;
    }


    template <typename Graph, typename Path, typename ClosedMatrix>
    inline bool
    can_extend_path(const Graph& g,
                    typename graph_traits<Graph>::edge_descriptor e,
                    const Path& p,
                    const ClosedMatrix& m)
    {
        BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<Graph> ));
        BOOST_CONCEPT_ASSERT(( VertexIndexGraphConcept<Graph> ));
        typedef typename graph_traits<Graph>::vertex_descriptor Vertex;

        // get the vertices in question
        Vertex
            u = source(e, g),
            v = target(e, g);

        // conditions for allowing a traversal along this edge are:
        // 1. the index of v must be greater than that at which the
        //    path is rooted (p.front()).
        // 2. the vertex v cannot already be in the path
        // 3. the vertex v cannot be closed to the vertex u

        bool indices = get(vertex_index, g, p.front()) < get(vertex_index, g, v);
        bool path = !is_vertex_in_path(g, v, p);
        bool closed = !is_path_closed(g, u, v, m);
        return indices && path && closed;
    }


    template <typename Graph, typename Path>
    inline bool
    can_wrap_path(const Graph& g, const Path& p)
    {
        BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<Graph> ));
        typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
        typedef typename graph_traits<Graph>::out_edge_iterator OutIterator;

        // iterate over the out-edges of the back, looking for the
        // front of the path. also, we can't travel along the same
        // edge that we did on the way here, but we don't quite have the
        // stringent requirements that we do in can_extend_path().
        Vertex
            u = p.back(),
            v = p.front();
        OutIterator i, end;
        for(boost::tie(i, end) = out_edges(u, g); i != end; ++i) {
            if((target(*i, g) == v)) {
                return true;
            }
        }
        return false;
    }


    template <typename Graph,
        typename Path,
        typename ClosedMatrix>
    inline typename graph_traits<Graph>::vertex_descriptor
    extend_path(const Graph& g,
                Path& p,
                ClosedMatrix& closed)
    {
        BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<Graph> ));
        typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
        typedef typename graph_traits<Graph>::edge_descriptor Edge;
        typedef typename graph_traits<Graph>::out_edge_iterator OutIterator;

        // get the current vertex
        Vertex u = p.back();
        Vertex ret = graph_traits<Graph>::null_vertex();

        // AdjacencyIterator i, end;
        OutIterator i, end;
        for(boost::tie(i, end) = out_edges(u, g); i != end; ++i) {
            Vertex v = target(*i, g);

            // if we can actually extend along this edge,
            // then that's what we want to do
            if(can_extend_path(g, *i, p, closed)) {
                p.push_back(v);         // add the vertex to the path
                ret = v;
                break;
            }
        }
        return ret;
    }


    template <typename Graph, typename Path, typename ClosedMatrix>
    inline bool
    exhaust_paths(const Graph& g, Path& p, ClosedMatrix& closed)
    {
        BOOST_CONCEPT_ASSERT(( GraphConcept<Graph> ));
        typedef typename graph_traits<Graph>::vertex_descriptor Vertex;

        // if there's more than one vertex in the path, this closes
        // of some possible routes and returns true. otherwise, if there's
        // only one vertex left, the vertex has been used up
        if(p.size() > 1) {
            // get the last and second to last vertices, popping the last
            // vertex off the path
            Vertex last, prev;
            last = p.back();
            p.pop_back();
            prev = p.back();

            // reset the closure for the last vertex of the path and
            // indicate that the last vertex in p is now closed to
            // the next-to-last vertex in p
            closed[get(vertex_index, g, last)].clear();
            closed[get(vertex_index, g, prev)].push_back(last);
            return true;
        }
        else {
            return false;
        }
    }


    template <typename Graph, typename Visitor>
    inline void
    all_cycles_from_vertex(const Graph& g,
                            typename graph_traits<Graph>::vertex_descriptor v,
                            Visitor vis,
                            std::size_t minlen,
                            std::size_t maxlen)
    {
        BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
        typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
        typedef std::vector<Vertex> Path;
        BOOST_CONCEPT_ASSERT(( CycleVisitorConcept<Visitor,Path,Graph> ));
        typedef std::vector<Vertex> VertexList;
        typedef std::vector<VertexList> ClosedMatrix;

        Path p;
        ClosedMatrix closed(num_vertices(g), VertexList());
        Vertex null = graph_traits<Graph>::null_vertex();

        // each path investigation starts at the ith vertex
        p.push_back(v);

        while(1) {
            // extend the path until we've reached the end or the
            // maxlen-sized cycle
            Vertex j = null;
            while(((j = detail::extend_path(g, p, closed)) != null)
                    && (p.size() < maxlen))
                ; // empty loop

            // if we're done extending the path and there's an edge
            // connecting the back to the front, then we should have
            // a cycle.
            if(detail::can_wrap_path(g, p) && p.size() >= minlen) {
                vis.cycle(p, g);
            }

            if(!detail::exhaust_paths(g, p, closed)) {
                break;
            }
        }
    }


template <typename Graph, typename Visitor>
inline void
tiernan_all_cycles(const Graph& g,
                    Visitor vis,
                    std::size_t minlen,
                    std::size_t maxlen)
{
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_iterator VertexIterator;

    VertexIterator i, end;
    for(boost::tie(i, end) = vertices(g); i != end; ++i) {
        detail::all_cycles_from_vertex(g, *i, vis, minlen, maxlen);
    }
}


template <typename Graph, typename Visitor>
inline void
tiernan_all_cycles(const Graph& g, Visitor vis)
{
    typedef typename graph_traits<Graph>::directed_category Dir;
    tiernan_all_cycles(g, vis, detail::min_cycles<Dir>::value,
                       (std::numeric_limits<std::size_t>::max)());
}

      template < typename Graph >
      mas_min_cut_visitor(const Graph& g,
                          ParityMap parity,
                          weight_type& cutweight,
                          const WeightMap& weight_map, 
                          IndexMap index_map)
        : m_bestParity(parity),
          m_parity(make_one_bit_color_map(num_vertices(g), index_map)),
          m_bestWeight(cutweight),
          m_cutweight(0),
          m_visited(0),
          m_weightMap(weight_map)
      {
        // set here since the init list sets the reference
        m_bestWeight = (std::numeric_limits<weight_type>::max)();
      }


      template < typename Vertex, typename Graph >
      void initialize_vertex(Vertex u, const Graph & g)
      {
        typedef typename boost::property_traits<ParityMap>::value_type parity_type;
        typedef typename boost::property_traits<InternalParityMap>::value_type internal_parity_type;

        put(m_parity, u, internal_parity_type(0));
        put(m_bestParity, u, parity_type(0));
      }


      template < typename Edge, typename Graph >
      void examine_edge(Edge e, const Graph & g)
      {
        weight_type w = get(m_weightMap, e);

        // if the target of e is already marked then decrease cutweight
        // otherwise, increase it
        if (get(m_parity, boost::target(e, g))) {
          m_cutweight -= w;
        } else {
          m_cutweight += w;
        }
      }


      template < typename Vertex, typename Graph >
      void finish_vertex(Vertex u, const Graph & g)
      {
        typedef typename boost::property_traits<ParityMap>::value_type parity_type;
        typedef typename boost::property_traits<InternalParityMap>::value_type internal_parity_type;

        ++m_visited;
        put(m_parity, u, internal_parity_type(1));

        if (m_cutweight < m_bestWeight && m_visited < num_vertices(g)) {
          m_bestWeight = m_cutweight;
          BGL_FORALL_VERTICES_T(i, g, Graph) {
            put(m_bestParity,i, get(m_parity,i));
          }
        }
      }


      inline void clear() {
        m_bestWeight = (std::numeric_limits<weight_type>::max)();
        m_visited = 0;
        m_cutweight = 0;
      }

    template <class UndirectedGraph, class WeightMap, class ParityMap, class VertexAssignmentMap, class KeyedUpdatablePriorityQueue, class IndexMap>
    typename boost::property_traits<WeightMap>::value_type
    stoer_wagner_min_cut(const UndirectedGraph& g, WeightMap weights, ParityMap parities, VertexAssignmentMap assignments, KeyedUpdatablePriorityQueue& pq, IndexMap index_map) {
      typedef typename boost::graph_traits<UndirectedGraph>::vertex_descriptor vertex_descriptor;
      typedef typename boost::graph_traits<UndirectedGraph>::vertices_size_type vertices_size_type;
      typedef typename boost::graph_traits<UndirectedGraph>::edge_descriptor edge_descriptor;
      typedef typename boost::property_traits<WeightMap>::value_type weight_type;
      typedef typename boost::property_traits<ParityMap>::value_type parity_type;

      typename graph_traits<UndirectedGraph>::vertex_iterator u_iter, u_end;

      weight_type bestW = (std::numeric_limits<weight_type>::max)();
      weight_type bestThisTime = (std::numeric_limits<weight_type>::max)();
      vertex_descriptor bestStart = boost::graph_traits<UndirectedGraph>::null_vertex();

      detail::mas_min_cut_visitor<ParityMap, WeightMap, IndexMap>
        vis(g, parities, bestThisTime, weights, index_map);

      // for each node in the graph,
      for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter) {
        // run the MAS and find the min cut
        vis.clear();
        boost::maximum_adjacency_search(g,
            boost::weight_map(weights).
            visitor(vis).
            root_vertex(*u_iter).
            vertex_assignment_map(assignments).
            max_priority_queue(pq));
        if (bestThisTime < bestW) {
          bestW = bestThisTime;
          bestStart = *u_iter;
        }
      }

      // Run one more time, starting from the best start location, to
      // ensure the visitor has the best values.
      vis.clear();
      boost::maximum_adjacency_search(g,
        boost::vertex_assignment_map(assignments).
        weight_map(weights).
        visitor(vis).
        root_vertex(bestStart).
        max_priority_queue(pq));

      return bestW;
    }


    template <class UndirectedGraph, class WeightMap, class ParityMap, class VertexAssignmentMap, class KeyedUpdatablePriorityQueue, class IndexMap>
    typename boost::property_traits<WeightMap>::value_type
    stoer_wagner_min_cut(const UndirectedGraph& g, WeightMap weights, ParityMap parities, VertexAssignmentMap assignments, KeyedUpdatablePriorityQueue& pq, IndexMap index_map) {
      BOOST_CONCEPT_ASSERT((boost::IncidenceGraphConcept<UndirectedGraph>));
      BOOST_CONCEPT_ASSERT((boost::VertexListGraphConcept<UndirectedGraph>));
      typedef typename boost::graph_traits<UndirectedGraph>::vertex_descriptor vertex_descriptor;
      typedef typename boost::graph_traits<UndirectedGraph>::vertices_size_type vertices_size_type;
      typedef typename boost::graph_traits<UndirectedGraph>::edge_descriptor edge_descriptor;
      BOOST_CONCEPT_ASSERT((boost::Convertible<typename boost::graph_traits<UndirectedGraph>::directed_category, boost::undirected_tag>));
      BOOST_CONCEPT_ASSERT((boost::ReadablePropertyMapConcept<WeightMap, edge_descriptor>));
      typedef typename boost::property_traits<WeightMap>::value_type weight_type;
      BOOST_CONCEPT_ASSERT((boost::WritablePropertyMapConcept<ParityMap, vertex_descriptor>));
      typedef typename boost::property_traits<ParityMap>::value_type parity_type;
      BOOST_CONCEPT_ASSERT((boost::ReadWritePropertyMapConcept<VertexAssignmentMap, vertex_descriptor>));
      BOOST_CONCEPT_ASSERT((boost::Convertible<vertex_descriptor, typename boost::property_traits<VertexAssignmentMap>::value_type>));
      BOOST_CONCEPT_ASSERT((boost::KeyedUpdatableQueueConcept<KeyedUpdatablePriorityQueue>));

      vertices_size_type n = num_vertices(g);
      if (n < 2)
        throw boost::bad_graph("the input graph must have at least two vertices.");
      else if (!pq.empty())
        throw std::invalid_argument("the max-priority queue must be empty initially.");

      return detail::stoer_wagner_min_cut(g, weights,
                                          parities, assignments, pq, index_map);
    }

      template <typename ArgPack>
      result_type operator() (const UndirectedGraph& g, WeightMap weights, const ArgPack& arg_pack) const {
        using namespace boost::graph::keywords;
        typedef typename boost::graph_traits<UndirectedGraph>::vertex_descriptor vertex_descriptor;
        typedef typename boost::property_traits<WeightMap>::value_type weight_type;

        typedef boost::detail::make_priority_queue_from_arg_pack_gen<boost::graph::keywords::tag::max_priority_queue, weight_type, vertex_descriptor, std::greater<weight_type> > gen_type;

        gen_type gen(choose_param(get_param(arg_pack, boost::distance_zero_t()), weight_type(0)));

        typename boost::result_of<gen_type(const UndirectedGraph&, const ArgPack&)>::type pq = gen(g, arg_pack);

        return boost::stoer_wagner_min_cut(g,
          weights,
          arg_pack [_parity_map | boost::dummy_property_map()],
          boost::detail::make_property_map_from_arg_pack_gen<tag::vertex_assignment_map, vertex_descriptor>(vertex_descriptor())(g, arg_pack),
          pq,
          boost::detail::override_const_property(arg_pack, _vertex_index_map, g, vertex_index)
        );
      }









    template <class UndirectedGraph, class WeightMap, class ParityMap, class VertexAssignmentMap, class KeyedUpdatablePriorityQueue>
    typename boost::property_traits<WeightMap>::value_type
    stoer_wagner_min_cut(const UndirectedGraph& g, WeightMap weights, ParityMap parities, VertexAssignmentMap assignments, KeyedUpdatablePriorityQueue& pq) {

      return stoer_wagner_min_cut(g, weights,
                                  parities, assignments, pq,
                                  get(vertex_index, g));
    }

      postincrement_proxy(const value_type& value) : value(value) { }

      reference operator*() const { return value; }


    reference operator*() const { return self->edge; }

    pointer operator->() const { return &self->edge; }


    reference operator*() const { return self->edge_weight; }

    pointer operator->() const { return &self->edge_weight; }


    edge_weight_iterator& operator++() { return *this; }

    edge_weight_iterator operator++(int) { return *this; }

    edge_weight_iterator(metis_reader* self) : self(self) { }

  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }


  vertices_size_type num_vertices() const { return n_vertices; }

  edges_size_type num_edges() const { return n_edges; }


  std::size_t num_vertex_weights() const { return n_vertex_weights; }


  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }


  bool has_edge_weights() const { return edge_weights; }

  process_id_type operator()(size_type n) const { return vertices[n]; }

  size_type global(size_type n) const { return global(my_id, n); }


  iterator begin() { return vertices.begin(); }

  iterator end()   { return vertices.end(); }
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator!=(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return !(x == y);
}
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator!=(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return !(x == y);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::edge_iterator(metis_reader* self) 
  : self(self) 
{
  if (self) advance(true);
}
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator!=(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return !(x == y);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::edge_iterator(metis_reader* self) 
  : self(self) 
{
  if (self) advance(true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator& metis_reader::edge_iterator::operator++()
{
  advance(false);
  return *this;
}
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator!=(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return !(x == y);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::edge_iterator(metis_reader* self) 
  : self(self) 
{
  if (self) advance(true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator& metis_reader::edge_iterator::operator++()
{
  advance(false);
  return *this;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
void metis_reader::edge_iterator::advance(bool skip_initial_read)
{
  do {

    if (!skip_initial_read) {
      // Try to read the next edge
      if (self->line_in >> std::ws >> self->edge.second) {
        --self->edge.second;
        if (self->has_edge_weights()) {
          if (!(self->line_in >> self->edge_weight))
            boost::throw_exception(metis_input_exception());
        }
        return;
      }

      // Check if we're done
      ++self->edge.first;
      if (self->edge.first == self->num_vertices())
        return;
    }

    // Find the next line
    std::string line;
    while (getline(self->in, line) && !line.empty() && line[0] == '%') {
      /* Keep reading lines in the loop header... */
    }
    if (!self->in) boost::throw_exception(metis_input_exception());
    self->line_in.str(line);
    self->line_in.clear();

    // Read the next line
    std::size_t weights_left = self->n_vertex_weights;
    vertex_weight_type weight;
    while (weights_left > 0) {
      if (self->line_in >> weight) self->vertex_weights.push_back(weight);
      else boost::throw_exception(metis_input_exception());
      --weights_left;
    }

    // Successive iterations will pick up edges for this vertex.
    skip_initial_read = false;
  } while (true);
}
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator!=(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return !(x == y);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::edge_iterator(metis_reader* self) 
  : self(self) 
{
  if (self) advance(true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator& metis_reader::edge_iterator::operator++()
{
  advance(false);
  return *this;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
void metis_reader::edge_iterator::advance(bool skip_initial_read)
{
  do {

    if (!skip_initial_read) {
      // Try to read the next edge
      if (self->line_in >> std::ws >> self->edge.second) {
        --self->edge.second;
        if (self->has_edge_weights()) {
          if (!(self->line_in >> self->edge_weight))
            boost::throw_exception(metis_input_exception());
        }
        return;
      }

      // Check if we're done
      ++self->edge.first;
      if (self->edge.first == self->num_vertices())
        return;
    }

    // Find the next line
    std::string line;
    while (getline(self->in, line) && !line.empty() && line[0] == '%') {
      /* Keep reading lines in the loop header... */
    }
    if (!self->in) boost::throw_exception(metis_input_exception());
    self->line_in.str(line);
    self->line_in.clear();

    // Read the next line
    std::size_t weights_left = self->n_vertex_weights;
    vertex_weight_type weight;
    while (weights_left > 0) {
      if (self->line_in >> weight) self->vertex_weights.push_back(weight);
      else boost::throw_exception(metis_input_exception());
      --weights_left;
    }

    // Successive iterations will pick up edges for this vertex.
    skip_initial_read = false;
  } while (true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::postincrement_proxy 
metis_reader::edge_iterator::operator++(int)
{
  postincrement_proxy result(**this);
  ++(*this);
  return result;
}
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator!=(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return !(x == y);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::edge_iterator(metis_reader* self) 
  : self(self) 
{
  if (self) advance(true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator& metis_reader::edge_iterator::operator++()
{
  advance(false);
  return *this;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
void metis_reader::edge_iterator::advance(bool skip_initial_read)
{
  do {

    if (!skip_initial_read) {
      // Try to read the next edge
      if (self->line_in >> std::ws >> self->edge.second) {
        --self->edge.second;
        if (self->has_edge_weights()) {
          if (!(self->line_in >> self->edge_weight))
            boost::throw_exception(metis_input_exception());
        }
        return;
      }

      // Check if we're done
      ++self->edge.first;
      if (self->edge.first == self->num_vertices())
        return;
    }

    // Find the next line
    std::string line;
    while (getline(self->in, line) && !line.empty() && line[0] == '%') {
      /* Keep reading lines in the loop header... */
    }
    if (!self->in) boost::throw_exception(metis_input_exception());
    self->line_in.str(line);
    self->line_in.clear();

    // Read the next line
    std::size_t weights_left = self->n_vertex_weights;
    vertex_weight_type weight;
    while (weights_left > 0) {
      if (self->line_in >> weight) self->vertex_weights.push_back(weight);
      else boost::throw_exception(metis_input_exception());
      --weights_left;
    }

    // Successive iterations will pick up edges for this vertex.
    skip_initial_read = false;
  } while (true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::postincrement_proxy 
metis_reader::edge_iterator::operator++(int)
{
  postincrement_proxy result(**this);
  ++(*this);
  return result;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator metis_reader::begin()
{
  if (edge.first != 0) start();
  return edge_iterator(this);
}
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator!=(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return !(x == y);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::edge_iterator(metis_reader* self) 
  : self(self) 
{
  if (self) advance(true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator& metis_reader::edge_iterator::operator++()
{
  advance(false);
  return *this;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
void metis_reader::edge_iterator::advance(bool skip_initial_read)
{
  do {

    if (!skip_initial_read) {
      // Try to read the next edge
      if (self->line_in >> std::ws >> self->edge.second) {
        --self->edge.second;
        if (self->has_edge_weights()) {
          if (!(self->line_in >> self->edge_weight))
            boost::throw_exception(metis_input_exception());
        }
        return;
      }

      // Check if we're done
      ++self->edge.first;
      if (self->edge.first == self->num_vertices())
        return;
    }

    // Find the next line
    std::string line;
    while (getline(self->in, line) && !line.empty() && line[0] == '%') {
      /* Keep reading lines in the loop header... */
    }
    if (!self->in) boost::throw_exception(metis_input_exception());
    self->line_in.str(line);
    self->line_in.clear();

    // Read the next line
    std::size_t weights_left = self->n_vertex_weights;
    vertex_weight_type weight;
    while (weights_left > 0) {
      if (self->line_in >> weight) self->vertex_weights.push_back(weight);
      else boost::throw_exception(metis_input_exception());
      --weights_left;
    }

    // Successive iterations will pick up edges for this vertex.
    skip_initial_read = false;
  } while (true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::postincrement_proxy 
metis_reader::edge_iterator::operator++(int)
{
  postincrement_proxy result(**this);
  ++(*this);
  return result;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator metis_reader::begin()
{
  if (edge.first != 0) start();
  return edge_iterator(this);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator metis_reader::end()
{
  return edge_iterator(0);
}
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator!=(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return !(x == y);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::edge_iterator(metis_reader* self) 
  : self(self) 
{
  if (self) advance(true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator& metis_reader::edge_iterator::operator++()
{
  advance(false);
  return *this;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
void metis_reader::edge_iterator::advance(bool skip_initial_read)
{
  do {

    if (!skip_initial_read) {
      // Try to read the next edge
      if (self->line_in >> std::ws >> self->edge.second) {
        --self->edge.second;
        if (self->has_edge_weights()) {
          if (!(self->line_in >> self->edge_weight))
            boost::throw_exception(metis_input_exception());
        }
        return;
      }

      // Check if we're done
      ++self->edge.first;
      if (self->edge.first == self->num_vertices())
        return;
    }

    // Find the next line
    std::string line;
    while (getline(self->in, line) && !line.empty() && line[0] == '%') {
      /* Keep reading lines in the loop header... */
    }
    if (!self->in) boost::throw_exception(metis_input_exception());
    self->line_in.str(line);
    self->line_in.clear();

    // Read the next line
    std::size_t weights_left = self->n_vertex_weights;
    vertex_weight_type weight;
    while (weights_left > 0) {
      if (self->line_in >> weight) self->vertex_weights.push_back(weight);
      else boost::throw_exception(metis_input_exception());
      --weights_left;
    }

    // Successive iterations will pick up edges for this vertex.
    skip_initial_read = false;
  } while (true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::postincrement_proxy 
metis_reader::edge_iterator::operator++(int)
{
  postincrement_proxy result(**this);
  ++(*this);
  return result;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator metis_reader::begin()
{
  if (edge.first != 0) start();
  return edge_iterator(this);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator metis_reader::end()
{
  return edge_iterator(0);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_weight_iterator metis_reader::weight_begin()
{
  return edge_weight_iterator(this);
}
inline
#endif

#include <string>
#include <iostream>
#include <iterator>
#include <utility>
#include <sstream>
#include <exception>
#include <vector>
#include <algorithm>

namespace boost { namespace graph {

class metis_exception : public std::exception {};
class metis_input_exception : public metis_exception {};

class metis_reader
{
 public:
  typedef std::size_t vertices_size_type;
  typedef std::size_t edges_size_type;
  typedef double vertex_weight_type;
  typedef double edge_weight_type;

  class edge_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef std::pair<vertices_size_type, vertices_size_type> value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;
    typedef std::ptrdiff_t difference_type;

  private:
    class postincrement_proxy
    {
      postincrement_proxy(const value_type& value) : value(value) { }

    public:
      reference operator*() const { return value; }

    private:
      value_type value;
      friend class edge_iterator;
    };
    
  public:
    edge_iterator& operator++();
    postincrement_proxy operator++(int);

    reference operator*() const { return self->edge; }
    pointer operator->() const { return &self->edge; }

    // Default copy constructor and assignment operator are okay

  private:
    edge_iterator(metis_reader* self);
    void advance(bool skip_initial_read);
    
    metis_reader* self;

    friend class metis_reader;
    friend bool operator==(edge_iterator, edge_iterator);
    friend bool operator!=(edge_iterator, edge_iterator);
  };
  friend class edge_iterator;

  class edge_weight_iterator
  {
  public:
    typedef std::input_iterator_tag iterator_category;
    typedef edge_weight_type value_type;
    typedef const value_type& reference;
    typedef const value_type* pointer;

    // Default copy constructor and assignment operator are okay

    reference operator*() const { return self->edge_weight; }
    pointer operator->() const { return &self->edge_weight; }

    edge_weight_iterator& operator++() { return *this; }
    edge_weight_iterator operator++(int) { return *this; }

  private:
    edge_weight_iterator(metis_reader* self) : self(self) { }

    metis_reader* self;
    
    friend class metis_reader;
  };
  
  metis_reader(std::istream& in) : in(in), edge_weight(1.0) { start(); }

  edge_iterator begin();
  edge_iterator end();
  edge_weight_iterator weight_begin();

  vertices_size_type num_vertices() const { return n_vertices; }
  edges_size_type num_edges() const { return n_edges; }

  std::size_t num_vertex_weights() const { return n_vertex_weights; }

  vertex_weight_type vertex_weight(vertices_size_type v, std::size_t n)
  { return vertex_weights[v*num_vertex_weights() + n]; }

  bool has_edge_weights() const { return edge_weights; }

 private:
  void start();

  // Configuration information
  std::istream& in;

  // Information about the current METIS file
  vertices_size_type n_vertices;
  edges_size_type n_edges;
  std::size_t n_vertex_weights;
  bool edge_weights;

  // Information about the current edge/vertex
  std::istringstream line_in;
  std::pair<vertices_size_type, vertices_size_type> edge;
  std::vector<vertex_weight_type> vertex_weights;
  edge_weight_type edge_weight;    

  friend bool operator==(edge_iterator, edge_iterator);
  friend bool operator!=(edge_iterator, edge_iterator);
};

class metis_distribution
{
 public:  
  typedef int process_id_type;
  typedef std::size_t size_type;
  typedef std::vector<process_id_type>::iterator iterator;

  metis_distribution(std::istream& in, process_id_type my_id);
  
  size_type block_size(process_id_type id, size_type) const;
  process_id_type operator()(size_type n) const { return vertices[n]; }
  size_type local(size_type n) const;
  size_type global(size_type n) const { return global(my_id, n); }
  size_type global(process_id_type id, size_type n) const;

  iterator begin() { return vertices.begin(); }
  iterator end()   { return vertices.end(); }

 private:
  std::istream& in;
  process_id_type my_id;
  std::vector<process_id_type> vertices;
};

#if !defined(BOOST_GRAPH_METIS_NO_INLINE) || defined(BOOST_GRAPH_METIS_SOURCE)
BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator==(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return (x.self == y.self
          || (x.self && x.self->edge.first == x.self->num_vertices())
          || (y.self && y.self->edge.first == y.self->num_vertices()));
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
bool operator!=(metis_reader::edge_iterator x, metis_reader::edge_iterator y)
{
  return !(x == y);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::edge_iterator(metis_reader* self) 
  : self(self) 
{
  if (self) advance(true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator& metis_reader::edge_iterator::operator++()
{
  advance(false);
  return *this;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
void metis_reader::edge_iterator::advance(bool skip_initial_read)
{
  do {

    if (!skip_initial_read) {
      // Try to read the next edge
      if (self->line_in >> std::ws >> self->edge.second) {
        --self->edge.second;
        if (self->has_edge_weights()) {
          if (!(self->line_in >> self->edge_weight))
            boost::throw_exception(metis_input_exception());
        }
        return;
      }

      // Check if we're done
      ++self->edge.first;
      if (self->edge.first == self->num_vertices())
        return;
    }

    // Find the next line
    std::string line;
    while (getline(self->in, line) && !line.empty() && line[0] == '%') {
      /* Keep reading lines in the loop header... */
    }
    if (!self->in) boost::throw_exception(metis_input_exception());
    self->line_in.str(line);
    self->line_in.clear();

    // Read the next line
    std::size_t weights_left = self->n_vertex_weights;
    vertex_weight_type weight;
    while (weights_left > 0) {
      if (self->line_in >> weight) self->vertex_weights.push_back(weight);
      else boost::throw_exception(metis_input_exception());
      --weights_left;
    }

    // Successive iterations will pick up edges for this vertex.
    skip_initial_read = false;
  } while (true);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator::postincrement_proxy 
metis_reader::edge_iterator::operator++(int)
{
  postincrement_proxy result(**this);
  ++(*this);
  return result;
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator metis_reader::begin()
{
  if (edge.first != 0) start();
  return edge_iterator(this);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_iterator metis_reader::end()
{
  return edge_iterator(0);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
metis_reader::edge_weight_iterator metis_reader::weight_begin()
{
  return edge_weight_iterator(this);
}

BOOST_GRAPH_METIS_INLINE_KEYWORD
void metis_reader::start()
{
  in.seekg(0, std::ios::beg);
  std::string line;
  while (getline(in, line) && !line.empty() && line[0] == '%') {
    /* Keep getting lines in loop header. */
  }

  if (!in || line.empty()) boost::throw_exception(metis_input_exception());

  // Determine number of vertices and edges in the graph
  line_in.str(line);
  if (!(line_in >> n_vertices >> n_edges)) boost::throw_exception(metis_input_exception());

  // Determine whether vertex or edge weights are included in the graph
  int fmt = 0;
  line_in >> fmt;
  n_vertex_weights = fmt / 10;
  edge_weights = (fmt % 10 == 1);
  
  // Determine how many (if any!) vertex weights are included
  if (n_vertex_weights) line_in >> n_vertex_weights;

  // Setup the iteration data structures
  edge_weight = 1.0;
  edge.first = 0;
  edge.second = 0;
  vertex_weights.reserve(n_vertex_weights * num_vertices());
}



metis_distribution::size_type 
metis_distribution::block_size(process_id_type id, size_type) const
{
  return std::count(vertices.begin(), vertices.end(), id);
}


metis_distribution::size_type metis_distribution::local(size_type n) const
{
  return std::count(vertices.begin(), vertices.begin() + n, vertices[n]);
}


metis_distribution::size_type 
metis_distribution::global(process_id_type id, size_type n) const
{
  std::vector<process_id_type>::const_iterator i = vertices.begin();
  while (*i != id) ++i;

  while (n > 0) {
    do { ++i; } while (*i != id); 
    --n;
  }

  return i - vertices.begin();
}


  template <typename Graph, typename MateMap, typename VertexIndexMap>
  typename graph_traits<Graph>::vertices_size_type 
  matching_size(const Graph& g, MateMap mate, VertexIndexMap vm)
  {
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator_t;
    typedef typename graph_traits<Graph>::vertex_descriptor
      vertex_descriptor_t;
    typedef typename graph_traits<Graph>::vertices_size_type v_size_t;

    v_size_t size_of_matching = 0;
    vertex_iterator_t vi, vi_end;

    for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
      {
        vertex_descriptor_t v = *vi;
        if (get(mate,v) != graph_traits<Graph>::null_vertex() 
            && get(vm,v) < get(vm,get(mate,v)))
        ++size_of_matching;
      }
    return size_of_matching;
  }





  template <typename Graph, typename MateMap>
  inline typename graph_traits<Graph>::vertices_size_type
  matching_size(const Graph& g, MateMap mate)
  {
    return matching_size(g, mate, get(vertex_index,g));
  }





  template <typename Graph, typename MateMap, typename VertexIndexMap>
  bool is_a_matching(const Graph& g, MateMap mate, VertexIndexMap)
  {
    typedef typename graph_traits<Graph>::vertex_descriptor
      vertex_descriptor_t;
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator_t;

    vertex_iterator_t vi, vi_end;
    for( boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
      {
        vertex_descriptor_t v = *vi;
        if (get(mate,v) != graph_traits<Graph>::null_vertex() 
            && v != get(mate,get(mate,v)))
        return false;
      }    
    return true;
  }





  template <typename Graph, typename MateMap>
  inline bool is_a_matching(const Graph& g, MateMap mate)
  {
    return is_a_matching(g, mate, get(vertex_index,g));
  }

    no_augmenting_path_finder(const Graph&, MateMap, VertexIndexMap)
    { }


    inline bool augment_matching() { return false; }


    template <typename PropertyMap>
    void get_current_matching(PropertyMap) {}




    
    edmonds_augmenting_path_finder(const Graph& arg_g, MateMap arg_mate, 
                                   VertexIndexMap arg_vm) : 
      g(arg_g),
      vm(arg_vm),
      n_vertices(num_vertices(arg_g)),

      mate_vector(n_vertices),
      ancestor_of_v_vector(n_vertices),
      ancestor_of_w_vector(n_vertices),
      vertex_state_vector(n_vertices),
      origin_vector(n_vertices),
      pred_vector(n_vertices),
      bridge_vector(n_vertices),
      ds_parent_vector(n_vertices),
      ds_rank_vector(n_vertices),

      mate(mate_vector.begin(), vm),
      ancestor_of_v(ancestor_of_v_vector.begin(), vm),
      ancestor_of_w(ancestor_of_w_vector.begin(), vm),
      vertex_state(vertex_state_vector.begin(), vm),
      origin(origin_vector.begin(), vm),
      pred(pred_vector.begin(), vm),
      bridge(bridge_vector.begin(), vm),
      ds_parent_map(ds_parent_vector.begin(), vm),
      ds_rank_map(ds_rank_vector.begin(), vm),

      ds(ds_rank_map, ds_parent_map)
    {
      vertex_iterator_t vi, vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        mate[*vi] = get(arg_mate, *vi);
    }



    

    bool augment_matching()
    {
      //As an optimization, some of these values can be saved from one
      //iteration to the next instead of being re-initialized each
      //iteration, allowing for "lazy blossom expansion." This is not
      //currently implemented.
      
      e_size_t timestamp = 0;
      even_edges.clear();
      
      vertex_iterator_t vi, vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
      {
        vertex_descriptor_t u = *vi;
      
        origin[u] = u;
        pred[u] = u;
        ancestor_of_v[u] = 0;
        ancestor_of_w[u] = 0;
        ds.make_set(u);
      
        if (mate[u] == graph_traits<Graph>::null_vertex())
        {
          vertex_state[u] = graph::detail::V_EVEN;
          out_edge_iterator_t ei, ei_end;
          for(boost::tie(ei,ei_end) = out_edges(u,g); ei != ei_end; ++ei)
          {
            if (target(*ei,g) != u)
            {
              even_edges.push_back( *ei );
            }
          }
        }
        else
          vertex_state[u] = graph::detail::V_UNREACHED;      
      }
    
      //end initializations
    
      vertex_descriptor_t v,w,w_free_ancestor,v_free_ancestor;
      w_free_ancestor = graph_traits<Graph>::null_vertex();
      v_free_ancestor = graph_traits<Graph>::null_vertex(); 
      bool found_alternating_path = false;
      
      while(!even_edges.empty() && !found_alternating_path)
      {
        // since we push even edges onto the back of the list as
        // they're discovered, taking them off the back will search
        // for augmenting paths depth-first.
        edge_descriptor_t current_edge = even_edges.back();
        even_edges.pop_back();

        v = source(current_edge,g);
        w = target(current_edge,g);
      
        vertex_descriptor_t v_prime = origin[ds.find_set(v)];
        vertex_descriptor_t w_prime = origin[ds.find_set(w)];
      
        // because of the way we put all of the edges on the queue,
        // v_prime should be labeled V_EVEN; the following is a
        // little paranoid but it could happen...
        if (vertex_state[v_prime] != graph::detail::V_EVEN)
        {
          std::swap(v_prime,w_prime);
          std::swap(v,w);
        }

        if (vertex_state[w_prime] == graph::detail::V_UNREACHED)
        {
          vertex_state[w_prime] = graph::detail::V_ODD;
          vertex_descriptor_t w_prime_mate = mate[w_prime];
          vertex_state[w_prime_mate] = graph::detail::V_EVEN;
          out_edge_iterator_t ei, ei_end;
          for( boost::tie(ei,ei_end) = out_edges(w_prime_mate, g); ei != ei_end; ++ei)
          {
            if (target(*ei,g) != w_prime_mate)
            {
              even_edges.push_back(*ei);
            }
          }
          pred[w_prime] = v;
        }
        
        //w_prime == v_prime can happen below if we get an edge that has been
        //shrunk into a blossom
        else if (vertex_state[w_prime] == graph::detail::V_EVEN && w_prime != v_prime) 
        {                                                             
          vertex_descriptor_t w_up = w_prime;
          vertex_descriptor_t v_up = v_prime;
          vertex_descriptor_t nearest_common_ancestor 
                = graph_traits<Graph>::null_vertex();
          w_free_ancestor = graph_traits<Graph>::null_vertex();
          v_free_ancestor = graph_traits<Graph>::null_vertex();
          
          // We now need to distinguish between the case that
          // w_prime and v_prime share an ancestor under the
          // "parent" relation, in which case we've found a
          // blossom and should shrink it, or the case that
          // w_prime and v_prime both have distinct ancestors that
          // are free, in which case we've found an alternating
          // path between those two ancestors.

          ++timestamp;

          while (nearest_common_ancestor == graph_traits<Graph>::null_vertex() && 
             (v_free_ancestor == graph_traits<Graph>::null_vertex() || 
              w_free_ancestor == graph_traits<Graph>::null_vertex()
              )
             )
          {
            ancestor_of_w[w_up] = timestamp;
            ancestor_of_v[v_up] = timestamp;

            if (w_free_ancestor == graph_traits<Graph>::null_vertex())
              w_up = parent(w_up);
            if (v_free_ancestor == graph_traits<Graph>::null_vertex())
              v_up = parent(v_up);
          
            if (mate[v_up] == graph_traits<Graph>::null_vertex())
              v_free_ancestor = v_up;
            if (mate[w_up] == graph_traits<Graph>::null_vertex())
              w_free_ancestor = w_up;
          
            if (ancestor_of_w[v_up] == timestamp)
              nearest_common_ancestor = v_up;
            else if (ancestor_of_v[w_up] == timestamp)
              nearest_common_ancestor = w_up;
            else if (v_free_ancestor == w_free_ancestor && 
              v_free_ancestor != graph_traits<Graph>::null_vertex())
            nearest_common_ancestor = v_up;
          }
          
          if (nearest_common_ancestor == graph_traits<Graph>::null_vertex())
            found_alternating_path = true; //to break out of the loop
          else
          {
            //shrink the blossom
            link_and_set_bridges(w_prime, nearest_common_ancestor, std::make_pair(w,v));
            link_and_set_bridges(v_prime, nearest_common_ancestor, std::make_pair(v,w));
          }
        }      
      }
      
      if (!found_alternating_path)
        return false;

      // retrieve the augmenting path and put it in aug_path
      reversed_retrieve_augmenting_path(v, v_free_ancestor);
      retrieve_augmenting_path(w, w_free_ancestor);

      // augment the matching along aug_path
      vertex_descriptor_t a,b;
      while (!aug_path.empty())
      {
        a = aug_path.front();
        aug_path.pop_front();
        b = aug_path.front();
        aug_path.pop_front();
        mate[a] = b;
        mate[b] = a;
      }
      
      return true;
      
    }





    template <typename PropertyMap>
    void get_current_matching(PropertyMap pm)
    {
      vertex_iterator_t vi,vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        put(pm, *vi, mate[*vi]);
    }





    template <typename PropertyMap>
    void get_vertex_state_map(PropertyMap pm)
    {
      vertex_iterator_t vi,vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        put(pm, *vi, vertex_state[origin[ds.find_set(*vi)]]);
    }
    

    vertex_descriptor_t parent(vertex_descriptor_t x)
    {
      if (vertex_state[x] == graph::detail::V_EVEN 
          && mate[x] != graph_traits<Graph>::null_vertex())
        return mate[x];
      else if (vertex_state[x] == graph::detail::V_ODD)
        return origin[ds.find_set(pred[x])];
      else
        return x;
    }

    
    


    void link_and_set_bridges(vertex_descriptor_t x, 
                              vertex_descriptor_t stop_vertex, 
                  vertex_pair_t the_bridge)
    {
      for(vertex_descriptor_t v = x; v != stop_vertex; v = parent(v))
      {
        ds.union_set(v, stop_vertex);
        origin[ds.find_set(stop_vertex)] = stop_vertex;

        if (vertex_state[v] == graph::detail::V_ODD)
        {
          bridge[v] = the_bridge;
          out_edge_iterator_t oei, oei_end;
          for(boost::tie(oei, oei_end) = out_edges(v,g); oei != oei_end; ++oei)
          {
            if (target(*oei,g) != v)
            {
              even_edges.push_back(*oei);
            }
          }
        }
      }
    }

    
    void retrieve_augmenting_path(vertex_descriptor_t v, vertex_descriptor_t w)  
    {
      if (v == w)
        aug_path.push_back(v);
      else if (vertex_state[v] == graph::detail::V_EVEN)
      {
        aug_path.push_back(v);
        aug_path.push_back(mate[v]);
        retrieve_augmenting_path(pred[mate[v]], w);
      }
      else //vertex_state[v] == graph::detail::V_ODD 
      {
        aug_path.push_back(v);
        reversed_retrieve_augmenting_path(bridge[v].first, mate[v]);
        retrieve_augmenting_path(bridge[v].second, w);
      }
    }



    void reversed_retrieve_augmenting_path(vertex_descriptor_t v,
                                           vertex_descriptor_t w)  
    {

      if (v == w)
        aug_path.push_back(v);
      else if (vertex_state[v] == graph::detail::V_EVEN)
      {
        reversed_retrieve_augmenting_path(pred[mate[v]], w);
        aug_path.push_back(mate[v]);
        aug_path.push_back(v);
      }
      else //vertex_state[v] == graph::detail::V_ODD 
      {
        reversed_retrieve_augmenting_path(bridge[v].second, w);
        retrieve_augmenting_path(bridge[v].first, mate[v]);
        aug_path.push_back(v);
      }
    }


    static void find_matching(const Graph& g, MateMap mate)
    {
      vertex_iterator_t vi, vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        put(mate, *vi, graph_traits<Graph>::null_vertex());
            
      edge_iterator_t ei, ei_end;
      for( boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
      {
        edge_descriptor_t e = *ei;
        vertex_descriptor_t u = source(e,g);
        vertex_descriptor_t v = target(e,g);
      
        if (u != v && get(mate,u) == get(mate,v))  
        //only way equality can hold is if
        //   mate[u] == mate[v] == null_vertex
        {
          put(mate,u,v);
          put(mate,v,u);
        }
      }    
    }

      inline static vertex_descriptor_t select_vertex(const vertex_pair_t p) 
      {return p.first;}

      inline static vertex_descriptor_t select_vertex(const vertex_pair_t p) 
      {return p.second;}

      less_than_by_degree(const Graph& g): m_g(g) {}

      bool operator() (const vertex_pair_t x, const vertex_pair_t y)
      {
        return 
          out_degree(PairSelector::select_vertex(x), m_g) 
          < out_degree(PairSelector::select_vertex(y), m_g);
      }



    static void find_matching(const Graph& g, MateMap mate)
    {
      typedef std::vector<std::pair<vertex_descriptor_t, vertex_descriptor_t> >
        directed_edges_vector_t;
      
      directed_edges_vector_t edge_list;
      vertex_iterator_t vi, vi_end;
      for(boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi)
        put(mate, *vi, graph_traits<Graph>::null_vertex());

      edge_iterator_t ei, ei_end;
      for(boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
      {
        edge_descriptor_t e = *ei;
        vertex_descriptor_t u = source(e,g);
        vertex_descriptor_t v = target(e,g);
        if (u == v) continue;
        edge_list.push_back(std::make_pair(u,v));
        edge_list.push_back(std::make_pair(v,u));
      }
      
      //sort the edges by the degree of the target, then (using a
      //stable sort) by degree of the source
      std::sort(edge_list.begin(), edge_list.end(), 
                less_than_by_degree<select_second>(g));
      std::stable_sort(edge_list.begin(), edge_list.end(), 
                       less_than_by_degree<select_first>(g));
      
      //construct the extra greedy matching
      for(typename directed_edges_vector_t::const_iterator itr = edge_list.begin(); itr != edge_list.end(); ++itr)
      {
        if (get(mate,itr->first) == get(mate,itr->second)) 
        //only way equality can hold is if mate[itr->first] == mate[itr->second] == null_vertex
        {
          put(mate, itr->first, itr->second);
          put(mate, itr->second, itr->first);
        }
      }    
    }

    
    static void find_matching(const Graph& g, MateMap mate)
    {
      vertex_iterator_t vi, vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        put(mate, *vi, graph_traits<Graph>::null_vertex());
    }

      odd_components_counter(SizeType& c_count):
        m_count(c_count)
      {
        m_count = 0;
      }

      
      template <class Vertex, class Graph>
      void start_vertex(Vertex, Graph&) 
      {
        m_parity = false; 
      }

      
      template <class Vertex, class Graph>
      void discover_vertex(Vertex, Graph&) 
      {
        m_parity = !m_parity;
        m_parity ? ++m_count : --m_count;
      }

    inline static bool 
    verify_matching(const Graph&, MateMap, VertexIndexMap) 
    { return true;}

      non_odd_vertex() : vertex_state(0) { }

  
      non_odd_vertex(VertexStateMap* arg_vertex_state) 
        : vertex_state(arg_vertex_state) { }


      template <typename Vertex>
      bool operator()(const Vertex& v) const 
      {
        BOOST_ASSERT(vertex_state);
        return get(*vertex_state, v) != graph::detail::V_ODD;
      }



    static bool verify_matching(const Graph& g, MateMap mate, VertexIndexMap vm)
    {
      //For any graph G, let o(G) be the number of connected
      //components in G of odd size. For a subset S of G's vertex set
      //V(G), let (G - S) represent the subgraph of G induced by
      //removing all vertices in S from G. Let M(G) be the size of the
      //maximum cardinality matching in G. Then the Tutte-Berge
      //formula guarantees that
      //
      //           2 * M(G) = min ( |V(G)| + |U| + o(G - U) )
      //
      //where the minimum is taken over all subsets U of
      //V(G). Edmonds' algorithm finds a set U that achieves the
      //minimum in the above formula, namely the vertices labeled
      //"ODD." This function runs one iteration of Edmonds' algorithm
      //to find U, then verifies that the size of the matching given
      //by mate satisfies the Tutte-Berge formula.

      //first, make sure it's a valid matching
      if (!is_a_matching(g,mate,vm))
        return false;

      //We'll try to augment the matching once. This serves two
      //purposes: first, if we find some augmenting path, the matching
      //is obviously non-maximum. Second, running edmonds' algorithm
      //on a graph with no augmenting path will create the
      //Edmonds-Gallai decomposition that we need as a certificate of
      //maximality - we can get it by looking at the vertex_state map
      //that results.
      edmonds_augmenting_path_finder<Graph,MateMap,VertexIndexMap>
        augmentor(g,mate,vm);
      if (augmentor.augment_matching())
        return false;

      std::vector<int> vertex_state_vector(num_vertices(g));
      vertex_to_int_map_t vertex_state(vertex_state_vector.begin(), vm);
      augmentor.get_vertex_state_map(vertex_state);
      
      //count the number of graph::detail::V_ODD vertices
      v_size_t num_odd_vertices = 0;
      vertex_iterator_t vi, vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        if (vertex_state[*vi] == graph::detail::V_ODD)
          ++num_odd_vertices;

      //count the number of connected components with odd cardinality
      //in the graph without graph::detail::V_ODD vertices
      non_odd_vertex<vertex_to_int_map_t> filter(&vertex_state);
      filtered_graph<Graph, keep_all, non_odd_vertex<vertex_to_int_map_t> > fg(g, keep_all(), filter);

      v_size_t num_odd_components;
      detail::odd_components_counter<v_size_t> occ(num_odd_components);
      depth_first_search(fg, visitor(occ).vertex_index_map(vm));

      if (2 * matching_size(g,mate,vm) == num_vertices(g) + num_odd_vertices - num_odd_components)
        return true;
      else
        return false;
    }





  template <typename Graph, 
        typename MateMap,
        typename VertexIndexMap,
        template <typename, typename, typename> class AugmentingPathFinder, 
        template <typename, typename> class InitialMatchingFinder,
        template <typename, typename, typename> class MatchingVerifier>
  bool matching(const Graph& g, MateMap mate, VertexIndexMap vm)
  {
    
    InitialMatchingFinder<Graph,MateMap>::find_matching(g,mate);

    AugmentingPathFinder<Graph,MateMap,VertexIndexMap> augmentor(g,mate,vm);
    bool not_maximum_yet = true;
    while(not_maximum_yet)
      {
        not_maximum_yet = augmentor.augment_matching();
      }
    augmentor.get_current_matching(mate);

    return MatchingVerifier<Graph,MateMap,VertexIndexMap>::verify_matching(g,mate,vm);    
    
  }





  template <typename Graph, typename MateMap, typename VertexIndexMap>
  inline bool checked_edmonds_maximum_cardinality_matching(const Graph& g, MateMap mate, VertexIndexMap vm)
  {
    return matching 
      < Graph, MateMap, VertexIndexMap,
        edmonds_augmenting_path_finder, extra_greedy_matching, maximum_cardinality_matching_verifier>
      (g, mate, vm);
  }





  template <typename Graph, typename MateMap>
  inline bool checked_edmonds_maximum_cardinality_matching(const Graph& g, MateMap mate)
  {
    return checked_edmonds_maximum_cardinality_matching(g, mate, get(vertex_index,g));
  }





  template <typename Graph, typename MateMap, typename VertexIndexMap>
  inline void edmonds_maximum_cardinality_matching(const Graph& g, MateMap mate, VertexIndexMap vm)
  {
    matching < Graph, MateMap, VertexIndexMap,
               edmonds_augmenting_path_finder, extra_greedy_matching, no_matching_verifier>
      (g, mate, vm);
  }





  template <typename Graph, typename MateMap>
  inline void edmonds_maximum_cardinality_matching(const Graph& g, MateMap mate)
  {
    edmonds_maximum_cardinality_matching(g, mate, get(vertex_index,g));
  }


  template <typename Graph, typename VertexIndexMap>
  typename graph_traits<Graph>::vertices_size_type
  profile(const Graph& g, VertexIndexMap index)
  {
    typename graph_traits<Graph>::vertices_size_type b = 0;
    typename graph_traits<Graph>::vertex_iterator i, end;
    for (boost::tie(i, end) = vertices(g); i != end; ++i){
      b += ith_bandwidth(*i, g, index) + 1;
    }
    
    return b;
  }


  template <typename Graph>
  typename graph_traits<Graph>::vertices_size_type
  profile(const Graph& g)
  {
    return profile(g, get(vertex_index, g));
  }



  template <typename Graph,
            typename VertexIndexMap,
            typename AddEdgeVisitor
            >
  void make_connected(Graph& g, VertexIndexMap vm, AddEdgeVisitor& vis)
  {
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator_t;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef typename graph_traits<Graph>::vertices_size_type v_size_t;
    typedef iterator_property_map< typename std::vector<v_size_t>::iterator,
                                   VertexIndexMap
                                  > vertex_to_v_size_map_t;

    std::vector<v_size_t> component_vector(num_vertices(g));
    vertex_to_v_size_map_t component(component_vector.begin(), vm);
    std::vector<vertex_t> vertices_by_component(num_vertices(g));

    v_size_t num_components = connected_components(g, component);

    if (num_components < 2)
      return;

    vertex_iterator_t vi, vi_end;
    boost::tie(vi,vi_end) = vertices(g);
    std::copy(vi, vi_end, vertices_by_component.begin());

    bucket_sort(vertices_by_component.begin(),
                vertices_by_component.end(),
                component,
                num_components
                );

    typedef typename std::vector<vertex_t>::iterator vec_of_vertices_itr_t;

    vec_of_vertices_itr_t ci_end = vertices_by_component.end();
    vec_of_vertices_itr_t ci_prev = vertices_by_component.begin();
    if (ci_prev == ci_end)
      return;

    for(vec_of_vertices_itr_t ci = boost::next(ci_prev); 
        ci != ci_end;  ci_prev = ci, ++ci
        )
      {
        if (component[*ci_prev] != component[*ci])
          vis.visit_vertex_pair(*ci_prev, *ci, g);
      }

  }





  template <typename Graph, typename VertexIndexMap>
  inline void make_connected(Graph& g, VertexIndexMap vm)
  {
    default_add_edge_visitor vis;
    make_connected(g, vm, vis);
  }





  template <typename Graph>
  inline void make_connected(Graph& g)
  {
    make_connected(g, get(vertex_index,g));
  }

    matrix_adj_iterator() { }

    matrix_adj_iterator(Iter i) : _iter(i) { }

    matrix_adj_iterator(const self& x) : _iter(x._iter) { }

    self& operator=(const self& x) { _iter = x._iter; return *this; }

    Vertex operator*() { return _iter.column(); }

    self& operator++() { ++_iter; return *this; }

    self operator++(int) { self t = *this; ++_iter; return t; }

    bool operator==(const self& x) const { return _iter == x._iter; }

    bool operator!=(const self& x) const { return _iter != x._iter; }

    matrix_incidence_iterator() { }

    matrix_incidence_iterator(Iter i) : _iter(i) { }

    matrix_incidence_iterator(const self& x) : _iter(x._iter) { }

    self& operator=(const self& x) { _iter = x._iter; return *this; }

    Iter operator*() { return _iter; }

    self& operator++() { ++_iter; return *this; }

    self operator++(int) { self t = *this; ++_iter; return t; }

    bool operator==(const self& x) const { return _iter == x._iter; }

    bool operator!=(const self& x) const { return _iter != x._iter; }

    
  template<typename Graph, 
           typename PlanarEmbedding, 
           typename OutputIterator, 
           typename VertexIndexMap>
  void planar_canonical_ordering(const Graph& g, 
                                 PlanarEmbedding embedding, 
                                 OutputIterator ordering, 
                                 VertexIndexMap vm)
  {
    
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef typename graph_traits<Graph>::edge_descriptor edge_t;
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator_t;
    typedef typename graph_traits<Graph>::adjacency_iterator
      adjacency_iterator_t;
    typedef typename std::pair<vertex_t, vertex_t> vertex_pair_t;
    typedef typename property_traits<PlanarEmbedding>::value_type 
      embedding_value_t;
    typedef typename embedding_value_t::const_iterator embedding_iterator_t;
    typedef iterator_property_map
      <typename std::vector<vertex_t>::iterator, VertexIndexMap> 
      vertex_to_vertex_map_t;
    typedef iterator_property_map
      <typename std::vector<std::size_t>::iterator, VertexIndexMap> 
      vertex_to_size_t_map_t;
    
    std::vector<vertex_t> processed_neighbor_vector(num_vertices(g));
    vertex_to_vertex_map_t processed_neighbor
      (processed_neighbor_vector.begin(), vm);

    std::vector<std::size_t> status_vector(num_vertices(g), detail::PCO_UNPROCESSED);
    vertex_to_size_t_map_t status(status_vector.begin(), vm);

    std::list<vertex_t> ready_to_be_processed;
    
    vertex_t first_vertex = *vertices(g).first;
    vertex_t second_vertex;
    adjacency_iterator_t ai, ai_end;
    for(boost::tie(ai,ai_end) = adjacent_vertices(first_vertex,g); ai != ai_end; ++ai)
      {
        if (*ai == first_vertex)
          continue;
        second_vertex = *ai;
        break;
      }

    ready_to_be_processed.push_back(first_vertex);
    status[first_vertex] = detail::PCO_READY_TO_BE_PROCESSED;
    ready_to_be_processed.push_back(second_vertex);
    status[second_vertex] = detail::PCO_READY_TO_BE_PROCESSED;

    while(!ready_to_be_processed.empty())
      {
        vertex_t u = ready_to_be_processed.front();
        ready_to_be_processed.pop_front();

        if (status[u] != detail::PCO_READY_TO_BE_PROCESSED && u != second_vertex)
          continue;

        embedding_iterator_t ei, ei_start, ei_end;
        embedding_iterator_t next_edge_itr, prior_edge_itr;

        ei_start = embedding[u].begin();
        ei_end = embedding[u].end();
        prior_edge_itr = prior(ei_end);
        while(source(*prior_edge_itr, g) == target(*prior_edge_itr,g))
          prior_edge_itr = prior(prior_edge_itr);

        for(ei = ei_start; ei != ei_end; ++ei)
          {
            
            edge_t e(*ei); // e = (u,v)
            next_edge_itr = boost::next(ei) == ei_end ? ei_start : boost::next(ei);
            vertex_t v = source(e,g) == u ? target(e,g) : source(e,g);

            vertex_t prior_vertex = source(*prior_edge_itr, g) == u ? 
              target(*prior_edge_itr, g) : source(*prior_edge_itr, g);
            vertex_t next_vertex = source(*next_edge_itr, g) == u ? 
              target(*next_edge_itr, g) : source(*next_edge_itr, g);

            // Need prior_vertex, u, v, and next_vertex to all be
            // distinct. This is possible, since the input graph is
            // triangulated. It'll be true all the time in a simple
            // graph, but loops and parallel edges cause some complications.
            if (prior_vertex == v || prior_vertex == u)
              {
                prior_edge_itr = ei;
                continue;
              }

            //Skip any self-loops
            if (u == v)
                continue;
                                                                
            // Move next_edge_itr (and next_vertex) forwards
            // past any loops or parallel edges
            while (next_vertex == v || next_vertex == u)
              {
                next_edge_itr = boost::next(next_edge_itr) == ei_end ?
                  ei_start : boost::next(next_edge_itr);
                next_vertex = source(*next_edge_itr, g) == u ? 
                  target(*next_edge_itr, g) : source(*next_edge_itr, g);
              }


            if (status[v] == detail::PCO_UNPROCESSED)
              {
                status[v] = detail::PCO_ONE_NEIGHBOR_PROCESSED;
                processed_neighbor[v] = u;
              }
            else if (status[v] == detail::PCO_ONE_NEIGHBOR_PROCESSED)
              {
                vertex_t x = processed_neighbor[v];
                //are edges (v,u) and (v,x) adjacent in the planar
                //embedding? if so, set status[v] = 1. otherwise, set
                //status[v] = 2.

                if ((next_vertex == x &&
                     !(first_vertex == u && second_vertex == x)
                     )
                    ||
                    (prior_vertex == x &&
                     !(first_vertex == x && second_vertex == u)
                     )
                    )
                  {
                    status[v] = detail::PCO_READY_TO_BE_PROCESSED;
                  }
                else
                  {
                    status[v] = detail::PCO_READY_TO_BE_PROCESSED + 1;
                  }                                                        
              }
            else if (status[v] > detail::PCO_ONE_NEIGHBOR_PROCESSED)
              {
                //check the two edges before and after (v,u) in the planar
                //embedding, and update status[v] accordingly

                bool processed_before = false;
                if (status[prior_vertex] == detail::PCO_PROCESSED)
                  processed_before = true;

                bool processed_after = false;
                if (status[next_vertex] == detail::PCO_PROCESSED)
                  processed_after = true;

                if (!processed_before && !processed_after)
                    ++status[v];

                else if (processed_before && processed_after)
                    --status[v];

              }

            if (status[v] == detail::PCO_READY_TO_BE_PROCESSED)
              ready_to_be_processed.push_back(v);

            prior_edge_itr = ei;

          }

        status[u] = detail::PCO_PROCESSED;
        *ordering = u;
        ++ordering;
        
      }
    
  }



  template<typename Graph, typename PlanarEmbedding, typename OutputIterator>
  void planar_canonical_ordering(const Graph& g, 
                                 PlanarEmbedding embedding, 
                                 OutputIterator ordering
                                 )
  {
    planar_canonical_ordering(g, embedding, ordering, get(vertex_index,g));
  }

      edge_descriptor() { }

      edge_descriptor(EdgeIter p, edge_id id) : _ptr(p), _id(id) { }

      operator edge_id() { return _id; }

      edge_iterator() { }

      edge_iterator(EdgeIter iter) : _iter(iter), _i(0) { }

      E operator*() { return E(_iter, _i); }

      self& operator++() { ++_iter; ++_i; return *this; }

      self operator++(int) { self t = *this; ++(*this); return t; }

      bool operator==(const self& x) { return _iter == x._iter; }

      bool operator!=(const self& x) { return _iter != x._iter; }


  template <class G, class EI, class T, class D>
  inline D
  get(edge_index_t, const edge_list_impl<G,EI,T,D>&,
      typename edge_list_impl<G,EI,T,D>::edge_descriptor e) {
    return e._i;
  }


  template <class G, class EI, class T, class D>
  inline D
  get(edge_index_t, const edge_list_impl_ra<G,EI,T,D>&,
      typename edge_list_impl_ra<G,EI,T,D>::edge_descriptor e) {
    return e;
  }


  template <class EdgeIter, class T, class D, class Cat>
  std::size_t num_edges(const edge_list<EdgeIter, T, D, Cat>& el) {
    return el.m_num_edges;
  }


    static Float infinity()
    { return std::numeric_limits<value_type>::infinity(); }


    static Float epsilon()
    { return Float(-0.005); }


      static value_type infinity()
      { return FloatTraits::infinity() * ComparatorProps::multiplier; }


      static value_type epsilon()
      { return FloatTraits::epsilon() * ComparatorProps::multiplier; }

      mcr_howard(const Graph &g, VertexIndexMap vim,
                  EdgeWeight1 ewm, EdgeWeight2 ew2m) :
        m_g(g), m_vim(vim), m_ew1m(ewm), m_ew2m(ew2m),
        m_bound(mcr_bound()),
        m_cr(m_bound),
        m_V(num_vertices(m_g)),
        m_dis(m_V, 0), m_dm(m_dis.begin(), m_vim),
        m_policyc(m_V), m_policy(m_policyc.begin(), m_vim),
        m_inelc(m_V), m_inel(m_inelc.begin(), m_vim),
        m_badvc(m_V, false), m_badv(m_badvc.begin(), m_vim),
        m_colcv(m_V),
        m_col_bfs(m_V)
      { }

      float_t ocr_howard()
      {
        construct_policy_graph();
        int k = 0;
        float_t mcr = 0;
        do
          {
            mcr = policy_mcr();
            ++k;
          }
        while (try_improve_policy(mcr) && k < 100); //To avoid infinite loop

        const float_t eps_ =  -0.00000001 * cmp_props_t::multiplier;
        if (m_cmp(mcr, m_bound + eps_))
          {
            return FloatTraits::infinity();
          }
        else
          {
            return  mcr;
          }
      }

      virtual ~mcr_howard() {}

      virtual void store_critical_edge(edge_t, critical_cycle_t &) {}

      virtual void store_critical_cycle(critical_cycle_t &) {}

      float_t mcr_bound()
      {
        typename  graph_traits<Graph>::vertex_iterator  vi, vie;
        typename  graph_traits<Graph>::out_edge_iterator  oei, oeie;
        float_t cz = (std::numeric_limits<float_t>::max)(); //Closest to zero value
        float_t s = 0;
        const float_t eps_ = std::numeric_limits<float_t>::epsilon();
        for (boost::tie(vi, vie) = vertices(m_g); vi != vie; ++vi)
          {
            for (boost::tie(oei, oeie) = out_edges(*vi, m_g); oei != oeie; ++oei)
              {
                s += std::abs(m_ew1m[*oei]);
                float_t a = std::abs(m_ew2m[*oei]);
                if ( a > eps_ && a < cz)
                {
                  cz = a;
                }
              }
          }
        return  cmp_props_t::multiplier * (s / cz);
      }

      void construct_policy_graph()
      {
        m_sink = graph_traits<Graph>().null_vertex();
        typename  graph_traits<Graph>::vertex_iterator  vi, vie;
        typename  graph_traits<Graph>::out_edge_iterator  oei, oeie;
        for ( boost::tie(vi, vie) = vertices(m_g); vi != vie; ++vi )
          {
            boost::tie(oei, oeie) = out_edges(*vi, m_g);
            typename graph_traits<Graph>::out_edge_iterator mei =
              std::max_element(oei, oeie,
                               boost::bind(m_cmp,
                                           boost::bind(&EdgeWeight1::operator[], m_ew1m, _1),
                                           boost::bind(&EdgeWeight1::operator[], m_ew1m, _2)
                                          )
                               );
            if (mei == oeie)
              {
                if (m_sink == graph_traits<Graph>().null_vertex())
                  {
                    m_sink = *vi;
                  }
                m_badv[*vi] = true;
                m_inel[m_sink].push_back(*vi);
              }
            else
              {
                m_inel[target(*mei, m_g)].push_back(*vi);
                m_policy[*vi] = *mei;
              }
          }
      }

      void mcr_bfv(vertex_t sv, float_t cr, color_map_t c)
      {
        boost::queue<vertex_t> Q;
        c[sv] = my_black;
        Q.push(sv);
        while (!Q.empty())
          {
            vertex_t v = Q.top(); Q.pop();
            for (typename pinel_t::const_iterator itr = m_inel[v].begin();
                 itr != m_inel[v].end(); ++itr)
              //For all in_edges of the policy graph
              {
                if (*itr != sv)
                  {
                    if (m_badv[*itr])
                      {
                        m_dm[*itr] = m_dm[v] + m_bound - cr;
                      }
                    else
                      {
                        m_dm[*itr] = m_dm[v] + m_ew1m[m_policy[*itr]] -
                          m_ew2m[m_policy[*itr]] * cr;
                      }
                    c[*itr] = my_black;
                    Q.push(*itr);
                  }
              }
          }
      }

      vertex_t find_cycle_vertex(vertex_t sv)
      {
        vertex_t gv = sv;
        std::fill(m_colcv.begin(), m_colcv.end(), my_white);
        color_map_t cm(m_colcv.begin(), m_vim);
        do
          {
            cm[gv] = my_black;
            if (! m_badv[gv])
              {
                gv = target(m_policy[gv], m_g);
              }
            else
              {
                gv = m_sink;
              }
          }
        while (cm[gv] != my_black);
        return gv;
      }

      float_t cycle_ratio(vertex_t sv)
      {
        if (sv == m_sink) return m_bound;
        std::pair<float_t, float_t> sums_(float_t(0), float_t(0));
        vertex_t v = sv;
        critical_cycle_t cc;
        do
          {
            store_critical_edge(m_policy[v], cc);
            sums_.first += m_ew1m[m_policy[v]];
            sums_.second += m_ew2m[m_policy[v]];
            v = target(m_policy[v], m_g);
          }
        while (v != sv);
        float_t cr = sums_.first / sums_.second;
        if ( m_cmp(m_cr, cr) )
          {
            m_cr = cr;
            store_critical_cycle(cc);
          }
        return cr;
      }

      float_t policy_mcr()
      {
        std::fill(m_col_bfs.begin(), m_col_bfs.end(), my_white);
        color_map_t vcm_ = color_map_t(m_col_bfs.begin(), m_vim);
        typename graph_traits<Graph>::vertex_iterator uv_itr, vie;
        boost::tie(uv_itr, vie) = vertices(m_g);
        float_t mcr = m_bound;
        while ( (uv_itr = std::find_if(uv_itr, vie,
                                       boost::bind(std::equal_to<my_color_type>(),
                                                   my_white,
                                                   boost::bind(&color_map_t::operator[], vcm_, _1)
                                                   )
                                       )
                 ) != vie )
          ///While there are undiscovered vertices
          {
            vertex_t gv = find_cycle_vertex(*uv_itr);
            float_t cr = cycle_ratio(gv) ;
            mcr_bfv(gv, cr, vcm_);
            if ( m_cmp(mcr, cr) )  mcr = cr;
            ++uv_itr;
          }
        return mcr;
      }

      void improve_policy(vertex_t s, edge_t new_edge)
      {
        vertex_t t = target(m_policy[s], m_g);
        typename property_traits<VertexIndexMap>::value_type ti = m_vim[t];
        m_inelc[ti].erase( std::find(m_inelc[ti].begin(), m_inelc[ti].end(), s));
        m_policy[s] = new_edge;
        t = target(new_edge, m_g);
        m_inel[t].push_back(s); ///Maintain in_edge list
      }

      bool try_improve_policy(float_t cr)
      {
        bool improved = false;
        typename  graph_traits<Graph>::vertex_iterator  vi, vie;
        typename  graph_traits<Graph>::out_edge_iterator  oei, oeie;
        const float_t eps_ =  FloatTraits::epsilon();
        for (boost::tie(vi, vie) = vertices(m_g); vi != vie; ++vi)
          {
            if (!m_badv[*vi])
              {
                for (boost::tie(oei, oeie) = out_edges(*vi, m_g); oei != oeie; ++oei)
                  {
                    vertex_t t = target(*oei, m_g);
                    //Current distance from *vi to some vertex
                    float_t dis_ = m_ew1m[*oei] - m_ew2m[*oei] * cr + m_dm[t];
                    if ( m_cmp(m_dm[*vi] + eps_, dis_) )
                      {
                        improve_policy(*vi, *oei);
                        m_dm[*vi] = dis_;
                        improved = true;
                      }
                  }
              }
            else
              {
                float_t dis_ = m_bound - cr + m_dm[m_sink];
                if ( m_cmp(m_dm[*vi] + eps_, dis_) )
                  {
                    m_dm[*vi] = dis_;
                  }
              }
          }
        return improved;
      }

      mcr_howard1(const Graph &g, VertexIndexMap vim,
        EdgeWeight1 ewm, EdgeWeight2 ew2m) :
        inhr_t(g, vim, ewm, ew2m)
      { }


      void get_critical_cycle(typename inhr_t::critical_cycle_t &cc)
      { return cc.swap(m_cc); }

      void store_critical_edge(typename inhr_t::edge_t ed,
        typename inhr_t::critical_cycle_t &cc)
      { cc.push_back(ed); }


      void store_critical_cycle(typename inhr_t::critical_cycle_t &cc)
      { m_cc.swap(cc); }

    template <typename FT,
              typename TG, typename TVIM,
              typename TEW1, typename TEW2,
              typename EV>
    typename FT::value_type
 optimum_cycle_ratio(const TG &g, TVIM vim, TEW1 ewm, TEW2 ew2m, EV* pcc)
    {
      typedef typename graph_traits<TG>::directed_category DirCat;
      BOOST_STATIC_ASSERT((is_convertible<DirCat*, directed_tag*>::value == true));
      BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<TG> ));
      BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<TG> ));
      typedef typename graph_traits<TG>::vertex_descriptor Vertex;
      BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<TVIM, Vertex> ));
      typedef typename graph_traits<TG>::edge_descriptor Edge;
      BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<TEW1, Edge> ));
      BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<TEW2, Edge> ));

      if(pcc == 0) {
          return detail::mcr_howard<FT,TG, TVIM, TEW1, TEW2>(
            g, vim, ewm, ew2m
          ).ocr_howard();
      }

      detail::mcr_howard1<FT, TG, TVIM, TEW1, TEW2> obj(g, vim, ewm, ew2m);
      double ocr = obj.ocr_howard();
      obj.get_critical_cycle(*pcc);
      return ocr;
    }


template <
    typename FloatTraits,
    typename Graph,
    typename VertexIndexMap,
    typename EdgeWeight1Map,
    typename EdgeWeight2Map>
inline typename FloatTraits::value_type
maximum_cycle_ratio(const Graph &g, VertexIndexMap vim, EdgeWeight1Map ew1m,
                    EdgeWeight2Map ew2m,
                    std::vector<typename graph_traits<Graph>::edge_descriptor>* pcc = 0,
                    FloatTraits = FloatTraits())
{
    typedef detail::float_wrapper<
        FloatTraits, detail::max_comparator_props<FloatTraits>
    > Traits;
    return detail::optimum_cycle_ratio<Traits>(g, vim, ew1m, ew2m, pcc);
}


template <
    typename FloatTraits,
    typename Graph,
    typename VertexIndexMap,
    typename EdgeWeight1Map,
    typename EdgeWeight2Map>
typename FloatTraits::value_type
minimum_cycle_ratio(const Graph &g, VertexIndexMap vim,
                    EdgeWeight1Map ew1m, EdgeWeight2Map ew2m,
                    std::vector<typename graph_traits<Graph>::edge_descriptor> *pcc = 0,
                    FloatTraits = FloatTraits())
{
    typedef detail::float_wrapper<
        FloatTraits, detail::min_comparator_props<FloatTraits>
    > Traits;
    return detail::optimum_cycle_ratio<Traits>(g, vim, ew1m, ew2m, pcc);
}


template <
    typename FloatTraits,
    typename Graph,
    typename VertexIndexMap,
    typename EdgeWeightMap,
    typename EdgeIndexMap>
inline typename FloatTraits::value_type
maximum_cycle_mean(const Graph &g, VertexIndexMap vim,
                   EdgeWeightMap ewm, EdgeIndexMap eim,
                   std::vector<typename graph_traits<Graph>::edge_descriptor>* pcc = 0,
                   FloatTraits ft = FloatTraits())
{
    typedef typename remove_const<
        typename property_traits<EdgeWeightMap>::value_type
    >::type Weight;
    typename std::vector<Weight> ed_w2(boost::num_edges(g), 1);
    return maximum_cycle_ratio(g, vim, ewm,
                               make_iterator_property_map(ed_w2.begin(), eim),
                               pcc, ft);
}


template <
    typename FloatTraits,
    typename Graph,
    typename VertexIndexMap,
    typename EdgeWeightMap,
    typename EdgeIndexMap>
inline typename FloatTraits::value_type
minimum_cycle_mean(const Graph &g, VertexIndexMap vim,
                   EdgeWeightMap ewm, EdgeIndexMap eim,
                   std::vector<typename graph_traits<Graph>::edge_descriptor>* pcc = 0,
                   FloatTraits ft = FloatTraits())
{
    typedef typename remove_const<
        typename property_traits<EdgeWeightMap>::value_type
    >::type Weight;
    typename std::vector<Weight> ed_w2(boost::num_edges(g), 1);
    return minimum_cycle_ratio(g, vim, ewm,
                               make_iterator_property_map(ed_w2.begin(), eim),
                               pcc, ft);
}

    void begin_traversal()
    {}


    void begin_face()
    {}


    template <typename Edge>
    void next_edge(Edge)
    {}


    template <typename Vertex>
    void next_vertex(Vertex)
    {}


    void end_face()
    {}


    void end_traversal()
    {}






  template<typename Graph, 
           typename PlanarEmbedding, 
           typename Visitor, 
           typename EdgeIndexMap>
  void planar_face_traversal(const Graph& g, 
                             PlanarEmbedding embedding, 
                             Visitor& visitor, EdgeIndexMap em
                             )
  {
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef typename graph_traits<Graph>::edge_descriptor edge_t;
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator_t;
    typedef typename graph_traits<Graph>::edge_iterator edge_iterator_t;
    typedef typename 
      property_traits<PlanarEmbedding>::value_type embedding_value_t;
    typedef typename embedding_value_t::const_iterator embedding_iterator_t;

    typedef typename 
      std::vector< std::set<vertex_t> > distinguished_edge_storage_t;
    typedef typename 
      std::vector< std::map<vertex_t, edge_t> > 
      distinguished_edge_to_edge_storage_t;

    typedef typename 
      boost::iterator_property_map
        <typename distinguished_edge_storage_t::iterator, EdgeIndexMap>
      distinguished_edge_map_t;

    typedef typename 
      boost::iterator_property_map
        <typename distinguished_edge_to_edge_storage_t::iterator, EdgeIndexMap>
      distinguished_edge_to_edge_map_t;

    distinguished_edge_storage_t visited_vector(num_edges(g));
    distinguished_edge_to_edge_storage_t next_edge_vector(num_edges(g));

    distinguished_edge_map_t visited(visited_vector.begin(), em);
    distinguished_edge_to_edge_map_t next_edge(next_edge_vector.begin(), em);

    vertex_iterator_t vi, vi_end;
    typename std::vector<edge_t>::iterator ei, ei_end;
    edge_iterator_t fi, fi_end;
    embedding_iterator_t pi, pi_begin, pi_end;

    visitor.begin_traversal();

    // Initialize the next_edge property map. This map is initialized from the
    // PlanarEmbedding so that get(next_edge, e)[v] is the edge that comes
    // after e in the clockwise embedding around vertex v.

    for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
      {
        vertex_t v(*vi);
        pi_begin = embedding[v].begin();
        pi_end = embedding[v].end();
        for(pi = pi_begin; pi != pi_end; ++pi)
          {
            edge_t e(*pi);
            std::map<vertex_t, edge_t> m = get(next_edge, e);
            m[v] = boost::next(pi) == pi_end ? *pi_begin : *boost::next(pi);
            put(next_edge, e, m);
          } 
      }

    // Take a copy of the edges in the graph here, since we want to accomodate
    // face traversals that add edges to the graph (for triangulation, in 
    // particular) and don't want to use invalidated edge iterators.
    // Also, while iterating over all edges in the graph, we single out
    // any self-loops, which need some special treatment in the face traversal.

    std::vector<edge_t> self_loops;
    std::vector<edge_t> edges_cache;
    std::vector<vertex_t> vertices_in_edge;

    for(boost::tie(fi,fi_end) = edges(g); fi != fi_end; ++fi)
      {
        edge_t e(*fi);
        edges_cache.push_back(e);
        if (source(e,g) == target(e,g))
          self_loops.push_back(e);
      }


    // Iterate over all edges in the graph
    ei_end = edges_cache.end();
    for(ei = edges_cache.begin(); ei != ei_end; ++ei)
      {

        edge_t e(*ei);
        vertices_in_edge.clear();
        vertices_in_edge.push_back(source(e,g));
        vertices_in_edge.push_back(target(e,g));

        typename std::vector<vertex_t>::iterator vi, vi_end;
        vi_end = vertices_in_edge.end();
        
        //Iterate over both vertices in the current edge
        for(vi = vertices_in_edge.begin(); vi != vi_end; ++vi)
          {

            vertex_t v(*vi);
            std::set<vertex_t> e_visited = get(visited, e);
            typename std::set<vertex_t>::iterator e_visited_found 
              = e_visited.find(v);
            
            if (e_visited_found == e_visited.end())
              visitor.begin_face();
            
            while (e_visited.find(v) == e_visited.end())
              {
                visitor.next_vertex(v);
                visitor.next_edge(e);
                e_visited.insert(v);
                put(visited, e, e_visited);
                v = source(e,g) == v ? target(e,g) : source(e,g);
                e = get(next_edge, e)[v];
                e_visited = get(visited, e);
              }
            
            if (e_visited_found == e_visited.end())
              visitor.end_face();
            
          }

      }

    // Iterate over all self-loops, visiting them once separately
    // (they've already been visited once, this visitation is for
    // the "inside" of the self-loop)
    
    ei_end = self_loops.end();
    for(ei = self_loops.begin(); ei != ei_end; ++ei)
      {
        visitor.begin_face();
        visitor.next_edge(*ei);
        visitor.next_vertex(source(*ei,g));
        visitor.end_face();
      }

    visitor.end_traversal();

  }




  template<typename Graph, typename PlanarEmbedding, typename Visitor>
  inline void planar_face_traversal(const Graph& g, 
                                    PlanarEmbedding embedding, 
                                    Visitor& visitor
                                    )
  {
    planar_face_traversal(g, embedding, visitor, get(edge_index, g));
  }


    directed_graph(GraphProp const& p = GraphProp())
        : m_graph(p), m_num_vertices(0), m_num_edges(0), m_max_vertex_index(0)
        , m_max_edge_index(0)
    { }


    directed_graph(directed_graph const& x)
        : m_graph(x), m_num_vertices(x.m_num_vertices), m_num_edges(x.m_num_edges)
        , m_max_vertex_index(x.m_max_vertex_index), m_max_edge_index(x.m_max_edge_index)
    { }


    directed_graph(vertices_size_type n, GraphProp const& p = GraphProp())
        : m_graph(n, p), m_num_vertices(n), m_num_edges(0), m_max_vertex_index(n)
        , m_max_edge_index(0)
    { renumber_vertex_indices(); }


    template <typename EdgeIterator>
    directed_graph(EdgeIterator f,
                   EdgeIterator l,
                   vertices_size_type n,
                   edges_size_type m = 0,
                   GraphProp const& p = GraphProp())
        : m_graph(f, l, n, m, p), m_num_vertices(n), m_num_edges(0)
        , m_max_vertex_index(n), m_max_edge_index(0)
    {
        // Unfortunately, we have to renumber the entire graph.
        renumber_indices();

        // Can't always guarantee that the number of edges is actually
        // m if distance(f, l) != m (or is undefined).
        m_num_edges = m_max_edge_index = boost::num_edges(m_graph);
    }


    directed_graph& operator=(directed_graph const& g) {
        if(&g != this) {
            m_graph = g.m_graph;
            m_num_vertices = g.m_num_vertices;
            m_num_edges = g.m_num_edges;
            m_max_vertex_index = g.m_max_vertex_index;
            m_max_edge_index = g.m_max_edge_index;
        }
        return *this;
    }

    graph_type& impl()
    { return m_graph; }


    graph_type const& impl() const
    { return m_graph; }

    vertices_size_type num_vertices() const
    { return m_num_vertices; }

    vertex_descriptor make_index(vertex_descriptor v) {
        boost::put(vertex_index, m_graph, v, m_max_vertex_index);
        m_num_vertices++;
        m_max_vertex_index++;
        return v;
    }

    vertex_descriptor add_vertex()
    { return make_index(boost::add_vertex(m_graph)); }


    vertex_descriptor add_vertex(vertex_property_type const& p)
    { return make_index(boost::add_vertex(internal_vertex_property(0u, p), m_graph)); }


    void clear_vertex(vertex_descriptor v)
    {
        m_num_edges -= boost::degree(v, m_graph);
        boost::clear_vertex(v, m_graph);
    }


    void remove_vertex(vertex_descriptor v)
    {
        boost::remove_vertex(v, m_graph);
        --m_num_vertices;
    }


    edges_size_type num_edges() const
    { return m_num_edges; }

template <DIRECTED_GRAPH_PARAMS>
inline typename DIRECTED_GRAPH::vertex_descriptor
source(typename DIRECTED_GRAPH::edge_descriptor e, DIRECTED_GRAPH const& g)
{ return source(e, g.impl()); }


template <DIRECTED_GRAPH_PARAMS>
inline typename DIRECTED_GRAPH::vertex_descriptor
target(typename DIRECTED_GRAPH::edge_descriptor e, DIRECTED_GRAPH const& g)
{ return target(e, g.impl()); }


template <DIRECTED_GRAPH_PARAMS>
inline typename DIRECTED_GRAPH::degree_size_type
out_degree(typename DIRECTED_GRAPH::vertex_descriptor v, DIRECTED_GRAPH const& g)
{ return out_degree(v, g.impl()); }


template <DIRECTED_GRAPH_PARAMS, typename Property, typename Key, typename Value>
inline void put(Property p, DIRECTED_GRAPH& g, Key const& k, Value const& v)
{ put(p, g.impl(), k, v); }


template <DIRECTED_GRAPH_PARAMS, typename Key, typename Value>
inline void put(vertex_all_t, DIRECTED_GRAPH& g, Key const& k, Value const& v)
{ put(vertex_all, g.impl(), k,
      typename DIRECTED_GRAPH::internal_vertex_property(get(vertex_index, g.impl(), k), v));
}


template <DIRECTED_GRAPH_PARAMS, typename Key, typename Value>
inline void put(edge_all_t, DIRECTED_GRAPH& g, Key const& k, Value const& v)
{ put(edge_all, g.impl(), k,
      typename DIRECTED_GRAPH::internal_vertex_property(get(edge_index, g.impl(), k), v));
}


template <DIRECTED_GRAPH_PARAMS, class Property>
typename graph_property<DIRECTED_GRAPH, Property>::type&
get_property(DIRECTED_GRAPH& g, Property p)
{ return get_property(g.impl(), p); }


template <DIRECTED_GRAPH_PARAMS, class Property>
typename graph_property<DIRECTED_GRAPH, Property>::type const&
get_property(DIRECTED_GRAPH const& g, Property p)
{ return get_property(g.impl(), p); }


template <DIRECTED_GRAPH_PARAMS, class Property, class Value>
void
set_property(DIRECTED_GRAPH& g, Property p, Value v)
{ return set_property(g.impl(), p, v); }


template <DIRECTED_GRAPH_PARAMS>
inline typename DIRECTED_GRAPH::vertex_index_type
get_vertex_index(typename DIRECTED_GRAPH::vertex_descriptor v,
                DIRECTED_GRAPH const& g)
{ return get(vertex_index, g, v); }


template <DIRECTED_GRAPH_PARAMS>
typename DIRECTED_GRAPH::vertex_index_type
max_vertex_index(DIRECTED_GRAPH const& g)
{ return g.max_vertex_index(); }


template <DIRECTED_GRAPH_PARAMS>
inline void
renumber_vertex_indices(DIRECTED_GRAPH& g)
{ g.renumber_vertex_indices(); }


template <DIRECTED_GRAPH_PARAMS>
inline void
remove_vertex_and_renumber_indices(typename DIRECTED_GRAPH::vertex_iterator i,
                                DIRECTED_GRAPH& g)
{ g.remove_vertex_and_renumber_indices(i); }

template <DIRECTED_GRAPH_PARAMS>
inline typename DIRECTED_GRAPH::edge_index_type
get_edge_index(typename DIRECTED_GRAPH::edge_descriptor v, DIRECTED_GRAPH const& g)
{ return get(edge_index, g, v); }


template <DIRECTED_GRAPH_PARAMS>
typename DIRECTED_GRAPH::edge_index_type
max_edge_index(DIRECTED_GRAPH const& g)
{ return g.max_edge_index(); }


template <DIRECTED_GRAPH_PARAMS>
inline void renumber_edge_indices(DIRECTED_GRAPH& g)
{ g.renumber_edge_indices(); }


template <DIRECTED_GRAPH_PARAMS>
inline void
remove_edge_and_renumber_indices(typename DIRECTED_GRAPH::edge_iterator i,
                                 DIRECTED_GRAPH& g)
{ g.remove_edge_and_renumber_indices(i); }

template <DIRECTED_GRAPH_PARAMS>
inline void
renumber_indices(DIRECTED_GRAPH& g)
{ g.renumber_indices(); }



  template <class Tree, class TreeVisitor>
  void traverse_tree(typename tree_traits<Tree>::node_descriptor v,
                     Tree& t, TreeVisitor visitor)
  {
    visitor.preorder(v, t);
    typename tree_traits<Tree>::children_iterator i, end;
    boost::tie(i, end) = children(v, t);
    if (i != end) {
      traverse_tree(*i++, t, visitor);
      visitor.inorder(v, t);
      while (i != end)
        traverse_tree(*i++, t, visitor);
    } else
      visitor.inorder(v, t);
    visitor.postorder(v, t);
  }

    template <typename Node, typename Tree> void preorder(Node, Tree&) { }

    template <typename Node, typename Tree> void inorder(Node, Tree&) { }

    template <typename Node, typename Tree> void postorder(Node, Tree&) { }



    adjacency_list(const GraphProperty& p = GraphProperty())
      : m_property(new graph_property_type(p))
    { }


    adjacency_list(const adjacency_list& x)
      : Base(x), m_property(new graph_property_type(*x.m_property))
    { }


    adjacency_list& operator=(const adjacency_list& x) {
      // TBD: probably should give the strong guarantee
      if (&x != this) {
        Base::operator=(x);

        // Copy/swap the ptr since we can't just assign it...
        property_ptr p(new graph_property_type(*x.m_property));
        m_property.swap(p);
      }
      return *this;
    }

    adjacency_list(vertices_size_type num_vertices,
                          const GraphProperty& p = GraphProperty())
      : Base(num_vertices), m_property(new graph_property_type(p))
    { }

    template <class EdgeIterator>
    adjacency_list(EdgeIterator first, EdgeIterator last,
                          vertices_size_type n,
                          edges_size_type = 0,
                          const GraphProperty& p = GraphProperty())
      : Base(n, first, last), m_property(new graph_property_type(p))
    { }


    template <class EdgeIterator, class EdgePropertyIterator>
    adjacency_list(EdgeIterator first, EdgeIterator last,
                          EdgePropertyIterator ep_iter,
                          vertices_size_type n,
                          edges_size_type = 0,
                          const GraphProperty& p = GraphProperty())
      : Base(n, first, last, ep_iter), m_property(new graph_property_type(p))
    { }


    void swap(adjacency_list& x) {
      // Is there a more efficient way to do this?
      adjacency_list tmp(x);
      x = *this;
      *this = tmp;
    }


    void clear()
    {
      this->clearing_graph();
      Base::clear();
    }

    vertex_bundled& operator[](vertex_descriptor v)
    { return get(vertex_bundle, *this)[v]; }


    const vertex_bundled& operator[](vertex_descriptor v) const
    { return get(vertex_bundle, *this)[v]; }


    graph_bundled& operator[](graph_bundle_t)
    { return get_property(*this); }


    graph_bundled const& operator[](graph_bundle_t) const
    { return get_property(*this); }


  template<ADJLIST_PARAMS, typename Tag, typename Value>
  inline void set_property(ADJLIST& g, Tag tag, Value const& value) {
    get_property_value(*g.m_property, tag) = value;
  }


  template<ADJLIST_PARAMS, typename Tag>
  inline typename graph_property<ADJLIST, Tag>::type&
  get_property(ADJLIST& g, Tag tag) {
    return get_property_value(*g.m_property, tag);
  }


  template<ADJLIST_PARAMS, typename Tag>
  inline typename graph_property<ADJLIST, Tag>::type const&
  get_property(ADJLIST const& g, Tag tag) {
    return get_property_value(*g.m_property, tag);
  }

  template <class Directed, class Vertex,
      class OutEdgeListS,
      class VertexListS,
      class DirectedS,
      class VertexProperty,
      class EdgeProperty,
      class GraphProperty, class EdgeListS>
  inline Vertex
  source(const detail::edge_base<Directed,Vertex>& e,
         const adjacency_list<OutEdgeListS, VertexListS, DirectedS,
                 VertexProperty, EdgeProperty, GraphProperty, EdgeListS>&)
  {
    return e.m_source;
  }


  template <class Directed, class Vertex, class OutEdgeListS,
      class VertexListS, class DirectedS, class VertexProperty,
      class EdgeProperty, class GraphProperty, class EdgeListS>
  inline Vertex
  target(const detail::edge_base<Directed,Vertex>& e,
         const adjacency_list<OutEdgeListS, VertexListS, DirectedS,
              VertexProperty, EdgeProperty, GraphProperty, EdgeListS>&)
  {
    return e.m_target;
  }

      bfs_rcm_visitor(OutputIterator *iter, Buffer *b, DegreeMap deg): 
        permutation(iter), Qptr(b), degree(deg) { }

      template <class Vertex, class Graph>
      void examine_vertex(Vertex u, Graph&) {
        *(*permutation)++ = u;
        index_begin = Qptr->size();
      }

      template <class Vertex, class Graph>
      void finish_vertex(Vertex, Graph&) {
        using std::sort;

        typedef typename property_traits<DegreeMap>::value_type ds_type;

        typedef indirect_cmp<DegreeMap, std::less<ds_type> > Compare;
        Compare comp(degree);
                
        sort(Qptr->begin()+index_begin, Qptr->end(), comp);
      }


  template <class Graph, class OutputIterator,
            class ColorMap, class DegreeMap>
  OutputIterator
  cuthill_mckee_ordering(const Graph& g,
                         std::deque< typename
                         graph_traits<Graph>::vertex_descriptor > vertex_queue,
                         OutputIterator permutation, 
                         ColorMap color, DegreeMap degree)
  {

    //create queue, visitor...don't forget namespaces!
    typedef typename property_traits<DegreeMap>::value_type ds_type;
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename boost::sparse::sparse_ordering_queue<Vertex> queue;
    typedef typename detail::bfs_rcm_visitor<OutputIterator, queue, DegreeMap> Visitor;
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;


    queue Q;

    //create a bfs_rcm_visitor as defined above
    Visitor     vis(&permutation, &Q, degree);

    typename graph_traits<Graph>::vertex_iterator ui, ui_end;    

    // Copy degree to pseudo_degree
    // initialize the color map
    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui){
      put(color, *ui, Color::white());
    }


    while( !vertex_queue.empty() ) {
      Vertex s = vertex_queue.front();
      vertex_queue.pop_front();
      
      //call BFS with visitor
      breadth_first_visit(g, s, Q, vis, color);
    }
    return permutation;
  }

  template <class Graph, class OutputIterator,
            class ColorMap, class DegreeMap>
  OutputIterator
  cuthill_mckee_ordering(const Graph& g,
                         typename graph_traits<Graph>::vertex_descriptor s,
                         OutputIterator permutation, 
                         ColorMap color, DegreeMap degree)
  {

    std::deque< typename graph_traits<Graph>::vertex_descriptor > vertex_queue;
    vertex_queue.push_front( s );

    return cuthill_mckee_ordering(g, vertex_queue, permutation, color, degree);
  
  }

  template < class Graph, class OutputIterator, 
             class ColorMap, class DegreeMap>
  OutputIterator 
  cuthill_mckee_ordering(const Graph& G, OutputIterator permutation, 
                         ColorMap color, DegreeMap degree)
  {
    if (boost::graph::has_no_vertices(G))
      return permutation;

    typedef typename boost::graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename boost::graph_traits<Graph>::vertex_iterator   VerIter;
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;

    std::deque<Vertex>      vertex_queue;

    // Mark everything white
    BGL_FORALL_VERTICES_T(v, G, Graph) put(color, v, Color::white());

    // Find one vertex from each connected component 
    BGL_FORALL_VERTICES_T(v, G, Graph) {
      if (get(color, v) == Color::white()) {
        depth_first_visit(G, v, dfs_visitor<>(), color);
        vertex_queue.push_back(v);
      }
    }

    // Find starting nodes for all vertices
    // TBD: How to do this with a directed graph?
    for (typename std::deque<Vertex>::iterator i = vertex_queue.begin();
         i != vertex_queue.end(); ++i)
      *i = find_starting_node(G, *i, color, degree);
    
    return cuthill_mckee_ordering(G, vertex_queue, permutation,
                                  color, degree);
  }


  template<typename Graph, typename OutputIterator, typename VertexIndexMap>
  OutputIterator 
  cuthill_mckee_ordering(const Graph& G, OutputIterator permutation, 
                         VertexIndexMap index_map)
  {
    if (boost::graph::has_no_vertices(G))
      return permutation;
    
    typedef out_degree_property_map<Graph> DegreeMap;
    std::vector<default_color_type> colors(num_vertices(G));
    return cuthill_mckee_ordering(G, permutation, 
                                  make_iterator_property_map(&colors[0], 
                                                             index_map,
                                                             colors[0]),
                                  make_out_degree_map(G));
  }


  template<typename Graph, typename OutputIterator>
  inline OutputIterator 
  cuthill_mckee_ordering(const Graph& G, OutputIterator permutation)
  { return cuthill_mckee_ordering(G, permutation, get(vertex_index, G)); }

    void constraints() {
      BOOST_CONCEPT_ASSERT(( CopyConstructibleConcept<Visitor> ));
      vis.initialize_vertex(u, g);
      vis.discover_vertex(u, g);
      vis.examine_vertex(u, g);
      vis.examine_edge(e, g);
      vis.tree_edge(e, g);
      vis.non_tree_edge(e, g);
      vis.gray_target(e, g);
      vis.black_target(e, g);
      vis.finish_vertex(u, g);
    }

  template <class IncidenceGraph, class Buffer, class BFSVisitor,
            class ColorMap, class SourceIterator>
  void breadth_first_visit
    (const IncidenceGraph& g,
     SourceIterator sources_begin, SourceIterator sources_end,
     Buffer& Q, BFSVisitor vis, ColorMap color)
  {
    BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<IncidenceGraph> ));
    typedef graph_traits<IncidenceGraph> GTraits;
    typedef typename GTraits::vertex_descriptor Vertex;
    typedef typename GTraits::edge_descriptor Edge;
    BOOST_CONCEPT_ASSERT(( BFSVisitorConcept<BFSVisitor, IncidenceGraph> ));
    BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<ColorMap, Vertex> ));
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;
    typename GTraits::out_edge_iterator ei, ei_end;

    for (; sources_begin != sources_end; ++sources_begin) {
      Vertex s = *sources_begin;
      put(color, s, Color::gray());           vis.discover_vertex(s, g);
      Q.push(s);
    }
    while (! Q.empty()) {
      Vertex u = Q.top(); Q.pop();            vis.examine_vertex(u, g);
      for (boost::tie(ei, ei_end) = out_edges(u, g); ei != ei_end; ++ei) {
        Vertex v = target(*ei, g);            vis.examine_edge(*ei, g);
        ColorValue v_color = get(color, v);
        if (v_color == Color::white()) {      vis.tree_edge(*ei, g);
          put(color, v, Color::gray());       vis.discover_vertex(v, g);
          Q.push(v);
        } else {                              vis.non_tree_edge(*ei, g);
          if (v_color == Color::gray())       vis.gray_target(*ei, g);
          else                                vis.black_target(*ei, g);
        }
      } // end for
      put(color, u, Color::black());          vis.finish_vertex(u, g);
    } // end while
  }

  template <class IncidenceGraph, class Buffer, class BFSVisitor,
            class ColorMap>
  void breadth_first_visit
    (const IncidenceGraph& g,
     typename graph_traits<IncidenceGraph>::vertex_descriptor s,
     Buffer& Q, BFSVisitor vis, ColorMap color)
  {
    typename graph_traits<IncidenceGraph>::vertex_descriptor sources[1] = {s};
    breadth_first_visit(g, sources, sources + 1, Q, vis, color);
  }



  template <class VertexListGraph, class SourceIterator,
            class Buffer, class BFSVisitor,
            class ColorMap>
  void breadth_first_search
    (const VertexListGraph& g,
     SourceIterator sources_begin, SourceIterator sources_end,
     Buffer& Q, BFSVisitor vis, ColorMap color)
  {
    // Initialization
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;
    typename boost::graph_traits<VertexListGraph>::vertex_iterator i, i_end;
    for (boost::tie(i, i_end) = vertices(g); i != i_end; ++i) {
      vis.initialize_vertex(*i, g);
      put(color, *i, Color::white());
    }
    breadth_first_visit(g, sources_begin, sources_end, Q, vis, color);
  }


  template <class VertexListGraph, class Buffer, class BFSVisitor,
            class ColorMap>
  void breadth_first_search
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     Buffer& Q, BFSVisitor vis, ColorMap color)
  {
    typename graph_traits<VertexListGraph>::vertex_descriptor sources[1] = {s};
    breadth_first_search(g, sources, sources + 1, Q, vis, color);
  }

    bfs_visitor() { }

    bfs_visitor(Visitors vis) : m_vis(vis) { }


    template <class Vertex, class Graph>
    graph::bfs_visitor_event_not_overridden
    initialize_vertex(Vertex u, Graph& g)
    {
      invoke_visitors(m_vis, u, g, ::boost::on_initialize_vertex());
      return graph::bfs_visitor_event_not_overridden();
    }


    template <class Vertex, class Graph>
    graph::bfs_visitor_event_not_overridden
    discover_vertex(Vertex u, Graph& g)
    {
      invoke_visitors(m_vis, u, g, ::boost::on_discover_vertex());
      return graph::bfs_visitor_event_not_overridden();
    }


    template <class Vertex, class Graph>
    graph::bfs_visitor_event_not_overridden
    examine_vertex(Vertex u, Graph& g)
    {
      invoke_visitors(m_vis, u, g, ::boost::on_examine_vertex());
      return graph::bfs_visitor_event_not_overridden();
    }


    template <class Edge, class Graph>
    graph::bfs_visitor_event_not_overridden
    examine_edge(Edge e, Graph& g)
    {
      invoke_visitors(m_vis, e, g, ::boost::on_examine_edge());
      return graph::bfs_visitor_event_not_overridden();
    }


    template <class Edge, class Graph>
    graph::bfs_visitor_event_not_overridden
    tree_edge(Edge e, Graph& g)
    {
      invoke_visitors(m_vis, e, g, ::boost::on_tree_edge());
      return graph::bfs_visitor_event_not_overridden();
    }


    template <class Edge, class Graph>
    graph::bfs_visitor_event_not_overridden
    non_tree_edge(Edge e, Graph& g)
    {
      invoke_visitors(m_vis, e, g, ::boost::on_non_tree_edge());
      return graph::bfs_visitor_event_not_overridden();
    }


    template <class Edge, class Graph>
    graph::bfs_visitor_event_not_overridden
    gray_target(Edge e, Graph& g)
    {
      invoke_visitors(m_vis, e, g, ::boost::on_gray_target());
      return graph::bfs_visitor_event_not_overridden();
    }


    template <class Edge, class Graph>
    graph::bfs_visitor_event_not_overridden
    black_target(Edge e, Graph& g)
    {
      invoke_visitors(m_vis, e, g, ::boost::on_black_target());
      return graph::bfs_visitor_event_not_overridden();
    }


    template <class Vertex, class Graph>
    graph::bfs_visitor_event_not_overridden
    finish_vertex(Vertex u, Graph& g)
    {
      invoke_visitors(m_vis, u, g, ::boost::on_finish_vertex());
      return graph::bfs_visitor_event_not_overridden();
    }

  template <class Visitors>
  bfs_visitor<Visitors>
  make_bfs_visitor(Visitors vis) {
    return bfs_visitor<Visitors>(vis);
  }


    template <class VertexListGraph, class ColorMap, class BFSVisitor,
      class P, class T, class R>
    void bfs_helper
      (VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s,
       ColorMap color,
       BFSVisitor vis,
       const bgl_named_params<P, T, R>& params,
       BOOST_GRAPH_ENABLE_IF_MODELS(VertexListGraph, vertex_list_graph_tag,
                                    void)* = 0)
    {
      typedef graph_traits<VertexListGraph> Traits;
      // Buffer default
      typedef typename Traits::vertex_descriptor Vertex;
      typedef boost::queue<Vertex> queue_t;
      queue_t Q;
      breadth_first_search
        (g, s,
         choose_param(get_param(params, buffer_param_t()), boost::ref(Q)).get(),
         vis, color);
    }

      template <class VertexListGraph, class P, class T, class R>
      static void apply
      (VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s,
       const bgl_named_params<P, T, R>& params,
       ColorMap color)
      {
        bfs_helper
          (g, s, color,
           choose_param(get_param(params, graph_visitor),
                        make_bfs_visitor(null_visitor())),
           params);
      }

      template <class VertexListGraph, class P, class T, class R>
      static void apply
      (VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s,
       const bgl_named_params<P, T, R>& params,
       param_not_found)
      {
        null_visitor null_vis;

        bfs_helper
          (g, s,
           make_two_bit_color_map
           (num_vertices(g),
            choose_const_pmap(get_param(params, vertex_index),
                              g, vertex_index)),
           choose_param(get_param(params, graph_visitor),
                        make_bfs_visitor(null_vis)),
           params);
      }

  template <class VertexListGraph, class P, class T, class R>
  void breadth_first_search
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     const bgl_named_params<P, T, R>& params)
  {
    // The graph is passed by *const* reference so that graph adaptors
    // (temporaries) can be passed into this function. However, the
    // graph is not really const since we may write to property maps
    // of the graph.
    VertexListGraph& ng = const_cast<VertexListGraph&>(g);
    typedef typename get_param_type< vertex_color_t, bgl_named_params<P,T,R> >::type C;
    detail::bfs_dispatch<C>::apply(ng, s, params,
                                   get_param(params, vertex_color));
  }


  template <class IncidenceGraph, class P, class T, class R>
  void breadth_first_visit
    (const IncidenceGraph& g,
     typename graph_traits<IncidenceGraph>::vertex_descriptor s,
     const bgl_named_params<P, T, R>& params)
  {
    // The graph is passed by *const* reference so that graph adaptors
    // (temporaries) can be passed into this function. However, the
    // graph is not really const since we may write to property maps
    // of the graph.
    IncidenceGraph& ng = const_cast<IncidenceGraph&>(g);

    typedef graph_traits<IncidenceGraph> Traits;
    // Buffer default
    typedef typename Traits::vertex_descriptor vertex_descriptor;
    typedef boost::queue<vertex_descriptor> queue_t;
    queue_t Q;

    breadth_first_visit
      (ng, s,
       choose_param(get_param(params, buffer_param_t()), boost::ref(Q)).get(),
       choose_param(get_param(params, graph_visitor),
                    make_bfs_visitor(null_visitor())),
       choose_pmap(get_param(params, vertex_color), ng, vertex_color)
       );
  }

        template <typename ArgPack>
        void operator()(const Graph& g, const Source& source, const ArgPack& arg_pack) {
          using namespace boost::graph::keywords;
          typename boost::graph_traits<Graph>::vertex_descriptor sources[1] = {source};
          boost::queue<typename boost::graph_traits<Graph>::vertex_descriptor> Q;
          boost::breadth_first_search(g,
                                      &sources[0],
                                      &sources[1], 
                                      boost::unwrap_ref(arg_pack[_buffer | boost::ref(Q)]),
                                      arg_pack[_visitor | make_bfs_visitor(null_visitor())],
                                      boost::detail::make_color_map_from_arg_pack(g, arg_pack));
        }







  template <class VertexListGraph, class OutputIterator>
  typename graph_traits<VertexListGraph>::degree_size_type
  edge_connectivity(VertexListGraph& g, OutputIterator disconnecting_set)
  {
    //-------------------------------------------------------------------------
    // Type Definitions
    typedef graph_traits<VertexListGraph> Traits;
    typedef typename Traits::vertex_iterator vertex_iterator;
    typedef typename Traits::edge_iterator edge_iterator;
    typedef typename Traits::out_edge_iterator out_edge_iterator;
    typedef typename Traits::vertex_descriptor vertex_descriptor;
    typedef typename Traits::degree_size_type degree_size_type;
    typedef color_traits<default_color_type> Color;

    typedef adjacency_list_traits<vecS, vecS, directedS> Tr;
    typedef typename Tr::edge_descriptor Tr_edge_desc;
    typedef adjacency_list<vecS, vecS, directedS, no_property, 
      property<edge_capacity_t, degree_size_type,
        property<edge_residual_capacity_t, degree_size_type,
          property<edge_reverse_t, Tr_edge_desc> > > > 
      FlowGraph;
    typedef typename graph_traits<FlowGraph>::edge_descriptor edge_descriptor;

    //-------------------------------------------------------------------------
    // Variable Declarations
    vertex_descriptor u, v, p, k;
    edge_descriptor e1, e2;
    bool inserted;
    vertex_iterator vi, vi_end;
    edge_iterator ei, ei_end;
    degree_size_type delta, alpha_star, alpha_S_k;
    std::set<vertex_descriptor> S, neighbor_S;
    std::vector<vertex_descriptor> S_star, non_neighbor_S;
    std::vector<default_color_type> color(num_vertices(g));
    std::vector<edge_descriptor> pred(num_vertices(g));

    //-------------------------------------------------------------------------
    // Create a network flow graph out of the undirected graph
    FlowGraph flow_g(num_vertices(g));

    typename property_map<FlowGraph, edge_capacity_t>::type
      cap = get(edge_capacity, flow_g);
    typename property_map<FlowGraph, edge_residual_capacity_t>::type
      res_cap = get(edge_residual_capacity, flow_g);
    typename property_map<FlowGraph, edge_reverse_t>::type
      rev_edge = get(edge_reverse, flow_g);

    for (boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei) {
      u = source(*ei, g), v = target(*ei, g);
      boost::tie(e1, inserted) = add_edge(u, v, flow_g);
      cap[e1] = 1;
      boost::tie(e2, inserted) = add_edge(v, u, flow_g);
      cap[e2] = 1; // not sure about this
      rev_edge[e1] = e2;
      rev_edge[e2] = e1;
    }

    //-------------------------------------------------------------------------
    // The Algorithm

    boost::tie(p, delta) = detail::min_degree_vertex(g);
    S_star.push_back(p);
    alpha_star = delta;
    S.insert(p);
    neighbor_S.insert(p);
    detail::neighbors(g, S.begin(), S.end(), 
                      std::inserter(neighbor_S, neighbor_S.begin()));

    boost::tie(vi, vi_end) = vertices(g);
    std::set_difference(vi, vi_end,
                        neighbor_S.begin(), neighbor_S.end(),
                        std::back_inserter(non_neighbor_S));

    while (!non_neighbor_S.empty()) { // at most n - 1 times
      k = non_neighbor_S.front();

      alpha_S_k = edmonds_karp_max_flow
        (flow_g, p, k, cap, res_cap, rev_edge, &color[0], &pred[0]);

      if (alpha_S_k < alpha_star) {
        alpha_star = alpha_S_k;
        S_star.clear();
        for (boost::tie(vi, vi_end) = vertices(flow_g); vi != vi_end; ++vi)
          if (color[*vi] != Color::white())
            S_star.push_back(*vi);
      }
      S.insert(k);
      neighbor_S.insert(k);
      detail::neighbors(g, k, std::inserter(neighbor_S, neighbor_S.begin()));
      non_neighbor_S.clear();
      boost::tie(vi, vi_end) = vertices(g);
      std::set_difference(vi, vi_end,
                          neighbor_S.begin(), neighbor_S.end(),
                          std::back_inserter(non_neighbor_S));
    }
    //-------------------------------------------------------------------------
    // Compute edges of the cut [S*, ~S*]
    std::vector<bool> in_S_star(num_vertices(g), false);
    typename std::vector<vertex_descriptor>::iterator si;
    for (si = S_star.begin(); si != S_star.end(); ++si)
      in_S_star[*si] = true;

    degree_size_type c = 0;
    for (si = S_star.begin(); si != S_star.end(); ++si) {
      out_edge_iterator ei, ei_end;
      for (boost::tie(ei, ei_end) = out_edges(*si, g); ei != ei_end; ++ei)
        if (!in_S_star[target(*ei, g)]) {
          *disconnecting_set++ = *ei;
          ++c;
        }
    }
    return c;
  }


template<class Tag, class Value, class Next>
std::istream& operator >> ( std::istream& in, property<Tag,Value,Next>& p )
{
        in >> p.m_value >> p.m_base; // houpla !!
        return in;
}

template<class Tag, class Value, class Next, class V, class Stag>
void get
( property<Tag,Value,Next>& p, const V& v, Stag s )
{
        get( p.m_base,v,s );
}


template<class Value, class Next, class V, class Stag>
void get
( property<Stag,Value,Next>& p, const V& v, Stag )
{
        p.m_value = v;
}

template<class Tag, class Value, class Next, 
        class Stag, class Svalue, class Snext>
void getSubset
( property<Tag,Value,Next>& p, const property<Stag,Svalue,Snext>& s )
{
        get( p, s.m_value, Stag() );
        getSubset( p, s.m_base );
}


template<class Tag, class Value, class Next, 
        class Stag, class Svalue>
void getSubset
( property<Tag,Value,Next>& p, const property<Stag,Svalue,no_property>& s)
{
        get( p, s.m_value, Stag() );
}


inline void getSubset
( no_property&, const no_property& )
{
}

template<typename T, typename U>
void getSubset(T& p, const U& s)
{
  p = s;
}


template<typename T>
void getSubset(T&, const no_property&)
{
}

        
        GraphParser( Graph* g ): graph(g)
        {}
      
        
        GraphParser& operator () ( std::istream& in )
        {
                typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
                std::vector<Vertex> nodes;

                GraphParserState state = PARSE_VERTEX;

                unsigned int numLine = 1;
                char c;
                while ( in.get(c) )
                {
                        if( c== '#' ) skip(in);
                        else if( c== 'n' ) state = PARSE_NUM_NODES;
                        else if( c== 'v' ) state = PARSE_VERTEX;
                        else if( c== 'e' ) state = PARSE_EDGE;
                        else if( c== '\n' ) numLine++;
                        else if( !std::isspace(c) ){
                                in.putback(c);
                                if( state == PARSE_VERTEX ){
                                        VertexPropertySubset readProp;
                                        if( in >> readProp )
                                        {
                                                VertexProperty vp;
                                                getSubset( vp, readProp );
                                                nodes.push_back( add_vertex(vp, *graph) );
                                        }
                                        else
                                                std::cerr<<"read vertex, parse error at line"<<numLine<<std::endl;
                                }
                                else if( state == PARSE_EDGE ) {
                                        int source, target;
                                        EdgePropertySubset readProp;
                                        in >> source >> target;
                                        if( in >> readProp ) 
                                        {
                                                EdgeProperty ep;
                                                getSubset( ep, readProp );
                                                add_edge(nodes[source], nodes[target], ep, *graph);
                                        }
                                        else
                                                std::cerr<<"read edge, parse error at line"<<numLine<<std::endl;
                                }
                                else { // state == PARSE_NUM_NODES
                                        int n;
                                        if( in >> n ){
                                                for( int i=0; i<n; ++i )
                                                        nodes.push_back( add_vertex( *graph ));
                                        }
                                        else 
                                                std::cerr<<"read num_nodes, parse error at line "<< numLine << std::endl;
                                }
                        }
                }
        return (*this);
        }

        
        void skip( std::istream& in )
        {
                char c = 0;
                while( c!='\n' && !in.eof() ) 
                       in.get(c);
                in.putback(c);
        }

        PropertyPrinter( const Graph& g ):graph(&g){}

        
        template<class Val>
        PropertyPrinter& operator () ( std::ostream& out, const Val& v )
        {
                out << (*graph)[ v ] <<" ";
                return (*this);
        }

        PropertyPrinter( const Graph& g ):graph(&g){}

        
        template<class Val>
        PropertyPrinter& operator () ( std::ostream& out, const Val& v )
        {
                typename property_map<Graph,Tag>::const_type ps = get(Tag(), *graph);
                out << ps[ v ] <<" ";
                PropertyPrinter<Graph,Next> print(*graph);
                print(out, v);
                return (*this);
        }

        PropertyPrinter( const Graph& ){}


        template<class Val>
        PropertyPrinter& operator () ( std::ostream&, const Val& ){ return *this; }

        
        EdgePrinter( const Graph& g )
                : graph(g)
        {}
      
        
        const EdgePrinter& operator () ( std::ostream& out ) const
        {
                // assign indices to vertices
                std::map<Vertex,int> indices;
                int num = 0;
                BGL_FORALL_VERTICES_T(v, graph, Graph) {
                        indices[v] = num++;
                }

                // write edges
                PropertyPrinter<Graph, EdgeProperty> print_Edge(graph);
                out << "e" << std::endl;
                BGL_FORALL_EDGES_T(e, graph, Graph) {
                        out << indices[source(e,graph)] <<  " " << indices[target(e,graph)] << "  "; 
                        print_Edge(out,e); 
                        out << std::endl;
                }
                out << std::endl;            
                return (*this);
        }

        GraphPrinter( const Graph& g )
          : EdgePrinter<Graph,E>(g)
        {}

        
        const GraphPrinter& operator () ( std::ostream& out ) const
        {
                PropertyPrinter<Graph, V> printNode(this->graph);
                out << "v"<<std::endl;
                BGL_FORALL_VERTICES_T(v, this->graph, Graph) {
                        printNode(out,v); 
                        out << std::endl;
                }
                
                EdgePrinter<Graph,E>::operator ()( out );
                return (*this);
        }

        GraphPrinter( const Graph& g )
          : EdgePrinter<Graph,E>(g)
        {}

        
        const GraphPrinter& operator () ( std::ostream& out ) const
        {
                out << "n "<< num_vertices(this->graph) << std::endl;
                EdgePrinter<Graph,E>::operator ()( out );
                return (*this);
        }

template<class EL, class VL, class D, class VP, class EP, class GP, class VPS, class EPS>
GraphParser<adjacency_list<EL,VL,D,VP,EP,GP>,VP,EP,VPS,EPS> 
read( adjacency_list<EL,VL,D,VP,EP,GP>& g, VPS vps, EPS eps )
{
        return GraphParser<adjacency_list<EL,VL,D,VP,EP,GP>,VP,EP,VPS,EPS>(&g);
}

template<class Graph, class VP, class EP>
std::ostream& operator << ( std::ostream& out, const GraphPrinter<Graph,VP,EP>& gp ) 
{ 
        gp(out); 
        return out; 
}

template<class EL, class VL, class D, class VP, class EP, class GP, class VPS, class EPS>
GraphPrinter<adjacency_list<EL,VL,D,VP,EP,GP>,VPS,EPS> 
write( const adjacency_list<EL,VL,D,VP,EP,GP>& g, VPS, EPS )
{
        return GraphPrinter<adjacency_list<EL,VL,D,VP,EP,GP>,VPS,EPS>(g);
}

  template <class VertexListGraph, class OrderPA, class ColorMap>
  typename property_traits<ColorMap>::value_type
  sequential_vertex_coloring(const VertexListGraph& G, OrderPA order, 
                             ColorMap color)
  {
    typedef graph_traits<VertexListGraph> GraphTraits;
    typedef typename GraphTraits::vertex_descriptor Vertex;
    typedef typename property_traits<ColorMap>::value_type size_type;
    
    size_type max_color = 0;
    const size_type V = num_vertices(G);

    // We need to keep track of which colors are used by
    // adjacent vertices. We do this by marking the colors
    // that are used. The mark array contains the mark
    // for each color. The length of mark is the
    // number of vertices since the maximum possible number of colors
    // is the number of vertices.
    std::vector<size_type> mark(V, 
                                std::numeric_limits<size_type>::max BOOST_PREVENT_MACRO_SUBSTITUTION());
    
    //Initialize colors 
    typename GraphTraits::vertex_iterator v, vend;
    for (boost::tie(v, vend) = vertices(G); v != vend; ++v)
      put(color, *v, V-1);
    
    //Determine the color for every vertex one by one
    for ( size_type i = 0; i < V; i++) {
      Vertex current = get(order,i);
      typename GraphTraits::adjacency_iterator v, vend;
      
      //Mark the colors of vertices adjacent to current.
      //i can be the value for marking since i increases successively
      for (boost::tie(v,vend) = adjacent_vertices(current, G); v != vend; ++v)
        mark[get(color,*v)] = i; 
      
      //Next step is to assign the smallest un-marked color
      //to the current vertex.
      size_type j = 0;

      //Scan through all useable colors, find the smallest possible
      //color that is not used by neighbors.  Note that if mark[j]
      //is equal to i, color j is used by one of the current vertex's
      //neighbors.
      while ( j < max_color && mark[j] == i ) 
        ++j;
      
      if ( j == max_color )  //All colors are used up. Add one more color
        ++max_color;

      //At this point, j is the smallest possible color
      put(color, current, j);  //Save the color of vertex current
    }
    
    return max_color;
  }


  template<class VertexListGraph, class ColorMap>
  typename property_traits<ColorMap>::value_type
  sequential_vertex_coloring(const VertexListGraph& G, ColorMap color)
  {
    typedef typename graph_traits<VertexListGraph>::vertex_descriptor
      vertex_descriptor;
    typedef typename graph_traits<VertexListGraph>::vertex_iterator
      vertex_iterator;

    std::pair<vertex_iterator, vertex_iterator> v = vertices(G);
#ifndef BOOST_NO_TEMPLATED_ITERATOR_CONSTRUCTORS
    std::vector<vertex_descriptor> order(v.first, v.second);
#else
    std::vector<vertex_descriptor> order;
    order.reserve(std::distance(v.first, v.second));
    while (v.first != v.second) order.push_back(*v.first++);
#endif
    return sequential_vertex_coloring
             (G, 
              make_iterator_property_map
              (order.begin(), identity_property_map(), 
               graph_traits<VertexListGraph>::null_vertex()), 
              color);
  }

    template <typename Graph, typename PredMap, typename ColorMap, typename NextEdge>
    void random_spanning_tree_internal(const Graph& g, typename graph_traits<Graph>::vertex_descriptor s, PredMap pred, ColorMap color, NextEdge next_edge) {
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
      typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;

      BOOST_ASSERT (num_vertices(g) >= 1); // g must also be undirected (or symmetric) and connected

      typedef color_traits<typename property_traits<ColorMap>::value_type> color_gen;
      BGL_FORALL_VERTICES_T(v, g, Graph) put(color, v, color_gen::white());

      std::vector<vertex_descriptor> path;

      put(color, s, color_gen::black());
      put(pred, s, graph_traits<Graph>::null_vertex());

      BGL_FORALL_VERTICES_T(v, g, Graph) {
        if (get(color, v) != color_gen::white()) continue;
        loop_erased_random_walk(g, v, next_edge, color, path);
        for (typename std::vector<vertex_descriptor>::const_reverse_iterator i = path.rbegin();
             boost::next(i) !=
               (typename std::vector<vertex_descriptor>::const_reverse_iterator)path.rend();
             ++i) {
          typename std::vector<vertex_descriptor>::const_reverse_iterator j = i;
          ++j;
          BOOST_ASSERT (get(color, *j) == color_gen::gray());
          put(color, *j, color_gen::black());
          put(pred, *j, *i);
        }
      }
    }

  template <typename Graph, typename Gen, typename PredMap, typename ColorMap>
  void random_spanning_tree(const Graph& g, Gen& gen, typename graph_traits<Graph>::vertex_descriptor root,
                            PredMap pred, static_property_map<double>, ColorMap color) {
    unweighted_random_out_edge_gen<Graph, Gen> random_oe(gen);
    detail::random_spanning_tree_internal(g, root, pred, color, random_oe);
  }

  template <typename Graph, typename Gen, typename PredMap, typename WeightMap, typename ColorMap>
  void random_spanning_tree(const Graph& g, Gen& gen, typename graph_traits<Graph>::vertex_descriptor root,
                            PredMap pred, WeightMap weight, ColorMap color) {
    weighted_random_out_edge_gen<Graph, WeightMap, Gen> random_oe(weight, gen);
    detail::random_spanning_tree_internal(g, root, pred, color, random_oe);
  }


  template <typename Graph, typename Gen, typename P, typename T, typename R>
  void random_spanning_tree(const Graph& g, Gen& gen, const bgl_named_params<P, T, R>& params) {
    using namespace boost::graph::keywords;
    typedef bgl_named_params<P, T, R> params_type;
    BOOST_GRAPH_DECLARE_CONVERTED_PARAMETERS(params_type, params)
    random_spanning_tree(g,
                         gen,
                         arg_pack[_root_vertex | *vertices(g).first],
                         arg_pack[_predecessor_map],
                         arg_pack[_weight_map | static_property_map<double>(1.)],
                         boost::detail::make_color_map_from_arg_pack(g, arg_pack));
  }

    inline void
      union_successor_sets(const std::vector < std::size_t > &s1,
                           const std::vector < std::size_t > &s2,
                           std::vector < std::size_t > &s3)
    {
      BOOST_USING_STD_MIN();
      for (std::size_t k = 0; k < s1.size(); ++k)
        s3[k] = min BOOST_PREVENT_MACRO_SUBSTITUTION(s1[k], s2[k]);
    }


      subscript_t(TheContainer & c):container(&c)
      {
      }

      VT & operator() (const ST & i) const
      {
        return (*container)[i];
      }

    template < typename TheContainer >
      subscript_t < TheContainer > subscript(TheContainer & c) {
      return subscript_t < TheContainer > (c);
    }


  template < typename Graph, typename GraphTC,
    typename G_to_TC_VertexMap,
    typename VertexIndexMap >
    void transitive_closure(const Graph & g, GraphTC & tc,
                            G_to_TC_VertexMap g_to_tc_map,
                            VertexIndexMap index_map)
  {
    if (num_vertices(g) == 0)
      return;
    typedef typename graph_traits < Graph >::vertex_descriptor vertex;
    typedef typename graph_traits < Graph >::edge_descriptor edge;
    typedef typename graph_traits < Graph >::vertex_iterator vertex_iterator;
    typedef typename property_traits < VertexIndexMap >::value_type size_type;
    typedef typename graph_traits <
      Graph >::adjacency_iterator adjacency_iterator;

    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept < Graph > ));
    BOOST_CONCEPT_ASSERT(( AdjacencyGraphConcept < Graph > ));
    BOOST_CONCEPT_ASSERT(( VertexMutableGraphConcept < GraphTC > ));
    BOOST_CONCEPT_ASSERT(( EdgeMutableGraphConcept < GraphTC > ));
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept < VertexIndexMap,
      vertex > ));

    typedef size_type cg_vertex;
    std::vector < cg_vertex > component_number_vec(num_vertices(g));
    iterator_property_map < cg_vertex *, VertexIndexMap, cg_vertex, cg_vertex& >
      component_number(&component_number_vec[0], index_map);

    int num_scc = strong_components(g, component_number,
                                    vertex_index_map(index_map));

    std::vector < std::vector < vertex > >components;
    build_component_lists(g, num_scc, component_number, components);

    typedef std::vector<std::vector<cg_vertex> > CG_t;
    CG_t CG(num_scc);
    for (cg_vertex s = 0; s < components.size(); ++s) {
      std::vector < cg_vertex > adj;
      for (size_type i = 0; i < components[s].size(); ++i) {
        vertex u = components[s][i];
        adjacency_iterator v, v_end;
        for (boost::tie(v, v_end) = adjacent_vertices(u, g); v != v_end; ++v) {
          cg_vertex t = component_number[*v];
          if (s != t)           // Avoid loops in the condensation graph
            adj.push_back(t);
        }
      }
      std::sort(adj.begin(), adj.end());
      typename std::vector<cg_vertex>::iterator di =
        std::unique(adj.begin(), adj.end());
      if (di != adj.end())
        adj.erase(di, adj.end());
      CG[s] = adj;
    }

    std::vector<cg_vertex> topo_order;
    std::vector<cg_vertex> topo_number(num_vertices(CG));
    topological_sort(CG, std::back_inserter(topo_order),
                     vertex_index_map(identity_property_map()));
    std::reverse(topo_order.begin(), topo_order.end());
    size_type n = 0;
    for (typename std::vector<cg_vertex>::iterator iter = topo_order.begin();
         iter != topo_order.end(); ++iter)
      topo_number[*iter] = n++;

    for (size_type i = 0; i < num_vertices(CG); ++i)
      std::sort(CG[i].begin(), CG[i].end(),
                boost::bind(std::less<cg_vertex>(),
                            boost::bind(detail::subscript(topo_number), _1),
                            boost::bind(detail::subscript(topo_number), _2)));

    std::vector<std::vector<cg_vertex> > chains;
    {
      std::vector<cg_vertex> in_a_chain(num_vertices(CG));
      for (typename std::vector<cg_vertex>::iterator i = topo_order.begin();
           i != topo_order.end(); ++i) {
        cg_vertex v = *i;
        if (!in_a_chain[v]) {
          chains.resize(chains.size() + 1);
          std::vector<cg_vertex>& chain = chains.back();
          for (;;) {
            chain.push_back(v);
            in_a_chain[v] = true;
            typename graph_traits<CG_t>::adjacency_iterator adj_first, adj_last;
            boost::tie(adj_first, adj_last) = adjacent_vertices(v, CG);
            typename graph_traits<CG_t>::adjacency_iterator next
              = std::find_if(adj_first, adj_last,
                             std::not1(detail::subscript(in_a_chain)));
            if (next != adj_last)
              v = *next;
            else
              break;            // end of chain, dead-end

          }
        }
      }
    }
    std::vector<size_type> chain_number(num_vertices(CG));
    std::vector<size_type> pos_in_chain(num_vertices(CG));
    for (size_type i = 0; i < chains.size(); ++i)
      for (size_type j = 0; j < chains[i].size(); ++j) {
        cg_vertex v = chains[i][j];
        chain_number[v] = i;
        pos_in_chain[v] = j;
      }

    cg_vertex inf = (std::numeric_limits< cg_vertex >::max)();
    std::vector<std::vector<cg_vertex> > successors(num_vertices(CG),
                                                    std::vector<cg_vertex>
                                                    (chains.size(), inf));
    for (typename std::vector<cg_vertex>::reverse_iterator
           i = topo_order.rbegin(); i != topo_order.rend(); ++i) {
      cg_vertex u = *i;
      typename graph_traits<CG_t>::adjacency_iterator adj, adj_last;
      for (boost::tie(adj, adj_last) = adjacent_vertices(u, CG);
           adj != adj_last; ++adj) {
        cg_vertex v = *adj;
        if (topo_number[v] < successors[u][chain_number[v]]) {
          // Succ(u) = Succ(u) U Succ(v)
          detail::union_successor_sets(successors[u], successors[v],
                                       successors[u]);
          // Succ(u) = Succ(u) U {v}
          successors[u][chain_number[v]] = topo_number[v];
        }
      }
    }

    for (size_type i = 0; i < CG.size(); ++i)
      CG[i].clear();
    for (size_type i = 0; i < CG.size(); ++i)
      for (size_type j = 0; j < chains.size(); ++j) {
        size_type topo_num = successors[i][j];
        if (topo_num < inf) {
          cg_vertex v = topo_order[topo_num];
          for (size_type k = pos_in_chain[v]; k < chains[j].size(); ++k)
            CG[i].push_back(chains[j][k]);
        }
      }


    // Add vertices to the transitive closure graph
    typedef typename graph_traits < GraphTC >::vertex_descriptor tc_vertex;
    {
      vertex_iterator i, i_end;
      for (boost::tie(i, i_end) = vertices(g); i != i_end; ++i)
        g_to_tc_map[*i] = add_vertex(tc);
    }
    // Add edges between all the vertices in two adjacent SCCs
    typename graph_traits<CG_t>::vertex_iterator si, si_end;
    for (boost::tie(si, si_end) = vertices(CG); si != si_end; ++si) {
      cg_vertex s = *si;
      typename graph_traits<CG_t>::adjacency_iterator i, i_end;
      for (boost::tie(i, i_end) = adjacent_vertices(s, CG); i != i_end; ++i) {
        cg_vertex t = *i;
        for (size_type k = 0; k < components[s].size(); ++k)
          for (size_type l = 0; l < components[t].size(); ++l)
            add_edge(g_to_tc_map[components[s][k]],
                     g_to_tc_map[components[t][l]], tc);
      }
    }
    // Add edges connecting all vertices in a SCC
    for (size_type i = 0; i < components.size(); ++i)
      if (components[i].size() > 1)
        for (size_type k = 0; k < components[i].size(); ++k)
          for (size_type l = 0; l < components[i].size(); ++l) {
            vertex u = components[i][k], v = components[i][l];
            add_edge(g_to_tc_map[u], g_to_tc_map[v], tc);
          }

    // Find loopbacks in the original graph.
    // Need to add it to transitive closure.
    {
      vertex_iterator i, i_end;
      for (boost::tie(i, i_end) = vertices(g); i != i_end; ++i)
        {
          adjacency_iterator ab, ae;
          for (boost::tie(ab, ae) = adjacent_vertices(*i, g); ab != ae; ++ab)
            {
              if (*ab == *i)
                if (components[component_number[*i]].size() == 1)
                  add_edge(g_to_tc_map[*i], g_to_tc_map[*i], tc);
            }
        }
    }
  }


  template <typename Graph, typename GraphTC>
  void transitive_closure(const Graph & g, GraphTC & tc)
  {
    if (num_vertices(g) == 0)
      return;
    typedef typename property_map<Graph, vertex_index_t>::const_type
      VertexIndexMap;
    VertexIndexMap index_map = get(vertex_index, g);

    typedef typename graph_traits<GraphTC>::vertex_descriptor tc_vertex;
    std::vector<tc_vertex> to_tc_vec(num_vertices(g));
    iterator_property_map < tc_vertex *, VertexIndexMap, tc_vertex, tc_vertex&>
      g_to_tc_map(&to_tc_vec[0], index_map);

    transitive_closure(g, tc, g_to_tc_map, index_map);
  }

    template < typename Graph, typename GraphTC, typename G_to_TC_VertexMap,
      typename VertexIndexMap>
    void transitive_closure_dispatch
      (const Graph & g, GraphTC & tc,
       G_to_TC_VertexMap g_to_tc_map, VertexIndexMap index_map)
    {
      typedef typename graph_traits < GraphTC >::vertex_descriptor tc_vertex;
      typename std::vector < tc_vertex >::size_type
        n = is_default_param(g_to_tc_map) ? num_vertices(g) : 1;
      std::vector < tc_vertex > to_tc_vec(n);

      transitive_closure
        (g, tc,
         choose_param(g_to_tc_map, make_iterator_property_map
                      (to_tc_vec.begin(), index_map, to_tc_vec[0])),
         index_map);
    }


  template < typename Graph, typename GraphTC,
    typename P, typename T, typename R >
    void transitive_closure(const Graph & g, GraphTC & tc,
                            const bgl_named_params < P, T, R > &params)
  {
    if (num_vertices(g) == 0)
      return;
    detail::transitive_closure_dispatch
      (g, tc, get_param(params, orig_to_copy_t()),
       choose_const_pmap(get_param(params, vertex_index), g, vertex_index) );
  }



  template < typename G > void warshall_transitive_closure(G & g)
  {
    typedef typename graph_traits < G >::vertex_descriptor vertex;
    typedef typename graph_traits < G >::vertex_iterator vertex_iterator;

    BOOST_CONCEPT_ASSERT(( AdjacencyMatrixConcept < G > ));
    BOOST_CONCEPT_ASSERT(( EdgeMutableGraphConcept < G > ));

    // Matrix form:
    // for k
    //  for i
    //    if A[i,k]
    //      for j
    //        A[i,j] = A[i,j] | A[k,j]
    vertex_iterator ki, ke, ii, ie, ji, je;
    for (boost::tie(ki, ke) = vertices(g); ki != ke; ++ki)
      for (boost::tie(ii, ie) = vertices(g); ii != ie; ++ii)
        if (edge(*ii, *ki, g).second)
          for (boost::tie(ji, je) = vertices(g); ji != je; ++ji)
            if (!edge(*ii, *ji, g).second && edge(*ki, *ji, g).second) {
              add_edge(*ii, *ji, g);
            }
  }



  template < typename G > void warren_transitive_closure(G & g)
  {
    using namespace boost;
    typedef typename graph_traits < G >::vertex_descriptor vertex;
    typedef typename graph_traits < G >::vertex_iterator vertex_iterator;

    BOOST_CONCEPT_ASSERT(( AdjacencyMatrixConcept < G > ));
    BOOST_CONCEPT_ASSERT(( EdgeMutableGraphConcept < G > ));

    // Make sure second loop will work
    if (num_vertices(g) == 0)
      return;

    // for i = 2 to n
    //    for k = 1 to i - 1
    //      if A[i,k]
    //        for j = 1 to n
    //          A[i,j] = A[i,j] | A[k,j]

    vertex_iterator ic, ie, jc, je, kc, ke;
    for (boost::tie(ic, ie) = vertices(g), ++ic; ic != ie; ++ic)
      for (boost::tie(kc, ke) = vertices(g); *kc != *ic; ++kc)
        if (edge(*ic, *kc, g).second)
          for (boost::tie(jc, je) = vertices(g); jc != je; ++jc)
            if (!edge(*ic, *jc, g).second && edge(*kc, *jc, g).second) {
              add_edge(*ic, *jc, g);
            }
    //  for i = 1 to n - 1
    //    for k = i + 1 to n
    //      if A[i,k]
    //        for j = 1 to n
    //          A[i,j] = A[i,j] | A[k,j]

    for (boost::tie(ic, ie) = vertices(g), --ie; ic != ie; ++ic)
      for (kc = ic, ke = ie, ++kc; kc != ke; ++kc)
        if (edge(*ic, *kc, g).second)
          for (boost::tie(jc, je) = vertices(g); jc != je; ++jc)
            if (!edge(*ic, *jc, g).second && edge(*kc, *jc, g).second) {
              add_edge(*ic, *jc, g);
            }
  }

    const T& dereference() const {return saved_value;}

    bool equal(default_construct_iterator /*i*/) const {return true;}

    void increment() {}

    void decrement() {}

    void advance(typename base_type::difference_type) {}

    compare_first(Less less = Less()): less(less) {}

    template <typename Tuple>
    bool operator()(const Tuple& a, const Tuple& b) const {
      return less(a.template get<0>(), b.template get<0>());
    }

    template <typename Tuple>
    result_type operator()(const Tuple& t) const {
      return t.template get<N>();
    }


  static vertex_descriptor null_vertex() { return vertex_descriptor(-1); }

  compressed_sparse_row_graph(): m_property() {}

  compressed_sparse_row_graph(vertices_size_type numverts)
    : inherited_vertex_properties(numverts), m_forward(numverts) {}

  template <typename MultiPassInputIterator>
  compressed_sparse_row_graph(edges_are_unsorted_multi_pass_t,
                              MultiPassInputIterator edge_begin,
                              MultiPassInputIterator edge_end,
                              vertices_size_type numverts,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numverts), m_property(prop)
  {
    m_forward.assign_unsorted_multi_pass_edges(edge_begin, edge_end, numverts, typed_identity_property_map<vertices_size_type>(), keep_all());
  }

  template <typename MultiPassInputIterator, typename EdgePropertyIterator>
  compressed_sparse_row_graph(edges_are_unsorted_multi_pass_t,
                              MultiPassInputIterator edge_begin,
                              MultiPassInputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numverts,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numverts), m_forward(), m_property(prop)
  {
    m_forward.assign_unsorted_multi_pass_edges(edge_begin, edge_end, ep_iter, numverts, typed_identity_property_map<vertices_size_type>(), keep_all());
  }

  template <typename MultiPassInputIterator, typename GlobalToLocal, typename SourcePred>
  compressed_sparse_row_graph(edges_are_unsorted_multi_pass_global_t,
                              MultiPassInputIterator edge_begin,
                              MultiPassInputIterator edge_end,
                              vertices_size_type numlocalverts,
                              const GlobalToLocal& global_to_local,
                              const SourcePred& source_pred,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numlocalverts), m_forward(), m_property(prop)
  {
    m_forward.assign_unsorted_multi_pass_edges(edge_begin, edge_end, numlocalverts, global_to_local, source_pred);
  }

  template <typename MultiPassInputIterator, typename EdgePropertyIterator, typename GlobalToLocal, typename SourcePred>
  compressed_sparse_row_graph(edges_are_unsorted_multi_pass_global_t,
                              MultiPassInputIterator edge_begin,
                              MultiPassInputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numlocalverts,
                              const GlobalToLocal& global_to_local,
                              const SourcePred& source_pred,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numlocalverts), m_forward(), m_property(prop)
  {
    m_forward.assign_unsorted_multi_pass_edges(edge_begin, edge_end, ep_iter, numlocalverts, global_to_local, source_pred);
  }

  template<typename InputIterator>
  compressed_sparse_row_graph(edges_are_sorted_t,
                              InputIterator edge_begin, InputIterator edge_end,
                              vertices_size_type numverts,
                              edges_size_type numedges = 0,
                              const GraphProperty& prop = GraphProperty())
    : m_property(prop)
  {
    m_forward.assign_from_sorted_edges(edge_begin, edge_end, typed_identity_property_map<vertices_size_type>(), keep_all(), numverts, numedges);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename InputIterator, typename EdgePropertyIterator>
  compressed_sparse_row_graph(edges_are_sorted_t,
                              InputIterator edge_begin, InputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numverts,
                              edges_size_type numedges = 0,
                              const GraphProperty& prop = GraphProperty())
    : m_property(prop)
  {
    m_forward.assign_from_sorted_edges(edge_begin, edge_end, ep_iter, typed_identity_property_map<vertices_size_type>(), keep_all(), numverts, numedges);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename InputIterator, typename GlobalToLocal, typename SourcePred>
  compressed_sparse_row_graph(edges_are_sorted_global_t,
                              InputIterator edge_begin, InputIterator edge_end,
                              const GlobalToLocal& global_to_local,
                              const SourcePred& source_pred,
                              vertices_size_type numverts,
                              const GraphProperty& prop = GraphProperty())
    : m_property(prop)
  {
    m_forward.assign_from_sorted_edges(edge_begin, edge_end, global_to_local, source_pred, numverts, 0);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename InputIterator, typename EdgePropertyIterator, typename GlobalToLocal, typename SourcePred>
  compressed_sparse_row_graph(edges_are_sorted_global_t,
                              InputIterator edge_begin, InputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              const GlobalToLocal& global_to_local,
                              const SourcePred& source_pred,
                              vertices_size_type numverts,
                              const GraphProperty& prop = GraphProperty())
    : m_property(prop)
  {
    m_forward.assign_from_sorted_edges(edge_begin, edge_end, ep_iter, global_to_local, source_pred, numverts, 0);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename InputIterator>
  compressed_sparse_row_graph(edges_are_unsorted_t,
                              InputIterator edge_begin, InputIterator edge_end,
                              vertices_size_type numverts,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numverts), m_property(prop)
  {
    std::vector<vertex_descriptor> sources, targets;
    boost::graph::detail::split_into_separate_coords
      (edge_begin, edge_end, sources, targets);
    m_forward.assign_sources_and_targets_global(sources, targets, numverts, boost::typed_identity_property_map<vertices_size_type>());
  }

  template<typename InputIterator, typename EdgePropertyIterator>
  compressed_sparse_row_graph(edges_are_unsorted_t,
                              InputIterator edge_begin, InputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numverts,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numverts), m_property(prop)
  {
    std::vector<vertex_descriptor> sources, targets;
    boost::graph::detail::split_into_separate_coords
      (edge_begin, edge_end, sources, targets);
    size_t numedges = sources.size();
    std::vector<typename forward_type::inherited_edge_properties::edge_bundled> edge_props(numedges);
    for (size_t i = 0; i < numedges; ++i) {
      edge_props[i] = *ep_iter++;
    }
    m_forward.assign_sources_and_targets_global(sources, targets, edge_props, numverts, boost::typed_identity_property_map<vertices_size_type>());
  }

  template<typename InputIterator, typename GlobalToLocal, typename SourcePred>
  compressed_sparse_row_graph(edges_are_unsorted_global_t,
                              InputIterator edge_begin, InputIterator edge_end,
                              vertices_size_type numlocalverts,
                              GlobalToLocal global_to_local,
                              const SourcePred& source_pred,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numlocalverts), m_property(prop)
  {
    std::vector<vertex_descriptor> sources, targets;
    boost::graph::detail::split_into_separate_coords_filtered
      (edge_begin, edge_end, sources, targets, source_pred);
    m_forward.assign_sources_and_targets_global(sources, targets, numlocalverts, global_to_local);
  }

  template<typename InputIterator, typename EdgePropertyIterator,
           typename GlobalToLocal, typename SourcePred>
  compressed_sparse_row_graph(edges_are_unsorted_global_t,
                              InputIterator edge_begin, InputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numlocalverts,
                              GlobalToLocal global_to_local,
                              const SourcePred& source_pred,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numlocalverts), m_property(prop)
  {
    std::vector<vertex_descriptor> sources, targets;
    std::vector<edge_bundled> edge_props;
    boost::graph::detail::split_into_separate_coords_filtered
      (edge_begin, edge_end, ep_iter, sources, targets, edge_props, source_pred);
    m_forward.assign_sources_and_targets_global(sources, targets, edge_props, numlocalverts, global_to_local);
  }

  template<typename Graph, typename VertexIndexMap>
  compressed_sparse_row_graph(const Graph& g, const VertexIndexMap& vi,
                              vertices_size_type numverts,
                              edges_size_type numedges)
    : m_property()
  {
    assign(g, vi, numverts, numedges);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename Graph, typename VertexIndexMap>
  compressed_sparse_row_graph(const Graph& g, const VertexIndexMap& vi)
    : m_property()
  {
    typename graph_traits<Graph>::edges_size_type numedges = num_edges(g);
    if (is_same<typename graph_traits<Graph>::directed_category, undirectedS>::value) {
      numedges *= 2; // Double each edge (actual doubling done by out_edges function)
    }
    vertices_size_type numverts = num_vertices(g);
    assign(g, vi, numverts, numedges);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename Graph>
  explicit compressed_sparse_row_graph(const Graph& g)
    : m_property()
  {
    typename graph_traits<Graph>::edges_size_type numedges = num_edges(g);
    if (is_same<typename graph_traits<Graph>::directed_category, undirectedS>::value) {
      numedges *= 2; // Double each edge (actual doubling done by out_edges function)
    }
    assign(g, get(vertex_index, g), num_vertices(g), numedges);
  }

  template<typename Graph, typename VertexIndexMap>
  void
  assign(const Graph& g, const VertexIndexMap& vi,
         vertices_size_type numverts, edges_size_type numedges)
  {
    m_forward.assign(g, vi, numverts, numedges);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename Graph, typename VertexIndexMap>
  void assign(const Graph& g, const VertexIndexMap& vi)
  {
    typename graph_traits<Graph>::edges_size_type numedges = num_edges(g);
    if (is_same<typename graph_traits<Graph>::directed_category, undirectedS>::value) {
      numedges *= 2; // Double each edge (actual doubling done by out_edges function)
    }
    vertices_size_type numverts = num_vertices(g);
    m_forward.assign(g, vi, numverts, numedges);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename Graph>
  void assign(const Graph& g)
  {
    typename graph_traits<Graph>::edges_size_type numedges = num_edges(g);
    if (is_same<typename graph_traits<Graph>::directed_category, undirectedS>::value) {
      numedges *= 2; // Double each edge (actual doubling done by out_edges function)
    }
    vertices_size_type numverts = num_vertices(g);
    m_forward.assign(g, get(vertex_index, g), numverts, numedges);
    inherited_vertex_properties::resize(numverts);
  }

  template <typename BidirectionalIteratorOrig, typename EPIterOrig,
            typename GlobalToLocal>
  void
  add_edges_sorted_internal(
      BidirectionalIteratorOrig first_sorted,
      BidirectionalIteratorOrig last_sorted,
      EPIterOrig ep_iter_sorted,
      const GlobalToLocal& global_to_local) {
    m_forward.add_edges_sorted_internal(first_sorted, last_sorted, ep_iter_sorted, global_to_local);
  }


  template <typename BidirectionalIteratorOrig, typename EPIterOrig>
  void
  add_edges_sorted_internal(
      BidirectionalIteratorOrig first_sorted,
      BidirectionalIteratorOrig last_sorted,
      EPIterOrig ep_iter_sorted)  {
    m_forward.add_edges_sorted_internal(first_sorted, last_sorted, ep_iter_sorted, typed_identity_property_map<vertices_size_type>());
  }

  template <typename BidirectionalIteratorOrig>
  void
  add_edges_sorted_internal(
      BidirectionalIteratorOrig first_sorted,
      BidirectionalIteratorOrig last_sorted) {
    m_forward.add_edges_sorted_internal(first_sorted, last_sorted, detail::default_construct_iterator<edge_bundled>());
  }


  template <typename BidirectionalIteratorOrig, typename GlobalToLocal>
  void
  add_edges_sorted_internal_global(
      BidirectionalIteratorOrig first_sorted,
      BidirectionalIteratorOrig last_sorted,
      const GlobalToLocal& global_to_local) {
    m_forward.add_edges_sorted_internal(first_sorted, last_sorted, detail::default_construct_iterator<edge_bundled>(), global_to_local);
  }


  template <typename BidirectionalIteratorOrig, typename EPIterOrig,
            typename GlobalToLocal>
  void
  add_edges_sorted_internal_global(
      BidirectionalIteratorOrig first_sorted,
      BidirectionalIteratorOrig last_sorted,
      EPIterOrig ep_iter_sorted,
      const GlobalToLocal& global_to_local) {
    m_forward.add_edges_sorted_internal(first_sorted, last_sorted, ep_iter_sorted, global_to_local);
  }

  template <typename InputIterator, typename GlobalToLocal>
  inline void
  add_edges_internal(InputIterator first, InputIterator last,
                     const GlobalToLocal& global_to_local) {
    typedef compressed_sparse_row_graph Graph;
    typedef typename boost::graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef std::vector<std::pair<vertex_t, vertex_t> > edge_vector_t;
    edge_vector_t new_edges(first, last);
    if (new_edges.empty()) return;
    std::sort(new_edges.begin(), new_edges.end());
    this->add_edges_sorted_internal_global(new_edges.begin(), new_edges.end(), global_to_local);
  }


  template <typename InputIterator>
  inline void
  add_edges_internal(InputIterator first, InputIterator last) {
    this->add_edges_internal(first, last, typed_identity_property_map<vertices_size_type>());
  }

  template <typename InputIterator, typename EPIterator, typename GlobalToLocal>
  inline void
  add_edges_internal(InputIterator first, InputIterator last,
                     EPIterator ep_iter, EPIterator ep_iter_end,
                     const GlobalToLocal& global_to_local) {
    typedef compressed_sparse_row_graph Graph;
    typedef typename boost::graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef std::pair<vertex_t, vertex_t> vertex_pair;
    typedef std::vector<
              boost::tuple<vertex_pair,
                           edge_bundled> >
      edge_vector_t;
    edge_vector_t new_edges
      (boost::make_zip_iterator(boost::make_tuple(first, ep_iter)),
       boost::make_zip_iterator(boost::make_tuple(last, ep_iter_end)));
    if (new_edges.empty()) return;
    std::sort(new_edges.begin(), new_edges.end(),
              boost::detail::compare_first<
                std::less<vertex_pair> >());
    m_forward.add_edges_sorted_internal
      (boost::make_transform_iterator(
         new_edges.begin(),
         boost::detail::my_tuple_get_class<0, vertex_pair>()),
       boost::make_transform_iterator(
         new_edges.end(),
         boost::detail::my_tuple_get_class<0, vertex_pair>()),
       boost::make_transform_iterator(
         new_edges.begin(),
         boost::detail::my_tuple_get_class
           <1, edge_bundled>()),
       global_to_local);
  }

  template <typename InputIterator, typename EPIterator>
  inline void
  add_edges_internal(InputIterator first, InputIterator last,
                     EPIterator ep_iter, EPIterator ep_iter_end) {
    this->add_edges_internal(first, last, ep_iter, ep_iter_end, typed_identity_property_map<vertices_size_type>());
  }

  edge_push_back_type& operator[](const edge_descriptor& v)
  { return m_forward.m_edge_properties[get(edge_index, *this, v)]; }


  const edge_push_back_type& operator[](const edge_descriptor& v) const
  { return m_forward.m_edge_properties[get(edge_index, *this, v)]; }

  graph_bundled& operator[](graph_bundle_t)
  { return get_property(*this); }


  const graph_bundled& operator[](graph_bundle_t) const
  { return get_property(*this); }

  inherited_vertex_properties&       vertex_properties()       {return *this;}

  const inherited_vertex_properties& vertex_properties() const {return *this;}

  typename forward_type::inherited_edge_properties&       edge_properties()       { return m_forward; }

  const typename forward_type::inherited_edge_properties& edge_properties() const { return m_forward; }


  static vertex_descriptor null_vertex() { return vertex_descriptor(-1); }

  compressed_sparse_row_graph(): m_property() {}

  compressed_sparse_row_graph(vertices_size_type numverts)
    : inherited_vertex_properties(numverts),
      m_forward(numverts), m_backward(numverts) {}


  void set_up_backward_property_links() {
    std::pair<edge_iterator, edge_iterator> e = edges(*this);
    m_backward.assign_unsorted_multi_pass_edges
      (detail::transpose_edges(
         detail::make_edge_to_index_pair_iter
           (*this, get(vertex_index, *this), e.first)),
       detail::transpose_edges(
         detail::make_edge_to_index_pair_iter
           (*this, get(vertex_index, *this), e.second)),
       boost::counting_iterator<EdgeIndex>(0),
       m_forward.m_rowstart.size() - 1,
       typed_identity_property_map<Vertex>(),
       keep_all());
  }

  template <typename MultiPassInputIterator>
  compressed_sparse_row_graph(edges_are_unsorted_multi_pass_t,
                              MultiPassInputIterator edge_begin,
                              MultiPassInputIterator edge_end,
                              vertices_size_type numverts,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numverts), m_property(prop)
  {
    m_forward.assign_unsorted_multi_pass_edges(edge_begin, edge_end, numverts, typed_identity_property_map<Vertex>(), keep_all());
    set_up_backward_property_links();
  }

  template <typename MultiPassInputIterator, typename EdgePropertyIterator>
  compressed_sparse_row_graph(edges_are_unsorted_multi_pass_t,
                              MultiPassInputIterator edge_begin,
                              MultiPassInputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numverts,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numverts), m_forward(), m_property(prop)
  {
    m_forward.assign_unsorted_multi_pass_edges(edge_begin, edge_end, ep_iter, numverts, typed_identity_property_map<Vertex>(), keep_all());
    set_up_backward_property_links();
  }

  template <typename MultiPassInputIterator, typename GlobalToLocal, typename SourcePred>
  compressed_sparse_row_graph(edges_are_unsorted_multi_pass_global_t,
                              MultiPassInputIterator edge_begin,
                              MultiPassInputIterator edge_end,
                              vertices_size_type numlocalverts,
                              const GlobalToLocal& global_to_local,
                              const SourcePred& source_pred,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numlocalverts), m_forward(), m_property(prop)
  {
    m_forward.assign_unsorted_multi_pass_edges(edge_begin, edge_end, numlocalverts, global_to_local, source_pred);
    set_up_backward_property_links();
  }

  template <typename MultiPassInputIterator, typename EdgePropertyIterator, typename GlobalToLocal, typename SourcePred>
  compressed_sparse_row_graph(edges_are_unsorted_multi_pass_global_t,
                              MultiPassInputIterator edge_begin,
                              MultiPassInputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numlocalverts,
                              const GlobalToLocal& global_to_local,
                              const SourcePred& source_pred,
                              const GraphProperty& prop = GraphProperty())
    : inherited_vertex_properties(numlocalverts), m_forward(), m_property(prop)
  {
    m_forward.assign_unsorted_multi_pass_edges(edge_begin, edge_end, ep_iter, numlocalverts, global_to_local, source_pred);
    set_up_backward_property_links();
  }

  template<typename Graph, typename VertexIndexMap>
  compressed_sparse_row_graph(const Graph& g, const VertexIndexMap& vi,
                              vertices_size_type numverts,
                              edges_size_type numedges)
    : m_property()
  {
    assign(g, vi, numverts, numedges);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename Graph, typename VertexIndexMap>
  compressed_sparse_row_graph(const Graph& g, const VertexIndexMap& vi)
    : m_property()
  {
    typename graph_traits<Graph>::edges_size_type numedges = num_edges(g);
    if (is_same<typename graph_traits<Graph>::directed_category, undirectedS>::value) {
      numedges *= 2; // Double each edge (actual doubling done by out_edges function)
    }
    vertices_size_type numverts = num_vertices(g);
    assign(g, vi, numverts, numedges);
    inherited_vertex_properties::resize(numverts);
  }

  template<typename Graph>
  explicit compressed_sparse_row_graph(const Graph& g)
    : m_property()
  {
    typename graph_traits<Graph>::edges_size_type numedges = num_edges(g);
    if (is_same<typename graph_traits<Graph>::directed_category, undirectedS>::value) {
      numedges *= 2; // Double each edge (actual doubling done by out_edges function)
    }
    assign(g, get(vertex_index, g), num_vertices(g), numedges);
  }

  template<typename Graph, typename VertexIndexMap>
  void
  assign(const Graph& g, const VertexIndexMap& vi,
         vertices_size_type numverts, edges_size_type numedges)
  {
    m_forward.assign(g, vi, numverts, numedges);
    inherited_vertex_properties::resize(numverts);
    set_up_backward_property_links();
  }

  template<typename Graph, typename VertexIndexMap>
  void assign(const Graph& g, const VertexIndexMap& vi)
  {
    typename graph_traits<Graph>::edges_size_type numedges = num_edges(g);
    if (is_same<typename graph_traits<Graph>::directed_category, undirectedS>::value) {
      numedges *= 2; // Double each edge (actual doubling done by out_edges function)
    }
    vertices_size_type numverts = num_vertices(g);
    m_forward.assign(g, vi, numverts, numedges);
    inherited_vertex_properties::resize(numverts);
    set_up_backward_property_links();
  }

  template<typename Graph>
  void assign(const Graph& g)
  {
    typename graph_traits<Graph>::edges_size_type numedges = num_edges(g);
    if (is_same<typename graph_traits<Graph>::directed_category, undirectedS>::value) {
      numedges *= 2; // Double each edge (actual doubling done by out_edges function)
    }
    vertices_size_type numverts = num_vertices(g);
    m_forward.assign(g, get(vertex_index, g), numverts, numedges);
    inherited_vertex_properties::resize(numverts);
    set_up_backward_property_links();
  }

  edge_push_back_type& operator[](const edge_descriptor& v)
  { return m_forward.m_edge_properties[get(edge_index, *this, v)]; }


  const edge_push_back_type& operator[](const edge_descriptor& v) const
  { return m_forward.m_edge_properties[get(edge_index, *this, v)]; }

  inherited_vertex_properties&       vertex_properties()       {return *this;}

  const inherited_vertex_properties& vertex_properties() const {return *this;}

  typename forward_type::inherited_edge_properties&       edge_properties()       { return m_forward; }

  const typename forward_type::inherited_edge_properties& edge_properties() const { return m_forward; }

template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline Vertex
add_vertex(BOOST_CSR_GRAPH_TYPE& g) {
  add_vertex(g, typename BOOST_CSR_GRAPH_TYPE::vertex_bundled());
}


template<BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS>
inline Vertex
add_vertex(BOOST_DIR_CSR_GRAPH_TYPE& g,
           typename BOOST_DIR_CSR_GRAPH_TYPE::vertex_bundled const& p) {
  Vertex old_num_verts_plus_one = g.m_forward.m_rowstart.size();
  g.m_forward.m_rowstart.push_back(g.m_forward.m_rowstart.back());
  g.vertex_properties().push_back(p);
  return old_num_verts_plus_one - 1;
}


template<BOOST_BIDIR_CSR_GRAPH_TEMPLATE_PARMS>
inline Vertex
add_vertex(BOOST_BIDIR_CSR_GRAPH_TYPE& g,
           typename BOOST_BIDIR_CSR_GRAPH_TYPE::vertex_bundled const& p) {
  Vertex old_num_verts_plus_one = g.m_forward.m_rowstart.size();
  g.m_forward.m_rowstart.push_back(g.m_forward.m_rowstart.back());
  g.m_backward.m_rowstart.push_back(g.m_backward.m_rowstart.back());
  g.vertex_properties().push_back(p);
  return old_num_verts_plus_one - 1;
}


template<BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS>
inline Vertex
add_vertices(typename BOOST_DIR_CSR_GRAPH_TYPE::vertices_size_type count, BOOST_DIR_CSR_GRAPH_TYPE& g) {
  Vertex old_num_verts_plus_one = g.m_forward.m_rowstart.size();
  EdgeIndex numedges = g.m_forward.m_rowstart.back();
  g.m_forward.m_rowstart.resize(old_num_verts_plus_one + count, numedges);
  g.vertex_properties().resize(num_vertices(g));
  return old_num_verts_plus_one - 1;
}

  template <BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS, typename BidirectionalIteratorOrig,
            typename EPIterOrig>
  void
  add_edges_sorted(
      BidirectionalIteratorOrig first_sorted,
      BidirectionalIteratorOrig last_sorted,
      EPIterOrig ep_iter_sorted,
      BOOST_DIR_CSR_GRAPH_TYPE& g) {
    g.add_edges_sorted_internal(first_sorted, last_sorted, ep_iter_sorted);
  }

  template <BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS, typename BidirectionalIteratorOrig>
  void
  add_edges_sorted(
      BidirectionalIteratorOrig first_sorted,
      BidirectionalIteratorOrig last_sorted,
      BOOST_DIR_CSR_GRAPH_TYPE& g) {
    g.add_edges_sorted_internal(first_sorted, last_sorted);
  }


  template <BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS, typename BidirectionalIteratorOrig,
            typename EPIterOrig, typename GlobalToLocal>
  void
  add_edges_sorted_global(
      BidirectionalIteratorOrig first_sorted,
      BidirectionalIteratorOrig last_sorted,
      EPIterOrig ep_iter_sorted,
      const GlobalToLocal& global_to_local,
      BOOST_DIR_CSR_GRAPH_TYPE& g) {
    g.add_edges_sorted_internal_global(first_sorted, last_sorted, ep_iter_sorted,
                                       global_to_local);
  }

  template <BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS, typename BidirectionalIteratorOrig,
            typename GlobalToLocal>
  void
  add_edges_sorted_global(
      BidirectionalIteratorOrig first_sorted,
      BidirectionalIteratorOrig last_sorted,
      const GlobalToLocal& global_to_local,
      BOOST_DIR_CSR_GRAPH_TYPE& g) {
    g.add_edges_sorted_internal_global(first_sorted, last_sorted, global_to_local);
  }

  template <BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS, typename InputIterator,
            typename GlobalToLocal>
  inline void
  add_edges_global(InputIterator first, InputIterator last,
                   const GlobalToLocal& global_to_local, BOOST_DIR_CSR_GRAPH_TYPE& g) {
    g.add_edges_internal(first, last, global_to_local);
  }

  template <BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS, typename InputIterator>
  inline void
  add_edges(InputIterator first, InputIterator last, BOOST_DIR_CSR_GRAPH_TYPE& g) {
    g.add_edges_internal(first, last);
  }

  template <BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS,
            typename InputIterator, typename EPIterator>
  inline void
  add_edges(InputIterator first, InputIterator last,
            EPIterator ep_iter, EPIterator ep_iter_end,
            BOOST_DIR_CSR_GRAPH_TYPE& g) {
    g.add_edges_internal(first, last, ep_iter, ep_iter_end);
  }


  template <BOOST_DIR_CSR_GRAPH_TEMPLATE_PARMS,
            typename InputIterator, typename EPIterator, typename GlobalToLocal>
  inline void
  add_edges_global(InputIterator first, InputIterator last,
            EPIterator ep_iter, EPIterator ep_iter_end,
            const GlobalToLocal& global_to_local,
            BOOST_DIR_CSR_GRAPH_TYPE& g) {
    g.add_edges_internal(first, last, ep_iter, ep_iter_end, global_to_local);
  }

template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline Vertex
num_vertices(const BOOST_CSR_GRAPH_TYPE& g) {
  return g.m_forward.m_rowstart.size() - 1;
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline typed_identity_property_map<Vertex>
get(vertex_index_t, const BOOST_CSR_GRAPH_TYPE&)
{
  return typed_identity_property_map<Vertex>();
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline Vertex
get(vertex_index_t,
    const BOOST_CSR_GRAPH_TYPE&, Vertex v)
{
  return v;
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline typed_identity_property_map<Vertex>
get(vertex_index_t, BOOST_CSR_GRAPH_TYPE&)
{
  return typed_identity_property_map<Vertex>();
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline Vertex
get(vertex_index_t,
    BOOST_CSR_GRAPH_TYPE&, Vertex v)
{
  return v;
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline EdgeIndex
get(edge_index_t, const BOOST_CSR_GRAPH_TYPE&,
    typename BOOST_CSR_GRAPH_TYPE::edge_descriptor e)
{
  return e.idx;
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline EdgeIndex
get(edge_index_t, BOOST_CSR_GRAPH_TYPE&,
    typename BOOST_CSR_GRAPH_TYPE::edge_descriptor e)
{
  return e.idx;
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline VertexProperty&
get(vertex_all_t,
    BOOST_CSR_GRAPH_TYPE& g, Vertex v)
{
  return get(vertex_all, g)[v];
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline const VertexProperty&
get(vertex_all_t,
    const BOOST_CSR_GRAPH_TYPE& g, Vertex v)
{
  return get(vertex_all, g)[v];
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline void
put(vertex_all_t,
    BOOST_CSR_GRAPH_TYPE& g,
    Vertex v,
    const VertexProperty& val)
{
  put(get(vertex_all, g), v, val);
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline EdgeProperty&
get(edge_all_t,
    BOOST_CSR_GRAPH_TYPE& g,
    const typename BOOST_CSR_GRAPH_TYPE::edge_descriptor& e)
{
  return get(edge_all, g)[e];
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline const EdgeProperty&
get(edge_all_t,
    const BOOST_CSR_GRAPH_TYPE& g,
    const typename BOOST_CSR_GRAPH_TYPE::edge_descriptor& e)
{
  return get(edge_all, g)[e];
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline void
put(edge_all_t,
    BOOST_CSR_GRAPH_TYPE& g,
    const typename BOOST_CSR_GRAPH_TYPE::edge_descriptor& e,
    const EdgeProperty& val)
{
  put(get(edge_all, g), e, val);
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline GraphProperty&
get(graph_all_t,
    BOOST_CSR_GRAPH_TYPE& g,
    BOOST_CSR_GRAPH_TYPE*)
{
  return g.m_property;
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline const GraphProperty&
get(graph_all_t,
    const BOOST_CSR_GRAPH_TYPE& g,
    BOOST_CSR_GRAPH_TYPE*)
{
  return g.m_property;
}


template<BOOST_CSR_GRAPH_TEMPLATE_PARMS>
inline void
put(graph_all_t,
    BOOST_CSR_GRAPH_TYPE& g,
    BOOST_CSR_GRAPH_TYPE*,
    const GraphProperty& val)
{
  g.m_property = val;
}

    labeled_graph(graph_property_type const& gp = graph_property_type())
        : _graph(gp), _map()
    { }


    labeled_graph(labeled_graph const& x)
        : _graph(x._graph), _map(x._map)
    { }

    labeled_graph(vertices_size_type n,
                  graph_property_type const& gp = graph_property_type())
        : _graph(n, gp), _map()
    {
        std::pair<vertex_iterator, vertex_iterator> rng = vertices(_graph);
        _map.insert(_map.end(), rng.first, rng.second);
    }

    template <typename LabelIter>
    labeled_graph(vertices_size_type n, LabelIter l,
                  graph_property_type const& gp = graph_property_type())
        : _graph(gp)
    { while(n-- >= 0) add_vertex(*l++); }

    template <typename LabelIter, typename PropIter>
    labeled_graph(vertices_size_type n, LabelIter l, PropIter p,
                  graph_property_type const& gp = graph_property_type())
    { while(n-- >= 0) add_vertex(*l++, *p++); }


    labeled_graph& operator=(labeled_graph const& x) {
        _graph = x._graph;
        _map = x._map;
        return *this;
    }

    graph_type& graph() { return _graph; }

    graph_type const& graph() const { return _graph; }

    bool label_vertex(vertex_descriptor v, Label const& l)
    { return graph_detail::put_vertex_label(_map, _graph, l, v); }

    vertex_descriptor add_vertex(Label const& l) {
        return graph_detail::insert_labeled_vertex(
            _map, _graph, l, vertex_property_type()
            ).first;
    }


    vertex_descriptor add_vertex(Label const& l, vertex_property_type const& p)
    { return graph_detail::insert_labeled_vertex(_map, _graph, l, p).first; }


    labeled_graph(graph_type* g)
        : _graph(g)
    { }

    graph_type& graph() { return *_graph; }

    graph_type const& graph() const { return *_graph; }

    bool label_vertex(vertex_descriptor v, Label const& l)
    { return graph_detail::put_vertex_label(_map, *_graph, l, v); }

    vertex_descriptor add_vertex(Label const& l) {
        return graph_detail::insert_labeled_vertex(
            _map, *_graph, l, vertex_property_type()
            ).first;
    }


    vertex_descriptor add_vertex(Label const& l, vertex_property_type const& p)
    { return graph_detail::insert_labeled_vertex(_map, *_graph, l, p).first; }

template <LABELED_GRAPH_PARAMS>
inline bool label_vertex(typename LABELED_GRAPH::vertex_descriptor v,
                         typename LABELED_GRAPH::label_type const l,
                         LABELED_GRAPH& g)
{ return g.label_vertex(v, l); }


template <LABELED_GRAPH_PARAMS>
inline typename LABELED_GRAPH::vertex_descriptor
vertex_by_label(typename LABELED_GRAPH::label_type const l,
                LABELED_GRAPH& g)
{ return g.vertex(l); }


template <LABELED_GRAPH_PARAMS, typename Prop, typename Key, typename Value>
inline void
put(Prop p, LABELED_GRAPH& g, Key const& k, Value const& v)
{ put(p, g.graph(), k, v); }


    template <class Graph, class ResCapMap>
    filtered_graph<Graph, is_residual_edge<ResCapMap> >
    residual_graph(Graph& g, ResCapMap residual_capacity) {
      return filtered_graph<Graph, is_residual_edge<ResCapMap> >
        (g, is_residual_edge<ResCapMap>(residual_capacity));
    }


    template <class Graph, class PredEdgeMap, class ResCapMap,
              class RevEdgeMap>
    inline void
    augment(Graph& g, 
            typename graph_traits<Graph>::vertex_descriptor src,
            typename graph_traits<Graph>::vertex_descriptor sink,
            PredEdgeMap p, 
            ResCapMap residual_capacity,
            RevEdgeMap reverse_edge)
    {
      typename graph_traits<Graph>::edge_descriptor e;
      typename graph_traits<Graph>::vertex_descriptor u;
      typedef typename property_traits<ResCapMap>::value_type FlowValue;

      // find minimum residual capacity along the augmenting path
      FlowValue delta = (std::numeric_limits<FlowValue>::max)();
      e = get(p, sink);
      do {
        BOOST_USING_STD_MIN();
        delta = min BOOST_PREVENT_MACRO_SUBSTITUTION(delta, get(residual_capacity, e));
        u = source(e, g);
        e = get(p, u);
      } while (u != src);

      // push delta units of flow along the augmenting path
      e = get(p, sink);
      do {
        put(residual_capacity, e, get(residual_capacity, e) - delta);
        put(residual_capacity, get(reverse_edge, e), get(residual_capacity, get(reverse_edge, e)) + delta);
        u = source(e, g);
        e = get(p, u);
      } while (u != src);
    }


  template <class Graph, 
            class CapacityEdgeMap, class ResidualCapacityEdgeMap,
            class ReverseEdgeMap, class ColorMap, class PredEdgeMap>
  typename property_traits<CapacityEdgeMap>::value_type
  edmonds_karp_max_flow
    (Graph& g, 
     typename graph_traits<Graph>::vertex_descriptor src,
     typename graph_traits<Graph>::vertex_descriptor sink,
     CapacityEdgeMap cap, 
     ResidualCapacityEdgeMap res,
     ReverseEdgeMap rev, 
     ColorMap color, 
     PredEdgeMap pred)
  {
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;
    
    typename graph_traits<Graph>::vertex_iterator u_iter, u_end;
    typename graph_traits<Graph>::out_edge_iterator ei, e_end;
    for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter)
      for (boost::tie(ei, e_end) = out_edges(*u_iter, g); ei != e_end; ++ei)
        put(res, *ei, get(cap, *ei));
    
    put(color, sink, Color::gray());
    while (get(color, sink) != Color::white()) {
      boost::queue<vertex_t> Q;
      breadth_first_search
        (detail::residual_graph(g, res), src, Q,
         make_bfs_visitor(record_edge_predecessors(pred, on_tree_edge())),
         color);
      if (get(color, sink) != Color::white())
        detail::augment(g, src, sink, pred, res, rev);
    } // while
    
    typename property_traits<CapacityEdgeMap>::value_type flow = 0;
    for (boost::tie(ei, e_end) = out_edges(src, g); ei != e_end; ++ei)
      flow += (get(cap, *ei) - get(res, *ei));
    return flow;
  }

      template <class Graph, class PredMap, class P, class T, class R>
      static typename edge_capacity_value<Graph, P, T, R>::type
      apply
      (Graph& g,
       typename graph_traits<Graph>::vertex_descriptor src,
       typename graph_traits<Graph>::vertex_descriptor sink,
       PredMap pred,
       const bgl_named_params<P, T, R>& params,
       ColorMap color)
      {
        return edmonds_karp_max_flow
          (g, src, sink, 
           choose_const_pmap(get_param(params, edge_capacity), g, edge_capacity),
           choose_pmap(get_param(params, edge_residual_capacity), 
                       g, edge_residual_capacity),
           choose_const_pmap(get_param(params, edge_reverse), g, edge_reverse),
           color, pred);
      }

      template <class Graph, class PredMap, class P, class T, class R>
      static typename edge_capacity_value<Graph, P, T, R>::type
      apply
      (Graph& g,
       typename graph_traits<Graph>::vertex_descriptor src,
       typename graph_traits<Graph>::vertex_descriptor sink,
       PredMap pred,
       const bgl_named_params<P, T, R>& params,
       param_not_found)
      {
        typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
        typedef typename graph_traits<Graph>::vertices_size_type size_type;
        size_type n = is_default_param(get_param(params, vertex_color)) ?
          num_vertices(g) : 1;
        std::vector<default_color_type> color_vec(n);
        return edmonds_karp_max_flow
          (g, src, sink, 
           choose_const_pmap(get_param(params, edge_capacity), g, edge_capacity),
           choose_pmap(get_param(params, edge_residual_capacity), 
                       g, edge_residual_capacity),
           choose_const_pmap(get_param(params, edge_reverse), g, edge_reverse),
           make_iterator_property_map(color_vec.begin(), choose_const_pmap
                                      (get_param(params, vertex_index),
                                       g, vertex_index), color_vec[0]),
           pred);
      }

      template <class Graph, class P, class T, class R>
      static typename edge_capacity_value<Graph, P, T, R>::type
      apply(Graph& g,
            typename graph_traits<Graph>::vertex_descriptor src,
            typename graph_traits<Graph>::vertex_descriptor sink,
            const bgl_named_params<P, T, R>& params,
            PredMap pred)
      {
        typedef typename get_param_type< vertex_color_t, bgl_named_params<P,T,R> >::type C;
        return edmonds_karp_dispatch2<C>::apply
          (g, src, sink, pred, params, get_param(params, vertex_color));
      }


      template <class Graph, class P, class T, class R>
      static typename edge_capacity_value<Graph, P, T, R>::type
      apply
      (Graph& g,
       typename graph_traits<Graph>::vertex_descriptor src,
       typename graph_traits<Graph>::vertex_descriptor sink,
       const bgl_named_params<P, T, R>& params,
       param_not_found)
      {
        typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
        typedef typename graph_traits<Graph>::vertices_size_type size_type;
        size_type n = is_default_param(get_param(params, vertex_predecessor)) ?
          num_vertices(g) : 1;
        std::vector<edge_descriptor> pred_vec(n);
        
        typedef typename get_param_type< vertex_color_t, bgl_named_params<P,T,R> >::type C;
        return edmonds_karp_dispatch2<C>::apply
          (g, src, sink, 
           make_iterator_property_map(pred_vec.begin(), choose_const_pmap
                                      (get_param(params, vertex_index),
                                       g, vertex_index), pred_vec[0]),
           params, 
           get_param(params, vertex_color));
      }


  template <class Graph, class P, class T, class R>
  typename detail::edge_capacity_value<Graph, P, T, R>::type
  edmonds_karp_max_flow
    (Graph& g,
     typename graph_traits<Graph>::vertex_descriptor src,
     typename graph_traits<Graph>::vertex_descriptor sink,
     const bgl_named_params<P, T, R>& params)
  {
    typedef typename get_param_type< vertex_predecessor_t, bgl_named_params<P,T,R> >::type Pred;
    return detail::edmonds_karp_dispatch1<Pred>::apply
      (g, src, sink, params, get_param(params, vertex_predecessor));
  }

    void constraints() {
      BOOST_CONCEPT_ASSERT(( CopyConstructibleConcept<Visitor> ));
      vis.examine_edge(e, g);
      vis.edge_relaxed(e, g);
      vis.edge_not_relaxed(e, g);
      vis.edge_minimized(e, g);
      vis.edge_not_minimized(e, g);
    }

    bellman_visitor() { }

    bellman_visitor(Visitors vis) : m_vis(vis) { }


    template <class Edge, class Graph>
    void examine_edge(Edge u, Graph& g) {
      invoke_visitors(m_vis, u, g, on_examine_edge());
    }

    template <class Edge, class Graph>
    void edge_relaxed(Edge u, Graph& g) {
      invoke_visitors(m_vis, u, g, on_edge_relaxed());      
    }

    template <class Edge, class Graph>
    void edge_not_relaxed(Edge u, Graph& g) {
      invoke_visitors(m_vis, u, g, on_edge_not_relaxed());
    }

    template <class Edge, class Graph>
    void edge_minimized(Edge u, Graph& g) {
      invoke_visitors(m_vis, u, g, on_edge_minimized());
    }

    template <class Edge, class Graph>
    void edge_not_minimized(Edge u, Graph& g) {
      invoke_visitors(m_vis, u, g, on_edge_not_minimized());
    }

  template <class Visitors>
  bellman_visitor<Visitors>
  make_bellman_visitor(Visitors vis) {
    return bellman_visitor<Visitors>(vis);
  }


  template <class EdgeListGraph, class Size, class WeightMap,
            class PredecessorMap, class DistanceMap,
            class BinaryFunction, class BinaryPredicate,
            class BellmanFordVisitor>
  bool bellman_ford_shortest_paths(EdgeListGraph& g, Size N, 
                         WeightMap weight, 
                         PredecessorMap pred,
                         DistanceMap distance, 
                         BinaryFunction combine, 
                         BinaryPredicate compare,
                         BellmanFordVisitor v)
  {
    BOOST_CONCEPT_ASSERT(( EdgeListGraphConcept<EdgeListGraph> ));
    typedef graph_traits<EdgeListGraph> GTraits;
    typedef typename GTraits::edge_descriptor Edge;
    typedef typename GTraits::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<DistanceMap, Vertex> ));
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<WeightMap, Edge> ));
    typedef typename property_traits<DistanceMap>::value_type D_value;
    typedef typename property_traits<WeightMap>::value_type W_value;

    typename GTraits::edge_iterator i, end;

    for (Size k = 0; k < N; ++k) {
      bool at_least_one_edge_relaxed = false;
      for (boost::tie(i, end) = edges(g); i != end; ++i) {
        v.examine_edge(*i, g);
        if (relax(*i, g, weight, pred, distance, combine, compare)) {
          at_least_one_edge_relaxed = true;
          v.edge_relaxed(*i, g);
        } else
          v.edge_not_relaxed(*i, g);
      }
      if (!at_least_one_edge_relaxed)
        break;
    }

    for (boost::tie(i, end) = edges(g); i != end; ++i)
      if (compare(combine(get(distance, source(*i, g)), get(weight, *i)),
                  get(distance, target(*i,g))))
      {
        v.edge_not_minimized(*i, g);
        return false;
      } else
        v.edge_minimized(*i, g);

    return true;
  }


    template<typename VertexAndEdgeListGraph, typename Size, 
             typename WeightMap, typename PredecessorMap, typename DistanceMap,
             typename P, typename T, typename R>
    bool 
    bellman_dispatch2
      (VertexAndEdgeListGraph& g, 
       typename graph_traits<VertexAndEdgeListGraph>::vertex_descriptor s,
       Size N, WeightMap weight, PredecessorMap pred, DistanceMap distance,
       const bgl_named_params<P, T, R>& params)
    {
      typedef typename property_traits<DistanceMap>::value_type D;
      bellman_visitor<> null_vis;
      typedef typename property_traits<WeightMap>::value_type weight_type;
      typename graph_traits<VertexAndEdgeListGraph>::vertex_iterator v, v_end;
      for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
        put(distance, *v, (std::numeric_limits<weight_type>::max)());
        put(pred, *v, *v);
      }
      put(distance, s, weight_type(0));
      return bellman_ford_shortest_paths
               (g, N, weight, pred, distance,
                choose_param(get_param(params, distance_combine_t()),
                             closed_plus<D>()),
                choose_param(get_param(params, distance_compare_t()),
                             std::less<D>()),
                choose_param(get_param(params, graph_visitor),
                             null_vis)
                );
    }


    template<typename VertexAndEdgeListGraph, typename Size, 
             typename WeightMap, typename PredecessorMap, typename DistanceMap,
             typename P, typename T, typename R>
    bool 
    bellman_dispatch2
      (VertexAndEdgeListGraph& g, 
       param_not_found,
       Size N, WeightMap weight, PredecessorMap pred, DistanceMap distance,
       const bgl_named_params<P, T, R>& params)
    {
      typedef typename property_traits<DistanceMap>::value_type D;
      bellman_visitor<> null_vis;
      return bellman_ford_shortest_paths
               (g, N, weight, pred, distance,
                choose_param(get_param(params, distance_combine_t()),
                             closed_plus<D>()),
                choose_param(get_param(params, distance_compare_t()),
                             std::less<D>()),
                choose_param(get_param(params, graph_visitor),
                             null_vis)
                );
    }


    template <class EdgeListGraph, class Size, class WeightMap,
              class DistanceMap, class P, class T, class R>
    bool bellman_dispatch(EdgeListGraph& g, Size N, 
                          WeightMap weight, DistanceMap distance, 
                          const bgl_named_params<P, T, R>& params)
    {
      dummy_property_map dummy_pred;
      return 
        detail::bellman_dispatch2
          (g, 
           get_param(params, root_vertex_t()),
           N, weight,
           choose_param(get_param(params, vertex_predecessor), dummy_pred),
           distance,
           params);
    }


  template <class EdgeListGraph, class Size, class P, class T, class R>
  bool bellman_ford_shortest_paths
    (EdgeListGraph& g, Size N, 
     const bgl_named_params<P, T, R>& params)
  {                                
    return detail::bellman_dispatch
      (g, N,
       choose_const_pmap(get_param(params, edge_weight), g, edge_weight),
       choose_pmap(get_param(params, vertex_distance), g, vertex_distance),
       params);
  }


  template <class EdgeListGraph, class Size>
  bool bellman_ford_shortest_paths(EdgeListGraph& g, Size N)
  {                                
    bgl_named_params<int,int> params(0);
    return bellman_ford_shortest_paths(g, N, params);
  }


  template <class VertexAndEdgeListGraph, class P, class T, class R>
  bool bellman_ford_shortest_paths
    (VertexAndEdgeListGraph& g, 
     const bgl_named_params<P, T, R>& params)
  {               
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<VertexAndEdgeListGraph> ));
    return detail::bellman_dispatch
      (g, num_vertices(g),
       choose_const_pmap(get_param(params, edge_weight), g, edge_weight),
       choose_pmap(get_param(params, vertex_distance), g, vertex_distance),
       params);
  }

      explicit reverse_graph_edge_descriptor(const EdgeDesc& underlying_descx = EdgeDesc())
        : underlying_descx(underlying_descx) {}


      reverse_graph_edge_descriptor<EdgeDesc> operator()(const EdgeDesc& ed) const {
        return reverse_graph_edge_descriptor<EdgeDesc>(ed);
      }

      static Desc convert(const reverse_graph_edge_descriptor<Desc>& d) {return d.underlying_descx;}

    reverse_graph(GraphRef g) : m_g(g) {}

    reverse_graph(const reverse_graph<BidirectionalGraph, BidirectionalGraph&>& o): m_g(o.m_g) {}

    template<typename Descriptor>
    typename graph::detail::bundled_result<
               BidirectionalGraph,
               typename detail::get_underlying_descriptor_from_reverse_descriptor<Descriptor>::type
             >::type&
    operator[](Descriptor x)
    { return m_g[detail::get_underlying_descriptor_from_reverse_descriptor<Descriptor>::convert(x)]; }


    template<typename Descriptor>
    typename graph::detail::bundled_result<
               BidirectionalGraph,
               typename detail::get_underlying_descriptor_from_reverse_descriptor<Descriptor>::type
             >::type const&
    operator[](Descriptor x) const
    { return m_g[detail::get_underlying_descriptor_from_reverse_descriptor<Descriptor>::convert(x)]; }


    static vertex_descriptor null_vertex()
    { return Traits::null_vertex(); }


template <class BidirectionalGraph>
inline reverse_graph<BidirectionalGraph>
make_reverse_graph(const BidirectionalGraph& g)
{
    return reverse_graph<BidirectionalGraph>(g);
}


template <class BidirectionalGraph>
inline reverse_graph<BidirectionalGraph, BidirectionalGraph&>
make_reverse_graph(BidirectionalGraph& g)
{
    return reverse_graph<BidirectionalGraph, BidirectionalGraph&>(g);
}


template <class BidirectionalGraph, class GRef, class Property, class Key, class Value>
void
put(Property p, reverse_graph<BidirectionalGraph,GRef>& g, const Key& k,
    const Value& val)
{
  put(get(p, g), k, val);
}

    E operator[](const reverse_graph_edge_descriptor<E>& k) const {
      return k.underlying_descx;
    }


  template <class E>
  E
  get(underlying_edge_desc_map_type<E> m,
      const reverse_graph_edge_descriptor<E>& k)
  {
    return m[k];
  }


template <class G>
typename enable_if<is_reverse_graph<G>,
  detail::underlying_edge_desc_map_type<typename graph_traits<typename G::base_type>::edge_descriptor> >::type
get(edge_underlying_t,
    G&)
{
  return detail::underlying_edge_desc_map_type<typename graph_traits<typename G::base_type>::edge_descriptor>();
}


template <class G>
typename enable_if<is_reverse_graph<G>, typename graph_traits<typename G::base_type>::edge_descriptor>::type
get(edge_underlying_t,
    G&,
    const typename graph_traits<G>::edge_descriptor& k)
{
  return k.underlying_descx;
}


template <class G>
typename enable_if<is_reverse_graph<G>, detail::underlying_edge_desc_map_type<typename graph_traits<typename G::base_type>::edge_descriptor> >::type
get(edge_underlying_t,
    const G&)
{
  return detail::underlying_edge_desc_map_type<typename graph_traits<typename G::base_type>::edge_descriptor>();
}


template <class G>
typename enable_if<is_reverse_graph<G>, typename graph_traits<typename G::base_type>::edge_descriptor>::type
get(edge_underlying_t,
    const G&,
    const typename graph_traits<G>::edge_descriptor& k)
{
  return k.underlying_descx;
}


template<typename BidirectionalGraph, typename GRef, typename Tag,
         typename Value>
inline void
set_property(const reverse_graph<BidirectionalGraph,GRef>& g, Tag tag,
             const Value& value)
{
  set_property(g.m_g, tag, value);
}


template<typename BidirectionalGraph, typename GRef, typename Tag>
inline
typename boost::mpl::if_<
           boost::is_const<typename boost::remove_reference<GRef>::type>,
           const typename graph_property<BidirectionalGraph, Tag>::type&,
           typename graph_property<BidirectionalGraph, Tag>::type& >::type
get_property(const reverse_graph<BidirectionalGraph,GRef>& g, Tag tag)
{
  return get_property(g.m_g, tag);
}


  template <class VertexListGraph, class Order, class Degree, class Marker>
  void 
  smallest_last_vertex_ordering(const VertexListGraph& G, Order order, 
                                Degree degree, Marker marker) {
    typedef typename boost::graph_traits<VertexListGraph> GraphTraits;
    typedef typename GraphTraits::vertex_descriptor Vertex;
    //typedef typename GraphTraits::size_type size_type;
    typedef std::size_t size_type;
    
    const size_type num = num_vertices(G);
    
    typedef typename boost::property_map<VertexListGraph, vertex_index_t>::type ID;
    typedef bucket_sorter<size_type, Vertex, Degree, ID> BucketSorter;
    
    BucketSorter degree_bucket_sorter(num, num, degree,  
                                      get(vertex_index,G));

    smallest_last_vertex_ordering(G, order, degree, marker, degree_bucket_sorter);
  }


  template <class VertexListGraph, class Order, class Degree, 
            class Marker, class BucketSorter>
  void 
  smallest_last_vertex_ordering(const VertexListGraph& G, Order order, 
                                Degree degree, Marker marker,
                                BucketSorter& degree_buckets) {
    typedef typename boost::graph_traits<VertexListGraph> GraphTraits;
    typedef typename GraphTraits::vertex_descriptor Vertex;
    //typedef typename GraphTraits::size_type size_type;
    typedef std::size_t size_type;

    const size_type num = num_vertices(G);
    
    typename GraphTraits::vertex_iterator v, vend;
    for (boost::tie(v, vend) = vertices(G); v != vend; ++v) {
      put(marker, *v, num);
      put(degree, *v, out_degree(*v, G));
      degree_buckets.push(*v);
    }
 
    size_type minimum_degree = 0;
    size_type current_order = num - 1;
    
    while ( 1 ) {
      typedef typename BucketSorter::stack MDStack;
      MDStack minimum_degree_stack = degree_buckets[minimum_degree];
      while (minimum_degree_stack.empty())
        minimum_degree_stack = degree_buckets[++minimum_degree];
      
      Vertex node = minimum_degree_stack.top();
      put(order, current_order, node);
      
      if ( current_order == 0 ) //find all vertices
        break;
      
      minimum_degree_stack.pop();
      put(marker, node, 0); //node has been ordered.
      
      typename GraphTraits::adjacency_iterator v, vend;
      for (boost::tie(v,vend) = adjacent_vertices(node, G); v != vend; ++v)
        
        if ( get(marker,*v) > current_order ) { //*v is unordered vertex
          put(marker, *v, current_order);  //mark the columns adjacent to node

          //delete *v from the bucket sorter         
          degree_buckets.remove(*v);
 
          //It is possible minimum degree goes down
          //Here we keep tracking it.
          put(degree, *v, get(degree, *v) - 1); 
          BOOST_USING_STD_MIN();
          minimum_degree = min BOOST_PREVENT_MACRO_SUBSTITUTION(minimum_degree, get(degree, *v)); 
          
          //reinsert *v in the bucket sorter with the new degree
          degree_buckets.push(*v);
        }

      current_order--;
    }
    
    //at this point, order[i] = v_i;
  }

  
  template <class VertexListGraph, class Order>
  void 
  smallest_last_vertex_ordering(const VertexListGraph& G, Order order) {
    typedef typename graph_traits<VertexListGraph>::vertex_descriptor vertex_descriptor;
    typedef typename graph_traits<VertexListGraph>::degree_size_type degree_size_type;
    smallest_last_vertex_ordering(G, order,
                                  make_shared_array_property_map(num_vertices(G), degree_size_type(0), get(vertex_index, G)),
                                  make_shared_array_property_map(num_vertices(G), (std::size_t)(0), get(vertex_index, G)));
  }


  update_position_visitor(PositionMap position_map,
                          NodeDistanceMap node_distance,
                          const Topology& space,
                          const Point& input_vector,
                          double distance_limit,
                          double learning_constant,
                          double falloff_ratio):
    position_map(position_map), node_distance(node_distance), 
    space(space),
    input_vector(input_vector), distance_limit(distance_limit),
    learning_constant(learning_constant), falloff_ratio(falloff_ratio) {}


  void operator()(vertex_descriptor v, const Graph&) const 
  {
#ifndef BOOST_NO_STDC_NAMESPACE
    using std::pow;
#endif

    if (get(node_distance, v) > distance_limit)
      BOOST_THROW_EXCEPTION(over_distance_limit());
    Point old_position = get(position_map, v);
    double distance = get(node_distance, v);
    double fraction = 
      learning_constant * pow(falloff_ratio, distance * distance);
    put(position_map, v,
        space.move_position_toward(old_position, fraction, input_vector));
  }

  template<typename Graph, typename NodeDistanceMap, typename UpdatePosition>
  static inline void 
  run(const Graph& g, typename graph_traits<Graph>::vertex_descriptor s,
      NodeDistanceMap node_distance,  UpdatePosition& update_position,
      EdgeWeightMap weight)
  {
    boost::dijkstra_shortest_paths(g, s, weight_map(weight).
      visitor(boost::make_dijkstra_visitor(std::make_pair(
       boost::record_distances(node_distance, boost::on_edge_relaxed()),
        update_position))));
  }

  template<typename Graph, typename NodeDistanceMap, typename UpdatePosition>
  static inline void 
  run(const Graph& g, typename graph_traits<Graph>::vertex_descriptor s,
      NodeDistanceMap node_distance,  UpdatePosition& update_position,
      dummy_property_map)
  {
    boost::breadth_first_search(g, s,
      visitor(boost::make_bfs_visitor(std::make_pair(
        boost::record_distances(node_distance, boost::on_tree_edge()),
        update_position))));
  }


template <typename VertexListAndIncidenceGraph,  typename Topology,
          typename PositionMap, typename Diameter, typename VertexIndexMap, 
          typename EdgeWeightMap>
void 
gursoy_atun_step
  (const VertexListAndIncidenceGraph& graph,  
   const Topology& space,
   PositionMap position,
   Diameter diameter,
   double learning_constant,
   VertexIndexMap vertex_index_map,
   EdgeWeightMap weight)
{
#ifndef BOOST_NO_STDC_NAMESPACE
  using std::pow;
  using std::exp;
#endif

  typedef typename graph_traits<VertexListAndIncidenceGraph>::vertex_iterator
    vertex_iterator;
  typedef typename graph_traits<VertexListAndIncidenceGraph>::vertex_descriptor
    vertex_descriptor;
  typedef typename Topology::point_type point_type;
  vertex_iterator i, iend;
  std::vector<double> distance_from_input_vector(num_vertices(graph));
  typedef boost::iterator_property_map<std::vector<double>::iterator, 
                                       VertexIndexMap,
                                       double, double&>
    DistanceFromInputMap;
  DistanceFromInputMap distance_from_input(distance_from_input_vector.begin(),
                                           vertex_index_map);
  std::vector<double> node_distance_map_vector(num_vertices(graph));
  typedef boost::iterator_property_map<std::vector<double>::iterator, 
                                       VertexIndexMap,
                                       double, double&>
    NodeDistanceMap;
  NodeDistanceMap node_distance(node_distance_map_vector.begin(),
                                vertex_index_map);
  point_type input_vector = space.random_point();
  vertex_descriptor min_distance_loc 
    = graph_traits<VertexListAndIncidenceGraph>::null_vertex();
  double min_distance = 0.0;
  bool min_distance_unset = true;
  for (boost::tie(i, iend) = vertices(graph); i != iend; ++i) {
    double this_distance = space.distance(get(position, *i), input_vector);
    put(distance_from_input, *i, this_distance);
    if (min_distance_unset || this_distance < min_distance) {
      min_distance = this_distance;
      min_distance_loc = *i;
    }
    min_distance_unset = false;
  }
  BOOST_ASSERT (!min_distance_unset); // Graph must have at least one vertex
  boost::detail::update_position_visitor<
      PositionMap, NodeDistanceMap, Topology,
      VertexListAndIncidenceGraph> 
    update_position(position, node_distance, space,
                    input_vector, diameter, learning_constant, 
                    exp(-1. / (2 * diameter * diameter)));
  std::fill(node_distance_map_vector.begin(), node_distance_map_vector.end(), 0);
  try {
    typedef detail::gursoy_shortest<EdgeWeightMap> shortest;
    shortest::run(graph, min_distance_loc, node_distance, update_position,
                  weight);    
  } catch (detail::over_distance_limit) { 
    /* Thrown to break out of BFS or Dijkstra early */ 
  }
}


template <typename VertexListAndIncidenceGraph,  typename Topology,
          typename PositionMap, typename VertexIndexMap, 
          typename EdgeWeightMap>
void gursoy_atun_refine(const VertexListAndIncidenceGraph& graph,  
                        const Topology& space,
                        PositionMap position,
                        int nsteps,
                        double diameter_initial,
                        double diameter_final,
                        double learning_constant_initial,
                        double learning_constant_final,
                        VertexIndexMap vertex_index_map,
                        EdgeWeightMap weight) 
{
#ifndef BOOST_NO_STDC_NAMESPACE
  using std::pow;
  using std::exp;
#endif

  typedef typename graph_traits<VertexListAndIncidenceGraph>::vertex_iterator
    vertex_iterator;
  typedef typename graph_traits<VertexListAndIncidenceGraph>::vertex_descriptor
    vertex_descriptor;
  typedef typename Topology::point_type point_type;
  vertex_iterator i, iend;
  double diameter_ratio = (double)diameter_final / diameter_initial;
  double learning_constant_ratio = 
    learning_constant_final / learning_constant_initial;
  std::vector<double> distance_from_input_vector(num_vertices(graph));
  typedef boost::iterator_property_map<std::vector<double>::iterator, 
                                       VertexIndexMap,
                                       double, double&>
    DistanceFromInputMap;
  DistanceFromInputMap distance_from_input(distance_from_input_vector.begin(),
                                           vertex_index_map);
  std::vector<int> node_distance_map_vector(num_vertices(graph));
  typedef boost::iterator_property_map<std::vector<int>::iterator, 
                                       VertexIndexMap, double, double&>
    NodeDistanceMap;
  NodeDistanceMap node_distance(node_distance_map_vector.begin(),
                                vertex_index_map);
  for (int round = 0; round < nsteps; ++round) {
    double part_done = (double)round / (nsteps - 1);
    int diameter = (int)(diameter_initial * pow(diameter_ratio, part_done));
    double learning_constant = 
      learning_constant_initial * pow(learning_constant_ratio, part_done);
    gursoy_atun_step(graph, space, position, diameter, learning_constant, 
                     vertex_index_map, weight);
  }
}


template <typename VertexListAndIncidenceGraph,  typename Topology,
          typename PositionMap, typename VertexIndexMap, 
          typename EdgeWeightMap>
void gursoy_atun_layout(const VertexListAndIncidenceGraph& graph,  
                        const Topology& space,
                        PositionMap position,
                        int nsteps,
                        double diameter_initial,
                        double diameter_final,
                        double learning_constant_initial,
                        double learning_constant_final,
                        VertexIndexMap vertex_index_map,
                        EdgeWeightMap weight)
{
  typedef typename graph_traits<VertexListAndIncidenceGraph>::vertex_iterator
    vertex_iterator;
  vertex_iterator i, iend;
  for (boost::tie(i, iend) = vertices(graph); i != iend; ++i) {
    put(position, *i, space.random_point());
  }
  gursoy_atun_refine(graph, space,
                     position, nsteps,
                     diameter_initial, diameter_final, 
                     learning_constant_initial, learning_constant_final,
                     vertex_index_map, weight);
}


template <typename VertexListAndIncidenceGraph,  typename Topology,
          typename PositionMap, typename VertexIndexMap>
void gursoy_atun_layout(const VertexListAndIncidenceGraph& graph,  
                        const Topology& space,
                        PositionMap position,
                        int nsteps,
                        double diameter_initial,
                        double diameter_final,
                        double learning_constant_initial,
                        double learning_constant_final,
                        VertexIndexMap vertex_index_map)
{
  gursoy_atun_layout(graph, space, position, nsteps, 
                     diameter_initial, diameter_final, 
                     learning_constant_initial, learning_constant_final, 
                     vertex_index_map, dummy_property_map());
}


template <typename VertexListAndIncidenceGraph, typename Topology,
          typename PositionMap>
void gursoy_atun_layout(const VertexListAndIncidenceGraph& graph,  
                        const Topology& space,
                        PositionMap position,
                        int nsteps,
                        double diameter_initial,
                        double diameter_final = 1.0,
                        double learning_constant_initial = 0.8,
                        double learning_constant_final = 0.2)
{ 
  gursoy_atun_layout(graph, space, position, nsteps, diameter_initial,
                     diameter_final, learning_constant_initial,
                     learning_constant_final, get(vertex_index, graph)); 
}


template <typename VertexListAndIncidenceGraph, typename Topology,
          typename PositionMap>
void gursoy_atun_layout(const VertexListAndIncidenceGraph& graph,  
                        const Topology& space,
                        PositionMap position,
                        int nsteps)
{
#ifndef BOOST_NO_STDC_NAMESPACE
  using std::sqrt;
#endif

  gursoy_atun_layout(graph, space, position, nsteps, 
                     sqrt((double)num_vertices(graph)));
}


template <typename VertexListAndIncidenceGraph, typename Topology,
          typename PositionMap>
void gursoy_atun_layout(const VertexListAndIncidenceGraph& graph,  
                        const Topology& space,
                        PositionMap position)
{
  gursoy_atun_layout(graph, space, position, num_vertices(graph));
}


template<typename VertexListAndIncidenceGraph, typename Topology,
         typename PositionMap, typename P, typename T, typename R>
void 
gursoy_atun_layout(const VertexListAndIncidenceGraph& graph,  
                   const Topology& space,
                   PositionMap position,
                   const bgl_named_params<P,T,R>& params)
{
#ifndef BOOST_NO_STDC_NAMESPACE
  using std::sqrt;
#endif

  std::pair<double, double> diam(sqrt(double(num_vertices(graph))), 1.0);
  std::pair<double, double> learn(0.8, 0.2);
  gursoy_atun_layout(graph, space, position,
                     choose_param(get_param(params, iterations_t()),
                                  num_vertices(graph)),
                     choose_param(get_param(params, diameter_range_t()), 
                                  diam).first,
                     choose_param(get_param(params, diameter_range_t()), 
                                  diam).second,
                     choose_param(get_param(params, learning_constant_range_t()), 
                                  learn).first,
                     choose_param(get_param(params, learning_constant_range_t()), 
                                  learn).second,
                     choose_const_pmap(get_param(params, vertex_index), graph,
                                       vertex_index),
                     choose_param(get_param(params, edge_weight), 
                                  dummy_property_map()));
}


  template <class EdgeList, class Alloc>
  typename detail::val_out_edge_ret<EdgeList>::type
  out_edges(typename EdgeList::value_type v,
            const std::vector<EdgeList, Alloc>& g)
  {
    typedef typename detail::val_out_edge_iter<EdgeList>::type Iter;
    typedef typename detail::val_out_edge_ret<EdgeList>::type return_type;
    return return_type(Iter(v, g[v].begin()), Iter(v, g[v].end()));
  }


  template <class EdgeList, class Alloc>
  typename EdgeList::size_type
  out_degree(typename EdgeList::value_type v,
             const std::vector<EdgeList, Alloc>& g)
  {
    return g[v].size();
  }


    grid_graph_index_map() { }


    grid_graph_index_map(const Graph& graph) :
      m_graph(&graph) { }


    value_type operator[](key_type key) const {
      return (m_graph->index_of(key));
    }


    grid_graph_reverse_edge_map() { }


    value_type operator[](const key_type& key) const {
      return (value_type(key.second, key.first));
    }


      grid_graph_vertex_at() : m_graph(0) {}


      grid_graph_vertex_at(const Graph* graph) :
        m_graph(graph) { }


      result_type
      operator()
      (typename graph_traits<Graph>::vertices_size_type vertex_index) const {
        return (vertex(vertex_index, *m_graph));
      }


      grid_graph_out_edge_at() : m_vertex(), m_graph(0) {}


      grid_graph_out_edge_at(vertex_descriptor source_vertex,
                             const Graph* graph) :
        m_vertex(source_vertex),
        m_graph(graph) { }


      result_type
      operator()
      (typename graph_traits<Graph>::degree_size_type out_edge_index) const {
        return (out_edge_at(m_vertex, out_edge_index, *m_graph));
      }


      grid_graph_in_edge_at() : m_vertex(), m_graph(0) {}


      grid_graph_in_edge_at(vertex_descriptor target_vertex,
                            const Graph* graph) :
        m_vertex(target_vertex),
        m_graph(graph) { }


      result_type
      operator()
      (typename graph_traits<Graph>::degree_size_type in_edge_index) const {
        return (in_edge_at(m_vertex, in_edge_index, *m_graph));
      }


      grid_graph_edge_at() : m_graph(0) {}


      grid_graph_edge_at(const Graph* graph) :
        m_graph(graph) { }


      result_type
      operator()
      (typename graph_traits<Graph>::edges_size_type edge_index) const {
        return (edge_at(edge_index, *m_graph));
      }


      grid_graph_adjacent_vertex_at(result_type source_vertex,
                                    const Graph* graph) :
        m_vertex(source_vertex),
        m_graph(graph) { }


      result_type
      operator()
      (typename graph_traits<Graph>::degree_size_type adjacent_index) const {
        return (target(out_edge_at(m_vertex, adjacent_index, *m_graph), *m_graph));
      }

    grid_graph() { };


    static inline vertex_descriptor null_vertex()
    {
      vertex_descriptor maxed_out_vertex;
      std::fill(maxed_out_vertex.begin(), maxed_out_vertex.end(),
                (std::numeric_limits<vertices_size_type>::max)());

      return (maxed_out_vertex);
    }

    grid_graph(vertex_descriptor dimension_lengths) :
      m_dimension_lengths(dimension_lengths) {

      std::fill(m_wrap_dimension.begin(),
                m_wrap_dimension.end(), false);

      precalculate();
    }

    grid_graph(vertex_descriptor dimension_lengths,
               bool wrap_all_dimensions) :
      m_dimension_lengths(dimension_lengths) {
      
      std::fill(m_wrap_dimension.begin(),
                m_wrap_dimension.end(),
                wrap_all_dimensions);

      precalculate();
    }

    grid_graph(vertex_descriptor dimension_lengths,
               WrapDimensionArray wrap_dimension) :
      m_dimension_lengths(dimension_lengths),
      m_wrap_dimension(wrap_dimension) {

      precalculate();
    }

    inline std::size_t dimensions() const {
      return (Dimensions);
    }

    inline vertices_size_type length(std::size_t dimension) const {
      return (m_dimension_lengths[dimension]);
    }

    inline bool wrapped(std::size_t dimension) const {
      return (m_wrap_dimension[dimension]);
    }

    vertex_descriptor next
    (vertex_descriptor vertex,
     std::size_t dimension_index,
     vertices_size_type distance = 1) const {

      vertices_size_type new_position =
        vertex[dimension_index] + distance;

      if (wrapped(dimension_index)) {
        new_position %= length(dimension_index);
      }
      else {
        // Stop at the end of this dimension if necessary.
        new_position =
          (std::min)(new_position,
                     vertices_size_type(length(dimension_index) - 1));
      }

      vertex[dimension_index] = new_position;

      return (vertex);    
    }

    vertex_descriptor previous
    (vertex_descriptor vertex,
     std::size_t dimension_index,
     vertices_size_type distance = 1) const {
    
      // We're assuming that vertices_size_type is unsigned, so we
      // need to be careful about the math.
      vertex[dimension_index] =
        (distance > vertex[dimension_index]) ?
        (wrapped(dimension_index) ?
         (length(dimension_index) - (distance % length(dimension_index))) : 0) :
        vertex[dimension_index] - distance;

      return (vertex);    
    }

    inline vertices_size_type num_vertices() const {
      return (m_num_vertices);
    }

    inline edges_size_type num_edges() const {
      return (m_num_edges);
    }

    vertices_size_type index_of(vertex_descriptor vertex) const {

      vertices_size_type vertex_index = 0;
      vertices_size_type index_multiplier = 1;

      for (std::size_t dimension_index = 0;
           dimension_index < Dimensions;
           ++dimension_index) {

        vertex_index += (vertex[dimension_index] * index_multiplier);
        index_multiplier *= length(dimension_index);
      }

      return (vertex_index);
    }

    vertex_descriptor vertex_at
    (vertices_size_type vertex_index) const {
    
      boost::array<vertices_size_type, Dimensions> vertex;
      vertices_size_type index_divider = 1;

      for (std::size_t dimension_index = 0;
           dimension_index < Dimensions;
           ++dimension_index) {

        vertex[dimension_index] = (vertex_index / index_divider) %
          length(dimension_index);

        index_divider *= length(dimension_index);
      }

      return (vertex);
    }

    edge_descriptor edge_at(edges_size_type edge_index) const {

      // Edge indices are sorted into bins by dimension
      std::size_t dimension_index = 0;
      edges_size_type dimension_edges = num_edges(0);

      while (edge_index >= dimension_edges) {
        edge_index -= dimension_edges;
        ++dimension_index;
        dimension_edges = num_edges(dimension_index);
      }

      vertex_descriptor vertex_source, vertex_target;
      bool is_forward = ((edge_index / (num_edges(dimension_index) / 2)) == 0);

      if (wrapped(dimension_index)) {
        vertex_source = vertex_at(edge_index % num_vertices());
        vertex_target = is_forward ?
          next(vertex_source, dimension_index) :
          previous(vertex_source, dimension_index);
      }
      else {

        // Dimensions can wrap arbitrarily, so an index needs to be
        // computed in a more complex manner.  This is done by
        // grouping the edges for each dimension together into "bins"
        // and considering [edge_index] as an offset into the bin.
        // Each bin consists of two parts: the "forward" looking edges
        // and the "backward" looking edges for the dimension.

        edges_size_type vertex_offset = edge_index % num_edges(dimension_index);

        // Consider vertex_offset an index into the graph's vertex
        // space but with the dimension [dimension_index] reduced in
        // size by one.
        vertices_size_type index_divider = 1;

        for (std::size_t dimension_index_iter = 0;
             dimension_index_iter < Dimensions;
             ++dimension_index_iter) {

          std::size_t dimension_length = (dimension_index_iter == dimension_index) ?
            length(dimension_index_iter) - 1 :
            length(dimension_index_iter);

          vertex_source[dimension_index_iter] = (vertex_offset / index_divider) %
            dimension_length;

          index_divider *= dimension_length;
        }

        if (is_forward) {
          vertex_target = next(vertex_source, dimension_index);
        }
        else {
          // Shift forward one more unit in the dimension for backward
          // edges since the algorithm above will leave us one behind.
          vertex_target = vertex_source;
          ++vertex_source[dimension_index];
        }

      } // if (wrapped(dimension_index))
      
      return (std::make_pair(vertex_source, vertex_target));
    }

    degree_size_type out_degree(vertex_descriptor vertex) const {

      degree_size_type out_edge_count = 0;

      for (std::size_t dimension_index = 0;
           dimension_index < Dimensions;
           ++dimension_index) {

        // If the vertex is on the edge of this dimension, then its
        // number of out edges is dependent upon whether the dimension
        // wraps or not.
        if ((vertex[dimension_index] == 0) ||
            (vertex[dimension_index] == (length(dimension_index) - 1))) {
          out_edge_count += (wrapped(dimension_index) ? 2 : 1);
        }
        else {
          // Next and previous edges, regardless or wrapping
          out_edge_count += 2;
        }
      }

      return (out_edge_count);
    }

    edge_descriptor out_edge_at
    (vertex_descriptor vertex,
     degree_size_type out_edge_index) const {

      edges_size_type edges_left = out_edge_index + 1;
      std::size_t dimension_index = 0;
      bool is_forward = false;

      // Walks the out edges of [vertex] and accommodates for dimension
      // wrapping.
      while (edges_left > 0) {

        if (!wrapped(dimension_index)) {
          if (!is_forward && (vertex[dimension_index] == 0)) {
            is_forward = true;
            continue;
          }
          else if (is_forward &&
                   (vertex[dimension_index] == (length(dimension_index) - 1))) {
            is_forward = false;
            ++dimension_index;
            continue;
          }
        }

        --edges_left;

        if (edges_left > 0) {
          is_forward = !is_forward;
        
          if (!is_forward) {
            ++dimension_index;
          }
        }
      }

      return (std::make_pair(vertex, is_forward ?
                             next(vertex, dimension_index) :
                             previous(vertex, dimension_index)));
    }

    inline degree_size_type in_degree(vertex_descriptor vertex) const {
      return (out_degree(vertex));
    }

    edge_descriptor in_edge_at
    (vertex_descriptor vertex,
     edges_size_type in_edge_index) const {

      edge_descriptor out_edge = out_edge_at(vertex, in_edge_index);
      return (std::make_pair(target(out_edge, *this), source(out_edge, *this)));

    }

    void precalculate() {
      m_num_vertices =
        std::accumulate(m_dimension_lengths.begin(),
                        m_dimension_lengths.end(),
                        vertices_size_type(1),
                        std::multiplies<vertices_size_type>());

      // Calculate number of edges in each dimension
      m_num_edges = 0;

      for (std::size_t dimension_index = 0;
           dimension_index < Dimensions;
           ++dimension_index) {

        if (wrapped(dimension_index)) {
          m_edge_count[dimension_index] = num_vertices() * 2;
        }
        else {
          m_edge_count[dimension_index] =
            (num_vertices() - (num_vertices() / length(dimension_index))) * 2;
        }

        m_num_edges += num_edges(dimension_index);
      }
    }

  explicit bc_clustering_threshold(T threshold) 
    : threshold(threshold), dividend(1.0) {}

  template<typename Graph>
  bc_clustering_threshold(T threshold, const Graph& g, bool normalize = true)
    : threshold(threshold), dividend(1.0)
  {
    if (normalize) {
      typename graph_traits<Graph>::vertices_size_type n = num_vertices(g);
      dividend = T((n - 1) * (n - 2)) / T(2);
    }
  }

  template<typename Graph, typename Edge>
  bool operator()(T max_centrality, Edge, const Graph&)
  {
    return (max_centrality / dividend) < threshold;
  }

template<typename MutableGraph, typename Done, typename EdgeCentralityMap,
         typename VertexIndexMap>
void 
betweenness_centrality_clustering(MutableGraph& g, Done done,
                                  EdgeCentralityMap edge_centrality,
                                  VertexIndexMap vertex_index)
{
  typedef typename property_traits<EdgeCentralityMap>::value_type
    centrality_type;
  typedef typename graph_traits<MutableGraph>::edge_iterator edge_iterator;
  typedef typename graph_traits<MutableGraph>::edge_descriptor edge_descriptor;
  typedef typename graph_traits<MutableGraph>::vertices_size_type
    vertices_size_type;

  if (has_no_edges(g)) return;

  // Function object that compares the centrality of edges
  indirect_cmp<EdgeCentralityMap, std::less<centrality_type> > 
    cmp(edge_centrality);

  bool is_done;
  do {
    brandes_betweenness_centrality(g, 
                                   edge_centrality_map(edge_centrality)
                                   .vertex_index_map(vertex_index));
    std::pair<edge_iterator, edge_iterator> edges_iters = edges(g);
    edge_descriptor e = *max_element(edges_iters.first, edges_iters.second, cmp);
    is_done = done(get(edge_centrality, e), e, g);
    if (!is_done) remove_edge(e, g);
  } while (!is_done && !has_no_edges(g));
}
 
template<typename MutableGraph, typename Done, typename EdgeCentralityMap>
void 
betweenness_centrality_clustering(MutableGraph& g, Done done,
                                  EdgeCentralityMap edge_centrality)
{
  betweenness_centrality_clustering(g, done, edge_centrality,
                                    get(vertex_index, g));
}
 
template<typename MutableGraph, typename Done>
void
betweenness_centrality_clustering(MutableGraph& g, Done done)
{
  typedef typename Done::centrality_type centrality_type;
  std::vector<centrality_type> edge_centrality(num_edges(g));
  betweenness_centrality_clustering(g, done, 
    make_iterator_property_map(edge_centrality.begin(), get(edge_index, g)),
    get(vertex_index, g));
}

      matrix_edge_desc_impl() { }

      matrix_edge_desc_impl(bool exists, Vertex s, Vertex d,
                            const void* ep = 0)
        : Base(s, d, ep), m_exists(exists) { }

      bool exists() const { return m_exists; }

      template <class Edge>
      bool operator()(const Edge& e) const { return e.exists(); }

    template <typename EdgeProperty>
    bool get_edge_exists(const std::pair<bool, EdgeProperty>& stored_edge, int) {
      return stored_edge.first;
    }


    template <typename EdgeProxy>
    bool get_edge_exists(const EdgeProxy& edge_proxy, ...) {
      return edge_proxy;
    }

    template <typename EdgeProperty>
    const EdgeProperty&
    get_edge_property(const std::pair<bool, EdgeProperty>& stored_edge) {
      return stored_edge.second;
    }


    inline const no_property& get_edge_property(const char&) {
      static no_property s_prop;
      return s_prop;
    }

    inline no_property& get_edge_property(char&) {
      static no_property s_prop;
      return s_prop;
    }


        dir_adj_matrix_out_edge_iter() { }


        dir_adj_matrix_out_edge_iter(
            const MatrixIter& i
          , const VertexDescriptor& src
          , const VerticesSizeType& n
           )
            : super_t(i), m_src(src), m_targ(0), m_n(n)
        { }


        void increment() {
            ++this->base_reference();
            ++m_targ;
        }


        inline EdgeDescriptor
        dereference() const
        {
            return EdgeDescriptor(get_edge_exists(*this->base(), 0),
                                  m_src, m_targ,
                                  &get_edge_property(*this->base()));
        }


        dir_adj_matrix_in_edge_iter() { }


        dir_adj_matrix_in_edge_iter(
            const MatrixIter& i
          , const MatrixIter& last
          , const VertexDescriptor& tgt
          , const VerticesSizeType& n
           )
          : super_t(i), m_last(last), m_src(0), m_targ(tgt), m_n(n)
        { }


        void increment() {
          if (VerticesSizeType(m_last - this->base_reference()) >= m_n) {
            this->base_reference() += m_n;
            ++m_src;
          } else {
            this->base_reference() = m_last;
          }
        }


        inline EdgeDescriptor
        dereference() const
        {
            return EdgeDescriptor(get_edge_exists(*this->base(), 0),
                                  m_src, m_targ,
                                  &get_edge_property(*this->base()));
        }


        undir_adj_matrix_out_edge_iter() { }


        undir_adj_matrix_out_edge_iter(
            const MatrixIter& i
          , const VertexDescriptor& src
          , const VerticesSizeType& n
        )
          : super_t(i), m_src(src), m_inc(src), m_targ(0), m_n(n)
        {}


        void increment()
        {
            if (m_targ < m_src)     // first half
            {
                ++this->base_reference();
            }
            else if (m_targ < m_n - 1)
            {                  // second half
                ++m_inc;
                this->base_reference() += m_inc;
            }
            else
            {                  // past-the-end
                this->base_reference() += m_n - m_src;
            }
            ++m_targ;
        }


        inline EdgeDescriptor
        dereference() const
        {
            return EdgeDescriptor(get_edge_exists(*this->base(), 0),
                                  m_src, m_targ,
                                  &get_edge_property(*this->base()));
        }


        undir_adj_matrix_in_edge_iter() { }


        undir_adj_matrix_in_edge_iter(
            const MatrixIter& i
          , const VertexDescriptor& src
          , const VerticesSizeType& n
        )
          : super_t(i), m_src(src), m_inc(src), m_targ(0), m_n(n)
        {}


        void increment()
        {
            if (m_targ < m_src)     // first half
            {
                ++this->base_reference();
            }
            else if (m_targ < m_n - 1)
            {                  // second half
                ++m_inc;
                this->base_reference() += m_inc;
            }
            else
            {                  // past-the-end
                this->base_reference() += m_n - m_src;
            }
            ++m_targ;
        }


        inline EdgeDescriptor
        dereference() const
        {
            return EdgeDescriptor(get_edge_exists(*this->base(), 0),
                                  m_targ, m_src,
                                  &get_edge_property(*this->base()));
        }


        adj_matrix_edge_iter() { }


        adj_matrix_edge_iter(const MatrixIter& i, const MatrixIter& start, const VerticesSizeType& n)
            : super_t(i), m_start(start), m_src(0), m_targ(0), m_n(n) { }


        void increment()
        {
            increment_dispatch(this->base_reference(), Directed());
        }


        void increment_dispatch(MatrixIter& i, directedS)
        {
            ++i;
            if (m_targ == m_n - 1)
            {
                m_targ = 0;
                ++m_src;
            }
            else
            {
                ++m_targ;
            }
        }


        void increment_dispatch(MatrixIter& i, undirectedS)
        {
            ++i;
            if (m_targ == m_src)
            {
                m_targ = 0;
                ++m_src;
            }
            else
            {
                ++m_targ;
            }
        }


        inline EdgeDescriptor
        dereference() const
        {
            return EdgeDescriptor(get_edge_exists(*this->base(), 0),
                                  m_src, m_targ,
                                  &get_edge_property(*this->base()));
        }


    static type get_nonconst(adjacency_matrix<D, VP, EP, GP, A>& g, Prop prop) {
      return type(prop, all_map_type(g.m_vertex_properties.begin(), vi_map_type()));
    }


    static const_type get_const(const adjacency_matrix<D, VP, EP, GP, A>& g, Prop prop) {
      return const_type(prop, all_map_const_type(g.m_vertex_properties.begin(), vi_map_type()));
    }


    static single_nonconst_type get_nonconst_one(adjacency_matrix<D, VP, EP, GP, A>& g, Prop prop, arg_type v) {
      return lookup_one_property<VP, Prop>::lookup(g.m_vertex_properties[v], prop);
    }


    static single_const_type get_const_one(const adjacency_matrix<D, VP, EP, GP, A>& g, Prop prop, arg_type v) {
      return lookup_one_property<const VP, Prop>::lookup(g.m_vertex_properties[v], prop);
    }


    template <typename G>
    inline typename graph_traits<G>::vertex_descriptor
    graph_traits<G>::null_vertex()
    { return G::null_vertex(); }

        inline bool is_directed(directed_tag) { return true; }

        inline bool is_directed(undirected_tag) { return false; }

    template <typename Graph>
    bool is_directed(const Graph&) {
        typedef typename graph_traits<Graph>::directed_category Cat;
        return detail::is_directed(Cat());
    }

    template <typename Graph>
    bool is_undirected(const Graph& g) {
        return !is_directed(g);
    }

        inline bool allows_parallel(allow_parallel_edge_tag) { return true; }

        inline bool allows_parallel(disallow_parallel_edge_tag) { return false; }


    template <typename Graph>
    bool allows_parallel_edges(const Graph&) {
        typedef typename graph_traits<Graph>::edge_parallel_category Cat;
        return detail::allows_parallel(Cat());
    }

      components_recorder(ComponentsMap c, 
                          comp_type& c_count)
        : m_component(c), m_count(c_count) {}


      template <class Vertex, class Graph>
      void start_vertex(Vertex, Graph&) {
        if (m_count == (std::numeric_limits<comp_type>::max)())
          m_count = 0; // start counting components at zero
        else
          ++m_count;
      }

      template <class Vertex, class Graph>
      void discover_vertex(Vertex u, Graph&) {
        put(m_component, u, m_count);
      }


  template <class Graph, class ComponentMap, class P, class T, class R>
  inline typename property_traits<ComponentMap>::value_type
  connected_components(const Graph& g, ComponentMap c, 
                       const bgl_named_params<P, T, R>& params
                       BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, vertex_list_graph_tag))
  {
    if (num_vertices(g) == 0) return 0;

    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( WritablePropertyMapConcept<ComponentMap, Vertex> ));
    typedef typename boost::graph_traits<Graph>::directed_category directed;
    BOOST_STATIC_ASSERT((boost::is_same<directed, undirected_tag>::value));

    typedef typename property_traits<ComponentMap>::value_type comp_type;
    // c_count initialized to "nil" (with nil represented by (max)())
    comp_type c_count((std::numeric_limits<comp_type>::max)());
    detail::components_recorder<ComponentMap> vis(c, c_count);
    depth_first_search(g, params.visitor(vis));
    return c_count + 1;
  }


  template <class Graph, class ComponentMap>
  inline typename property_traits<ComponentMap>::value_type
  connected_components(const Graph& g, ComponentMap c
                       BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, vertex_list_graph_tag))
  {
    if (num_vertices(g) == 0) return 0;

    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( WritablePropertyMapConcept<ComponentMap, Vertex> ));
    typedef typename boost::graph_traits<Graph>::directed_category directed;
    // BOOST_STATIC_ASSERT((boost::is_same<directed, undirected_tag>::value));

    typedef typename property_traits<ComponentMap>::value_type comp_type;
    // c_count initialized to "nil" (with nil represented by (max)())
    comp_type c_count((std::numeric_limits<comp_type>::max)());
    detail::components_recorder<ComponentMap> vis(c, c_count);
    depth_first_search(g, visitor(vis));
    return c_count + 1;
  }

  template <class T>
  inline T numeric_limits_max(T) { return (std::numeric_limits<T>::max)(); }

      functor_to_visitor(const Visitor& visitor) : Visitor(visitor) {}

    template <class T, class Graph>
    void operator()(T, Graph&) { }

    template <class T, class Graph>
    void operator()(T, Graph&) { }

    template <class Visitor, class T, class Graph>
    inline void invoke_dispatch(Visitor& v, T x, Graph& g, mpl::true_) {
       v(x, g);
    }


    template <class Visitor, class T, class Graph>
    inline void invoke_dispatch(Visitor&, T, Graph&, mpl::false_)
    { }

    predecessor_recorder(PredecessorMap pa) : m_predecessor(pa) { }

    template <class Edge, class Graph>
    void operator()(Edge e, const Graph& g) {
      put(m_predecessor, target(e, g), source(e, g));
    }

  template <class PredecessorMap, class Tag>
  predecessor_recorder<PredecessorMap, Tag>
  record_predecessors(PredecessorMap pa, Tag) {
    return predecessor_recorder<PredecessorMap, Tag> (pa);
  }

    edge_predecessor_recorder(PredEdgeMap pa) : m_predecessor(pa) { }

    template <class Edge, class Graph>
    void operator()(Edge e, const Graph& g) {
      put(m_predecessor, target(e, g), e);
    }

  template <class PredEdgeMap, class Tag>
  edge_predecessor_recorder<PredEdgeMap, Tag>
  record_edge_predecessors(PredEdgeMap pa, Tag) {
    return edge_predecessor_recorder<PredEdgeMap, Tag> (pa);
  }

    distance_recorder(DistanceMap pa) : m_distance(pa) { }

    template <class Edge, class Graph>
    void operator()(Edge e, const Graph& g) {
      typename graph_traits<Graph>::vertex_descriptor
        u = source(e, g), v = target(e, g);
      put(m_distance, v, get(m_distance, u) + 1);
    }

  template <class DistanceMap, class Tag>
  distance_recorder<DistanceMap, Tag>
  record_distances(DistanceMap pa, Tag) {
    return distance_recorder<DistanceMap, Tag> (pa);
  }

    time_stamper(TimeMap pa, TimeT& t) : m_time_pa(pa), m_time(t) { }

    template <class Vertex, class Graph>
    void operator()(Vertex u, const Graph&) {
      put(m_time_pa, u, ++m_time);
    }

  template <class TimeMap, class TimeT, class Tag>
  time_stamper<TimeMap, TimeT, Tag>
  stamp_times(TimeMap pa, TimeT& time_counter, Tag) {
    return time_stamper<TimeMap, TimeT, Tag>(pa, time_counter);
  }


    property_writer(PA pa, OutputIterator out) : m_pa(pa), m_out(out) { }


    template <class T, class Graph>
    void operator()(T x, Graph&) { *m_out++ = get(m_pa, x); }

  template <class PA, class OutputIterator, class Tag>
  property_writer<PA, OutputIterator, Tag>
  write_property(PA pa, OutputIterator out, Tag) {
    return property_writer<PA, OutputIterator, Tag>(pa, out);
  }

    
    property_put (PropertyMap property_map,
                  typename property_traits <PropertyMap>::value_type value) :
      property_map_ (property_map), value_ (value)
    {}


    template <typename VertexOrEdge, typename Graph>
    void operator() (VertexOrEdge v, const Graph&)
    {
      put (property_map_, v, value_);
    }


    template <typename PropertyMap, typename EventTag>
    inline property_put <PropertyMap, EventTag>
    put_property (PropertyMap property_map,
                  typename property_traits <PropertyMap>::value_type value,
                  EventTag)
    {
      return property_put <PropertyMap, EventTag> (property_map, value);
    }

    virtual ~loop_erased_random_walk_stuck() throw() {}

    inline virtual const char* what() const throw() {
      return "Loop-erased random walk found a vertex with no out-edges";
    }


  template <typename Graph, typename ColorMap, typename NextEdge>
  void loop_erased_random_walk(
         const Graph& g,
         typename boost::graph_traits<Graph>::vertex_descriptor s,
         NextEdge next_edge,
         ColorMap color,
         std::vector<typename boost::graph_traits<Graph>::vertex_descriptor>& path
  ) {
    typedef typename boost::graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename boost::graph_traits<Graph>::edge_descriptor edge_descriptor;
    typedef typename boost::property_traits<ColorMap>::value_type color_t;
    typedef boost::color_traits<color_t> color_gen;
    
    BOOST_ASSERT (get(color, s) == color_gen::white());
    path.clear();
    path.push_back(s);
    put(color, s, color_gen::gray());
    while (true) {
      edge_descriptor e = next_edge(s, g);
      vertex_descriptor t = target(e, g);
      color_t t_color = get(color, t);
      if (t_color == color_gen::white()) {
        path.push_back(t);
        put(color, t, color_gen::gray());
        s = t;
      } else if (t_color == color_gen::gray()) {
        // Found a loop; delete from path from the first occurrence of t to the
        // end, coloring vertices white.
        typename std::vector<vertex_descriptor>::iterator it = std::find(path.begin(), path.end(), t);
        BOOST_ASSERT (it != path.end());
        ++it;
        for (typename std::vector<vertex_descriptor>::iterator j = it; j != path.end(); ++j) {
          put(color, *j, color_gen::white());
        }
        path.erase(it, path.end());
        s = t;
      } else {
        // Done
        path.push_back(t);
        break;
      }
    }
  }

    unweighted_random_out_edge_gen(Gen& gen): gen(gen) {}


    typename gt::edge_descriptor
    operator()(typename gt::vertex_descriptor src, const Graph& g) const {
      if (out_degree(src, g) == 0) throw loop_erased_random_walk_stuck();
      return boost::random_out_edge(g, src, gen);
    }

    weighted_random_out_edge_gen(const WeightMap& weight, Gen& gen): weight(weight), gen(gen) {}


    typename gt::edge_descriptor
    operator()(typename gt::vertex_descriptor src, const Graph& g) const {
      if (out_degree(src, g) == 0) throw loop_erased_random_walk_stuck();
      return boost::weighted_random_out_edge(g, src, weight, gen);
    }


  VertexProperty operator()(const vertex_name_type& name)
  {
    return VertexProperty(name);
  }


  VertexProperty operator()(const vertex_name_type&)
  {
      boost::throw_exception(std::runtime_error("add_vertex: "
                                                "unable to create a vertex from its name"));
  }


    extract_name_from_vertex(Graph& graph, const extract_name_type& extract)
      : graph(graph), extract(extract) { }


    const result_type& operator()(Vertex vertex) const
    {
      return extract(graph[vertex]);
    }

  Graph&       derived()       { return static_cast<Graph&>(*this); }

  const Graph& derived() const { return static_cast<const Graph&>(*this); }


template<BGL_NAMED_GRAPH_PARAMS>
BGL_NAMED_GRAPH::named_graph(const extract_name_type& extract,
                             const vertex_constructor_type& vertex_constructor)
  : named_vertices(
      typename named_vertices_type::ctor_args_list(
        boost::make_tuple(
          boost::make_tuple(
            0, // initial number of buckets
            extract_name_from_vertex(derived(), extract),
            boost::hash<vertex_name_type>(),
            std::equal_to<vertex_name_type>())))),
    vertex_constructor(vertex_constructor)
{
}


template<BGL_NAMED_GRAPH_PARAMS>
inline void BGL_NAMED_GRAPH::added_vertex(Vertex vertex)
{
  named_vertices.insert(vertex);
}

template<typename VertexIterStability>
inline void BGL_NAMED_GRAPH::removing_vertex(Vertex vertex, VertexIterStability)
{
  BOOST_STATIC_ASSERT_MSG ((boost::is_base_of<boost::graph_detail::stable_tag, VertexIterStability>::value), "Named graphs cannot use vecS as vertex container and remove vertices; the lack of vertex descriptor stability (which iterator stability is a proxy for) means that the name -> vertex mapping would need to be completely rebuilt after each deletion.  See https://svn.boost.org/trac/boost/ticket/7863 for more information and a test case.");
  typedef typename BGL_NAMED_GRAPH::vertex_name_type vertex_name_type;
  const vertex_name_type& vertex_name = extract_name(derived()[vertex]);
  named_vertices.erase(vertex_name);
}


template<BGL_NAMED_GRAPH_PARAMS>
inline void BGL_NAMED_GRAPH::clearing_graph()
{
  named_vertices.clear();
}


template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::extract_name_type::result_type
BGL_NAMED_GRAPH::extract_name(const bundled_vertex_property_type& property)
{
  return named_vertices.key_extractor().extract(property);
}


template<BGL_NAMED_GRAPH_PARAMS>
optional<typename BGL_NAMED_GRAPH::vertex_descriptor>
BGL_NAMED_GRAPH::
vertex_by_property(const bundled_vertex_property_type& property)
{
  return find_vertex(extract_name(property), *this);
}

template<BGL_NAMED_GRAPH_PARAMS>
optional<Vertex>
find_vertex(typename BGL_NAMED_GRAPH::vertex_name_type const& name,
            const BGL_NAMED_GRAPH& g)
{
  typedef typename BGL_NAMED_GRAPH::vertices_by_name_type
    vertices_by_name_type;

  // Retrieve the set of vertices indexed by name
  vertices_by_name_type const& vertices_by_name
    = g.named_vertices.template get<vertex_name_t>();

  /// Look for a vertex with the given name
  typename vertices_by_name_type::const_iterator iter
    = vertices_by_name.find(name);

  if (iter == vertices_by_name.end())
    return optional<Vertex>(); // vertex not found
  else
    return *iter;
}

template<BGL_NAMED_GRAPH_PARAMS>
    typename disable_if<is_same<
        typename BGL_NAMED_GRAPH::vertex_name_type,
        VertexProperty
    >,
Vertex>::type
add_vertex(typename BGL_NAMED_GRAPH::vertex_name_type const& name,
           BGL_NAMED_GRAPH& g)
{
  if (optional<Vertex> vertex = find_vertex(name, g))
    /// We found the vertex, so return it
    return *vertex;
  else
    /// There is no vertex with the given name, so create one
    return add_vertex(g.vertex_constructor(name), g.derived());
}

  void added_vertex(Vertex) { }

  template <typename VertexIterStability>
  void removing_vertex(Vertex, VertexIterStability) { }

  void clearing_graph() { }

  optional<Vertex>
  vertex_by_property(const bundled_vertex_property_type&)
  {
    return optional<Vertex>();
  }

      tarjan_scc_visitor(ComponentMap comp_map, RootMap r, DiscoverTime d, 
                         comp_type& c_, Stack& s_)
        : c(c_), comp(comp_map), root(r), discover_time(d),
          dfs_time(time_type()), s(s_) { }


      template <typename Graph>
      void discover_vertex(typename graph_traits<Graph>::vertex_descriptor v,
                           const Graph&) {
        put(root, v, v);
        put(comp, v, (std::numeric_limits<comp_type>::max)());
        put(discover_time, v, dfs_time++);
        s.push(v);
      }

      template <typename Graph>
      void finish_vertex(typename graph_traits<Graph>::vertex_descriptor v,
                         const Graph& g) {
        typename graph_traits<Graph>::vertex_descriptor w;
        typename graph_traits<Graph>::out_edge_iterator ei, ei_end;
        for (boost::tie(ei, ei_end) = out_edges(v, g); ei != ei_end; ++ei) {
          w = target(*ei, g);
          if (get(comp, w) == (std::numeric_limits<comp_type>::max)())
            put(root, v, this->min_discover_time(get(root,v), get(root,w)));
        }
        if (get(root, v) == v) {
          do {
            w = s.top(); s.pop();
            put(comp, w, c);
          } while (w != v);
          ++c;
        }
      }

      template <typename Vertex>
      Vertex min_discover_time(Vertex u, Vertex v) {
        return get(discover_time, u) < get(discover_time,v) ? u : v;
      }

    
    template <class Graph, class ComponentMap, class RootMap,
              class DiscoverTime, class P, class T, class R>
    typename property_traits<ComponentMap>::value_type
    strong_components_impl
      (const Graph& g,    // Input
       ComponentMap comp, // Output
       // Internal record keeping
       RootMap root, 
       DiscoverTime discover_time,
       const bgl_named_params<P, T, R>& params)
    {
      typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<ComponentMap, Vertex> ));
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<RootMap, Vertex> ));
      typedef typename property_traits<RootMap>::value_type RootV;
      BOOST_CONCEPT_ASSERT(( ConvertibleConcept<RootV, Vertex> ));
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<DiscoverTime, Vertex> ));

      typename property_traits<ComponentMap>::value_type total = 0;

      std::stack<Vertex> s;
      detail::tarjan_scc_visitor<ComponentMap, RootMap, DiscoverTime, 
        std::stack<Vertex> > 
        vis(comp, root, discover_time, total, s);
      depth_first_search(g, params.visitor(vis));
      return total;
    }

      template <class Graph, class ComponentMap, class RootMap, class P, class T, class R>
      inline static typename property_traits<ComponentMap>::value_type
      apply(const Graph& g,
            ComponentMap comp,
            RootMap r_map,
            const bgl_named_params<P, T, R>& params,
            DiscoverTimeMap time_map)
      {
        return strong_components_impl(g, comp, r_map, time_map, params);
      }

      template <class Graph, class ComponentMap, class RootMap,
                class P, class T, class R>
      inline static typename property_traits<ComponentMap>::value_type
      apply(const Graph& g,
            ComponentMap comp,
            RootMap r_map,
            const bgl_named_params<P, T, R>& params,
            param_not_found)
      {
        typedef typename graph_traits<Graph>::vertices_size_type size_type;
        size_type       n = num_vertices(g) > 0 ? num_vertices(g) : 1;
        std::vector<size_type> time_vec(n);
        return strong_components_impl
          (g, comp, r_map,
           make_iterator_property_map(time_vec.begin(), choose_const_pmap
                                      (get_param(params, vertex_index),
                                       g, vertex_index), time_vec[0]),
           params);
      }


    template <class Graph, class ComponentMap, class RootMap,
              class P, class T, class R, class DiscoverTimeMap>
    inline typename property_traits<ComponentMap>::value_type
    scc_helper2(const Graph& g,
                ComponentMap comp,
                RootMap r_map,
                const bgl_named_params<P, T, R>& params,
                DiscoverTimeMap time_map)
    {
      return strong_comp_dispatch2<DiscoverTimeMap>::apply(g, comp, r_map, params, time_map);
    }


      template <class Graph, class ComponentMap, class P, class T, class R>
      inline static typename property_traits<ComponentMap>::value_type
      apply(const Graph& g,
            ComponentMap comp,
            const bgl_named_params<P, T, R>& params,
            RootMap r_map)
      {
        return scc_helper2(g, comp, r_map, params, get_param(params, vertex_discover_time));
      }


      template <class Graph, class ComponentMap, 
                class P, class T, class R>
      inline static typename property_traits<ComponentMap>::value_type
      apply(const Graph& g,
            ComponentMap comp,
            const bgl_named_params<P, T, R>& params,
            param_not_found)
      {
        typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
        typename std::vector<Vertex>::size_type
          n = num_vertices(g) > 0 ? num_vertices(g) : 1;
        std::vector<Vertex> root_vec(n);
        return scc_helper2
          (g, comp, 
           make_iterator_property_map(root_vec.begin(), choose_const_pmap
                                      (get_param(params, vertex_index),
                                       g, vertex_index), root_vec[0]),
           params, 
           get_param(params, vertex_discover_time));
      }


    template <class Graph, class ComponentMap, class RootMap,
              class P, class T, class R>
    inline typename property_traits<ComponentMap>::value_type
    scc_helper1(const Graph& g,
               ComponentMap comp,
               const bgl_named_params<P, T, R>& params,
               RootMap r_map)
    {
      return detail::strong_comp_dispatch1<RootMap>::apply(g, comp, params,
                                                           r_map);
    }


  template <class Graph, class ComponentMap, 
            class P, class T, class R>
  inline typename property_traits<ComponentMap>::value_type
  strong_components(const Graph& g, ComponentMap comp,
                    const bgl_named_params<P, T, R>& params
                    BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, vertex_list_graph_tag))
  {
    typedef typename graph_traits<Graph>::directed_category DirCat;
    BOOST_STATIC_ASSERT((is_convertible<DirCat*, directed_tag*>::value == true));
    return detail::scc_helper1(g, comp, params, 
                               get_param(params, vertex_root_t()));
  }


  template <class Graph, class ComponentMap>
  inline typename property_traits<ComponentMap>::value_type
  strong_components(const Graph& g, ComponentMap comp
                    BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, vertex_list_graph_tag))
  {
    typedef typename graph_traits<Graph>::directed_category DirCat;
    BOOST_STATIC_ASSERT((is_convertible<DirCat*, directed_tag*>::value == true));
    bgl_named_params<int, int> params(0);
    return strong_components(g, comp, params);
  }


  template <typename Graph, typename ComponentMap, typename ComponentLists>
  void build_component_lists
    (const Graph& g,
     typename graph_traits<Graph>::vertices_size_type num_scc,
     ComponentMap component_number,
     ComponentLists& components)
  {
    components.resize(num_scc);
    typename graph_traits<Graph>::vertex_iterator vi, vi_end;
    for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi)
      components[component_number[*vi]].push_back(*vi);
  }


  template <class Graph, class DFSVisitor, class ComponentsMap,
            class DiscoverTime, class FinishTime,
            class ColorMap>
  typename property_traits<ComponentsMap>::value_type
  kosaraju_strong_components(Graph& G, ComponentsMap c,
                             FinishTime finish_time, ColorMap color)
  {
    BOOST_CONCEPT_ASSERT(( MutableGraphConcept<Graph> ));
    // ...
    
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;
    typename property_traits<FinishTime>::value_type time = 0;
    depth_first_search
     (G, make_dfs_visitor(stamp_times(finish_time, time, on_finish_vertex())),
      color);

    Graph G_T(num_vertices(G));
    transpose_graph(G, G_T);

    typedef typename property_traits<ComponentsMap>::value_type count_type;

    count_type c_count(0);
    detail::components_recorder<ComponentsMap>
      vis(c, c_count);

    // initialize G_T
    typename graph_traits<Graph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(G_T); ui != ui_end; ++ui)
      put(color, *ui, Color::white());

    typedef typename property_traits<FinishTime>::value_type D;
    typedef indirect_cmp< FinishTime, std::less<D> > Compare;

    Compare fl(finish_time);
    std::priority_queue<Vertex, std::vector<Vertex>, Compare > Q(fl);

    typename graph_traits<Graph>::vertex_iterator i, j, iend, jend;
    boost::tie(i, iend) = vertices(G_T);
    boost::tie(j, jend) = vertices(G);
    for ( ; i != iend; ++i, ++j) {
      put(finish_time, *i, get(finish_time, *j));
       Q.push(*i);
    }

    while ( !Q.empty() ) {
      Vertex u = Q.top();
      Q.pop();
      if  (get(color, u) == Color::white()) {
        depth_first_visit(G_T, u, vis, color);
        ++c_count; 
      }
    }
    return c_count;
  }

    template <typename T>
    bool operator()(const T&) const { return true; }

    is_residual_edge() { }

    is_residual_edge(ResidualCapacityEdgeMap rcap) : m_rcap(rcap) { }

    template <typename Edge>
    bool operator()(const Edge& e) const {
      return 0 < get(m_rcap, e);
    }

    is_in_subset() : m_s(0) { }

    is_in_subset(const Set& s) : m_s(&s) { }


    template <typename Elt>
    bool operator()(const Elt& x) const {
      return set_contains(*m_s, x);
    }

    is_not_in_subset() : m_s(0) { }

    is_not_in_subset(const Set& s) : m_s(&s) { }


    template <typename Elt>
    bool operator()(const Elt& x) const {
      return !set_contains(*m_s, x);
    }

      out_edge_predicate() { }

      out_edge_predicate(EdgePredicate ep, VertexPredicate vp, 
                         const Graph& g)
        : m_edge_pred(ep), m_vertex_pred(vp), m_g(&g) { }


      template <typename Edge>
      bool operator()(const Edge& e) const {
        return m_edge_pred(e) && m_vertex_pred(target(e, *m_g));
      }

      in_edge_predicate() { }

      in_edge_predicate(EdgePredicate ep, VertexPredicate vp, 
                         const Graph& g)
        : m_edge_pred(ep), m_vertex_pred(vp), m_g(&g) { }


      template <typename Edge>
      bool operator()(const Edge& e) const {
        return m_edge_pred(e) && m_vertex_pred(source(e, *m_g));
      }

      edge_predicate() { }

      edge_predicate(EdgePredicate ep, VertexPredicate vp, 
                     const Graph& g)
        : m_edge_pred(ep), m_vertex_pred(vp), m_g(&g) { }


      template <typename Edge>
      bool operator()(const Edge& e) const {
        return m_edge_pred(e)
          && m_vertex_pred(source(e, *m_g)) && m_vertex_pred(target(e, *m_g));
      }

    filtered_graph_base(const G& g) : m_g(g) { }

    filtered_graph(const Graph& g, EdgePredicate ep)
      : Base(g), m_edge_pred(ep) { }


    filtered_graph(const Graph& g, EdgePredicate ep, VertexPredicate vp)
      : Base(g), m_edge_pred(ep), m_vertex_pred(vp) { }

    template<typename Descriptor>
    typename graph::detail::bundled_result<Graph, Descriptor>::type&
    operator[](Descriptor x)
    { return const_cast<Graph&>(this->m_g)[x]; }


    template<typename Descriptor>
    typename graph::detail::bundled_result<Graph, Descriptor>::type const&
    operator[](Descriptor x) const
    { return this->m_g[x]; }


    static vertex_descriptor null_vertex()
    {
       return Traits::null_vertex();
    }

  template <typename Graph, typename EdgePredicate>
  inline filtered_graph<Graph, EdgePredicate>
  make_filtered_graph(Graph& g, EdgePredicate ep) {
    return filtered_graph<Graph, EdgePredicate>(g, ep);
  }

  template <typename Graph, typename EdgePredicate, typename VertexPredicate>
  inline filtered_graph<Graph, EdgePredicate, VertexPredicate>
  make_filtered_graph(Graph& g, EdgePredicate ep, VertexPredicate vp) {
    return filtered_graph<Graph, EdgePredicate, VertexPredicate>(g, ep, vp);
  }

  template <typename Graph, typename EdgePredicate, typename VertexPredicate>
  inline filtered_graph<const Graph, EdgePredicate, VertexPredicate>
  make_filtered_graph(const Graph& g, EdgePredicate ep, VertexPredicate vp) {
    return filtered_graph<const Graph, EdgePredicate, VertexPredicate>(g, ep, vp);
  }


  template <typename G, typename EP, typename VP, typename Property,
            typename Key>
  typename property_map_value<G, Property>::type
  get(Property p, const filtered_graph<G, EP, VP>& g, const Key& k)
  {
    return get(p, (const G&)g.m_g, k);
  }


  template <typename G, typename EP, typename VP, typename Property, 
            typename Key, typename Value>
  void
  put(Property p, const filtered_graph<G, EP, VP>& g, const Key& k,
      const Value& val)
  {
    put(p, const_cast<G&>(g.m_g), k, val);
  }

  template <typename Graph, typename Set>
  inline typename vertex_subset_filter<Graph, Set>::type
  make_vertex_subset_filter(Graph& g, const Set& s) {
    typedef typename vertex_subset_filter<Graph, Set>::type Filter;
    is_in_subset<Set> p(s);
    return Filter(g, keep_all(), p);
  }

  template <typename Graph, typename Set>
  inline typename vertex_subset_compliment_filter<Graph, Set>::type
  make_vertex_subset_compliment_filter(Graph& g, const Set& s) {
    typedef typename vertex_subset_compliment_filter<Graph, Set>::type Filter;
    is_not_in_subset<Set> p(s);
    return Filter(g, keep_all(), p);
  }

  template <typename Graph, typename Set>
  inline typename vertex_subset_complement_filter<Graph, Set>::type
  make_vertex_subset_complement_filter(Graph& g, const Set& s) {
    typedef typename vertex_subset_complement_filter<Graph, Set>::type Filter;
    is_not_in_subset<Set> p(s);
    return Filter(g, keep_all(), p);
  }

    
    property_map_filter() { }

      
    property_map_filter(const PropertyMap& property_map) :
      m_property_map(property_map) { }

    
    template <typename Key>
    bool operator()(const Key& key) const {
      return (get(m_property_map, key));
    }

    
    vf2_print_callback(const Graph1& graph1, const Graph2& graph2) 
      : graph1_(graph1), graph2_(graph2) {}

    
    template <typename CorrespondenceMap1To2,
              typename CorrespondenceMap2To1>
    bool operator()(CorrespondenceMap1To2 f, CorrespondenceMap2To1) const {
      
      // Print (sub)graph isomorphism map
      BGL_FORALL_VERTICES_T(v, graph1_, Graph1) 
        std::cout << '(' << get(vertex_index_t(), graph1_, v) << ", " 
                  << get(vertex_index_t(), graph2_, get(f, v)) << ") ";
      
      std::cout << std::endl;
      
      return true;
    }


      base_state(const GraphThis& graph_this, const GraphOther& graph_other,
                 IndexMapThis index_map_this, IndexMapOther index_map_other)
        : graph_this_(graph_this), graph_other_(graph_other), 
          index_map_this_(index_map_this), index_map_other_(index_map_other), 
          term_in_count_(0), term_out_count_(0), term_both_count_(0), core_count_(0) {

        core_vec_.resize(num_vertices(graph_this_), graph_traits<GraphOther>::null_vertex());
        core_ = make_iterator_property_map(core_vec_.begin(), index_map_this_);

        in_vec_.resize(num_vertices(graph_this_), 0);
        in_ = make_iterator_property_map(in_vec_.begin(), index_map_this_);

        out_vec_.resize(num_vertices(graph_this_), 0);
        out_ = make_iterator_property_map(out_vec_.begin(), index_map_this_);
      }

      void push(const vertex_this_type& v_this, const vertex_other_type& v_other) {

        ++core_count_;

        put(core_, v_this, v_other);

        if (!get(in_, v_this)) {   
          put(in_, v_this, core_count_);
          ++term_in_count_;
          if (get(out_, v_this))
            ++term_both_count_;
        }

        if (!get(out_, v_this)) {   
          put(out_, v_this, core_count_);
          ++term_out_count_;
          if (get(in_, v_this))
            ++term_both_count_;
        }

        BGL_FORALL_INEDGES_T(v_this, e, graph_this_, GraphThis) {
          vertex_this_type w = source(e, graph_this_);
          if (!get(in_, w)) {
            put(in_, w, core_count_);
            ++term_in_count_;
            if (get(out_, w))
              ++term_both_count_;
          }
        }
        
        BGL_FORALL_OUTEDGES_T(v_this, e, graph_this_, GraphThis) {
          vertex_this_type w = target(e, graph_this_);
          if (!get(out_, w)) {
            put(out_, w, core_count_);
            ++term_out_count_;
            if (get(in_, w))
              ++term_both_count_;                        
          }
        }
        
      }

      void pop(const vertex_this_type& v_this, const vertex_other_type&) {
        
        if (!core_count_) return;
        
        if (get(in_, v_this) == core_count_) {
          put(in_, v_this, 0);
          --term_in_count_;
          if (get(out_, v_this))
            --term_both_count_;
        }

        BGL_FORALL_INEDGES_T(v_this, e, graph_this_, GraphThis) {
          vertex_this_type w = source(e, graph_this_);
          if (get(in_, w) == core_count_) {
            put(in_, w, 0);
            --term_in_count_;
            if (get(out_, w))
              --term_both_count_;
          }
        }

        if (get(out_, v_this) == core_count_) {
          put(out_, v_this, 0);
          --term_out_count_;
          if (get(in_, v_this))
            --term_both_count_;
        }

        BGL_FORALL_OUTEDGES_T(v_this, e, graph_this_, GraphThis) {
          vertex_this_type w = target(e, graph_this_);
          if (get(out_, w) == core_count_) {
            put(out_, w, 0);
            --term_out_count_;
            if (get(in_, w))
              --term_both_count_;
          }
        }
        put(core_, v_this, graph_traits<GraphOther>::null_vertex());

        --core_count_;
        
      }

      bool term_in() const {
        return core_count_ < term_in_count_ ;
      }

      bool term_in(const vertex_this_type& v) const {
        return (get(in_, v) > 0) &&
               (get(core_, v) == graph_traits<GraphOther>::null_vertex());
      }

      bool term_out() const {
        return core_count_ < term_out_count_;
      }

      bool term_out(const vertex_this_type& v) const {
        return (get(out_, v) > 0) && 
               (get(core_, v) == graph_traits<GraphOther>::null_vertex());
      }

      bool term_both() const {
        return core_count_ < term_both_count_;
      }

      bool term_both(const vertex_this_type& v) const {
        return (get(in_, v) > 0) && (get(out_, v) > 0) && 
               (get(core_, v) == graph_traits<GraphOther>::null_vertex());
      }

      bool in_core(const vertex_this_type& v) const {
        return get(core_, v) != graph_traits<GraphOther>::null_vertex();
      }

      size_type count() const {
        return core_count_;
      }

      vertex_other_type core(const vertex_this_type& v) const {
        return get(core_, v);
      }

      core_map_type get_map() const {
        return core_;
      }

      size_type in_depth(const vertex_this_type& v) const {
        return get(in_, v);
      }

      size_type out_depth(const vertex_this_type& v) const {
        return get(out_, v);
      }

      boost::tuple<size_type, size_type, size_type>
      term_set() const {
        return boost::make_tuple(term_in_count_, term_out_count_, 
                                 term_both_count_);
      }


      template<typename EdgePredicate>
      bool operator()(typename graph_traits<Graph>::vertex_descriptor s,
                      typename graph_traits<Graph>::vertex_descriptor t, 
                      EdgePredicate is_valid_edge, const Graph& g) {
        
        BGL_FORALL_OUTEDGES_T(s, e, g, Graph) {
          if ((target(e, g) == t) && is_valid_edge(e) && 
              (matched_edges_.find(e) == matched_edges_.end())) {
            matched_edges_.insert(e);
            return true;
          }
        }

        return false;
      }

      
      edge1_predicate(EdgeEquivalencePredicate edge_comp, 
                      typename graph_traits<Graph2>::edge_descriptor e2)
        : edge_comp_(edge_comp), e2_(e2) {}

      
      bool operator()(typename graph_traits<Graph1>::edge_descriptor e1) {
        return edge_comp_(e1, e2_);
      }

      
      edge2_predicate(EdgeEquivalencePredicate edge_comp, 
                      typename graph_traits<Graph1>::edge_descriptor e1)
        : edge_comp_(edge_comp), e1_(e1) {}


      bool operator()(typename graph_traits<Graph2>::edge_descriptor e2) {
        return edge_comp_(e1_, e2);
      }

      inline bool comp_term_sets(graph1_size_type a, 
                                 graph2_size_type b,
                                 boost::mpl::int_<subgraph_mono>) const {
        return a <= b;
      }

      inline bool comp_term_sets(graph1_size_type a, 
                                 graph2_size_type b,
                                 boost::mpl::int_<subgraph_iso>) const {
        return a <= b;
      }

      inline bool comp_term_sets(graph1_size_type a, 
                                 graph2_size_type b,
                                 boost::mpl::int_<isomorphism>) const {
        return a == b;
      }


      state(const Graph1& graph1, const Graph2& graph2, 
            IndexMap1 index_map1, IndexMap2 index_map2, 
            EdgeEquivalencePredicate edge_comp,
            VertexEquivalencePredicate vertex_comp)
        : graph1_(graph1), graph2_(graph2), 
          index_map1_(index_map1), 
          edge_comp_(edge_comp), vertex_comp_(vertex_comp),
          state1_(graph1, graph2, index_map1, index_map2), 
          state2_(graph2, graph1, index_map2, index_map1) {}

      void push(const vertex1_type& v, const vertex2_type& w) {
        state1_.push(v, w);
        state2_.push(w, v);
      }

      void pop(const vertex1_type& v, const vertex2_type&) {
        vertex2_type w = state1_.core(v);
        state1_.pop(v, w);
        state2_.pop(w, v);
      }

      bool feasible(const vertex1_type& v_new, const vertex2_type& w_new) {
        
        if (!vertex_comp_(v_new, w_new)) return false;
        
        // graph1
        graph1_size_type term_in1_count = 0, term_out1_count = 0, rest1_count = 0;
        
        {
          equivalent_edge_exists<Graph2> edge2_exists;
          
          BGL_FORALL_INEDGES_T(v_new, e1, graph1_, Graph1) {
            vertex1_type v = source(e1, graph1_);
            
            if (state1_.in_core(v) || (v == v_new)) {
              vertex2_type w = w_new;
              if (v != v_new)
                w = state1_.core(v);
              if (!edge2_exists(w, w_new,
                                edge2_predicate<Graph1, Graph2, EdgeEquivalencePredicate>(edge_comp_, e1), 
                                graph2_))
                return false;
              
            } else {
              if (0 < state1_.in_depth(v))
                ++term_in1_count;
              if (0 < state1_.out_depth(v))
                ++term_out1_count;
              if ((state1_.in_depth(v) == 0) && (state1_.out_depth(v) == 0))
                ++rest1_count;
            }
          }
        }
        
        {
          equivalent_edge_exists<Graph2> edge2_exists;
          
          BGL_FORALL_OUTEDGES_T(v_new, e1, graph1_, Graph1) {
            vertex1_type v = target(e1, graph1_);
            if (state1_.in_core(v) || (v == v_new)) {
              vertex2_type w = w_new;
              if (v != v_new)
                w = state1_.core(v);
              
              if (!edge2_exists(w_new, w,
                                edge2_predicate<Graph1, Graph2, EdgeEquivalencePredicate>(edge_comp_, e1), 
                                graph2_))
                return false;
              
            } else {
              if (0 < state1_.in_depth(v))
                ++term_in1_count;
              if (0 < state1_.out_depth(v))
                ++term_out1_count;
              if ((state1_.in_depth(v) == 0) && (state1_.out_depth(v) == 0))
                ++rest1_count;
            }
          }
        }
        
        // graph2
        graph2_size_type term_out2_count = 0, term_in2_count = 0, rest2_count = 0;
        
        {
          equivalent_edge_exists<Graph1> edge1_exists;
          
          BGL_FORALL_INEDGES_T(w_new, e2, graph2_, Graph2) {
            vertex2_type w = source(e2, graph2_);
            if (state2_.in_core(w) || (w == w_new)) {
              if (problem_selection != subgraph_mono) {
                vertex1_type v = v_new;
                if (w != w_new)
                  v = state2_.core(w);
              
                if (!edge1_exists(v, v_new,
                                  edge1_predicate<Graph1, Graph2, EdgeEquivalencePredicate>(edge_comp_, e2), 
                                  graph1_))
                  return false;
              }
            } else {
              if (0 < state2_.in_depth(w))
                ++term_in2_count;
              if (0 < state2_.out_depth(w))
                ++term_out2_count;
              if ((state2_.in_depth(w) == 0) && (state2_.out_depth(w) == 0))
                ++rest2_count;
            }
          }
        }

        {
          equivalent_edge_exists<Graph1> edge1_exists;
          
          BGL_FORALL_OUTEDGES_T(w_new, e2, graph2_, Graph2) {
            vertex2_type w = target(e2, graph2_);
            if (state2_.in_core(w) || (w == w_new)) {
              if (problem_selection != subgraph_mono) {
                vertex1_type v = v_new;
                if (w != w_new)
                  v = state2_.core(w);
              
                if (!edge1_exists(v_new, v,
                                  edge1_predicate<Graph1, Graph2, EdgeEquivalencePredicate>(edge_comp_, e2), 
                                  graph1_))
                  return false;
              }
            } else {
              if (0 < state2_.in_depth(w))
                ++term_in2_count;
              if (0 < state2_.out_depth(w))
                ++term_out2_count;
              if ((state2_.in_depth(w) == 0) && (state2_.out_depth(w) == 0))
                ++rest2_count;
            }
          }
        }

        if (problem_selection != subgraph_mono) { // subgraph_iso and isomorphism
          return comp_term_sets(term_in1_count, term_in2_count,
                                boost::mpl::int_<problem_selection>()) &&
                 comp_term_sets(term_out1_count, term_out2_count, 
                                boost::mpl::int_<problem_selection>()) &&
                 comp_term_sets(rest1_count, rest2_count, 
                                boost::mpl::int_<problem_selection>());
        } else { // subgraph_mono
          return comp_term_sets(term_in1_count, term_in2_count,
                                boost::mpl::int_<problem_selection>()) &&
                 comp_term_sets(term_out1_count, term_out2_count, 
                                boost::mpl::int_<problem_selection>()) &&
                 comp_term_sets(term_in1_count + term_out1_count + rest1_count,
                                term_in2_count + term_out2_count + rest2_count, 
                                boost::mpl::int_<problem_selection>());
        }
      }

      bool possible_candidate1(const vertex1_type& v) const {
        if (state1_.term_both() && state2_.term_both()) 
          return state1_.term_both(v);
        else if (state1_.term_out() && state2_.term_out())
          return state1_.term_out(v);
        else if (state1_.term_in() && state2_.term_in())
          return state1_.term_in(v);
        else
          return !state1_.in_core(v);
      }

      bool possible_candidate2(const vertex2_type& w) const {
        if (state1_.term_both() && state2_.term_both()) 
          return state2_.term_both(w);
        else if (state1_.term_out() && state2_.term_out())
          return state2_.term_out(w);
        else if (state1_.term_in() && state2_.term_in())
          return state2_.term_in(w);
        else
          return !state2_.in_core(w);
      }

      bool success() const {
        return state1_.count() == num_vertices(graph1_);
      }

      bool valid() const {
        boost::tuple<graph1_size_type, graph1_size_type, graph1_size_type> term1;
        boost::tuple<graph2_size_type, graph2_size_type, graph2_size_type> term2;
        
        term1 = state1_.term_set();
        term2 = state2_.term_set();
        
        return comp_term_sets(boost::get<0>(term1), boost::get<0>(term2),
                              boost::mpl::int_<problem_selection>()) &&
               comp_term_sets(boost::get<1>(term1), boost::get<1>(term2),
                              boost::mpl::int_<problem_selection>()) &&
               comp_term_sets(boost::get<2>(term1), boost::get<2>(term2),
                              boost::mpl::int_<problem_selection>()); 
      }

      bool call_back(SubGraphIsoMapCallback user_callback) const {
        return user_callback(state1_.get_map(), state2_.get_map());
      }

    template<typename Graph1,
             typename Graph2,
             typename IndexMap1,
             typename IndexMap2,
             typename VertexOrder1,
             typename EdgeEquivalencePredicate,
             typename VertexEquivalencePredicate, 
             typename SubGraphIsoMapCallback,
             problem_selector problem_selection>
    bool match(const Graph1& graph1, const Graph2& graph2, 
               SubGraphIsoMapCallback user_callback, const VertexOrder1& vertex_order1, 
               state<Graph1, Graph2, IndexMap1, IndexMap2,
               EdgeEquivalencePredicate, VertexEquivalencePredicate,
               SubGraphIsoMapCallback, problem_selection>& s) {
      
      typename VertexOrder1::const_iterator graph1_verts_iter;

      typedef typename graph_traits<Graph2>::vertex_iterator vertex2_iterator_type;
      vertex2_iterator_type graph2_verts_iter, graph2_verts_iter_end;
    
      typedef vf2_match_continuation<Graph1, Graph2, VertexOrder1> match_continuation_type;
      std::vector<match_continuation_type> k;
  
      recur:
      if (s.success()) {
        if (!s.call_back(user_callback)) 
          return false;

        goto back_track;
      }
 
      if (!s.valid())
        goto back_track;

      graph1_verts_iter = vertex_order1.begin();
      while (graph1_verts_iter != vertex_order1.end() && 
             !s.possible_candidate1(*graph1_verts_iter)) {
        ++graph1_verts_iter;
      }

      boost::tie(graph2_verts_iter, graph2_verts_iter_end) = vertices(graph2);
      while (graph2_verts_iter != graph2_verts_iter_end) {
        if (s.possible_candidate2(*graph2_verts_iter)) {
          if (s.feasible(*graph1_verts_iter, *graph2_verts_iter)) {
            match_continuation_type kk;
            kk.graph1_verts_iter = graph1_verts_iter;
            kk.graph2_verts_iter = graph2_verts_iter;
            k.push_back(kk);
            
            s.push(*graph1_verts_iter, *graph2_verts_iter);
            goto recur;
          }
        }
        graph2_loop: ++graph2_verts_iter;
      }

      back_track:
      if (k.empty()) 
        return true;    
      
      const match_continuation_type kk = k.back();
      graph1_verts_iter = kk.graph1_verts_iter;
      graph2_verts_iter = kk.graph2_verts_iter;
      k.pop_back();
      
      s.pop(*graph1_verts_iter, *graph2_verts_iter);
      
      goto graph2_loop;
    }


      vertex_in_out_degree_cmp(const Graph& graph)
        : graph_(graph) {}


      bool operator()(const vertex_type& v, const vertex_type& w) const {
        // lexicographical comparison
        return std::make_pair(in_degree(v, graph_), out_degree(v, graph_)) <
               std::make_pair(in_degree(w, graph_), out_degree(w, graph_));
      }

      
      vertex_frequency_degree_cmp(const Graph& graph, FrequencyMap freq)
        : graph_(graph), freq_(freq) {}

      
      bool operator()(const vertex_type& v, const vertex_type& w) const {
        // lexicographical comparison
        return std::make_pair(freq_[v], in_degree(v, graph_)+out_degree(v, graph_)) <
               std::make_pair(freq_[w], in_degree(w, graph_)+out_degree(w, graph_));
      }

    template<typename Graph,
             typename IndexMap,
             typename VertexOrder>
    void sort_vertices(const Graph& graph, IndexMap index_map, VertexOrder& order) {
      typedef typename graph_traits<Graph>::vertices_size_type size_type;

      boost::range::sort(order, vertex_in_out_degree_cmp<Graph>(graph));

      std::vector<size_type> freq_vec(num_vertices(graph), 0);
      typedef iterator_property_map<typename std::vector<size_type>::iterator,
                                    IndexMap, size_type, size_type&> frequency_map_type;
                
      frequency_map_type freq = make_iterator_property_map(freq_vec.begin(), index_map);

      typedef typename VertexOrder::iterator order_iterator;

      for (order_iterator order_iter = order.begin(); order_iter != order.end(); ) {
        size_type count = 0;
        for (order_iterator count_iter = order_iter;
             (count_iter != order.end()) &&
             (in_degree(*order_iter, graph) == in_degree(*count_iter, graph)) &&
             (out_degree(*order_iter, graph) == out_degree(*count_iter, graph)); 
             ++count_iter)
          ++count;
      
        for (size_type i = 0; i < count; ++i) {
          freq[*order_iter] = count;
          ++order_iter;
        }
      }

      boost::range::sort(order, vertex_frequency_degree_cmp<Graph, frequency_map_type>(graph, freq));

    }

    template <problem_selector problem_selection,
              typename GraphSmall,
              typename GraphLarge,
              typename IndexMapSmall,
              typename IndexMapLarge,
              typename VertexOrderSmall,
              typename EdgeEquivalencePredicate,
              typename VertexEquivalencePredicate,
              typename SubGraphIsoMapCallback>
    bool vf2_subgraph_morphism(const GraphSmall& graph_small, const GraphLarge& graph_large,
                          SubGraphIsoMapCallback user_callback,
                          IndexMapSmall index_map_small, IndexMapLarge index_map_large, 
                          const VertexOrderSmall& vertex_order_small,
                          EdgeEquivalencePredicate edge_comp,
                          VertexEquivalencePredicate vertex_comp) {

      // Graph requirements
      BOOST_CONCEPT_ASSERT(( BidirectionalGraphConcept<GraphSmall> ));
      BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<GraphSmall> ));
      BOOST_CONCEPT_ASSERT(( EdgeListGraphConcept<GraphSmall> ));
      BOOST_CONCEPT_ASSERT(( AdjacencyMatrixConcept<GraphSmall> ));

      BOOST_CONCEPT_ASSERT(( BidirectionalGraphConcept<GraphLarge> ));
      BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<GraphLarge> ));
      BOOST_CONCEPT_ASSERT(( EdgeListGraphConcept<GraphLarge> ));
      BOOST_CONCEPT_ASSERT(( AdjacencyMatrixConcept<GraphLarge> ));

      typedef typename graph_traits<GraphSmall>::vertex_descriptor vertex_small_type;
      typedef typename graph_traits<GraphLarge>::vertex_descriptor vertex_large_type;

      typedef typename graph_traits<GraphSmall>::vertices_size_type size_type_small;
      typedef typename graph_traits<GraphLarge>::vertices_size_type size_type_large;
        
      // Property map requirements
      BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<IndexMapSmall, vertex_small_type> ));
      typedef typename property_traits<IndexMapSmall>::value_type IndexMapSmallValue;
      BOOST_STATIC_ASSERT(( is_convertible<IndexMapSmallValue, size_type_small>::value ));
        
      BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<IndexMapLarge, vertex_large_type> ));
      typedef typename property_traits<IndexMapLarge>::value_type IndexMapLargeValue;
      BOOST_STATIC_ASSERT(( is_convertible<IndexMapLargeValue, size_type_large>::value ));

      // Edge & vertex requirements
      typedef typename graph_traits<GraphSmall>::edge_descriptor edge_small_type;
      typedef typename graph_traits<GraphLarge>::edge_descriptor edge_large_type;

      BOOST_CONCEPT_ASSERT(( BinaryPredicateConcept<EdgeEquivalencePredicate, 
                             edge_small_type, edge_large_type> ));

      BOOST_CONCEPT_ASSERT(( BinaryPredicateConcept<VertexEquivalencePredicate, 
                             vertex_small_type, vertex_large_type> ));

      // Vertex order requirements
      BOOST_CONCEPT_ASSERT(( ContainerConcept<VertexOrderSmall> )); 
      typedef typename VertexOrderSmall::value_type order_value_type;
      BOOST_STATIC_ASSERT(( is_same<vertex_small_type, order_value_type>::value ));
      BOOST_ASSERT( num_vertices(graph_small) == vertex_order_small.size() );

      if (num_vertices(graph_small) > num_vertices(graph_large))
        return false;

      typename graph_traits<GraphSmall>::edges_size_type num_edges_small = num_edges(graph_small);
      typename graph_traits<GraphLarge>::edges_size_type num_edges_large = num_edges(graph_large);

      // Double the number of edges for undirected graphs: each edge counts as
      // in-edge and out-edge
      if (is_undirected(graph_small)) num_edges_small *= 2;
      if (is_undirected(graph_large)) num_edges_large *= 2;
      if (num_edges_small > num_edges_large)
        return false;
    
      if ((num_vertices(graph_small) == 0) && (num_vertices(graph_large) == 0))
        return true;

      detail::state<GraphSmall, GraphLarge, IndexMapSmall, IndexMapLarge,
                    EdgeEquivalencePredicate, VertexEquivalencePredicate,
                    SubGraphIsoMapCallback, problem_selection> 
        s(graph_small, graph_large, index_map_small, index_map_large, edge_comp, vertex_comp);

      return detail::match(graph_small, graph_large, user_callback, vertex_order_small, s);
    }


    static vertex_descriptor null_vertex() 
    { return traits_type::null_vertex(); }


    vertex_and_edge_range(const Graph& g,
                          VertexIterator first_v, VertexIterator last_v,
                          vertices_size_type n,
                          EdgeIterator first_e, EdgeIterator last_e,
                          edges_size_type m)
      : g(&g), 
        first_vertex(first_v), last_vertex(last_v), m_num_vertices(n),
        first_edge(first_e), last_edge(last_e), m_num_edges(m)
    {
    }


    vertex_and_edge_range(const Graph& g, 
                          VertexIterator first_v, VertexIterator last_v,
                          EdgeIterator first_e, EdgeIterator last_e)
      : g(&g), 
        first_vertex(first_v), last_vertex(last_v),
        first_edge(first_e), last_edge(last_e)
    {
      m_num_vertices = std::distance(first_v, last_v);
      m_num_edges = std::distance(first_e, last_e);
    }

  static one_bit_color_type white() { return one_bit_white; }

  static one_bit_color_type gray()  { return one_bit_not_white; }

  static one_bit_color_type black() { return one_bit_not_white; }


  explicit one_bit_color_map(std::size_t n, const IndexMap& index = IndexMap())
    : n(n), index(index), data(new unsigned char[(n + bits_per_char - 1) / bits_per_char])
  {
    // Fill to white
    std::fill(data.get(), data.get() + (n + bits_per_char - 1) / bits_per_char, 0);
  }


template<typename IndexMap>
inline one_bit_color_type
get(const one_bit_color_map<IndexMap>& pm, 
    typename property_traits<IndexMap>::key_type key) 
{
  BOOST_STATIC_CONSTANT(int, bits_per_char = one_bit_color_map<IndexMap>::bits_per_char);
  typename property_traits<IndexMap>::value_type i = get(pm.index, key);
  BOOST_ASSERT ((std::size_t)i < pm.n);
  return one_bit_color_type((pm.data.get()[i / bits_per_char] >> (i % bits_per_char)) & 1);
}


template<typename IndexMap>
inline void
put(const one_bit_color_map<IndexMap>& pm, 
    typename property_traits<IndexMap>::key_type key,
    one_bit_color_type value)
{
  BOOST_STATIC_CONSTANT(int, bits_per_char = one_bit_color_map<IndexMap>::bits_per_char);
  typename property_traits<IndexMap>::value_type i = get(pm.index, key);
  BOOST_ASSERT ((std::size_t)i < pm.n);
  BOOST_ASSERT (value >= 0 && value < 2);
  std::size_t byte_num = i / bits_per_char;
  std::size_t bit_position = (i % bits_per_char);
    pm.data.get()[byte_num] =
      (unsigned char)
        ((pm.data.get()[byte_num] & ~(1 << bit_position))
         | (value << bit_position));
}


template<typename IndexMap>
inline one_bit_color_map<IndexMap>
make_one_bit_color_map(std::size_t n, const IndexMap& index_map)
{
  return one_bit_color_map<IndexMap>(n, index_map);
}



        PreorderTraverser(std::vector<Node>& p) : path_(p) {}


        void preorder(Node n, const Tree&)
        { path_.push_back(n); }


        void inorder(Node, const Tree&) const {}

        void postorder(Node, const Tree&) const {}


        const_iterator begin() const { return path_.begin(); }

        const_iterator end() const { return path_.end(); }


    template<typename VertexListGraph, typename OutputIterator>
    void metric_tsp_approx_tour(VertexListGraph& g, OutputIterator o)
    {
        metric_tsp_approx_from_vertex(g, *vertices(g).first,
            get(edge_weight, g), get(vertex_index, g),
            tsp_tour_visitor<OutputIterator>(o));
    }


    template<typename VertexListGraph, typename WeightMap, typename OutputIterator>
    void metric_tsp_approx_tour(VertexListGraph& g, WeightMap w, OutputIterator o)
    {
        metric_tsp_approx_from_vertex(g, *vertices(g).first,
            w, tsp_tour_visitor<OutputIterator>(o));
    }


    template<typename VertexListGraph, typename OutputIterator>
    void metric_tsp_approx_tour_from_vertex(VertexListGraph& g,
        typename graph_traits<VertexListGraph>::vertex_descriptor start,
        OutputIterator o)
    {
        metric_tsp_approx_from_vertex(g, start, get(edge_weight, g),
            get(vertex_index, g), tsp_tour_visitor<OutputIterator>(o));
    }


    template<typename VertexListGraph, typename WeightMap,
        typename OutputIterator>
    void metric_tsp_approx_tour_from_vertex(VertexListGraph& g,
    typename graph_traits<VertexListGraph>::vertex_descriptor start,
        WeightMap w, OutputIterator o)
    {
        metric_tsp_approx_from_vertex(g, start, w, get(vertex_index, g),
            tsp_tour_visitor<OutputIterator>(o));
    }


    template<typename VertexListGraph, typename TSPVertexVisitor>
    void metric_tsp_approx(VertexListGraph& g, TSPVertexVisitor vis)
    {
        metric_tsp_approx_from_vertex(g, *vertices(g).first,
            get(edge_weight, g), get(vertex_index, g), vis);
    }


    template<typename VertexListGraph, typename Weightmap,
        typename VertexIndexMap, typename TSPVertexVisitor>
    void metric_tsp_approx(VertexListGraph& g, Weightmap w,
        TSPVertexVisitor vis)
    {
        metric_tsp_approx_from_vertex(g, *vertices(g).first, w,
            get(vertex_index, g), vis);
    }


    template<typename VertexListGraph, typename WeightMap,
        typename VertexIndexMap, typename TSPVertexVisitor>
    void metric_tsp_approx(VertexListGraph& g, WeightMap w, VertexIndexMap id,
        TSPVertexVisitor vis)
    {
        metric_tsp_approx_from_vertex(g, *vertices(g).first, w, id, vis);
    }


    template<typename VertexListGraph, typename WeightMap,
        typename TSPVertexVisitor>
    void metric_tsp_approx_from_vertex(VertexListGraph& g,
    typename graph_traits<VertexListGraph>::vertex_descriptor start,
        WeightMap w, TSPVertexVisitor vis)
    {
        metric_tsp_approx_from_vertex(g, start, w, get(vertex_index, g), vis);
    }


    template <
        typename VertexListGraph,
        typename WeightMap,
        typename VertexIndexMap,
        typename TSPVertexVisitor>
    void metric_tsp_approx_from_vertex(const VertexListGraph& g,
                                       typename graph_traits<VertexListGraph>::vertex_descriptor start,
                                       WeightMap weightmap,
                                       VertexIndexMap indexmap,
                                       TSPVertexVisitor vis)
    {
        using namespace boost;
        using namespace std;

        BOOST_CONCEPT_ASSERT((VertexListGraphConcept<VertexListGraph>));
        BOOST_CONCEPT_ASSERT((TSPVertexVisitorConcept<TSPVertexVisitor, VertexListGraph>));

        // Types related to the input graph (GVertex is a template parameter).
        typedef typename graph_traits<VertexListGraph>::vertex_descriptor GVertex;
        typedef typename graph_traits<VertexListGraph>::vertex_iterator GVItr;

        // We build a custom graph in this algorithm.
        typedef adjacency_list <vecS, vecS, directedS, no_property, no_property > MSTImpl;
        typedef graph_traits<MSTImpl>::edge_descriptor Edge;
        typedef graph_traits<MSTImpl>::vertex_descriptor Vertex;
        typedef graph_traits<MSTImpl>::vertex_iterator VItr;

        // And then re-cast it as a tree.
        typedef iterator_property_map<vector<Vertex>::iterator, property_map<MSTImpl, vertex_index_t>::type> ParentMap;
        typedef graph_as_tree<MSTImpl, ParentMap> Tree;
        typedef tree_traits<Tree>::node_descriptor Node;

        // A predecessor map.
        typedef vector<GVertex> PredMap;
        typedef iterator_property_map<typename PredMap::iterator, VertexIndexMap> PredPMap;

        PredMap preds(num_vertices(g));
        PredPMap pred_pmap(preds.begin(), indexmap);

        // Compute a spanning tree over the in put g.
        prim_minimum_spanning_tree(g, pred_pmap,
             root_vertex(start)
            .vertex_index_map(indexmap)
            .weight_map(weightmap));

        // Build a MST using the predecessor map from prim mst
        MSTImpl mst(num_vertices(g));
        std::size_t cnt = 0;
        pair<VItr, VItr> mst_verts(vertices(mst));
        for(typename PredMap::iterator vi(preds.begin()); vi != preds.end(); ++vi, ++cnt)
        {
            if(indexmap[*vi] != cnt) {
                add_edge(*next(mst_verts.first, indexmap[*vi]),
                         *next(mst_verts.first, cnt), mst);
            }
        }

        // Build a tree abstraction over the MST.
        vector<Vertex> parent(num_vertices(mst));
        Tree t(mst, *vertices(mst).first,
            make_iterator_property_map(parent.begin(),
            get(vertex_index, mst)));

        // Create tour using a preorder traversal of the mst
        vector<Node> tour;
        PreorderTraverser<Node, Tree> tvis(tour);
        traverse_tree(indexmap[start], t, tvis);

        pair<GVItr, GVItr> g_verts(vertices(g));
        for(PreorderTraverser<Node, Tree>::const_iterator curr(tvis.begin());
            curr != tvis.end(); ++curr)
        {
            // TODO: This is will be O(n^2) if vertex storage of g != vecS.
            GVertex v = *next(g_verts.first, get(vertex_index, mst)[*curr]);
            vis.visit_vertex(v, g);
        }

        // Connect back to the start of the tour
        vis.visit_vertex(start, g);
    }

        tsp_tour_visitor(OutItr itr)
            : itr_(itr)
        { }


        template <typename Vertex, typename Graph>
        void visit_vertex(Vertex v, const Graph&)
        {
            BOOST_CONCEPT_ASSERT((OutputIterator<OutItr, Vertex>));
            *itr_++ = v;
        }

        Vertex null()
        { return graph_traits<Graph>::null_vertex(); }

        tsp_tour_len_visitor(Graph const&, OutIter iter, Length& l, WeightMap map)
            : iter_(iter), tourlen_(l), wmap_(map), previous_(null())
        { }


        void visit_vertex(Vertex v, const Graph& g)
        {
            typedef typename graph_traits<Graph>::edge_descriptor Edge;

            // If it is not the start, then there is a
            // previous vertex
            if(previous_ != null())
            {
                // NOTE: For non-adjacency matrix graphs g, this bit of code
                // will be linear in the degree of previous_ or v. A better
                // solution would be to visit edges of the graph, but that
                // would require revisiting the core algorithm.
                Edge e;
                bool found;
                boost::tie(e, found) = lookup_edge(previous_, v, g);
                if(!found) {
                    BOOST_THROW_EXCEPTION(not_complete());
                }

                tourlen_ += wmap_[e];
            }

            previous_ = v;
            *iter_++ = v;
        }

    template <typename OutIter>
    inline tsp_tour_visitor<OutIter>
    make_tsp_tour_visitor(OutIter iter)
    { return tsp_tour_visitor<OutIter>(iter); }


    template <typename Graph, typename WeightMap, typename OutIter, typename Length>
    inline tsp_tour_len_visitor<Graph, WeightMap, OutIter, Length>
    make_tsp_tour_len_visitor(Graph const& g, OutIter iter, Length& l, WeightMap map)
    { return tsp_tour_len_visitor<Graph, WeightMap, OutIter, Length>(g, iter, l, map); }




  template <typename Graph,
            typename PlanarEmbedding,
            typename EdgeIndexMap,
            typename AddEdgeVisitor
            >
  void make_biconnected_planar(Graph& g,
                               PlanarEmbedding embedding, 
                               EdgeIndexMap em, 
                               AddEdgeVisitor& vis
                               )
  {
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
    typedef typename graph_traits<Graph>::edge_descriptor edge_t;
    typedef typename graph_traits<Graph>::edges_size_type edge_size_t;
    typedef typename 
      property_traits<PlanarEmbedding>::value_type embedding_value_t;
    typedef typename embedding_value_t::const_iterator embedding_iterator_t;
    typedef iterator_property_map
      <std::vector<std::size_t>::iterator, EdgeIndexMap> component_map_t;

    edge_size_t n_edges(num_edges(g));
    std::vector<vertex_t> articulation_points;
    std::vector<edge_size_t> component_vector(n_edges);
    component_map_t component_map(component_vector.begin(), em);

    biconnected_components(g, component_map, 
                           std::back_inserter(articulation_points));

    typename std::vector<vertex_t>::iterator ap, ap_end;
    ap_end = articulation_points.end();
    for(ap = articulation_points.begin(); ap != ap_end; ++ap)
      {
        vertex_t v(*ap);
        embedding_iterator_t pi = embedding[v].begin();
        embedding_iterator_t pi_end = embedding[v].end();
        edge_size_t previous_component(n_edges + 1);
        vertex_t previous_vertex = graph_traits<Graph>::null_vertex();

        for(; pi != pi_end; ++pi)
          {
            edge_t e(*pi);
            vertex_t e_source(source(e,g));
            vertex_t e_target(target(e,g));

            //Skip self-loops and parallel edges
            if (e_source == e_target || previous_vertex == e_target)
              continue;

            vertex_t current_vertex = e_source == v ? e_target : e_source;
            edge_size_t current_component = component_map[e];
            if (previous_vertex != graph_traits<Graph>::null_vertex() &&
                current_component != previous_component)
              {
                vis.visit_vertex_pair(current_vertex, previous_vertex, g);
              }
            previous_vertex = current_vertex;
            previous_component = current_component;
          }
      }

  }





  template <typename Graph,
            typename PlanarEmbedding,
            typename EdgeIndexMap
            >
  inline void make_biconnected_planar(Graph& g, 
                                      PlanarEmbedding embedding, 
                                      EdgeIndexMap em
                                      )
  {
    default_add_edge_visitor vis;
    make_biconnected_planar(g, embedding, em, vis); 
  }





  template <typename Graph,
            typename PlanarEmbedding
            >
  inline void make_biconnected_planar(Graph& g, PlanarEmbedding embedding)
  {
    make_biconnected_planar(g, embedding, get(edge_index,g));
  }

  template <class VertexListGraph, class DijkstraVisitor, 
            class DistanceMap, class WeightMap, class ColorMap, 
            class PredecessorMap,
            class Compare, class Combine, 
            class DistInf, class DistZero>
  inline void
  dag_shortest_paths
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s, 
     DistanceMap distance, WeightMap weight, ColorMap color,
     PredecessorMap pred,
     DijkstraVisitor vis, Compare compare, Combine combine, 
     DistInf inf, DistZero zero)
  {
    typedef typename graph_traits<VertexListGraph>::vertex_descriptor Vertex;
    std::vector<Vertex> rev_topo_order;
    rev_topo_order.reserve(num_vertices(g));

    // Call 'depth_first_visit', not 'topological_sort', because we don't
    // want to traverse the entire graph, only vertices reachable from 's',
    // and 'topological_sort' will traverse everything. The logic below
    // is the same as for 'topological_sort', only we call 'depth_first_visit'
    // and 'topological_sort' calls 'depth_first_search'.
    topo_sort_visitor<std::back_insert_iterator<std::vector<Vertex> > >
        topo_visitor(std::back_inserter(rev_topo_order));
    depth_first_visit(g, s, topo_visitor, color);

    typename graph_traits<VertexListGraph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
      put(distance, *ui, inf);
      put(pred, *ui, *ui);
    }

    put(distance, s, zero);
    vis.discover_vertex(s, g);
    typename std::vector<Vertex>::reverse_iterator i;
    for (i = rev_topo_order.rbegin(); i != rev_topo_order.rend(); ++i) {
      Vertex u = *i;
      vis.examine_vertex(u, g);
      typename graph_traits<VertexListGraph>::out_edge_iterator e, e_end;
      for (boost::tie(e, e_end) = out_edges(u, g); e != e_end; ++e) {
        vis.discover_vertex(target(*e, g), g);
        bool decreased = relax(*e, g, weight, pred, distance, 
                               combine, compare);
        if (decreased)
          vis.edge_relaxed(*e, g);
        else
          vis.edge_not_relaxed(*e, g);
      }
      vis.finish_vertex(u, g);      
    }
  }

    template <class VertexListGraph, class DijkstraVisitor, 
      class DistanceMap, class WeightMap, class ColorMap, 
      class IndexMap, class Params>
    inline void
    dag_sp_dispatch2
      (const VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s, 
       DistanceMap distance, WeightMap weight, ColorMap color, IndexMap /*id*/,
       DijkstraVisitor vis, const Params& params)
    {
      typedef typename property_traits<DistanceMap>::value_type D;
      dummy_property_map p_map;
      D inf =
        choose_param(get_param(params, distance_inf_t()), 
                     (std::numeric_limits<D>::max)());
      dag_shortest_paths
        (g, s, distance, weight, color, 
         choose_param(get_param(params, vertex_predecessor), p_map),
         vis, 
         choose_param(get_param(params, distance_compare_t()), std::less<D>()),
         choose_param(get_param(params, distance_combine_t()), closed_plus<D>(inf)),
         inf,
         choose_param(get_param(params, distance_zero_t()), 
                      D()));
    }

    template <class VertexListGraph, class DijkstraVisitor, 
              class DistanceMap, class WeightMap, class ColorMap,
              class IndexMap, class Params>
    inline void
    dag_sp_dispatch1
      (const VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s, 
       DistanceMap distance, WeightMap weight, ColorMap color, IndexMap id,
       DijkstraVisitor vis, const Params& params)
    {
      typedef typename property_traits<WeightMap>::value_type T;
      typename std::vector<T>::size_type n;
      n = is_default_param(distance) ? num_vertices(g) : 1;
      std::vector<T> distance_map(n);
      n = is_default_param(color) ? num_vertices(g) : 1;
      std::vector<default_color_type> color_map(n);

      dag_sp_dispatch2
        (g, s, 
         choose_param(distance, 
                      make_iterator_property_map(distance_map.begin(), id,
                                                 distance_map[0])),
         weight, 
         choose_param(color,
                      make_iterator_property_map(color_map.begin(), id, 
                                                 color_map[0])),
         id, vis, params);
    }

  
  template <class VertexListGraph, class Param, class Tag, class Rest>
  inline void
  dag_shortest_paths
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     const bgl_named_params<Param,Tag,Rest>& params)
  {
    // assert that the graph is directed...
    null_visitor null_vis;
    detail::dag_sp_dispatch1
      (g, s, 
       get_param(params, vertex_distance),
       choose_const_pmap(get_param(params, edge_weight), g, edge_weight),
       get_param(params, vertex_color),
       choose_const_pmap(get_param(params, vertex_index), g, vertex_index),
       choose_param(get_param(params, graph_visitor),
                    make_dijkstra_visitor(null_vis)),
       params);
  }


    inline undirected_graph(GraphProp const& p = GraphProp())
        : m_graph(p), m_num_vertices(0), m_num_edges(0), m_max_vertex_index(0)
        , m_max_edge_index(0)
    { }


    inline undirected_graph(undirected_graph const& x)
        : m_graph(x.m_graph), m_num_vertices(x.m_num_vertices), m_num_edges(x.m_num_edges)
        , m_max_vertex_index(x.m_max_vertex_index), m_max_edge_index(x.m_max_edge_index)
    { }


    inline undirected_graph(vertices_size_type n,
                            GraphProp const& p = GraphProp())
        : m_graph(n, p), m_num_vertices(n), m_num_edges(0), m_max_vertex_index(n)
        , m_max_edge_index(0)
    { renumber_vertex_indices(); }


    template <typename EdgeIterator>
    inline undirected_graph(EdgeIterator f,
                            EdgeIterator l,
                            vertices_size_type n,
                            edges_size_type m = 0,
                            GraphProp const& p = GraphProp())
        : m_graph(f, l, n, m, p), m_num_vertices(n), m_num_edges(0)
        , m_max_vertex_index(n), m_max_edge_index(0)
    {
        // Unfortunately, we have to renumber to ensure correct indexing.
        renumber_indices();

        // Can't always guarantee that the number of edges is actually
        // m if distance(f, l) != m (or is undefined).
        m_num_edges = m_max_edge_index = boost::num_edges(m_graph);
    }


    undirected_graph& operator =(undirected_graph const& g) {
        if(&g != this) {
            m_graph = g.m_graph;
            m_num_vertices = g.m_num_vertices;
            m_num_edges = g.m_num_edges;
            m_max_vertex_index = g.m_max_vertex_index;
        }
        return *this;
    }

    graph_type& impl()
    { return m_graph; }


    graph_type const& impl() const
    { return m_graph; }

    vertices_size_type num_vertices() const
    { return m_num_vertices; }

    vertex_descriptor make_index(vertex_descriptor v) {
        boost::put(vertex_index, m_graph, v, m_max_vertex_index);
        m_num_vertices++;
        m_max_vertex_index++;
        return v;
    }

    vertex_descriptor add_vertex()
    { return make_index(boost::add_vertex(m_graph)); }


    vertex_descriptor add_vertex(vertex_property_type const& p)
    { return make_index(boost::add_vertex(internal_vertex_property(0u, p), m_graph)); }


    void clear_vertex(vertex_descriptor v) {
        std::pair<out_edge_iterator, out_edge_iterator>
        p = boost::out_edges(v, m_graph);
        m_num_edges -= std::distance(p.first, p.second);
        boost::clear_vertex(v, m_graph);
    }


    void remove_vertex(vertex_descriptor v) {
        boost::remove_vertex(v, m_graph);
        --m_num_vertices;
    }


    edges_size_type num_edges() const
    { return m_num_edges; }

template <UNDIRECTED_GRAPH_PARAMS>
inline typename UNDIRECTED_GRAPH::vertex_descriptor
source(typename UNDIRECTED_GRAPH::edge_descriptor e,
       UNDIRECTED_GRAPH const& g)
{ return source(e, g.impl()); }


template <UNDIRECTED_GRAPH_PARAMS>
inline typename UNDIRECTED_GRAPH::vertex_descriptor
target(typename UNDIRECTED_GRAPH::edge_descriptor e,
       UNDIRECTED_GRAPH const& g)
{ return target(e, g.impl()); }


template <UNDIRECTED_GRAPH_PARAMS>
inline typename UNDIRECTED_GRAPH::degree_size_type
out_degree(typename UNDIRECTED_GRAPH::vertex_descriptor v,
           UNDIRECTED_GRAPH const& g)
{ return out_degree(v, g.impl()); }


template <UNDIRECTED_GRAPH_PARAMS, typename Property, typename Key, typename Value>
inline void put(Property p, UNDIRECTED_GRAPH& g, Key const& k, Value const& v)
{ put(p, g.impl(), k, v); }


template <UNDIRECTED_GRAPH_PARAMS, typename Key, typename Value>
inline void put(vertex_all_t, UNDIRECTED_GRAPH& g, Key const& k, Value const& v)
{ put(vertex_all, g.impl(), k,
      typename UNDIRECTED_GRAPH::internal_vertex_property(get(vertex_index, g.impl(), k), v));
}


template <UNDIRECTED_GRAPH_PARAMS, typename Key, typename Value>
inline void put(edge_all_t, UNDIRECTED_GRAPH& g, Key const& k, Value const& v)
{ put(edge_all, g.impl(), k,
      typename UNDIRECTED_GRAPH::internal_vertex_property(get(edge_index, g.impl(), k), v));
}


template <UNDIRECTED_GRAPH_PARAMS, class Property>
inline typename graph_property<UNDIRECTED_GRAPH, Property>::type&
get_property(UNDIRECTED_GRAPH& g, Property p)
{ return get_property(g.impl(), p); }


template <UNDIRECTED_GRAPH_PARAMS, class Property>
inline typename graph_property<UNDIRECTED_GRAPH, Property>::type const&
get_property(UNDIRECTED_GRAPH const& g, Property p)
{ return get_property(g.impl(), p); }


template <UNDIRECTED_GRAPH_PARAMS, class Property, class Value>
inline void set_property(UNDIRECTED_GRAPH& g, Property p, Value v)
{ return set_property(g.impl(), p, v); }


template <UNDIRECTED_GRAPH_PARAMS>
inline typename UNDIRECTED_GRAPH::vertex_index_type
get_vertex_index(typename UNDIRECTED_GRAPH::vertex_descriptor v,
                 UNDIRECTED_GRAPH const& g)
{ return get(vertex_index, g, v); }


template <UNDIRECTED_GRAPH_PARAMS>
typename UNDIRECTED_GRAPH::vertex_index_type
max_vertex_index(UNDIRECTED_GRAPH const& g)
{ return g.max_vertex_index(); }


template <UNDIRECTED_GRAPH_PARAMS>
inline void
renumber_vertex_indices(UNDIRECTED_GRAPH& g)
{ g.renumber_vertex_indices(); }


template <UNDIRECTED_GRAPH_PARAMS>
inline void
remove_vertex_and_renumber_indices(typename UNDIRECTED_GRAPH::vertex_iterator i,
                                   UNDIRECTED_GRAPH& g)
{ g.remove_vertex_and_renumber_indices(i); }


template <UNDIRECTED_GRAPH_PARAMS>
inline typename UNDIRECTED_GRAPH::edge_index_type
get_edge_index(typename UNDIRECTED_GRAPH::edge_descriptor v,
               UNDIRECTED_GRAPH const& g)
{ return get(edge_index, g, v); }


template <UNDIRECTED_GRAPH_PARAMS>
typename UNDIRECTED_GRAPH::edge_index_type
max_edge_index(UNDIRECTED_GRAPH const& g)
{ return g.max_edge_index(); }


template <UNDIRECTED_GRAPH_PARAMS>
inline void
renumber_edge_indices(UNDIRECTED_GRAPH& g)
{ g.renumber_edge_indices(); }


template <UNDIRECTED_GRAPH_PARAMS>
inline void
remove_edge_and_renumber_indices(typename UNDIRECTED_GRAPH::edge_iterator i,
                                 UNDIRECTED_GRAPH& g)
{ g.remove_edge_and_renumber_indices(i); }

template <UNDIRECTED_GRAPH_PARAMS>
inline void
renumber_indices(UNDIRECTED_GRAPH& g)
{ g.renumber_indices(); }


template<typename Graph, typename ColorMap>
bool 
st_connected(const Graph& g, 
             typename graph_traits<Graph>::vertex_descriptor s,
             typename graph_traits<Graph>::vertex_descriptor t,
             ColorMap color)
{
  typedef typename property_traits<ColorMap>::value_type Color;
  typedef color_traits<Color> ColorTraits;
  typedef typename graph_traits<Graph>::vertex_descriptor Vertex;

  // Set all vertices to white (unvisited)
  BGL_FORALL_VERTICES_T(v, g, Graph)
    put(color, v, ColorTraits::white());

  // Vertices found from the source are grey
  put(color, s, ColorTraits::gray());

  // Vertices found from the target are greeen
  put(color, t, ColorTraits::green());
  queue<Vertex> Q;
  Q.push(s);
  Q.push(t);

  while (!Q.empty()) {
    Vertex u = Q.top(); Q.pop();
    Color u_color = get(color, u);

    BGL_FORALL_OUTEDGES_T(u, e, g, Graph) {
      Vertex v = target(e, g);
      Color v_color = get(color, v);
      if (v_color == ColorTraits::white()) {
        // We have not seen "v" before; mark it with the same color as u
        Color u_color = get(color, u);
        put(color, v, u_color);
        
        // Push it on the queue
        Q.push(v);
      } else if (v_color != ColorTraits::black() && u_color != v_color) {
        // Colors have collided. We're done!
        return true;
      }
    }
    // u is done, so mark it black
    put(color, u, ColorTraits::black());
  }

  return false;
}


template<typename Graph>
inline bool 
st_connected(const Graph& g, 
             typename graph_traits<Graph>::vertex_descriptor s,
             typename graph_traits<Graph>::vertex_descriptor t)
{
  return st_connected(g, s, t, 
                      make_two_bit_color_map(num_vertices(g),
                                             get(vertex_index, g)));
}

  
  template <class EdgeListGraph, class DisjointSets>
  void incremental_components(EdgeListGraph& g, DisjointSets& ds)
  {
    typename graph_traits<EdgeListGraph>::edge_iterator e, end;
    for (boost::tie(e,end) = edges(g); e != end; ++e)
      ds.union_set(source(*e,g),target(*e,g));
  }

  
  template <class ParentIterator>
  void compress_components(ParentIterator first, ParentIterator last)
  {
    for (ParentIterator current = first; current != last; ++current) 
      detail::find_representative_with_full_compression(first, current-first);
  }

  
  template <class ParentIterator>
  typename boost::detail::iterator_traits<ParentIterator>::difference_type
  component_count(ParentIterator first, ParentIterator last)
  {
    std::ptrdiff_t count = 0;
    for (ParentIterator current = first; current != last; ++current) 
      if (*current == current - first) ++count; 
    return count;
  }

  template <class ParentIterator>
  void normalize_components(ParentIterator first, ParentIterator last)
  {
    for (ParentIterator current = first; current != last; ++current) 
      detail::normalize_node(first, current - first);
  }

  
  template <class VertexListGraph, class DisjointSets> 
  void initialize_incremental_components(VertexListGraph& G, DisjointSets& ds)
  {
    typename graph_traits<VertexListGraph>
      ::vertex_iterator v, vend;
    for (boost::tie(v, vend) = vertices(G); v != vend; ++v)
      ds.make_set(*v);
  }


  template <class Vertex, class DisjointSet>
  inline bool same_component(Vertex u, Vertex v, DisjointSet& ds)
  {
    return ds.find_set(u) == ds.find_set(v);
  }

    template <typename ParentIterator,
              typename ElementIndexMap>
    component_index(ParentIterator parent_start,
                    ParentIterator parent_end,
                    const ElementIndexMap& index_map) :
      m_num_elements(std::distance(parent_start, parent_end)),
      m_components(make_shared<IndexContainer>()),
      m_index_list(make_shared<IndexContainer>(m_num_elements)) {

      build_index_lists(parent_start, index_map);
      
    }


    template <typename ParentIterator>
    component_index(ParentIterator parent_start,
                    ParentIterator parent_end) :
      m_num_elements(std::distance(parent_start, parent_end)),
      m_components(make_shared<IndexContainer>()),
      m_index_list(make_shared<IndexContainer>(m_num_elements)) {

      build_index_lists(parent_start, boost::identity_property_map());

    }

    inline std::size_t size() const {
      return (m_components->size());
    }

    iterator begin() const {
      return (iterator(0));
    }

    iterator end() const {
      return (iterator(this->size()));
    }


        static T zero()
        { return T(); }


        static T infinity()
        { return (std::numeric_limits<T>::max)(); }
 \
        static type zero() { return 0.0; } \
        static type infinity() { return std::numeric_limits<type>::infinity(); } \
    };

    /**
     * This generic type reports various numeric values for some type. In the
     * general case, numeric values simply treat their maximum value as infinity
     * and the default-constructed value as 0.
     *
     * Specializations of this template can redefine the notions of zero and
     * infinity for various types. For example, the class is specialized for
     * floating point types to use the built in notion of infinity.
     */
    template <typename T>
    struct numeric_values
    {
        typedef T value_type;

        static T zero()
        { return T(); }

        static T infinity()
        { return (std::numeric_limits<T>::max)(); }
    };

    // Specializations for floating point types refer to 0.0 and their infinity
    // value defined by numeric_limits.
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(float)
 \
        static type infinity() { return std::numeric_limits<type>::infinity(); } \
    };

    /**
     * This generic type reports various numeric values for some type. In the
     * general case, numeric values simply treat their maximum value as infinity
     * and the default-constructed value as 0.
     *
     * Specializations of this template can redefine the notions of zero and
     * infinity for various types. For example, the class is specialized for
     * floating point types to use the built in notion of infinity.
     */
    template <typename T>
    struct numeric_values
    {
        typedef T value_type;

        static T zero()
        { return T(); }

        static T infinity()
        { return (std::numeric_limits<T>::max)(); }
    };

    // Specializations for floating point types refer to 0.0 and their infinity
    // value defined by numeric_limits.
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(float)
 \
        static type zero() { return 0.0; } \
        static type infinity() { return std::numeric_limits<type>::infinity(); } \
    };

    /**
     * This generic type reports various numeric values for some type. In the
     * general case, numeric values simply treat their maximum value as infinity
     * and the default-constructed value as 0.
     *
     * Specializations of this template can redefine the notions of zero and
     * infinity for various types. For example, the class is specialized for
     * floating point types to use the built in notion of infinity.
     */
    template <typename T>
    struct numeric_values
    {
        typedef T value_type;

        static T zero()
        { return T(); }

        static T infinity()
        { return (std::numeric_limits<T>::max)(); }
    };

    // Specializations for floating point types refer to 0.0 and their infinity
    // value defined by numeric_limits.
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(float)
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(double)
 \
        static type infinity() { return std::numeric_limits<type>::infinity(); } \
    };

    /**
     * This generic type reports various numeric values for some type. In the
     * general case, numeric values simply treat their maximum value as infinity
     * and the default-constructed value as 0.
     *
     * Specializations of this template can redefine the notions of zero and
     * infinity for various types. For example, the class is specialized for
     * floating point types to use the built in notion of infinity.
     */
    template <typename T>
    struct numeric_values
    {
        typedef T value_type;

        static T zero()
        { return T(); }

        static T infinity()
        { return (std::numeric_limits<T>::max)(); }
    };

    // Specializations for floating point types refer to 0.0 and their infinity
    // value defined by numeric_limits.
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(float)
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(double)
 \
        static type zero() { return 0.0; } \
        static type infinity() { return std::numeric_limits<type>::infinity(); } \
    };

    /**
     * This generic type reports various numeric values for some type. In the
     * general case, numeric values simply treat their maximum value as infinity
     * and the default-constructed value as 0.
     *
     * Specializations of this template can redefine the notions of zero and
     * infinity for various types. For example, the class is specialized for
     * floating point types to use the built in notion of infinity.
     */
    template <typename T>
    struct numeric_values
    {
        typedef T value_type;

        static T zero()
        { return T(); }

        static T infinity()
        { return (std::numeric_limits<T>::max)(); }
    };

    // Specializations for floating point types refer to 0.0 and their infinity
    // value defined by numeric_limits.
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(float)
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(double)
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(long double)
 \
        static type infinity() { return std::numeric_limits<type>::infinity(); } \
    };

    /**
     * This generic type reports various numeric values for some type. In the
     * general case, numeric values simply treat their maximum value as infinity
     * and the default-constructed value as 0.
     *
     * Specializations of this template can redefine the notions of zero and
     * infinity for various types. For example, the class is specialized for
     * floating point types to use the built in notion of infinity.
     */
    template <typename T>
    struct numeric_values
    {
        typedef T value_type;

        static T zero()
        { return T(); }

        static T infinity()
        { return (std::numeric_limits<T>::max)(); }
    };

    // Specializations for floating point types refer to 0.0 and their infinity
    // value defined by numeric_limits.
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(float)
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(double)
    BOOST_GRAPH_SPECIALIZE_NUMERIC_FLOAT(long double)

        void constraints()
        {
            BOOST_CONCEPT_ASSERT(( CopyConstructibleConcept<Visitor> ));
            vis.examine_vertex(u,g);
            vis.finish_vertex(u,g);
            vis.examine_edge(e,g);
        }

        core_numbers_visitor() {}

        core_numbers_visitor(Visitors vis)
            : bfs_visitor<Visitors>(vis) {}

        template <class Vertex, class Graph>
        void initialize_vertex(Vertex, Graph&) {}


        template <class Vertex, class Graph>
        void discover_vertex(Vertex , Graph&) {}


        template <class Vertex, class Graph>
        void gray_target(Vertex, Graph&) {}


        template <class Vertex, class Graph>
        void black_target(Vertex, Graph&) {}


        template <class Edge, class Graph>
        void tree_edge(Edge, Graph&) {}


        template <class Edge, class Graph>
        void non_tree_edge(Edge, Graph&) {}


    template <class Visitors>
    core_numbers_visitor<Visitors> make_core_numbers_visitor(Visitors vis)
    { return core_numbers_visitor<Visitors>(vis); }

            inline constant_value_property_map(ValueType cc) : c(cc) { }

            inline constant_value_property_map(const constant_value_property_map<ValueType>& x)
              : c(x.c) { }

            template <class Vertex>
            inline reference operator[](Vertex) const { return c; }

        template <typename Graph, typename CoreMap, typename EdgeWeightMap>
        void compute_in_degree_map(Graph& g, CoreMap d, EdgeWeightMap wm)
        {
            typename graph_traits<Graph>::vertex_iterator vi,vi_end;
            typename graph_traits<Graph>::out_edge_iterator ei,ei_end;
            for (boost::tie(vi,vi_end) = vertices(g); vi!=vi_end; ++vi) {
                put(d,*vi,0);
            }
            for (boost::tie(vi,vi_end) = vertices(g); vi!=vi_end; ++vi) {
                for (boost::tie(ei,ei_end) = out_edges(*vi,g); ei!=ei_end; ++ei) {
                    put(d,target(*ei,g),get(d,target(*ei,g))+get(wm,*ei));
                }
            }
        }

        template <typename Graph, typename CoreMap,
            typename EdgeWeightMap, typename MutableQueue,
            typename Visitor>
        typename property_traits<CoreMap>::value_type
        core_numbers_impl(Graph& g, CoreMap c, EdgeWeightMap wm,
            MutableQueue& Q, Visitor vis)
        {
            typename property_traits<CoreMap>::value_type v_cn = 0;
            typedef typename graph_traits<Graph>::vertex_descriptor vertex;
            while (!Q.empty())
            {
                // remove v from the Q, and then decrease the core numbers
                // of its successors
                vertex v = Q.top();
                vis.examine_vertex(v,g);
                Q.pop();
                v_cn = get(c,v);
                typename graph_traits<Graph>::out_edge_iterator oi,oi_end;
                for (boost::tie(oi,oi_end) = out_edges(v,g); oi!=oi_end; ++oi) {
                    vis.examine_edge(*oi,g);
                    vertex u = target(*oi,g);
                    // if c[u] > c[v], then u is still in the graph,
                    if (get(c,u) > v_cn) {
                        // remove the edge
                        put(c,u,get(c,u)-get(wm,*oi));
                        if (Q.contains(u))
                          Q.update(u);
                    }
                }
                vis.finish_vertex(v,g);
            }
            return (v_cn);
        }


        template <typename Graph, typename CoreMap, typename EdgeWeightMap,
            typename IndexMap, typename CoreNumVisitor>
        typename property_traits<CoreMap>::value_type
        core_numbers_dispatch(Graph&g, CoreMap c, EdgeWeightMap wm,
            IndexMap im, CoreNumVisitor vis)
        {
            typedef typename property_traits<CoreMap>::value_type D;
            typedef std::less<D> Cmp;
            // build the mutable queue
            typedef typename graph_traits<Graph>::vertex_descriptor vertex;
            std::vector<std::size_t> index_in_heap_data(num_vertices(g));
            typedef iterator_property_map<std::vector<std::size_t>::iterator, IndexMap>
              index_in_heap_map_type;
            index_in_heap_map_type index_in_heap_map(index_in_heap_data.begin(), im);
            typedef d_ary_heap_indirect<vertex, 4, index_in_heap_map_type, CoreMap, Cmp> MutableQueue;
            MutableQueue Q(c, index_in_heap_map, Cmp());
            typename graph_traits<Graph>::vertex_iterator vi,vi_end;
            for (boost::tie(vi,vi_end) = vertices(g); vi!=vi_end; ++vi) {
                Q.push(*vi);
            }
            return core_numbers_impl(g, c, wm, Q, vis);
        }

        template <typename Graph, typename CoreMap, typename PositionMap,
            typename Visitor>
        typename property_traits<CoreMap>::value_type
        core_numbers_impl(Graph& g, CoreMap c, PositionMap pos, Visitor vis)
        {
            typedef typename graph_traits<Graph>::vertices_size_type size_type;
            typedef typename graph_traits<Graph>::degree_size_type degree_type;
            typedef typename graph_traits<Graph>::vertex_descriptor vertex;
            typename graph_traits<Graph>::vertex_iterator vi,vi_end;

            // store the vertex core numbers
            typename property_traits<CoreMap>::value_type v_cn = 0;

            // compute the maximum degree (degrees are in the coremap)
            typename graph_traits<Graph>::degree_size_type max_deg = 0;
            for (boost::tie(vi,vi_end) = vertices(g); vi!=vi_end; ++vi) {
                max_deg = (std::max<typename graph_traits<Graph>::degree_size_type>)(max_deg, get(c,*vi));
            }

            // store the vertices in bins by their degree
            // allocate two extra locations to ease boundary cases
            std::vector<size_type> bin(max_deg+2);
            for (boost::tie(vi,vi_end) = vertices(g); vi!=vi_end; ++vi) {
                ++bin[get(c,*vi)];
            }

            // this loop sets bin[d] to the starting position of vertices
            // with degree d in the vert array for the bucket sort
            size_type cur_pos = 0;
            for (degree_type cur_deg = 0; cur_deg < max_deg+2; ++cur_deg) {
                degree_type tmp = bin[cur_deg];
                bin[cur_deg] = cur_pos;
                cur_pos += tmp;
            }

            // perform the bucket sort with pos and vert so that
            // pos[0] is the vertex of smallest degree
            std::vector<vertex> vert(num_vertices(g));
            for (boost::tie(vi,vi_end) = vertices(g); vi!=vi_end; ++vi) {
                vertex v=*vi;
                size_type p=bin[get(c,v)];
                put(pos,v,p);
                vert[p]=v;
                ++bin[get(c,v)];
            }
            // we ``abused'' bin while placing the vertices, now,
            // we need to restore it
            std::copy(boost::make_reverse_iterator(bin.end()-2),
                boost::make_reverse_iterator(bin.begin()),
                boost::make_reverse_iterator(bin.end()-1));
            // now simulate removing the vertices
            for (size_type i=0; i < num_vertices(g); ++i) {
                vertex v = vert[i];
                vis.examine_vertex(v,g);
                v_cn = get(c,v);
                typename graph_traits<Graph>::out_edge_iterator oi,oi_end;
                for (boost::tie(oi,oi_end) = out_edges(v,g); oi!=oi_end; ++oi) {
                    vis.examine_edge(*oi,g);
                    vertex u = target(*oi,g);
                    // if c[u] > c[v], then u is still in the graph,
                    if (get(c,u) > v_cn) {
                        degree_type deg_u = get(c,u);
                        degree_type pos_u = get(pos,u);
                        // w is the first vertex with the same degree as u
                        // (this is the resort operation!)
                        degree_type pos_w = bin[deg_u];
                        vertex w = vert[pos_w];
                        if (u!=v) {
                            // swap u and w
                            put(pos,u,pos_w);
                            put(pos,w,pos_u);
                            vert[pos_w] = u;
                            vert[pos_u] = w;
                        }
                        // now, the vertices array is sorted assuming
                        // we perform the following step
                        // start the set of vertices with degree of u
                        // one into the future (this now points at vertex
                        // w which we swapped with u).
                        ++bin[deg_u];
                        // we are removing v from the graph, so u's degree
                        // decreases
                        put(c,u,get(c,u)-1);
                    }
                }
                vis.finish_vertex(v,g);
            }
            return v_cn;
        }

    template <typename Graph, typename CoreMap, typename CoreNumVisitor>
    typename property_traits<CoreMap>::value_type
    core_numbers(Graph& g, CoreMap c, CoreNumVisitor vis)
    {
        typedef typename graph_traits<Graph>::vertices_size_type size_type;
        detail::compute_in_degree_map(g,c,
            detail::constant_value_property_map<
                typename property_traits<CoreMap>::value_type>(1) );
        return detail::core_numbers_impl(g,c,
            make_iterator_property_map(
                std::vector<size_type>(num_vertices(g)).begin(),get(vertex_index, g)),
            vis
        );
    }

    template <typename Graph, typename CoreMap>
    typename property_traits<CoreMap>::value_type
    core_numbers(Graph& g, CoreMap c)
    {
        return core_numbers(g, c, make_core_numbers_visitor(null_visitor()));
    }

    template <typename Graph, typename CoreMap, typename EdgeWeightMap,
        typename VertexIndexMap, typename CoreNumVisitor>
    typename property_traits<CoreMap>::value_type
    core_numbers(Graph& g, CoreMap c, EdgeWeightMap wm, VertexIndexMap vim,
        CoreNumVisitor vis)
    {
        typedef typename graph_traits<Graph>::vertices_size_type size_type;
        detail::compute_in_degree_map(g,c,wm);
        return detail::core_numbers_dispatch(g,c,wm,vim,vis);
    }


    template <typename Graph, typename CoreMap>
    typename property_traits<CoreMap>::value_type
    weighted_core_numbers(Graph& g, CoreMap c)
    {
        return weighted_core_numbers(
            g,c, make_core_numbers_visitor(null_visitor())
        );
    }


    template <typename Graph, typename CoreMap, typename CoreNumVisitor>
    typename property_traits<CoreMap>::value_type
    weighted_core_numbers(Graph& g, CoreMap c, CoreNumVisitor vis)
    { return core_numbers(g,c,get(edge_weight,g),get(vertex_index,g),vis); }

    static std::string name() {
      return "digraph";
    }

    static std::string delimiter() {
      return "->";
    }

    static std::string name() {
      return "graph";
    }

    static std::string delimiter() {
      return "--";
    }

    void operator()(std::ostream&) const {
    }


  template <typename T>
  inline std::string escape_dot_string(const T& obj) {
    using namespace boost::xpressive;
    static sregex valid_unquoted_id = (((alpha | '_') >> *_w) | (!as_xpr('-') >> (('.' >> *_d) | (+_d >> !('.' >> *_d)))));
    std::string s(boost::lexical_cast<std::string>(obj));
    if (regex_match(s, valid_unquoted_id)) {
      return s;
    } else {
      boost::algorithm::replace_all(s, "\"", "\\\"");
      return "\"" + s + "\"";
    }
  }

    label_writer(Name _name) : name(_name) {}

    template <class VertexOrEdge>
    void operator()(std::ostream& out, const VertexOrEdge& v) const {
      out << "[label=" << escape_dot_string(get(name, v)) << "]";
    }

  template <class Name>
  inline label_writer<Name>
  make_label_writer(Name n) {
    return label_writer<Name>(n);
  }



  template <class Attribute>
  inline void write_attributes(const Attribute& attr, std::ostream& out) {
    typename Attribute::const_iterator i, iend;
    i    = attr.begin();
    iend = attr.end();

    while ( i != iend ) {
      out << i->first << "=" << escape_dot_string(i->second);
      ++i;
      if ( i != iend )
        out << ", ";
    }
  }


  template<typename Attributes>
  inline void write_all_attributes(Attributes attributes,
                                   const std::string& name,
                                   std::ostream& out)
  {
    typename Attributes::const_iterator i = attributes.begin(),
                                        end = attributes.end();
    if (i != end) {
      out << name << " [\n";
      write_attributes(attributes, out);
      out << "];\n";
    }
  }

    graph_attributes_writer(GraphGraphAttributes gg,
                            GraphNodeAttributes gn,
                            GraphEdgeAttributes ge)
      : g_attributes(gg), n_attributes(gn), e_attributes(ge) { }


    void operator()(std::ostream& out) const {
      write_all_attributes(g_attributes, "graph", out);
      write_all_attributes(n_attributes, "node", out);
      write_all_attributes(e_attributes, "edge", out);
    }


  template <typename GAttrMap, typename NAttrMap, typename EAttrMap>
  graph_attributes_writer<GAttrMap, NAttrMap, EAttrMap>
  make_graph_attributes_writer(const GAttrMap& g_attr, const NAttrMap& n_attr,
                              const EAttrMap& e_attr) {
    return graph_attributes_writer<GAttrMap, NAttrMap, EAttrMap>
      (g_attr, n_attr, e_attr);
  }



  template <typename Graph>
  graph_attributes_writer
    <typename graph_property<Graph, graph_graph_attribute_t>::type,
     typename graph_property<Graph, graph_vertex_attribute_t>::type,
     typename graph_property<Graph, graph_edge_attribute_t>::type>
  make_graph_attributes_writer(const Graph& g)
  {
    typedef typename graph_property<Graph, graph_graph_attribute_t>::type
      GAttrMap;
    typedef typename graph_property<Graph, graph_vertex_attribute_t>::type
      NAttrMap;
    typedef typename graph_property<Graph, graph_edge_attribute_t>::type
      EAttrMap;
    GAttrMap gam = get_property(g, graph_graph_attribute);
    NAttrMap nam = get_property(g, graph_vertex_attribute);
    EAttrMap eam = get_property(g, graph_edge_attribute);
    graph_attributes_writer<GAttrMap, NAttrMap, EAttrMap> writer(gam, nam, eam);
    return writer;
  }

    attributes_writer(AttributeMap attr)
      : attributes(attr) { }


    template <class VorE>
    void operator()(std::ostream& out, const VorE& e) const {
      this->write_attribute(out, attributes[e]);
    }

      template<typename AttributeSequence>
      void write_attribute(std::ostream& out,
                           const AttributeSequence& seq) const
      {
        if (!seq.empty()) {
          out << "[";
          write_attributes(seq, out);
          out << "]";
        }
      }


  template <typename Graph>
  attributes_writer
    <typename property_map<Graph, edge_attribute_t>::const_type>
  make_edge_attributes_writer(const Graph& g)
  {
    typedef typename property_map<Graph, edge_attribute_t>::const_type
      EdgeAttributeMap;
    return attributes_writer<EdgeAttributeMap>(get(edge_attribute, g));
  }


  template <typename Graph>
  attributes_writer
    <typename property_map<Graph, vertex_attribute_t>::const_type>
  make_vertex_attributes_writer(const Graph& g)
  {
    typedef typename property_map<Graph, vertex_attribute_t>::const_type
      VertexAttributeMap;
    return attributes_writer<VertexAttributeMap>(get(vertex_attribute, g));
  }


  template <typename Graph, typename VertexPropertiesWriter,
            typename EdgePropertiesWriter, typename GraphPropertiesWriter,
            typename VertexID>
  inline void
  write_graphviz
    (std::ostream& out, const Graph& g,
     VertexPropertiesWriter vpw,
     EdgePropertiesWriter epw,
     GraphPropertiesWriter gpw,
     VertexID vertex_id
     BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,vertex_list_graph_tag))
  {
    BOOST_CONCEPT_ASSERT((EdgeListGraphConcept<Graph>));

    typedef typename graph_traits<Graph>::directed_category cat_type;
    typedef graphviz_io_traits<cat_type> Traits;
    std::string name = "G";
    out << Traits::name() << " " << escape_dot_string(name) << " {" << std::endl;

    gpw(out); //print graph properties

    typename graph_traits<Graph>::vertex_iterator i, end;

    for(boost::tie(i,end) = vertices(g); i != end; ++i) {
      out << escape_dot_string(get(vertex_id, *i));
      vpw(out, *i); //print vertex attributes
      out << ";" << std::endl;
    }
    typename graph_traits<Graph>::edge_iterator ei, edge_end;
    for(boost::tie(ei, edge_end) = edges(g); ei != edge_end; ++ei) {
      out << escape_dot_string(get(vertex_id, source(*ei, g))) << Traits::delimiter() << escape_dot_string(get(vertex_id, target(*ei, g))) << " ";
      epw(out, *ei); //print edge attributes
      out << ";" << std::endl;
    }
    out << "}" << std::endl;
  }


    template <class Graph_, class RandomAccessIterator, class VertexID>
    void write_graphviz_subgraph (std::ostream& out,
                                  const subgraph<Graph_>& g,
                                  RandomAccessIterator vertex_marker,
                                  RandomAccessIterator edge_marker,
                                  VertexID vertex_id)
    {
      typedef subgraph<Graph_> Graph;
      typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
      typedef typename graph_traits<Graph>::directed_category cat_type;
      typedef graphviz_io_traits<cat_type> Traits;

      typedef typename graph_property<Graph, graph_name_t>::type NameType;
      const NameType& g_name = get_property(g, graph_name);

      if ( g.is_root() )
        out << Traits::name() ;
      else
        out << "subgraph";

      out << " " << escape_dot_string(g_name) << " {" << std::endl;

      typename Graph::const_children_iterator i_child, j_child;

      //print graph/node/edge attributes
#if defined(BOOST_MSVC) && BOOST_MSVC <= 1300
      typedef typename graph_property<Graph, graph_graph_attribute_t>::type
        GAttrMap;
      typedef typename graph_property<Graph, graph_vertex_attribute_t>::type
        NAttrMap;
      typedef typename graph_property<Graph, graph_edge_attribute_t>::type
        EAttrMap;
      GAttrMap gam = get_property(g, graph_graph_attribute);
      NAttrMap nam = get_property(g, graph_vertex_attribute);
      EAttrMap eam = get_property(g, graph_edge_attribute);
      graph_attributes_writer<GAttrMap, NAttrMap, EAttrMap> writer(gam, nam, eam);
      writer(out);
#else
      make_graph_attributes_writer(g)(out);
#endif

      //print subgraph
      for ( boost::tie(i_child,j_child) = g.children();
            i_child != j_child; ++i_child )
        write_graphviz_subgraph(out, *i_child, vertex_marker, edge_marker,
                                vertex_id);

      // Print out vertices and edges not in the subgraphs.

      typename graph_traits<Graph>::vertex_iterator i, end;
      typename graph_traits<Graph>::edge_iterator ei, edge_end;

      for(boost::tie(i,end) = vertices(g); i != end; ++i) {
        Vertex v = g.local_to_global(*i);
        int pos = get(vertex_id, v);
        if ( vertex_marker[pos] ) {
          vertex_marker[pos] = false;
          out << escape_dot_string(pos);
#if defined(BOOST_MSVC) && BOOST_MSVC <= 1300
          typedef typename property_map<Graph, vertex_attribute_t>::const_type
            VertexAttributeMap;
          attributes_writer<VertexAttributeMap> vawriter(get(vertex_attribute,
                                                             g.root()));
          vawriter(out, v);
#else
          make_vertex_attributes_writer(g.root())(out, v);
#endif
          out << ";" << std::endl;
        }
      }

      for (boost::tie(ei, edge_end) = edges(g); ei != edge_end; ++ei) {
        Vertex u = g.local_to_global(source(*ei,g)),
          v = g.local_to_global(target(*ei, g));
        int pos = get(get(edge_index, g.root()), g.local_to_global(*ei));
        if ( edge_marker[pos] ) {
          edge_marker[pos] = false;
          out << escape_dot_string(get(vertex_id, u)) << " " << Traits::delimiter()
              << " " << escape_dot_string(get(vertex_id, v));
#if defined(BOOST_MSVC) && BOOST_MSVC <= 1300
          typedef typename property_map<Graph, edge_attribute_t>::const_type
            EdgeAttributeMap;
          attributes_writer<EdgeAttributeMap> eawriter(get(edge_attribute, g));
          eawriter(out, *ei);
#else
          make_edge_attributes_writer(g)(out, *ei); //print edge properties
#endif
          out << ";" << std::endl;
        }
      }
      out << "}" << std::endl;
    }

    dynamic_properties_writer(const dynamic_properties& dp) : dp(&dp) { }


    template<typename Descriptor>
    void operator()(std::ostream& out, Descriptor key) const
    {
      bool first = true;
      for (dynamic_properties::const_iterator i = dp->begin();
           i != dp->end(); ++i) {
        if (typeid(key) == i->second->key()) {
          if (first) out << " [";
          else out << ", ";
          first = false;

          out << i->first << "=" << escape_dot_string(i->second->get_string(key));
        }
      }

      if (!first) out << "]";
    }

    dynamic_vertex_properties_writer(const dynamic_properties& dp,
                                     const std::string& node_id)
      : dp(&dp), node_id(&node_id) { }


    template<typename Descriptor>
    void operator()(std::ostream& out, Descriptor key) const
    {
      bool first = true;
      for (dynamic_properties::const_iterator i = dp->begin();
           i != dp->end(); ++i) {
        if (typeid(key) == i->second->key()
            && i->first != *node_id) {
          if (first) out << " [";
          else out << ", ";
          first = false;

          out << i->first << "=" << escape_dot_string(i->second->get_string(key));
        }
      }

      if (!first) out << "]";
    }


      node_id_property_map() {}


    template<typename Vertex>
    inline std::string
    get(node_id_property_map<Vertex> pm,
        typename node_id_property_map<Vertex>::key_type v)
    { return get(*pm.node_id, *pm.dp, v); }


  template<typename Graph>
  inline void
  write_graphviz_dp(std::ostream& out, const Graph& g,
                    const dynamic_properties& dp,
                    const std::string& node_id = "node_id"
                    BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,vertex_list_graph_tag))
  {
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    write_graphviz_dp(out, g, dp, node_id,
                      graph::detail::node_id_property_map<Vertex>(dp, node_id));
  }

  virtual ~graph_exception() throw() {}

  bad_parallel_edge(const std::string& i, const std::string& j) :
    from(i), to(j) {}


  virtual ~bad_parallel_edge() throw() {}

  const char* what() const throw() {
    if(statement.empty())
      statement =
        std::string("Failed to add parallel edge: (")
        + from +  "," + to + ")\n";

    return statement.c_str();
  }

  virtual ~directed_graph_error() throw() {}

  virtual const char* what() const throw() {
    return
      "read_graphviz: "
      "Tried to read a directed graph into an undirected graph.";
  }

  virtual ~undirected_graph_error() throw() {}

  virtual const char* what() const throw() {
    return
      "read_graphviz: "
      "Tried to read an undirected graph into a directed graph.";
  }

  bad_graphviz_syntax(const std::string& errmsg)
    : errmsg(errmsg) {}

  const char* what() const throw () {return errmsg.c_str();}

  ~bad_graphviz_syntax() throw () {};

  explicit edge_t(int i) : idx_(i) {}

  static edge_t new_edge() {
    static int idx = 0;
    return edge_t(idx++);
  };


  bool operator==(const edge_t& rhs) const {
    return idx_ == rhs.idx_;
  }

  bool operator<(const edge_t& rhs) const {
    return idx_ < rhs.idx_;
  }

  virtual ~mutate_graph() {}

  mutate_graph_impl(MutableGraph& graph, dynamic_properties& dp,
                    std::string node_id_prop)
    : graph_(graph), dp_(dp), node_id_prop_(node_id_prop) { }


  ~mutate_graph_impl() {}


  bool is_directed() const
  {
    return
      boost::is_convertible<
        typename boost::graph_traits<MutableGraph>::directed_category,
        boost::directed_tag>::value;
  }


  virtual void do_add_vertex(const node_t& node)
  {
    // Add the node to the graph.
    bgl_vertex_t v = add_vertex(graph_);

    // Set up a mapping from name to BGL vertex.
    bgl_nodes.insert(std::make_pair(node, v));

    // node_id_prop_ allows the caller to see the real id names for nodes.
    put(node_id_prop_, dp_, v, node);
  }


  void
  do_add_edge(const edge_t& edge, const node_t& source, const node_t& target)
  {
    std::pair<bgl_edge_t, bool> result =
     add_edge(bgl_nodes[source], bgl_nodes[target], graph_);

    if(!result.second) {
      // In the case of no parallel edges allowed
        boost::throw_exception(bad_parallel_edge(source, target));
    } else {
      bgl_edges.insert(std::make_pair(edge, result.first));
    }
  }


  void
  set_node_property(const id_t& key, const node_t& node, const id_t& value)
  {
    put(key, dp_, bgl_nodes[node], value);
  }


  void
  set_edge_property(const id_t& key, const edge_t& edge, const id_t& value)
  {
    put(key, dp_, bgl_edges[edge], value);
  }


  void
  set_graph_property(const id_t& key, const id_t& value)
  {
    /* RG: pointer to graph prevents copying */
    put(key, dp_, &graph_, value);
  }


  void finish_building_graph() {}

  mutate_graph_impl(CSRGraph& graph, dynamic_properties& dp,
                    std::string node_id_prop)
    : graph_(graph), dp_(dp), vertex_count(0), node_id_prop_(node_id_prop) { }


  ~mutate_graph_impl() {}


  void finish_building_graph() {
    typedef compressed_sparse_row_graph<directedS, no_property, bgl_edge_t, GraphProperty, Vertex, EdgeIndex> TempCSRGraph;
    TempCSRGraph temp(edges_are_unsorted_multi_pass,
                      edges_to_add.begin(), edges_to_add.end(),
                      counting_iterator<bgl_edge_t>(0),
                      vertex_count);
    set_property(temp, graph_all, get_property(graph_, graph_all));
    graph_.assign(temp); // Copies structure, not properties
    std::vector<edge_descriptor> edge_permutation_from_sorting(num_edges(temp));
    BGL_FORALL_EDGES_T(e, temp, TempCSRGraph) {
      edge_permutation_from_sorting[temp[e]] = e;
    }
    typedef boost::tuple<id_t, bgl_vertex_t, id_t> v_prop;
    BOOST_FOREACH(const v_prop& t, vertex_props) {
      put(boost::get<0>(t), dp_, boost::get<1>(t), boost::get<2>(t));
    }
    typedef boost::tuple<id_t, bgl_edge_t, id_t> e_prop;
    BOOST_FOREACH(const e_prop& t, edge_props) {
      put(boost::get<0>(t), dp_, edge_permutation_from_sorting[boost::get<1>(t)], boost::get<2>(t));
    }
  }


  bool is_directed() const
  {
    return
      boost::is_convertible<
        typename boost::graph_traits<CSRGraph>::directed_category,
        boost::directed_tag>::value;
  }


  virtual void do_add_vertex(const node_t& node)
  {
    // Add the node to the graph.
    bgl_vertex_t v = vertex_count++;

    // Set up a mapping from name to BGL vertex.
    bgl_nodes.insert(std::make_pair(node, v));

    // node_id_prop_ allows the caller to see the real id names for nodes.
    vertex_props.push_back(boost::make_tuple(node_id_prop_, v, node));
  }


  void
  do_add_edge(const edge_t& edge, const node_t& source, const node_t& target)
  {
    bgl_edge_t result = edges_to_add.size();
    edges_to_add.push_back(std::make_pair(bgl_nodes[source], bgl_nodes[target]));
    bgl_edges.insert(std::make_pair(edge, result));
  }


  void
  set_node_property(const id_t& key, const node_t& node, const id_t& value)
  {
    vertex_props.push_back(boost::make_tuple(key, bgl_nodes[node], value));
  }


  void
  set_edge_property(const id_t& key, const edge_t& edge, const id_t& value)
  {
    edge_props.push_back(boost::make_tuple(key, bgl_edges[edge], value));
  }


  void
  set_graph_property(const id_t& key, const id_t& value)
  {
    /* RG: pointer to graph prevents copying */
    put(key, dp_, &graph_, value);
  }

template <typename MutableGraph>
bool read_graphviz(const std::string& data,
                   MutableGraph& graph,
                   dynamic_properties& dp,
                   std::string const& node_id = "node_id") {
#ifdef BOOST_GRAPH_USE_SPIRIT_PARSER
  return read_graphviz_spirit(data.begin(), data.end(), graph, dp, node_id);
#else // Non-Spirit parser
  return read_graphviz_new(data,graph,dp,node_id);
#endif
}

      
      inline adjacency_iterator() {}

      inline adjacency_iterator(OutEdgeIter const& i, const Graph* g) : super_t(i), m_g(g) { }


      inline Vertex
      dereference() const
        { return target(*this->base(), *m_g); }


      inline inv_adjacency_iterator() { }

      inline inv_adjacency_iterator(InEdgeIter const& i, const Graph* g) : super_t(i), m_g(g) { }


      inline Vertex
      dereference() const
        { return source(*this->base(), *m_g); }


    inline degree_type operator ()(vertex_type v, const Graph& g)
    {
        BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<Graph> ));
        return out_degree(v, g);
    }


template <typename Graph>
inline influence_measure<Graph>
measure_influence(const Graph&)
{ return influence_measure<Graph>(); }


    inline degree_type operator ()(vertex_type v, const Graph& g)
    {
        BOOST_CONCEPT_ASSERT(( BidirectionalGraphConcept<Graph> ));
        return in_degree(v, g);
    }


template <typename Graph>
inline prestige_measure<Graph>
measure_prestige(const Graph&)
{ return prestige_measure<Graph>(); }



template <typename Graph, typename Vertex, typename Measure>
inline typename Measure::degree_type
degree_centrality(const Graph& g, Vertex v, Measure measure)
{
    BOOST_CONCEPT_ASSERT(( DegreeMeasureConcept<Measure, Graph> ));
    return measure(v, g);
}


template <typename Graph, typename Vertex>
inline typename graph_traits<Graph>::degree_size_type
degree_centrality(const Graph& g, Vertex v)
{
    return degree_centrality(g, v, measure_influence(g));
}


template <typename Graph, typename Vertex>
inline typename graph_traits<Graph>::degree_size_type
influence(const Graph& g, Vertex v)
{ return degree_centrality(g, v, measure_influence(g)); }



template <typename Graph, typename Vertex>
inline typename graph_traits<Graph>::degree_size_type
prestige(const Graph& g, Vertex v)
{ return degree_centrality(g, v, measure_prestige(g)); }



template <typename Graph, typename CentralityMap, typename Measure>
inline void
all_degree_centralities(const Graph& g, CentralityMap cent, Measure measure)
{
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename graph_traits<Graph>::vertex_iterator VertexIterator;
    BOOST_CONCEPT_ASSERT(( WritablePropertyMapConcept<CentralityMap,Vertex> ));
    typedef typename property_traits<CentralityMap>::value_type Centrality;

    VertexIterator i, end;
    for(boost::tie(i, end) = vertices(g); i != end; ++i) {
        Centrality c = degree_centrality(g, *i, measure);
        put(cent, *i, c);
    }
}


template <typename Graph, typename CentralityMap>
inline void all_degree_centralities(const Graph& g, CentralityMap cent)
{ all_degree_centralities(g, cent, measure_influence(g)); }


template <typename Graph, typename CentralityMap>
inline void all_influence_values(const Graph& g, CentralityMap cent)
{ all_degree_centralities(g, cent, measure_influence(g)); }


template <typename Graph, typename CentralityMap>
inline void all_prestige_values(const Graph& g, CentralityMap cent)
{ all_degree_centralities(g, cent, measure_prestige(g)); }

    ssca_iterator()
      : gen(), verticesRemaining(0) { }

    ssca_iterator(RandomGenerator& gen, vertices_size_type totVertices, 
                  vertices_size_type maxCliqueSize, double probUnidirectional, 
                  int maxParallelEdges, double probIntercliqueEdges) 
      : gen(&gen), totVertices(totVertices), maxCliqueSize(maxCliqueSize), 
        probUnidirectional(probUnidirectional), maxParallelEdges(maxParallelEdges),
        probIntercliqueEdges(probIntercliqueEdges), currentClique(0), 
        verticesRemaining(totVertices)
    { 
      cliqueNum = std::vector<int>(totVertices, -1);
      current = std::make_pair(0,0);
    }


    reference operator*() const { return current; }

    pointer operator->() const { return &current; }

    
    ssca_iterator& operator++()
    {
      BOOST_USING_STD_MIN();
      while (values.empty() && verticesRemaining > 0) { // If there are no values left, generate a new clique
        uniform_int<vertices_size_type> clique_size(1, maxCliqueSize);
        uniform_int<vertices_size_type> rand_vertex(0, totVertices-1);
        uniform_int<int> num_parallel_edges(1, maxParallelEdges);
        uniform_int<short> direction(0,1);
        uniform_01<RandomGenerator> prob(*gen);
        std::vector<vertices_size_type> cliqueVertices;

        cliqueVertices.clear();
        vertices_size_type size = min BOOST_PREVENT_MACRO_SUBSTITUTION (clique_size(*gen), verticesRemaining);
        while (cliqueVertices.size() < size) {
          vertices_size_type v = rand_vertex(*gen);
          if (cliqueNum[v] == -1) {
            cliqueNum[v] = currentClique;
            cliqueVertices.push_back(v);
            verticesRemaining--;
          }
        }  // Nick: This is inefficient when only a few vertices remain...
           //       I should probably just select the remaining vertices 
           //       in order when only a certain fraction remain.

        typename std::vector<vertices_size_type>::iterator first, second;
        for (first = cliqueVertices.begin(); first != cliqueVertices.end(); ++first)
          for (second = first+1; second != cliqueVertices.end(); ++second) {
            Direction d;
            int edges;

            d = prob() < probUnidirectional ? (direction(*gen) == 0 ? FORWARD : BACKWARD) : BOTH;

            if (d & FORWARD) {
              edges = num_parallel_edges(*gen);
              for (int i = 0; i < edges; ++i)
                values.push(std::make_pair(*first, *second));
            }
              
            if (d & BACKWARD) {
              edges = num_parallel_edges(*gen);
              for (int i = 0; i < edges; ++i)
                values.push(std::make_pair(*second, *first));
            }
          }

        if (verticesRemaining == 0) {
          // Generate interclique edges
          for (vertices_size_type i = 0; i < totVertices; ++i) {
            double p = probIntercliqueEdges;
            for (vertices_size_type d = 2; d < totVertices/2; d *= 2, p/= 2) {
              vertices_size_type j = (i+d) % totVertices;
              if (cliqueNum[j] != cliqueNum[i] && prob() < p) {
                int edges = num_parallel_edges(*gen);
                for (int i = 0; i < edges; ++i)
                  values.push(std::make_pair(i, j));
              }
            }
          }
        }

        currentClique++;
      } 

      if (!values.empty()) { // If we're not done return a value
        current = values.front();
        values.pop();
      }

      return *this;
    }


    ssca_iterator operator++(int)
    {
      ssca_iterator temp(*this);
      ++(*this);
      return temp;
    }


    bool operator==(const ssca_iterator& other) const
    {
      return verticesRemaining == other.verticesRemaining && values.empty() && other.values.empty();
    }


    bool operator!=(const ssca_iterator& other) const
    { return !(*this == other); }


    brandes_dijkstra_visitor(std::stack<vertex_descriptor>& ordered_vertices,
                             WeightMap weight,
                             IncomingMap incoming,
                             DistanceMap distance,
                             PathCountMap path_count)
      : ordered_vertices(ordered_vertices), weight(weight), 
        incoming(incoming), distance(distance),
        path_count(path_count)
    { }

    void edge_relaxed(edge_descriptor e, const Graph& g) 
    { 
      vertex_descriptor v = source(e, g), w = target(e, g);
      incoming[w].clear();
      incoming[w].push_back(e);
      put(path_count, w, get(path_count, v));
    }

    void edge_not_relaxed(edge_descriptor e, const Graph& g) 
    {
      typedef typename property_traits<WeightMap>::value_type weight_type;
      typedef typename property_traits<DistanceMap>::value_type distance_type;
      vertex_descriptor v = source(e, g), w = target(e, g);
      distance_type d_v = get(distance, v), d_w = get(distance, w);
      weight_type w_e = get(weight, e);

      closed_plus<distance_type> combine;
      if (d_w == combine(d_v, w_e)) {
        put(path_count, w, get(path_count, w) + get(path_count, v));
        incoming[w].push_back(e);
      }
    }

    void examine_vertex(vertex_descriptor w, const Graph&) 
    { 
      ordered_vertices.push(w);
    }

    brandes_dijkstra_shortest_paths(WeightMap weight_map) 
      : weight_map(weight_map) { }


    template<typename Graph, typename IncomingMap, typename DistanceMap, 
             typename PathCountMap, typename VertexIndexMap>
    void 
    operator()(Graph& g, 
               typename graph_traits<Graph>::vertex_descriptor s,
               std::stack<typename graph_traits<Graph>::vertex_descriptor>& ov,
               IncomingMap incoming,
               DistanceMap distance,
               PathCountMap path_count,
               VertexIndexMap vertex_index)
    {
      typedef brandes_dijkstra_visitor<Graph, WeightMap, IncomingMap, 
                                       DistanceMap, PathCountMap> visitor_type;
      visitor_type visitor(ov, weight_map, incoming, distance, path_count);

      dijkstra_shortest_paths(g, s, 
                              boost::weight_map(weight_map)
                              .vertex_index_map(vertex_index)
                              .distance_map(distance)
                              .visitor(visitor));
    }

      
      visitor_type(IncomingMap incoming, DistanceMap distance, 
                   PathCountMap path_count, 
                   std::stack<vertex_descriptor>& ordered_vertices)
        : incoming(incoming), distance(distance), 
          path_count(path_count), ordered_vertices(ordered_vertices) { }

      void examine_vertex(vertex_descriptor v, Graph&)
      {
        ordered_vertices.push(v);
      }

      void tree_edge(edge_descriptor e, Graph& g)
      {
        vertex_descriptor v = source(e, g);
        vertex_descriptor w = target(e, g);
        put(distance, w, get(distance, v) + 1);
        
        put(path_count, w, get(path_count, v));
        incoming[w].push_back(e);
      }

      void non_tree_edge(edge_descriptor e, Graph& g)
      {
        vertex_descriptor v = source(e, g);
        vertex_descriptor w = target(e, g);
        if (get(distance, w) == get(distance, v) + 1) {
          put(path_count, w, get(path_count, w) + get(path_count, v));
          incoming[w].push_back(e);
        }
      }


    template<typename Graph, typename IncomingMap, typename DistanceMap, 
             typename PathCountMap, typename VertexIndexMap>
    void 
    operator()(Graph& g, 
               typename graph_traits<Graph>::vertex_descriptor s,
               std::stack<typename graph_traits<Graph>::vertex_descriptor>& ov,
               IncomingMap incoming,
               DistanceMap distance,
               PathCountMap path_count,
               VertexIndexMap vertex_index)
    {
      typedef typename graph_traits<Graph>::vertex_descriptor
        vertex_descriptor;

      visitor_type<Graph, IncomingMap, DistanceMap, PathCountMap>
        visitor(incoming, distance, path_count, ov);
      
      std::vector<default_color_type> 
        colors(num_vertices(g), color_traits<default_color_type>::white());
      boost::queue<vertex_descriptor> Q;
      breadth_first_visit(g, s, Q, visitor, 
                          make_iterator_property_map(colors.begin(), 
                                                     vertex_index));
    }

  template<typename Key, typename T>
  inline void 
  update_centrality(dummy_property_map, const Key&, const T&) { }

  template<typename CentralityMap, typename Key, typename T>
  inline void 
  update_centrality(CentralityMap centrality_map, Key k, const T& x)
  { put(centrality_map, k, get(centrality_map, k) + x); }


  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
           typename IncomingMap, typename DistanceMap, 
           typename DependencyMap, typename PathCountMap,
           typename VertexIndexMap, typename ShortestPaths>
  void 
  brandes_betweenness_centrality_impl(const Graph& g, 
                                      CentralityMap centrality,     // C_B
                                      EdgeCentralityMap edge_centrality_map,
                                      IncomingMap incoming, // P
                                      DistanceMap distance,         // d
                                      DependencyMap dependency,     // delta
                                      PathCountMap path_count,      // sigma
                                      VertexIndexMap vertex_index,
                                      ShortestPaths shortest_paths)
  {
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
    typedef typename graph_traits<Graph>::edge_iterator edge_iterator;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;

    // Initialize centrality
    init_centrality_map(vertices(g), centrality);
    init_centrality_map(edges(g), edge_centrality_map);

    std::stack<vertex_descriptor> ordered_vertices;
    vertex_iterator s, s_end;
    for (boost::tie(s, s_end) = vertices(g); s != s_end; ++s) {
      // Initialize for this iteration
      vertex_iterator w, w_end;
      for (boost::tie(w, w_end) = vertices(g); w != w_end; ++w) {
        incoming[*w].clear();
        put(path_count, *w, 0);
        put(dependency, *w, 0);
      }
      put(path_count, *s, 1);
      
      // Execute the shortest paths algorithm. This will be either
      // Dijkstra's algorithm or a customized breadth-first search,
      // depending on whether the graph is weighted or unweighted.
      shortest_paths(g, *s, ordered_vertices, incoming, distance,
                     path_count, vertex_index);
      
      while (!ordered_vertices.empty()) {
        vertex_descriptor w = ordered_vertices.top();
        ordered_vertices.pop();
        
        typedef typename property_traits<IncomingMap>::value_type
          incoming_type;
        typedef typename incoming_type::iterator incoming_iterator;
        typedef typename property_traits<DependencyMap>::value_type 
          dependency_type;
        
        for (incoming_iterator vw = incoming[w].begin();
             vw != incoming[w].end(); ++vw) {
          vertex_descriptor v = source(*vw, g);
          dependency_type factor = dependency_type(get(path_count, v))
            / dependency_type(get(path_count, w));
          factor *= (dependency_type(1) + get(dependency, w));
          put(dependency, v, get(dependency, v) + factor);
          update_centrality(edge_centrality_map, *vw, factor);
        }
        
        if (w != *s) {
          update_centrality(centrality, w, get(dependency, w));
        }
      }
    }

    typedef typename graph_traits<Graph>::directed_category directed_category;
    const bool is_undirected = 
      is_convertible<directed_category*, undirected_tag*>::value;
    if (is_undirected) {
      divide_centrality_by_two(vertices(g), centrality);
      divide_centrality_by_two(edges(g), edge_centrality_map);
    }
  }


template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
         typename IncomingMap, typename DistanceMap, 
         typename DependencyMap, typename PathCountMap, 
         typename VertexIndexMap>
void 
brandes_betweenness_centrality(const Graph& g, 
                               CentralityMap centrality,     // C_B
                               EdgeCentralityMap edge_centrality_map,
                               IncomingMap incoming, // P
                               DistanceMap distance,         // d
                               DependencyMap dependency,     // delta
                               PathCountMap path_count,      // sigma
                               VertexIndexMap vertex_index
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,vertex_list_graph_tag))
{
  detail::graph::brandes_unweighted_shortest_paths shortest_paths;

  detail::graph::brandes_betweenness_centrality_impl(g, centrality, 
                                                     edge_centrality_map,
                                                     incoming, distance,
                                                     dependency, path_count,
                                                     vertex_index, 
                                                     shortest_paths);
}


template<typename Graph, typename CentralityMap, typename EdgeCentralityMap, 
         typename IncomingMap, typename DistanceMap, 
         typename DependencyMap, typename PathCountMap, 
         typename VertexIndexMap, typename WeightMap>    
void 
brandes_betweenness_centrality(const Graph& g, 
                               CentralityMap centrality,     // C_B
                               EdgeCentralityMap edge_centrality_map,
                               IncomingMap incoming, // P
                               DistanceMap distance,         // d
                               DependencyMap dependency,     // delta
                               PathCountMap path_count,      // sigma
                               VertexIndexMap vertex_index,
                               WeightMap weight_map
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,vertex_list_graph_tag))
{
  detail::graph::brandes_dijkstra_shortest_paths<WeightMap>
    shortest_paths(weight_map);

  detail::graph::brandes_betweenness_centrality_impl(g, centrality, 
                                                     edge_centrality_map,
                                                     incoming, distance,
                                                     dependency, path_count,
                                                     vertex_index, 
                                                     shortest_paths);
}

  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
           typename WeightMap, typename VertexIndexMap>
  void 
  brandes_betweenness_centrality_dispatch2(const Graph& g,
                                           CentralityMap centrality,
                                           EdgeCentralityMap edge_centrality_map,
                                           WeightMap weight_map,
                                           VertexIndexMap vertex_index)
  {
    typedef typename graph_traits<Graph>::degree_size_type degree_size_type;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
    typedef typename mpl::if_c<(is_same<CentralityMap, 
                                        dummy_property_map>::value),
                                         EdgeCentralityMap, 
                               CentralityMap>::type a_centrality_map;
    typedef typename property_traits<a_centrality_map>::value_type 
      centrality_type;

    typename graph_traits<Graph>::vertices_size_type V = num_vertices(g);
    
    std::vector<std::vector<edge_descriptor> > incoming(V);
    std::vector<centrality_type> distance(V);
    std::vector<centrality_type> dependency(V);
    std::vector<degree_size_type> path_count(V);

    brandes_betweenness_centrality(
      g, centrality, edge_centrality_map,
      make_iterator_property_map(incoming.begin(), vertex_index),
      make_iterator_property_map(distance.begin(), vertex_index),
      make_iterator_property_map(dependency.begin(), vertex_index),
      make_iterator_property_map(path_count.begin(), vertex_index),
      vertex_index,
      weight_map);
  }

  

  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
           typename VertexIndexMap>
  void 
  brandes_betweenness_centrality_dispatch2(const Graph& g,
                                           CentralityMap centrality,
                                           EdgeCentralityMap edge_centrality_map,
                                           VertexIndexMap vertex_index)
  {
    typedef typename graph_traits<Graph>::degree_size_type degree_size_type;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
    typedef typename mpl::if_c<(is_same<CentralityMap, 
                                        dummy_property_map>::value),
                                         EdgeCentralityMap, 
                               CentralityMap>::type a_centrality_map;
    typedef typename property_traits<a_centrality_map>::value_type 
      centrality_type;

    typename graph_traits<Graph>::vertices_size_type V = num_vertices(g);
    
    std::vector<std::vector<edge_descriptor> > incoming(V);
    std::vector<centrality_type> distance(V);
    std::vector<centrality_type> dependency(V);
    std::vector<degree_size_type> path_count(V);

    brandes_betweenness_centrality(
      g, centrality, edge_centrality_map,
      make_iterator_property_map(incoming.begin(), vertex_index),
      make_iterator_property_map(distance.begin(), vertex_index),
      make_iterator_property_map(dependency.begin(), vertex_index),
      make_iterator_property_map(path_count.begin(), vertex_index),
      vertex_index);
  }

    template<typename Graph, typename CentralityMap, 
             typename EdgeCentralityMap, typename VertexIndexMap>
    static void 
    run(const Graph& g, CentralityMap centrality, 
        EdgeCentralityMap edge_centrality_map, VertexIndexMap vertex_index,
        WeightMap weight_map)
    {
      brandes_betweenness_centrality_dispatch2(g, centrality, edge_centrality_map,
                                               weight_map, vertex_index);
    }

    template<typename Graph, typename CentralityMap, 
             typename EdgeCentralityMap, typename VertexIndexMap>
    static void 
    run(const Graph& g, CentralityMap centrality, 
        EdgeCentralityMap edge_centrality_map, VertexIndexMap vertex_index,
        param_not_found)
    {
      brandes_betweenness_centrality_dispatch2(g, centrality, edge_centrality_map,
                                               vertex_index);
    }


template<typename Graph, typename Param, typename Tag, typename Rest>
void 
brandes_betweenness_centrality(const Graph& g, 
                               const bgl_named_params<Param,Tag,Rest>& params
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,vertex_list_graph_tag))
{
  typedef bgl_named_params<Param,Tag,Rest> named_params;

  typedef typename get_param_type<edge_weight_t, named_params>::type ew;
  detail::graph::brandes_betweenness_centrality_dispatch1<ew>::run(
    g, 
    choose_param(get_param(params, vertex_centrality), 
                 dummy_property_map()),
    choose_param(get_param(params, edge_centrality), 
                 dummy_property_map()),
    choose_const_pmap(get_param(params, vertex_index), g, vertex_index),
    get_param(params, edge_weight));
}

template<typename Graph, typename CentralityMap>
typename disable_if<detail::graph::is_bgl_named_params<CentralityMap>,
                    void>::type
brandes_betweenness_centrality(const Graph& g, CentralityMap centrality
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,vertex_list_graph_tag))
{
  detail::graph::brandes_betweenness_centrality_dispatch2(
    g, centrality, dummy_property_map(), get(vertex_index, g));
}


template<typename Graph, typename CentralityMap, typename EdgeCentralityMap>
void 
brandes_betweenness_centrality(const Graph& g, CentralityMap centrality,
                               EdgeCentralityMap edge_centrality_map
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,vertex_list_graph_tag))
{
  detail::graph::brandes_betweenness_centrality_dispatch2(
    g, centrality, edge_centrality_map, get(vertex_index, g));
}

template<typename Graph, typename CentralityMap>
void 
relative_betweenness_centrality(const Graph& g, CentralityMap centrality)
{
  typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
  typedef typename property_traits<CentralityMap>::value_type centrality_type;

  typename graph_traits<Graph>::vertices_size_type n = num_vertices(g);
  centrality_type factor = centrality_type(2)/centrality_type(n*n - 3*n + 2);
  vertex_iterator v, v_end;
  for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
    put(centrality, *v, factor * get(centrality, *v));
  }
}

template<typename Graph, typename CentralityMap>
typename property_traits<CentralityMap>::value_type
central_point_dominance(const Graph& g, CentralityMap centrality
                        BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,vertex_list_graph_tag))
{
  using std::max;

  typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
  typedef typename property_traits<CentralityMap>::value_type centrality_type;

  typename graph_traits<Graph>::vertices_size_type n = num_vertices(g);

  // Find max centrality
  centrality_type max_centrality(0);
  vertex_iterator v, v_end;
  for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
    max_centrality = (max)(max_centrality, get(centrality, *v));
  }

  // Compute central point dominance
  centrality_type sum(0);
  for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
    sum += (max_centrality - get(centrality, *v));
  }
  return sum/(n-1);
}


  dimacs_basic_reader( std::istream& in, bool want_weights = true ) : 
      inpt( in ), seen_edges( 0 ), want_weights(want_weights)
    {
    while( getline( inpt, buf ) && !buf.empty() && buf[0] == 'c' );
    
    if( buf[0] != 'p' ) {
        boost::throw_exception(dimacs_exception());
    }
    
    std::stringstream instr( buf );
    std::string junk;

    instr >> junk >> junk >> num_vertices >> num_edges;
    read_edge_weights.push( -1 );
    incr( edge_weight );
  }

  dimacs_basic_reader() : inpt( std::cin ), num_vertices( 0 ), 
                          num_edges( 0 ), seen_edges( 0 ), want_weights(false) {}


  edge_type edge_deref() {
    BOOST_ASSERT( !read_edges.empty() );
    return read_edges.front();
   }


  inline edge_type* edge_ref() {
    BOOST_ASSERT( !read_edges.empty() );
    return &read_edges.front();
  }


  inline edge_weight_type edge_weight_deref() {
    BOOST_ASSERT( !read_edge_weights.empty() );
    return read_edge_weights.front();
  }


  inline dimacs_basic_reader incr( incr_mode mode ) {
    if( mode == edge ) {
      BOOST_ASSERT( !read_edges.empty() );
      read_edges.pop();
    }
    else if( mode == edge_weight ) {
      BOOST_ASSERT( !read_edge_weights.empty() );
      read_edge_weights.pop();
    }

    if( (mode == edge && read_edges.empty()) ||
        (mode == edge_weight && read_edge_weights.empty() )) {

      if( seen_edges > num_edges ) {
          boost::throw_exception(dimacs_exception());
      }

      while( getline( inpt, buf ) && !buf.empty() && buf[0] == 'c' );
      
      if( !inpt.eof() ) {
          int source, dest, weight;
          read_edge_line((char*) buf.c_str(), source, dest, weight);

          seen_edges++;
          source--;
          dest--;
        
          read_edges.push( edge_type( source, dest ) );
          if (want_weights) {
              read_edge_weights.push( weight );
          }
      }
      BOOST_ASSERT( read_edges.size() < 100 );
      BOOST_ASSERT( read_edge_weights.size() < 100 );
    }

    // the 1000000 just happens to be about how many edges can be read in 
    // 10s
//     if( !(seen_edges % 1000000) && !process_id( pg ) && mode == edge ) {
//       std::cout << "read " << seen_edges << " edges" << std::endl;
//     }
    return *this;
  }


  inline bool done_edges() {
    return inpt.eof() && read_edges.size() == 0;
  }


  inline bool done_edge_weights() {
    return inpt.eof() && read_edge_weights.size() == 0;
  }


  inline vertices_size_type n_vertices() {
    return num_vertices;
  }

  
  inline vertices_size_type processed_edges() {
    return seen_edges - read_edges.size();
  }


  inline vertices_size_type processed_edge_weights() {
    return seen_edges - read_edge_weights.size();
  }


  inline vertices_size_type n_edges() {
    return num_edges;
  }

    bool read_edge_line(char *linebuf, int &from, int &to, int &weight)
    {
        char *fs = NULL, *ts = NULL, *ws = NULL;
        char *tmp = linebuf + 2;

        fs = tmp;
        if ('e' == linebuf[0]) {
            while (*tmp != '\n' && *tmp != '\0') {
                if (*tmp == ' ') { 
                    *tmp = '\0';
                    ts = ++tmp;
                    break;
                }
                tmp++;
            }
            *tmp = '\0';
            if (NULL == fs || NULL == ts) return false;
            from = atoi(fs); to = atoi(ts); weight = 0;

        } else if ('a' == linebuf[0]) {
            while (*tmp != '\n' && *tmp != '\0') {
                if (*tmp == ' ') { 
                    *tmp = '\0';
                    ts = ++tmp;
                    break;
                }
                tmp++;
            } 
            while (*tmp != '\n' && *tmp != '\0') {
                if (*tmp == ' ') { 
                    *tmp = '\0';
                    ws = ++tmp;
                    break;
                }
                tmp++;
            }
            while (*tmp != '\n' && *tmp != '\0') tmp++;
            *tmp = '\0';
            if (fs == NULL || ts == NULL || ws == NULL) return false;
            from = atoi(fs); to = atoi(ts) ; 
            if (want_weights) weight = atoi(ws); else weight = 0;

        } else {
            return false;
        }

        return true;
    }


  dimacs_edge_iterator( T& reader ) :
    reader( reader ) {}


  inline dimacs_edge_iterator& operator++() {
    reader.incr( dimacs_basic_reader::edge );
    return *this;
  }


  inline edge_type operator*() {
    return reader.edge_deref();
  }


  inline edge_type* operator->() {
    return reader.edge_ref();
  }

  inline bool operator==( dimacs_edge_iterator arg ) {
    if( reader.n_vertices() == 0 ) {
      return arg.reader.done_edges();
    }
    else if( arg.reader.n_vertices() == 0 ) {
      return reader.done_edges();
    }
    else {
      return false;
    }
    return false;
  }


  inline bool operator!=( dimacs_edge_iterator arg ) {
    if( reader.n_vertices() == 0 ) {
      return !arg.reader.done_edges();
    }
    else if( arg.reader.n_vertices() == 0 ) {
      return !reader.done_edges();
    }
    else {
      return true;
    }
    return true;
  }


  dimacs_edge_weight_iterator( T& reader ) : reader( reader ) {}


  inline dimacs_edge_weight_iterator& operator++() {
    reader.incr( dimacs_basic_reader::edge_weight );
    return *this;
  }


  inline edge_weight_type operator*() {
    return reader.edge_weight_deref();
  }

  inline bool operator==( dimacs_edge_weight_iterator arg ) {
    if( reader.n_vertices() == 0 ) {
      return arg.reader.done_edge_weights();
    }
    else if( arg.reader.n_vertices() == 0 ) {
      return reader.done_edge_weights();
    }
    else {
      return false;
    }
    return false;
  }


  inline bool operator!=( dimacs_edge_weight_iterator arg ) {
    if( reader.n_vertices() == 0 ) {
      return !arg.reader.done_edge_weights();
    }
    else if( arg.reader.n_vertices() == 0 ) {
      return !reader.done_edge_weights();
    }
    else {
      return true;
    }
    return true;
  }

      ignore_vertex() { }

      ignore_vertex(vertex_t v) : v(v) { }

      bool operator()(vertex_t x) const { return x != v; }

      ignore_edge() { }

      ignore_edge(edge_t e) : e(e) { }

      bool operator()(edge_t x) const { return x != e; }

      ignore_edges(vertex_t s, vertex_t t, const Graph& g) 
        : s(s), t(t), g(g) { }

      bool operator()(edge_t x) const { 
        return !(source(x, g) == s && target(x, g) == t);
      }


    void test_incidence_graph
       (const std::vector<vertex_t>& vertex_set,
        const std::vector< std::pair<vertex_t, vertex_t> >& edge_set,
        const Graph& g)
    {
      typedef typename std::vector<vertex_t>::const_iterator vertex_iter;
      typedef typename std::vector< std::pair<vertex_t, vertex_t> >
        ::const_iterator edge_iter;
      typedef typename graph_traits<Graph>::out_edge_iterator out_edge_iter;

      for (vertex_iter ui = vertex_set.begin(); ui != vertex_set.end(); ++ui) {
        vertex_t u = *ui;
        std::vector<vertex_t> adj;
        for (edge_iter e = edge_set.begin(); e != edge_set.end(); ++e)
          if (e->first == u)
            adj.push_back(e->second);
        
        std::pair<out_edge_iter, out_edge_iter> p = out_edges(u, g);
        BOOST_CHECK(out_degree(u, g) == adj.size());
        BOOST_CHECK(deg_size_t(std::distance(p.first, p.second))
                   == out_degree(u, g));
        for (; p.first != p.second; ++p.first) {
          edge_t e = *p.first;
          BOOST_CHECK(source(e, g) == u);
          BOOST_CHECK(container_contains(adj, target(e, g)) == true);
        }
      }
    }


    void test_bidirectional_graph
      (const std::vector<vertex_t>& vertex_set,
       const std::vector< std::pair<vertex_t, vertex_t> >& edge_set,
       const Graph& g)
    {
      typedef typename std::vector<vertex_t>::const_iterator vertex_iter;
      typedef typename std::vector< std::pair<vertex_t, vertex_t> >
        ::const_iterator edge_iter;
      typedef typename graph_traits<Graph>::in_edge_iterator in_edge_iter;

      for (vertex_iter vi = vertex_set.begin(); vi != vertex_set.end(); ++vi) {
        vertex_t v = *vi;
        std::vector<vertex_t> inv_adj;
        for (edge_iter e = edge_set.begin(); e != edge_set.end(); ++e)
          if (e->second == v)
            inv_adj.push_back(e->first);

        std::pair<in_edge_iter, in_edge_iter> p = in_edges(v, g);
        BOOST_CHECK(in_degree(v, g) == inv_adj.size());
        BOOST_CHECK(deg_size_t(std::distance(p.first, p.second))
                   == in_degree(v, g));
        for (; p.first != p.second; ++p.first) {
          edge_t e = *p.first;
          BOOST_CHECK(target(e, g) == v);
          BOOST_CHECK(container_contains(inv_adj, source(e, g)) == true);
        }
      }
    }


    void test_adjacency_graph
      (const std::vector<vertex_t>& vertex_set,
       const std::vector< std::pair<vertex_t,vertex_t> >& edge_set,
       const Graph& g)
    {
      typedef typename std::vector<vertex_t>::const_iterator vertex_iter;
      typedef typename std::vector<std::pair<vertex_t,vertex_t> >
        ::const_iterator edge_iter;
      typedef typename graph_traits<Graph>::adjacency_iterator adj_iter;

      for (vertex_iter ui = vertex_set.begin(); ui != vertex_set.end(); ++ui) {
        vertex_t u = *ui;
        std::vector<vertex_t> adj;
        for (edge_iter e = edge_set.begin(); e != edge_set.end(); ++e)
          if (e->first == u)
            adj.push_back(e->second);

        std::pair<adj_iter, adj_iter> p = adjacent_vertices(u, g);
        BOOST_CHECK(deg_size_t(std::distance(p.first, p.second)) == adj.size());
        for (; p.first != p.second; ++p.first) {
          vertex_t v = *p.first;
          BOOST_CHECK(container_contains(adj, v) == true);
        }
      }
    }
      

    void test_vertex_list_graph
      (const std::vector<vertex_t>& vertex_set, const Graph& g)
    {
      typedef typename graph_traits<Graph>::vertex_iterator v_iter;
      std::pair<v_iter, v_iter> p = vertices(g);
      BOOST_CHECK(num_vertices(g) == vertex_set.size());
      v_size_t n = (size_t)std::distance(p.first, p.second);
      BOOST_CHECK(n == num_vertices(g));
      for (; p.first != p.second; ++p.first) {
        vertex_t v = *p.first;
        BOOST_CHECK(container_contains(vertex_set, v) == true);
      }
    }


    void test_edge_list_graph
      (const std::vector<vertex_t>& vertex_set, 
       const std::vector< std::pair<vertex_t, vertex_t> >& edge_set, 
       const Graph& g)
    {
      typedef typename graph_traits<Graph>::edge_iterator e_iter;
      std::pair<e_iter, e_iter> p = edges(g);
      BOOST_CHECK(num_edges(g) == edge_set.size());
      e_size_t m = std::distance(p.first, p.second);
      BOOST_CHECK(m == num_edges(g));
      for (; p.first != p.second; ++p.first) {
        edge_t e = *p.first;
        BOOST_CHECK(find_if(edge_set, connects(source(e, g), target(e, g), g)) != boost::end(edge_set));
        BOOST_CHECK(container_contains(vertex_set, source(e, g)) == true);
        BOOST_CHECK(container_contains(vertex_set, target(e, g)) == true);
      }
    }


    void test_adjacency_matrix
      (const std::vector<vertex_t>& vertex_set, 
       const std::vector< std::pair<vertex_t, vertex_t> >& edge_set, 
       const Graph& g)
    {
      std::pair<edge_t, bool> p;
      for (typename std::vector<std::pair<vertex_t, vertex_t> >
             ::const_iterator i = edge_set.begin();
           i != edge_set.end(); ++i) {
        p = edge(i->first, i->second, g);
        BOOST_CHECK(p.second == true);
        BOOST_CHECK(source(p.first, g) == i->first);
        BOOST_CHECK(target(p.first, g) == i->second);
      }
      typename std::vector<vertex_t>::const_iterator j, k;
      for (j = vertex_set.begin(); j != vertex_set.end(); ++j)
        for (k = vertex_set.begin(); k != vertex_set.end(); ++k) {
          p = edge(*j, *k, g);
          if (p.second == true)
            BOOST_CHECK(find_if(edge_set, 
              connects(source(p.first, g), target(p.first, g), g)) != boost::end(edge_set));
        }
    }


    void test_add_vertex(Graph& g)
    {
      Graph cpy;
      std::vector<vertex_t> iso_vec(num_vertices(g));
      IsoMap iso_map(iso_vec.begin(), get(vertex_index, g));
      copy_graph(g, cpy, orig_to_copy(iso_map));

      BOOST_CHECK((verify_isomorphism(g, cpy, iso_map)));

      vertex_t v = add_vertex(g);
      
      BOOST_CHECK(num_vertices(g) == num_vertices(cpy) + 1);

      BOOST_CHECK(out_degree(v, g) == 0);

      // Make sure the rest of the graph stayed the same
      BOOST_CHECK((verify_isomorphism
                  (make_filtered_graph(g, keep_all(), ignore_vertex(v)), cpy,
                   iso_map)));
    }

    
    void test_add_edge(vertex_t u, vertex_t v, Graph& g)
    {
      Graph cpy;
      std::vector<vertex_t> iso_vec(num_vertices(g));
      IsoMap iso_map(iso_vec.begin(), get(vertex_index, g));
      copy_graph(g, cpy, orig_to_copy(iso_map));

      bool parallel_edge_exists = container_contains(adjacent_vertices(u, g), v);
      
      std::pair<edge_t, bool> p = add_edge(u, v, g);
      edge_t e = p.first;
      bool added = p.second;

      if (is_undirected(g) && u == v) // self edge
        BOOST_CHECK(added == false);
      else if (parallel_edge_exists)
        BOOST_CHECK(allows_parallel_edges(g) && added == true
                   || !allows_parallel_edges(g) && added == false);
      else
        BOOST_CHECK(added == true);

      if (p.second == true) { // edge added
        BOOST_CHECK(num_edges(g) == num_edges(cpy) + 1);
        
        BOOST_CHECK(container_contains(out_edges(u, g), e) == true);
        
        BOOST_CHECK((verify_isomorphism
                    (make_filtered_graph(g, ignore_edge(e)), cpy, iso_map)));
      }
      else { // edge not added
        if (! (is_undirected(g) && u == v)) {
          // e should be a parallel edge
          BOOST_CHECK(source(e, g) == u);
          BOOST_CHECK(target(e, g) == v);
        }
        // The graph should not be changed.
        BOOST_CHECK((verify_isomorphism(g, cpy, iso_map)));
      }
    }



    void test_remove_edge(vertex_t u, vertex_t v, Graph& g)
    {
      Graph cpy;
      std::vector<vertex_t> iso_vec(num_vertices(g));
      IsoMap iso_map(iso_vec.begin(), get(vertex_index, g));
      copy_graph(g, cpy, orig_to_copy(iso_map));

      deg_size_t occurances = count(adjacent_vertices(u, g), v);

      remove_edge(u, v, g);
      
      BOOST_CHECK(num_edges(g) + occurances == num_edges(cpy));
      BOOST_CHECK((verify_isomorphism
                  (g, make_filtered_graph(cpy, ignore_edges(u,v,cpy)),
                   iso_map)));
    }


    void test_remove_edge(edge_t e, Graph& g)
    {
      Graph cpy;
      std::vector<vertex_t> iso_vec(num_vertices(g));
      IsoMap iso_map(iso_vec.begin(), get(vertex_index, g));
      copy_graph(g, cpy, orig_to_copy(iso_map));

      vertex_t u = source(e, g), v = target(e, g);
      deg_size_t occurances = count(adjacent_vertices(u, g), v);
      
      remove_edge(e, g);

      BOOST_CHECK(num_edges(g) + 1 == num_edges(cpy));
      BOOST_CHECK(count(adjacent_vertices(u, g), v) + 1 == occurances);
      BOOST_CHECK((verify_isomorphism
                  (g, make_filtered_graph(cpy, ignore_edge(e)),
                   iso_map)));
    }


    void test_clear_vertex(vertex_t v, Graph& g)
    {
      Graph cpy;
      std::vector<vertex_t> iso_vec(num_vertices(g));
      IsoMap iso_map(iso_vec.begin(), get(vertex_index, g));
      copy_graph(g, cpy, orig_to_copy(iso_map));

      clear_vertex(v, g);

      BOOST_CHECK(out_degree(v, g) == 0);
      BOOST_CHECK(num_vertices(g) == num_vertices(cpy));
      BOOST_CHECK((verify_isomorphism
                  (g, make_filtered_graph(cpy, keep_all(), ignore_vertex(v)),
                   iso_map)));
    }


    template <typename PropVal, typename PropertyTag>
    void test_readable_vertex_property_graph
      (const std::vector<PropVal>& vertex_prop, PropertyTag tag, const Graph& g)
    {
      typedef typename property_map<Graph, PropertyTag>::const_type const_Map;
      const_Map pmap = get(tag, g);
      typename std::vector<PropVal>::const_iterator i = vertex_prop.begin();

  for (typename boost::graph_traits<Graph>::vertex_iterator 
           bgl_first_9 = vertices(g).first, bgl_last_9 = vertices(g).second;
       bgl_first_9 != bgl_last_9; bgl_first_9 = bgl_last_9)
    for (typename boost::graph_traits<Graph>::vertex_descriptor v;
         bgl_first_9 != bgl_last_9 ? (v = *bgl_first_9, true) : false;
         ++bgl_first_9) {
      //BGL_FORALL_VERTICES_T(v, g, Graph) {
        typename property_traits<const_Map>::value_type 
          pval1 = get(pmap, v), pval2 = get(tag, g, v);
        BOOST_CHECK(pval1 == pval2);
        BOOST_CHECK(pval1 == *i++);
      }
    }


    template <typename PropVal, typename PropertyTag>
    void test_vertex_property_graph
      (const std::vector<PropVal>& vertex_prop, PropertyTag tag, Graph& g)
    {
      typedef typename property_map<Graph, PropertyTag>::type PMap;
      PMap pmap = get(tag, g);
      typename std::vector<PropVal>::const_iterator i = vertex_prop.begin();
  for (typename boost::graph_traits<Graph>::vertex_iterator 
           bgl_first_9 = vertices(g).first, bgl_last_9 = vertices(g).second;
       bgl_first_9 != bgl_last_9; bgl_first_9 = bgl_last_9)
    for (typename boost::graph_traits<Graph>::vertex_descriptor v;
         bgl_first_9 != bgl_last_9 ? (v = *bgl_first_9, true) : false;
         ++bgl_first_9)
      //      BGL_FORALL_VERTICES_T(v, g, Graph)
        put(pmap, v, *i++);

      test_readable_vertex_property_graph(vertex_prop, tag, g);

      BGL_FORALL_VERTICES_T(v, g, Graph)
        put(pmap, v, vertex_prop[0]);
      
      typename std::vector<PropVal>::const_iterator j = vertex_prop.begin();
      BGL_FORALL_VERTICES_T(v, g, Graph)
        put(tag, g, v, *j++);
      
      test_readable_vertex_property_graph(vertex_prop, tag, g);      
    }


    template <typename VertexSet, typename Graph>
    void clique(const VertexSet&, Graph&)
    { }

    max_clique_visitor(std::size_t& max)
        : maximum(max)
    { }


    template <typename Clique, typename Graph>
    inline void clique(const Clique& p, const Graph& g)
    {
        BOOST_USING_STD_MAX();
        maximum = max BOOST_PREVENT_MACRO_SUBSTITUTION (maximum, p.size());
    }


inline max_clique_visitor find_max_clique(std::size_t& max)
{ return max_clique_visitor(max); }

    template <typename Graph>
    inline bool
    is_connected_to_clique(const Graph& g,
                            typename graph_traits<Graph>::vertex_descriptor u,
                            typename graph_traits<Graph>::vertex_descriptor v,
                            typename graph_traits<Graph>::undirected_category)
    {
        return lookup_edge(u, v, g).second;
    }


    template <typename Graph>
    inline bool
    is_connected_to_clique(const Graph& g,
                            typename graph_traits<Graph>::vertex_descriptor u,
                            typename graph_traits<Graph>::vertex_descriptor v,
                            typename graph_traits<Graph>::directed_category)
    {
        // Note that this could alternate between using an || to determine
        // full connectivity. I believe that this should produce strongly
        // connected components. Note that using && instead of || will
        // change the results to a fully connected subgraph (i.e., symmetric
        // edges between all vertices s.t., if a->b, then b->a.
        return lookup_edge(u, v, g).second && lookup_edge(v, u, g).second;
    }


    template <typename Graph, typename Container>
    inline void
    filter_unconnected_vertices(const Graph& g,
                                typename graph_traits<Graph>::vertex_descriptor v,
                                const Container& in,
                                Container& out)
    {
        BOOST_CONCEPT_ASSERT(( GraphConcept<Graph> ));

        typename graph_traits<Graph>::directed_category cat;
        typename Container::const_iterator i, end = in.end();
        for(i = in.begin(); i != end; ++i) {
            if(is_connected_to_clique(g, v, *i, cat)) {
                out.push_back(*i);
            }
        }
    }


    template <
        typename Graph,
        typename Clique,        // compsub type
        typename Container,     // candidates/not type
        typename Visitor>
    void extend_clique(const Graph& g,
                        Clique& clique,
                        Container& cands,
                        Container& nots,
                        Visitor vis,
                        std::size_t min)
    {
        BOOST_CONCEPT_ASSERT(( GraphConcept<Graph> ));
        BOOST_CONCEPT_ASSERT(( CliqueVisitorConcept<Visitor,Clique,Graph> ));
        typedef typename graph_traits<Graph>::vertex_descriptor Vertex;

        // Is there vertex in nots that is connected to all vertices
        // in the candidate set? If so, no clique can ever be found.
        // This could be broken out into a separate function.
        {
            typename Container::iterator ni, nend = nots.end();
            typename Container::iterator ci, cend = cands.end();
            for(ni = nots.begin(); ni != nend; ++ni) {
                for(ci = cands.begin(); ci != cend; ++ci) {
                    // if we don't find an edge, then we're okay.
                    if(!lookup_edge(*ni, *ci, g).second) break;
                }
                // if we iterated all the way to the end, then *ni
                // is connected to all *ci
                if(ci == cend) break;
            }
            // if we broke early, we found *ni connected to all *ci
            if(ni != nend) return;
        }

        // TODO: the original algorithm 457 describes an alternative
        // (albeit really complicated) mechanism for selecting candidates.
        // The given optimizaiton seeks to bring about the above
        // condition sooner (i.e., there is a vertex in the not set
        // that is connected to all candidates). unfortunately, the
        // method they give for doing this is fairly unclear.

        // basically, for every vertex in not, we should know how many
        // vertices it is disconnected from in the candidate set. if
        // we fix some vertex in the not set, then we want to keep
        // choosing vertices that are not connected to that fixed vertex.
        // apparently, by selecting fix point with the minimum number
        // of disconnections (i.e., the maximum number of connections
        // within the candidate set), then the previous condition wil
        // be reached sooner.

        // there's some other stuff about using the number of disconnects
        // as a counter, but i'm jot really sure i followed it.

        // TODO: If we min-sized cliques to visit, then theoretically, we
        // should be able to stop recursing if the clique falls below that
        // size - maybe?

        // otherwise, iterate over candidates and and test
        // for maxmimal cliquiness.
        typename Container::iterator i, j;
        for(i = cands.begin(); i != cands.end(); ) {
            Vertex candidate = *i;

            // add the candidate to the clique (keeping the iterator!)
            // typename Clique::iterator ci = clique.insert(clique.end(), candidate);
            clique.push_back(candidate);

            // remove it from the candidate set
            i = cands.erase(i);

            // build new candidate and not sets by removing all vertices
            // that are not connected to the current candidate vertex.
            // these actually invert the operation, adding them to the new
            // sets if the vertices are connected. its semantically the same.
            Container new_cands, new_nots;
            filter_unconnected_vertices(g, candidate, cands, new_cands);
            filter_unconnected_vertices(g, candidate, nots, new_nots);

            if(new_cands.empty() && new_nots.empty()) {
                // our current clique is maximal since there's nothing
                // that's connected that we haven't already visited. If
                // the clique is below our radar, then we won't visit it.
                if(clique.size() >= min) {
                    vis.clique(clique, g);
                }
            }
            else {
                // recurse to explore the new candidates
                extend_clique(g, clique, new_cands, new_nots, vis, min);
            }

            // we're done with this vertex, so we need to move it
            // to the nots, and remove the candidate from the clique.
            nots.push_back(candidate);
            clique.pop_back();
        }
    }


template <typename Graph, typename Visitor>
inline void
bron_kerbosch_all_cliques(const Graph& g, Visitor vis, std::size_t min)
{
    BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<Graph> ));
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
    BOOST_CONCEPT_ASSERT(( AdjacencyMatrixConcept<Graph> )); // Structural requirement only
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename graph_traits<Graph>::vertex_iterator VertexIterator;
    typedef std::vector<Vertex> VertexSet;
    typedef std::deque<Vertex> Clique;
    BOOST_CONCEPT_ASSERT(( CliqueVisitorConcept<Visitor,Clique,Graph> ));

    // NOTE: We're using a deque to implement the clique, because it provides
    // constant inserts and removals at the end and also a constant size.

    VertexIterator i, end;
    boost::tie(i, end) = vertices(g);
    VertexSet cands(i, end);    // start with all vertices as candidates
    VertexSet nots;             // start with no vertices visited

    Clique clique;              // the first clique is an empty vertex set
    detail::extend_clique(g, clique, cands, nots, vis, min);
}

template <typename Graph, typename Visitor>
inline void
bron_kerbosch_all_cliques(const Graph& g, Visitor vis)
{ bron_kerbosch_all_cliques(g, vis, 2); }


template <typename Graph>
inline std::size_t
bron_kerbosch_clique_number(const Graph& g)
{
    std::size_t ret = 0;
    bron_kerbosch_all_cliques(g, find_max_clique(ret));
    return ret;
}

    parse_error(const std::string& err) {error = err; statement = "parse error: " + error;}

    virtual ~parse_error() throw() {}

    virtual const char* what() const throw() {return statement.c_str();}

    virtual ~mutate_graph() {}

    mutate_graph_impl(MutableGraph& g, dynamic_properties& dp)
        : m_g(g), m_dp(dp) { }


    bool is_directed() const
    {
        return is_convertible<typename graph_traits<MutableGraph>::directed_category,
                              directed_tag>::value;
    }


    virtual any do_add_vertex()
    {
        return any(add_vertex(m_g));
    }

    get_type_name(const std::type_info& type, const char** type_names, std::string& type_name)
        : m_type(type), m_type_names(type_names), m_type_name(type_name) {}

    template <typename Type>
    void operator()(Type)
    {
        if (typeid(Type) == m_type)
            m_type_name = m_type_names[mpl::find<Types,Type>::type::pos::value];
    }



template <typename Graph, typename VertexIndexMap>
void
write_graphml(std::ostream& out, const Graph& g, VertexIndexMap vertex_index,
              const dynamic_properties& dp, bool ordered_vertices=false)
{
    typedef typename graph_traits<Graph>::directed_category directed_category;
    typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;

    using boost::property_tree::xml_parser::encode_char_entities;

    BOOST_STATIC_CONSTANT(bool,
                          graph_is_directed =
                          (is_convertible<directed_category*, directed_tag*>::value));

    out << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        << "<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">\n";

    typedef mpl::vector<bool, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long, float, double, long double, std::string> value_types;
    const char* type_names[] = {"boolean", "int", "int", "int", "int", "long", "long", "long", "long", "float", "double", "double", "string"};
    std::map<std::string, std::string> graph_key_ids;
    std::map<std::string, std::string> vertex_key_ids;
    std::map<std::string, std::string> edge_key_ids;
    int key_count = 0;

    // Output keys
    for (dynamic_properties::const_iterator i = dp.begin(); i != dp.end(); ++i)
    {
        std::string key_id = "key" + lexical_cast<std::string>(key_count++);
        if (i->second->key() == typeid(Graph*))
            graph_key_ids[i->first] = key_id;
        else if (i->second->key() == typeid(vertex_descriptor))
            vertex_key_ids[i->first] = key_id;
        else if (i->second->key() == typeid(edge_descriptor))
            edge_key_ids[i->first] = key_id;
        else
            continue;
        std::string type_name = "string";
        mpl::for_each<value_types>(get_type_name<value_types>(i->second->value(), type_names, type_name));
        out << "  <key id=\"" << encode_char_entities(key_id) << "\" for=\""
            << (i->second->key() == typeid(Graph*) ? "graph" : (i->second->key() == typeid(vertex_descriptor) ? "node" : "edge")) << "\""
            << " attr.name=\"" << i->first << "\""
            << " attr.type=\"" << type_name << "\""
            << " />\n";
    }

    out << "  <graph id=\"G\" edgedefault=\""
        << (graph_is_directed ? "directed" : "undirected") << "\""
        << " parse.nodeids=\"" << (ordered_vertices ? "canonical" : "free") << "\""
        << " parse.edgeids=\"canonical\" parse.order=\"nodesfirst\">\n";

    // Output graph data
    for (dynamic_properties::const_iterator i = dp.begin(); i != dp.end(); ++i)
    {
        if (i->second->key() == typeid(Graph*))
        {
            // The const_cast here is just to get typeid correct for property
            // map key; the graph should not be mutated using it.
            out << "   <data key=\"" << graph_key_ids[i->first] << "\">"
                << encode_char_entities(i->second->get_string(const_cast<Graph*>(&g))) << "</data>\n";
        }
    }

    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
    vertex_iterator v, v_end;
    for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v)
    {
        out << "    <node id=\"n" << get(vertex_index, *v) << "\">\n";
        // Output data
        for (dynamic_properties::const_iterator i = dp.begin(); i != dp.end(); ++i)
        {
            if (i->second->key() == typeid(vertex_descriptor))
            {
                out << "      <data key=\"" << vertex_key_ids[i->first] << "\">"
                    << encode_char_entities(i->second->get_string(*v)) << "</data>\n";
            }
        }
        out << "    </node>\n";
    }

    typedef typename graph_traits<Graph>::edge_iterator edge_iterator;
    edge_iterator e, e_end;
    typename graph_traits<Graph>::edges_size_type edge_count = 0;
    for (boost::tie(e, e_end) = edges(g); e != e_end; ++e)
    {
        out << "    <edge id=\"e" << edge_count++ << "\" source=\"n"
            << get(vertex_index, source(*e, g)) << "\" target=\"n"
            << get(vertex_index, target(*e, g)) << "\">\n";

        // Output data
        for (dynamic_properties::const_iterator i = dp.begin(); i != dp.end(); ++i)
        {
            if (i->second->key() == typeid(edge_descriptor))
            {
                out << "      <data key=\"" << edge_key_ids[i->first] << "\">"
                    << encode_char_entities(i->second->get_string(*e)) << "</data>\n";
            }
        }
        out << "    </edge>\n";
    }

    out << "  </graph>\n"
        << "</graphml>\n";
}


      inline bool is_admissible(vertex_descriptor u, vertex_descriptor v) {
        return get(distance, u) == get(distance, v) + 1;
      }

      inline bool is_residual_edge(edge_descriptor a) {
        return 0 < get(residual_capacity, a);
      }

      inline bool is_saturated(edge_descriptor a) {
        return get(residual_capacity, a) == 0;
      }


      void add_to_active_list(vertex_descriptor u, Layer& layer) {
        BOOST_USING_STD_MIN();
        BOOST_USING_STD_MAX();
        layer.active_vertices.push_front(u);
        max_active = max BOOST_PREVENT_MACRO_SUBSTITUTION(get(distance, u), max_active);
        min_active = min BOOST_PREVENT_MACRO_SUBSTITUTION(get(distance, u), min_active);
        layer_list_ptr[u] = layer.active_vertices.begin();
      }

      void remove_from_active_list(vertex_descriptor u) {
        layers[get(distance, u)].active_vertices.erase(layer_list_ptr[u]);    
      }


      void add_to_inactive_list(vertex_descriptor u, Layer& layer) {
        layer.inactive_vertices.push_front(u);
        layer_list_ptr[u] = layer.inactive_vertices.begin();
      }

      void remove_from_inactive_list(vertex_descriptor u) {
        layers[get(distance, u)].inactive_vertices.erase(layer_list_ptr[u]);    
      }

      push_relabel(Graph& g_, 
                   EdgeCapacityMap cap,
                   ResidualCapacityEdgeMap res,
                   ReverseEdgeMap rev,
                   vertex_descriptor src_, 
                   vertex_descriptor sink_,
                   VertexIndexMap idx)
        : g(g_), n(num_vertices(g_)), capacity(cap), src(src_), sink(sink_), 
          index(idx),
          excess_flow_data(num_vertices(g_)),
          excess_flow(excess_flow_data.begin(), idx),
          current_data(num_vertices(g_), out_edges(*vertices(g_).first, g_)),
          current(current_data.begin(), idx),
          distance_data(num_vertices(g_)),
          distance(distance_data.begin(), idx),
          color_data(num_vertices(g_)),
          color(color_data.begin(), idx),
          reverse_edge(rev),
          residual_capacity(res),
          layers(num_vertices(g_)),
          layer_list_ptr_data(num_vertices(g_), 
                              layers.front().inactive_vertices.end()),
          layer_list_ptr(layer_list_ptr_data.begin(), idx),
          push_count(0), update_count(0), relabel_count(0), 
          gap_count(0), gap_node_count(0),
          work_since_last_update(0)
      {
        vertex_iterator u_iter, u_end;
        // Don't count the reverse edges
        edges_size_type m = num_edges(g) / 2;
        nm = alpha() * n + m;

        // Initialize flow to zero which means initializing
        // the residual capacity to equal the capacity.
        out_edge_iterator ei, e_end;
        for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter)
          for (boost::tie(ei, e_end) = out_edges(*u_iter, g); ei != e_end; ++ei) {
            put(residual_capacity, *ei, get(capacity, *ei));
          }

        for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter) {
          vertex_descriptor u = *u_iter;
          put(excess_flow, u, 0);
          current[u] = out_edges(u, g);
        }

        bool overflow_detected = false;
        FlowValue test_excess = 0;

        out_edge_iterator a_iter, a_end;
        for (boost::tie(a_iter, a_end) = out_edges(src, g); a_iter != a_end; ++a_iter)
          if (target(*a_iter, g) != src)
            test_excess += get(residual_capacity, *a_iter);
        if (test_excess > (std::numeric_limits<FlowValue>::max)())
          overflow_detected = true;

        if (overflow_detected)
          put(excess_flow, src, (std::numeric_limits<FlowValue>::max)());
        else {
          put(excess_flow, src, 0);
          for (boost::tie(a_iter, a_end) = out_edges(src, g); 
               a_iter != a_end; ++a_iter) {
            edge_descriptor a = *a_iter;
            vertex_descriptor tgt = target(a, g);
            if (tgt != src) {
              ++push_count;
              FlowValue delta = get(residual_capacity, a);
              put(residual_capacity, a, get(residual_capacity, a) - delta);
              edge_descriptor rev = get(reverse_edge, a);
              put(residual_capacity, rev, get(residual_capacity, rev) + delta);
              put(excess_flow, tgt, get(excess_flow, tgt) + delta);
            }
          }
        }
        max_distance = num_vertices(g) - 1;
        max_active = 0;
        min_active = n;

        for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter) {
          vertex_descriptor u = *u_iter;
          if (u == sink) {
            put(distance, u, 0);
            continue;
          } else if (u == src && !overflow_detected)
            put(distance, u, n);
          else
            put(distance, u, 1);

          if (get(excess_flow, u) > 0)
            add_to_active_list(u, layers[1]);
          else if (get(distance, u) < n)
            add_to_inactive_list(u, layers[1]);
        }       

      }

      void global_distance_update()
      {
        BOOST_USING_STD_MAX();
        ++update_count;
        vertex_iterator u_iter, u_end;
        for (boost::tie(u_iter,u_end) = vertices(g); u_iter != u_end; ++u_iter) {
          put(color, *u_iter, ColorTraits::white());
          put(distance, *u_iter, n);
        }
        put(color, sink, ColorTraits::gray());
        put(distance, sink, 0);
        
        for (distance_size_type l = 0; l <= max_distance; ++l) {
          layers[l].active_vertices.clear();
          layers[l].inactive_vertices.clear();
        }
        
        max_distance = max_active = 0;
        min_active = n;

        Q.push(sink);
        while (! Q.empty()) {
          vertex_descriptor u = Q.top();
          Q.pop();
          distance_size_type d_v = get(distance, u) + 1;

          out_edge_iterator ai, a_end;
          for (boost::tie(ai, a_end) = out_edges(u, g); ai != a_end; ++ai) {
            edge_descriptor a = *ai;
            vertex_descriptor v = target(a, g);
            if (get(color, v) == ColorTraits::white()
                && is_residual_edge(get(reverse_edge, a))) {
              put(distance, v, d_v);
              put(color, v, ColorTraits::gray());
              current[v] = out_edges(v, g);
              max_distance = max BOOST_PREVENT_MACRO_SUBSTITUTION(d_v, max_distance);

              if (get(excess_flow, v) > 0)
                add_to_active_list(v, layers[d_v]);
              else
                add_to_inactive_list(v, layers[d_v]);

              Q.push(v);
            }
          }
        }
      }

      void discharge(vertex_descriptor u)
      {
        BOOST_ASSERT(get(excess_flow, u) > 0);
        while (1) {
          out_edge_iterator ai, ai_end;
          for (boost::tie(ai, ai_end) = current[u]; ai != ai_end; ++ai) {
            edge_descriptor a = *ai;
            if (is_residual_edge(a)) {
              vertex_descriptor v = target(a, g);
              if (is_admissible(u, v)) {
                ++push_count;
                if (v != sink && get(excess_flow, v) == 0) {
                  remove_from_inactive_list(v);
                  add_to_active_list(v, layers[get(distance, v)]);
                }
                push_flow(a);
                if (get(excess_flow, u) == 0)
                  break;
              } 
            } 
          } // for out_edges of i starting from current

          Layer& layer = layers[get(distance, u)];
          distance_size_type du = get(distance, u);

          if (ai == ai_end) {   // i must be relabeled
            relabel_distance(u);
            if (layer.active_vertices.empty()
                && layer.inactive_vertices.empty())
              gap(du);
            if (get(distance, u) == n)
              break;
          } else {              // i is no longer active
            current[u].first = ai;
            add_to_inactive_list(u, layer);
            break;
          }
        } // while (1)
      }

      void push_flow(edge_descriptor u_v)
      {
        vertex_descriptor
          u = source(u_v, g),
          v = target(u_v, g);
        
        BOOST_USING_STD_MIN();
        FlowValue flow_delta
          = min BOOST_PREVENT_MACRO_SUBSTITUTION(get(excess_flow, u), get(residual_capacity, u_v));

        put(residual_capacity, u_v, get(residual_capacity, u_v) - flow_delta);
        edge_descriptor rev = get(reverse_edge, u_v);
        put(residual_capacity, rev, get(residual_capacity, rev) + flow_delta);

        put(excess_flow, u, get(excess_flow, u) - flow_delta);
        put(excess_flow, v, get(excess_flow, v) + flow_delta);
      }

      distance_size_type relabel_distance(vertex_descriptor u)
      {
        BOOST_USING_STD_MAX();
        ++relabel_count;
        work_since_last_update += beta();

        distance_size_type min_distance = num_vertices(g);
        put(distance, u, min_distance);

        // Examine the residual out-edges of vertex i, choosing the
        // edge whose target vertex has the minimal distance.
        out_edge_iterator ai, a_end, min_edge_iter;
        for (boost::tie(ai, a_end) = out_edges(u, g); ai != a_end; ++ai) {
          ++work_since_last_update;
          edge_descriptor a = *ai;
          vertex_descriptor v = target(a, g);
          if (is_residual_edge(a) && get(distance, v) < min_distance) {
            min_distance = get(distance, v);
            min_edge_iter = ai;
          }
        }
        ++min_distance;
        if (min_distance < n) {
          put(distance, u, min_distance);     // this is the main action
          current[u].first = min_edge_iter;
          max_distance = max BOOST_PREVENT_MACRO_SUBSTITUTION(min_distance, max_distance);
        }
        return min_distance;
      }

      void gap(distance_size_type empty_distance)
      {
        ++gap_count;

        distance_size_type r; // distance of layer before the current layer
        r = empty_distance - 1;

        // Set the distance for the vertices beyond the gap to "infinity".
        for (layer_iterator l = layers.begin() + empty_distance + 1;
             l < layers.begin() + max_distance; ++l) {
          list_iterator i;
          for (i = l->inactive_vertices.begin(); 
               i != l->inactive_vertices.end(); ++i) {
            put(distance, *i, n);
            ++gap_node_count;
          }
          l->inactive_vertices.clear();
        }
        max_distance = r;
        max_active = r;
      }

      FlowValue maximum_preflow()
      {
        work_since_last_update = 0;

        while (max_active >= min_active) { // "main" loop

          Layer& layer = layers[max_active];
          list_iterator u_iter = layer.active_vertices.begin();

          if (u_iter == layer.active_vertices.end())
            --max_active;
          else {
            vertex_descriptor u = *u_iter;
            remove_from_active_list(u);
            
            discharge(u);

            if (work_since_last_update * global_update_frequency() > nm) {
              global_distance_update();
              work_since_last_update = 0;
            }
          }
        } // while (max_active >= min_active)

        return get(excess_flow, sink);
      }

      void convert_preflow_to_flow()
      {
        vertex_iterator u_iter, u_end;
        out_edge_iterator ai, a_end;

        vertex_descriptor r, restart, u;

        std::vector<vertex_descriptor> parent(n);
        std::vector<vertex_descriptor> topo_next(n);

        vertex_descriptor tos(parent[0]), 
          bos(parent[0]); // bogus initialization, just to avoid warning
        bool bos_null = true;

        // handle self-loops
        for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter)
          for (boost::tie(ai, a_end) = out_edges(*u_iter, g); ai != a_end; ++ai)
            if (target(*ai, g) == *u_iter)
              put(residual_capacity, *ai, get(capacity, *ai));

        // initialize
        for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter) {
          u = *u_iter;
          put(color, u, ColorTraits::white());
          parent[get(index, u)] = u;
          current[u] = out_edges(u, g);
        }
        // eliminate flow cycles and topologically order the vertices
        for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter) {
          u = *u_iter;
          if (get(color, u) == ColorTraits::white() 
              && get(excess_flow, u) > 0
              && u != src && u != sink ) {
            r = u;
            put(color, r, ColorTraits::gray());
            while (1) {
              for (; current[u].first != current[u].second; ++current[u].first) {
                edge_descriptor a = *current[u].first;
                if (get(capacity, a) == 0 && is_residual_edge(a)) {
                  vertex_descriptor v = target(a, g);
                  if (get(color, v) == ColorTraits::white()) {
                    put(color, v, ColorTraits::gray());
                    parent[get(index, v)] = u;
                    u = v;
                    break;
                  } else if (get(color, v) == ColorTraits::gray()) {
                    // find minimum flow on the cycle
                    FlowValue delta = get(residual_capacity, a);
                    while (1) {
                      BOOST_USING_STD_MIN();
                      delta = min BOOST_PREVENT_MACRO_SUBSTITUTION(delta, get(residual_capacity, *current[v].first));
                      if (v == u)
                        break;
                      else
                        v = target(*current[v].first, g);
                    }
                    // remove delta flow units
                    v = u;
                    while (1) {
                      a = *current[v].first;
                      put(residual_capacity, a, get(residual_capacity, a) - delta);
                      edge_descriptor rev = get(reverse_edge, a);
                      put(residual_capacity, rev, get(residual_capacity, rev) + delta);
                      v = target(a, g);
                      if (v == u)
                        break;
                    }

                    // back-out of DFS to the first saturated edge
                    restart = u;
                    for (v = target(*current[u].first, g); v != u; v = target(a, g)){
                      a = *current[v].first;
                      if (get(color, v) == ColorTraits::white() 
                          || is_saturated(a)) {
                        put(color, target(*current[v].first, g), ColorTraits::white());
                        if (get(color, v) != ColorTraits::white())
                          restart = v;
                      }
                    }
                    if (restart != u) {
                      u = restart;
                      ++current[u].first;
                      break;
                    }
                  } // else if (color[v] == ColorTraits::gray())
                } // if (get(capacity, a) == 0 ...
              } // for out_edges(u, g)  (though "u" changes during loop)
              
              if ( current[u].first == current[u].second ) {
                // scan of i is complete
                put(color, u, ColorTraits::black());
                if (u != src) {
                  if (bos_null) {
                    bos = u;
                    bos_null = false;
                    tos = u;
                  } else {
                    topo_next[get(index, u)] = tos;
                    tos = u;
                  }
                }
                if (u != r) {
                  u = parent[get(index, u)];
                  ++current[u].first;
                } else
                  break;
              }
            } // while (1)
          } // if (color[u] == white && excess_flow[u] > 0 & ...)
        } // for all vertices in g

        // return excess flows
        // note that the sink is not on the stack
        if (! bos_null) {
          for (u = tos; u != bos; u = topo_next[get(index, u)]) {
            boost::tie(ai, a_end) = out_edges(u, g);
            while (get(excess_flow, u) > 0 && ai != a_end) {
              if (get(capacity, *ai) == 0 && is_residual_edge(*ai))
                push_flow(*ai);
              ++ai;
            }
          }
          // do the bottom
          u = bos;
          boost::tie(ai, a_end) = out_edges(u, g);
          while (get(excess_flow, u) > 0 && ai != a_end) {
            if (get(capacity, *ai) == 0 && is_residual_edge(*ai))
              push_flow(*ai);
            ++ai;
          }
        }
        
      }

      inline bool is_flow()
      {
        vertex_iterator u_iter, u_end;
        out_edge_iterator ai, a_end;

        // check edge flow values
        for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter) {
          for (boost::tie(ai, a_end) = out_edges(*u_iter, g); ai != a_end; ++ai) {
            edge_descriptor a = *ai;
            if (get(capacity, a) > 0)
              if ((get(residual_capacity, a) + get(residual_capacity, get(reverse_edge, a))
                   != get(capacity, a) + get(capacity, get(reverse_edge, a)))
                  || (get(residual_capacity, a) < 0)
                  || (get(residual_capacity, get(reverse_edge, a)) < 0))
              return false;
          }
        }
        
        // check conservation
        FlowValue sum;  
        for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter) {
          vertex_descriptor u = *u_iter;
          if (u != src && u != sink) {
            if (get(excess_flow, u) != 0)
              return false;
            sum = 0;
            for (boost::tie(ai, a_end) = out_edges(u, g); ai != a_end; ++ai) 
              if (get(capacity, *ai) > 0)
                sum -= get(capacity, *ai) - get(residual_capacity, *ai);
              else
                sum += get(residual_capacity, *ai);

            if (get(excess_flow, u) != sum)
              return false;
          }
        }

        return true;
      }


      bool is_optimal() {
        // check if mincut is saturated...
        global_distance_update();
        return get(distance, src) >= n;
      }


      void print_statistics(std::ostream& os) const {
        os << "pushes:     " << push_count << std::endl
           << "relabels:   " << relabel_count << std::endl
           << "updates:    " << update_count << std::endl
           << "gaps:       " << gap_count << std::endl
           << "gap nodes:  " << gap_node_count << std::endl
           << std::endl;
      }


      void print_flow_values(std::ostream& os) const {
        os << "flow values" << std::endl;
        vertex_iterator u_iter, u_end;
        out_edge_iterator ei, e_end;
        for (boost::tie(u_iter, u_end) = vertices(g); u_iter != u_end; ++u_iter)
          for (boost::tie(ei, e_end) = out_edges(*u_iter, g); ei != e_end; ++ei)
            if (get(capacity, *ei) > 0)
              os << *u_iter << " " << target(*ei, g) << " " 
                 << (get(capacity, *ei) - get(residual_capacity, *ei)) << std::endl;
        os << std::endl;
      }


      inline double global_update_frequency() { return 0.5; }

      inline vertices_size_type alpha() { return 6; }

      inline long beta() { return 12; }

  
  template <class Graph, 
            class CapacityEdgeMap, class ResidualCapacityEdgeMap,
            class ReverseEdgeMap, class VertexIndexMap>
  typename property_traits<CapacityEdgeMap>::value_type
  push_relabel_max_flow
    (Graph& g, 
     typename graph_traits<Graph>::vertex_descriptor src,
     typename graph_traits<Graph>::vertex_descriptor sink,
     CapacityEdgeMap cap, ResidualCapacityEdgeMap res,
     ReverseEdgeMap rev, VertexIndexMap index_map)
  {
    typedef typename property_traits<CapacityEdgeMap>::value_type FlowValue;
    
    detail::push_relabel<Graph, CapacityEdgeMap, ResidualCapacityEdgeMap, 
      ReverseEdgeMap, VertexIndexMap, FlowValue>
      algo(g, cap, res, rev, src, sink, index_map);
    
    FlowValue flow = algo.maximum_preflow();
    
    algo.convert_preflow_to_flow();
    
    BOOST_ASSERT(algo.is_flow());
    BOOST_ASSERT(algo.is_optimal());
    
    return flow;
  }

  
  template <class Graph, class P, class T, class R>
  typename detail::edge_capacity_value<Graph, P, T, R>::type
  push_relabel_max_flow
    (Graph& g, 
     typename graph_traits<Graph>::vertex_descriptor src,
     typename graph_traits<Graph>::vertex_descriptor sink,
     const bgl_named_params<P, T, R>& params)
  {
    return push_relabel_max_flow
      (g, src, sink,
       choose_const_pmap(get_param(params, edge_capacity), g, edge_capacity),
       choose_pmap(get_param(params, edge_residual_capacity), 
                   g, edge_residual_capacity),
       choose_const_pmap(get_param(params, edge_reverse), g, edge_reverse),
       choose_const_pmap(get_param(params, vertex_index), g, vertex_index)
       );
  }

    void constraints() {
      boost::function_requires< boost::CopyConstructibleConcept<Visitor> >();
      vis.initialize_vertex(u, g);
      vis.start_vertex(u, g);
      vis.examine_edge(e, g);
      vis.finish_vertex(u, g);
    }

    mas_visitor() { }

    mas_visitor(Visitors vis) : m_vis(vis) { }


    template <class Vertex, class Graph>
    void
    initialize_vertex(Vertex u, Graph& g)
    {
      invoke_visitors(m_vis, u, g, ::boost::on_initialize_vertex());
    }


    template <class Vertex, class Graph>
    void
    start_vertex(Vertex u, Graph& g)
    {
      invoke_visitors(m_vis, u, g, ::boost::on_start_vertex());
    }


    template <class Edge, class Graph>
    void
    examine_edge(Edge e, Graph& g)
    {
      invoke_visitors(m_vis, e, g, ::boost::on_examine_edge());
    }


    template <class Vertex, class Graph>
    void
    finish_vertex(Vertex u, Graph& g)
    {
      invoke_visitors(m_vis, u, g, ::boost::on_finish_vertex());
    }

  template <class Visitors>
  mas_visitor<Visitors>
  make_mas_visitor(Visitors vis) {
    return mas_visitor<Visitors>(vis);
  }

    template <class Graph, class WeightMap, class MASVisitor, class VertexAssignmentMap, class KeyedUpdatablePriorityQueue>
      void
      maximum_adjacency_search(const Graph& g, WeightMap weights, MASVisitor vis, const typename boost::graph_traits<Graph>::vertex_descriptor start, VertexAssignmentMap assignments, KeyedUpdatablePriorityQueue pq) {
      typedef typename boost::graph_traits<Graph>::vertex_descriptor vertex_descriptor;
      typedef typename boost::graph_traits<Graph>::vertices_size_type vertices_size_type;
      typedef typename boost::graph_traits<Graph>::edge_descriptor edge_descriptor;
      typedef typename boost::property_traits<WeightMap>::value_type weight_type;

     std::set<vertex_descriptor> assignedVertices;

     // initialize `assignments` (all vertices are initially
     // assigned to themselves)
     BGL_FORALL_VERTICES_T(v, g, Graph) {
       put(assignments, v, v);
     }

      typename KeyedUpdatablePriorityQueue::key_map keys = pq.keys();

      // set number of visited neighbors for all vertices to 0
      BGL_FORALL_VERTICES_T(v, g, Graph) {
        if (v == get(assignments, v)) { // foreach u \in V do
          put(keys, v, weight_type(0));          vis.initialize_vertex(v, g);

          pq.push(v);
        }
      }
      BOOST_ASSERT(pq.size() >= 2);

      // Give the starting vertex high priority
      put(keys, start, get(keys, start) + num_vertices(g) + 1);
      pq.update(start);

      // start traversing the graph
      //vertex_descriptor s, t;
      weight_type w;
      while (!pq.empty()) { // while PQ \neq {} do
        const vertex_descriptor u = pq.top(); // u = extractmax(PQ)
        w = get(keys, u);                        vis.start_vertex(u, g);
        pq.pop();                  //            vis.start_vertex(u, g);

        BGL_FORALL_OUTEDGES_T(u, e, g, Graph) { // foreach (u, v) \in E do
                                                 vis.examine_edge(e, g);

          const vertex_descriptor v = get(assignments, target(e, g));

          if (pq.contains(v)) { // if v \in PQ then
            put(keys, v, get(keys, v) + get(weights, e)); // increasekey(PQ, v, wA(v) + w(u, v))
            pq.update(v);
          }
        }

        typename std::set<vertex_descriptor>::const_iterator assignedVertexIt, assignedVertexEnd = assignedVertices.end();
        for (assignedVertexIt = assignedVertices.begin(); assignedVertexIt != assignedVertexEnd; ++assignedVertexIt) {
          const vertex_descriptor uPrime = *assignedVertexIt;

          if (get(assignments, uPrime) == u) {
            BGL_FORALL_OUTEDGES_T(uPrime, e, g, Graph) { // foreach (u, v) \in E do
                                                 vis.examine_edge(e, g);

              const vertex_descriptor v = get(assignments, target(e, g));

              if (pq.contains(v)) { // if v \in PQ then
                put(keys, v, get(keys, v) + get(weights, e)); // increasekey(PQ, v, wA(v) + w(u, v))
                pq.update(v);
              }
            }
          }
        }
                                                 vis.finish_vertex(u, g);
      }
    }


  template <class Graph, class WeightMap, class MASVisitor, class VertexAssignmentMap, class KeyedUpdatablePriorityQueue>
    void
maximum_adjacency_search(const Graph& g, WeightMap weights, MASVisitor vis, const typename boost::graph_traits<Graph>::vertex_descriptor start, VertexAssignmentMap assignments, KeyedUpdatablePriorityQueue pq) {
    BOOST_CONCEPT_ASSERT((boost::IncidenceGraphConcept<Graph>));
    BOOST_CONCEPT_ASSERT((boost::VertexListGraphConcept<Graph>));
    typedef typename boost::graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename boost::graph_traits<Graph>::vertices_size_type vertices_size_type;
    typedef typename boost::graph_traits<Graph>::edge_descriptor edge_descriptor;
    BOOST_CONCEPT_ASSERT((boost::Convertible<typename boost::graph_traits<Graph>::directed_category, boost::undirected_tag>));
    BOOST_CONCEPT_ASSERT((boost::ReadablePropertyMapConcept<WeightMap, edge_descriptor>));
    typedef typename boost::property_traits<WeightMap>::value_type weight_type;
    boost::function_requires< MASVisitorConcept<MASVisitor, Graph> >();
    BOOST_CONCEPT_ASSERT((boost::ReadWritePropertyMapConcept<VertexAssignmentMap, vertex_descriptor>));
    BOOST_CONCEPT_ASSERT((boost::Convertible<vertex_descriptor, typename boost::property_traits<VertexAssignmentMap>::value_type>));
    BOOST_CONCEPT_ASSERT((boost::KeyedUpdatableQueueConcept<KeyedUpdatablePriorityQueue>));

    vertices_size_type n = num_vertices(g);
    if (n < 2)
      throw boost::bad_graph("the input graph must have at least two vertices.");
    else if (!pq.empty())
      throw std::invalid_argument("the max-priority queue must be empty initially.");

    detail::maximum_adjacency_search(g, weights,
                                            vis, start,
                                            assignments, pq);
  }

        template <typename Graph, typename ArgPack>
        static result_type apply(const Graph& g, 
                          //const bgl_named_params<P,T,R>& params, 
                          const ArgPack& params, 
                          WeightMap w) {

          using namespace boost::graph::keywords;
          typedef typename boost::graph_traits<Graph>::vertex_descriptor vertex_descriptor;
          typedef typename WeightMap::value_type weight_type;

          typedef boost::detail::make_priority_queue_from_arg_pack_gen<boost::graph::keywords::tag::max_priority_queue, weight_type, vertex_descriptor, std::greater<weight_type> > default_pq_gen_type;

          default_pq_gen_type pq_gen(choose_param(get_param(params, boost::distance_zero_t()), weight_type(0)));

          typename boost::result_of<default_pq_gen_type(const Graph&, const ArgPack&)>::type pq = pq_gen(g, params);

          boost::maximum_adjacency_search
               (g,
                w,
                params [ _visitor | make_mas_visitor(null_visitor())],
                params [ _root_vertex | *vertices(g).first],
                params [ _vertex_assignment_map | boost::detail::make_property_map_from_arg_pack_gen<boost::graph::keywords::tag::vertex_assignment_map, vertex_descriptor>(vertex_descriptor())(g, params)],
                pq
                );
        }


        template <typename Graph, typename ArgPack>
        static result_type apply(const Graph& g, 
                          const ArgPack& params, 
                          param_not_found) {

          using namespace boost::graph::keywords;
          typedef typename boost::graph_traits<Graph>::vertex_descriptor vertex_descriptor;

          // get edge_weight_t as the weight type
          typedef typename boost::property_map<Graph, edge_weight_t> WeightMap;
          typedef typename WeightMap::value_type weight_type;

          typedef boost::detail::make_priority_queue_from_arg_pack_gen<boost::graph::keywords::tag::max_priority_queue, weight_type, vertex_descriptor, std::greater<weight_type> > default_pq_gen_type;

          default_pq_gen_type pq_gen(choose_param(get_param(params, boost::distance_zero_t()), weight_type(0)));

          typename boost::result_of<default_pq_gen_type(const Graph&, const ArgPack&)>::type pq = pq_gen(g, params);

          boost::maximum_adjacency_search
               (g,
                get(edge_weight, g),
                params [ _visitor | make_mas_visitor(null_visitor())],
                params [ _root_vertex | *vertices(g).first],
                params [ _vertex_assignment_map | boost::detail::make_property_map_from_arg_pack_gen<boost::graph::keywords::tag::vertex_assignment_map, vertex_descriptor>(vertex_descriptor())(g, params)],
                pq
                );
        }

  template <typename Graph, typename P, typename T, typename R>
  void
  maximum_adjacency_search (const Graph& g,
      const bgl_named_params<P,T,R>& params) {

    typedef bgl_named_params<P, T, R> params_type;
    BOOST_GRAPH_DECLARE_CONVERTED_PARAMETERS(params_type, params)

    // do the dispatch based on WeightMap
    typedef typename get_param_type<edge_weight_t, bgl_named_params<P,T,R> >::type W;
    graph::detail::mas_dispatch<W>::apply(g, arg_pack, get_param(params, edge_weight));
  }


        template <typename ArgPack>
        void
        operator() (const Graph& g, const ArgPack& arg_pack) const {
          // call the function that does the dispatching
          typedef typename get_param_type<edge_weight_t, ArgPack >::type W;
          graph::detail::mas_dispatch<W>::apply(g, arg_pack, get_param(arg_pack, edge_weight));
        }










    triangulation_visitor(Graph& arg_g, 
                          VertexIndexMap arg_vm, 
                          AddEdgeVisitor arg_add_edge_visitor
                          ) : 
      g(arg_g),
      vm(arg_vm),
      add_edge_visitor(arg_add_edge_visitor),
      timestamp(0),
      marked_vector(num_vertices(g), timestamp),
      degree_vector(num_vertices(g), 0),
      marked(marked_vector.begin(), vm),
      degree(degree_vector.begin(), vm)
    {
      vertex_iterator_t vi, vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        put(degree, *vi, out_degree(*vi, g));
    }


    template <typename Vertex>
    void next_vertex(Vertex v)
    {
      // Self-loops will appear as consecutive vertices in the list of
      // vertices on a face. We want to skip these.
      if (!vertices_on_face.empty() && 
          (vertices_on_face.back() == v || vertices_on_face.front() == v)
          )
        return;

      vertices_on_face.push_back(v);
    }


    void end_face()
    {
      ++timestamp;

      if (vertices_on_face.size() <= 3)
        {
          // At most three vertices on this face - don't need to triangulate
          vertices_on_face.clear();
          return;
        }
      
      // Find vertex on face of minimum degree
      degree_size_t min_degree = num_vertices(g);
      typename vertex_vector_t::iterator min_degree_vertex_itr;
      face_iterator fi_end = vertices_on_face.end();
      for(face_iterator fi = vertices_on_face.begin(); fi != fi_end; ++fi)
        {
          degree_size_t deg = get(degree,*fi);
          if (deg < min_degree)
            {
              min_degree_vertex_itr = fi;
              min_degree = deg;
            }
        }

      // To simplify some of the manipulations, we'll re-arrange 
      // vertices_on_face so that it still contains the same 
      // (counter-clockwise) order of the vertices on this face, but now the 
      // min_degree_vertex is the first element in vertices_on_face.
      vertex_vector_t temp_vector;
      std::copy(min_degree_vertex_itr, vertices_on_face.end(), 
                std::back_inserter(temp_vector));
      std::copy(vertices_on_face.begin(), min_degree_vertex_itr, 
                std::back_inserter(temp_vector));
      vertices_on_face.swap(temp_vector);

      // Mark all of the min degree vertex's neighbors
      adjacency_iterator_t ai, ai_end;
      for(boost::tie(ai,ai_end) = adjacent_vertices(vertices_on_face.front(),g); 
          ai != ai_end; ++ai
          )
        {
          put(marked, *ai, timestamp);
        }

      typename vertex_vector_t::iterator marked_neighbor 
        = vertices_on_face.end();
     
      // The iterator manipulations on the next two lines are safe because 
      // vertices_on_face.size() > 3 (from the first test in this function)
      fi_end = prior(vertices_on_face.end());
      for(face_iterator fi = boost::next(boost::next(vertices_on_face.begin())); 
          fi != fi_end; ++fi
          )
        {
          if (get(marked, *fi) == timestamp)
            {
              marked_neighbor = fi;
              break;
            }
        }

      if (marked_neighbor == vertices_on_face.end())
        {
          add_edge_range(
                         vertices_on_face[0],
                         boost::next(boost::next(vertices_on_face.begin())),
                         prior(vertices_on_face.end())
                         );
        }
      else
        {
          add_edge_range(
                         vertices_on_face[1],
                         boost::next(marked_neighbor),
                         vertices_on_face.end()
                         );

          add_edge_range(
                         *boost::next(marked_neighbor),
                         boost::next(boost::next(vertices_on_face.begin())),
                         marked_neighbor
                         );
        }

      //reset for the next face
      vertices_on_face.clear();
      
    }


    
    void add_edge_range(vertex_t anchor, 
                        face_iterator fi, 
                        face_iterator fi_end
                        )
    {
      for (; fi != fi_end; ++fi)
        {
          vertex_t v(*fi);
          add_edge_visitor.visit_vertex_pair(anchor, v, g);
          put(degree, anchor, get(degree, anchor) + 1);
          put(degree, v, get(degree, v) + 1);
        }
    }





  template <typename Graph,
            typename PlanarEmbedding,
            typename VertexIndexMap,
            typename EdgeIndexMap,
            typename AddEdgeVisitor
            >
  void make_maximal_planar(Graph& g, 
                           PlanarEmbedding embedding,
                           VertexIndexMap vm, 
                           EdgeIndexMap em,
                           AddEdgeVisitor& vis)
  {
    triangulation_visitor<Graph,VertexIndexMap,AddEdgeVisitor> 
      visitor(g, vm, vis);
    planar_face_traversal(g, embedding, visitor, em);
  }





  template <typename Graph,
            typename PlanarEmbedding,
            typename VertexIndexMap,
            typename EdgeIndexMap
            >
  void make_maximal_planar(Graph& g,
                           PlanarEmbedding embedding,
                           VertexIndexMap vm,
                           EdgeIndexMap em
                           )
  {
    default_add_edge_visitor vis;
    make_maximal_planar(g, embedding, vm, em, vis);
  }





  template <typename Graph,
            typename PlanarEmbedding,
            typename VertexIndexMap
            >
  void make_maximal_planar(Graph& g,
                           PlanarEmbedding embedding,
                           VertexIndexMap vm
                           )
  {
    make_maximal_planar(g, embedding, vm, get(edge_index,g));
  }





  template <typename Graph,
            typename PlanarEmbedding
            >
  void make_maximal_planar(Graph& g,
                           PlanarEmbedding embedding
                           )
  {
    make_maximal_planar(g, embedding, get(vertex_index,g));
  }


  template <typename Graph, typename VertexIndexMap>
  typename graph_traits<Graph>::vertices_size_type
  ith_wavefront(typename graph_traits<Graph>::vertex_descriptor i,
                const Graph& g,
                VertexIndexMap index)
  {
    typename graph_traits<Graph>::vertex_descriptor v, w;
    typename graph_traits<Graph>::vertices_size_type b = 1;
    typename graph_traits<Graph>::out_edge_iterator edge_it2, edge_it2_end; 
    typename graph_traits<Graph>::vertices_size_type index_i = index[i];
    std::vector<bool> rows_active(num_vertices(g), false);

    rows_active[index_i] = true;
      
      typename graph_traits<Graph>::vertex_iterator ui, ui_end;
      for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui)
      {
        v = *ui;
          if(index[v] <= index_i)
            {
              for (boost::tie(edge_it2, edge_it2_end) = out_edges(v, g); edge_it2 != edge_it2_end; ++edge_it2)
              {
                w = target(*edge_it2, g);
                if( (index[w] >= index_i) && (!rows_active[index[w]]) )
                  {
                    b++;
                    rows_active[index[w]] = true;
                  }
              }
            }
      }
 
    return b;
  }



  template <typename Graph>
  typename graph_traits<Graph>::vertices_size_type
  ith_wavefront(typename graph_traits<Graph>::vertex_descriptor i,
                const Graph& g)
  {
    return ith_wavefront(i, g, get(vertex_index, g));
  }



  template <typename Graph, typename VertexIndexMap>
  typename graph_traits<Graph>::vertices_size_type
  max_wavefront(const Graph& g, VertexIndexMap index)
  {
    BOOST_USING_STD_MAX();
    typename graph_traits<Graph>::vertices_size_type b = 0;
    typename graph_traits<Graph>::vertex_iterator i, end;
    for (boost::tie(i, end) = vertices(g); i != end; ++i)
      b = max BOOST_PREVENT_MACRO_SUBSTITUTION(b, ith_wavefront(*i, g, index));
    return b;
  }


  template <typename Graph>
  typename graph_traits<Graph>::vertices_size_type
  max_wavefront(const Graph& g)
  {
    return max_wavefront(g, get(vertex_index, g));
  }



  template <typename Graph, typename VertexIndexMap>
  double
  aver_wavefront(const Graph& g, VertexIndexMap index)
  {
    double b = 0;
    typename graph_traits<Graph>::vertex_iterator i, end;
    for (boost::tie(i, end) = vertices(g); i != end; ++i)
      b += ith_wavefront(*i, g, index);

    b /= num_vertices(g);
    return b;
  }


  template <typename Graph>
  double
  aver_wavefront(const Graph& g)
  {
    return aver_wavefront(g, get(vertex_index, g));
  }



  template <typename Graph, typename VertexIndexMap>
  double
  rms_wavefront(const Graph& g, VertexIndexMap index)
  {
    double b = 0;
    typename graph_traits<Graph>::vertex_iterator i, end;
    for (boost::tie(i, end) = vertices(g); i != end; ++i)
      b += std::pow(double ( ith_wavefront(*i, g, index) ), 2.0);

    b /= num_vertices(g);

    return std::sqrt(b);
  }


  template <typename Graph>
  double
  rms_wavefront(const Graph& g)
  {
    return rms_wavefront(g, get(vertex_index, g));
  }

      bk_max_flow(Graph& g,
                  EdgeCapacityMap cap,
                  ResidualCapacityEdgeMap res,
                  ReverseEdgeMap rev,
                  PredecessorMap pre,
                  ColorMap color,
                  DistanceMap dist,
                  IndexMap idx,
                  vertex_descriptor src,
                  vertex_descriptor sink):
      m_g(g),
      m_index_map(idx),
      m_cap_map(cap),
      m_res_cap_map(res),
      m_rev_edge_map(rev),
      m_pre_map(pre),
      m_tree_map(color),
      m_dist_map(dist),
      m_source(src),
      m_sink(sink),
      m_active_nodes(),
      m_in_active_list_vec(num_vertices(g), false),
      m_in_active_list_map(make_iterator_property_map(m_in_active_list_vec.begin(), m_index_map)),
      m_has_parent_vec(num_vertices(g), false),
      m_has_parent_map(make_iterator_property_map(m_has_parent_vec.begin(), m_index_map)),
      m_time_vec(num_vertices(g), 0),
      m_time_map(make_iterator_property_map(m_time_vec.begin(), m_index_map)),
      m_flow(0),
      m_time(1),
      m_last_grow_vertex(graph_traits<Graph>::null_vertex()){
        // initialize the color-map with gray-values
        vertex_iterator vi, v_end;
        for(boost::tie(vi, v_end) = vertices(m_g); vi != v_end; ++vi){
          set_tree(*vi, tColorTraits::gray());
        }
        // Initialize flow to zero which means initializing
        // the residual capacity equal to the capacity
        edge_iterator ei, e_end;
        for(boost::tie(ei, e_end) = edges(m_g); ei != e_end; ++ei) {
          put(m_res_cap_map, *ei, get(m_cap_map, *ei));
          BOOST_ASSERT(get(m_rev_edge_map, get(m_rev_edge_map, *ei)) == *ei); //check if the reverse edge map is build up properly
        }
        //init the search trees with the two terminals
        set_tree(m_source, tColorTraits::black());
        set_tree(m_sink, tColorTraits::white());
        put(m_time_map, m_source, 1);
        put(m_time_map, m_sink, 1);
      }


      tEdgeVal max_flow(){
        //augment direct paths from SOURCE->SINK and SOURCE->VERTEX->SINK
        augment_direct_paths();
        //start the main-loop
        while(true){
          bool path_found;
          edge_descriptor connecting_edge;
          boost::tie(connecting_edge, path_found) = grow(); //find a path from source to sink
          if(!path_found){
            //we're finished, no more paths were found
            break;
          }
          ++m_time;
          augment(connecting_edge); //augment that path
          adopt(); //rebuild search tree structure
        }
        return m_flow;
      }

      void augment_direct_paths(){
        // in a first step, we augment all direct paths from source->NODE->sink
        // and additionally paths from source->sink. This improves especially
        // graphcuts for segmentation, as most of the nodes have source/sink
        // connects but shouldn't have an impact on other maxflow problems
        // (this is done in grow() anyway)
        out_edge_iterator ei, e_end;
        for(boost::tie(ei, e_end) = out_edges(m_source, m_g); ei != e_end; ++ei){
          edge_descriptor from_source = *ei;
          vertex_descriptor current_node = target(from_source, m_g);
          if(current_node == m_sink){
            tEdgeVal cap = get(m_res_cap_map, from_source);
            put(m_res_cap_map, from_source, 0);
            m_flow += cap;
            continue;
          }
          edge_descriptor to_sink;
          bool is_there;
          boost::tie(to_sink, is_there) = lookup_edge(current_node, m_sink, m_g);
          if(is_there){
            tEdgeVal cap_from_source = get(m_res_cap_map, from_source);
            tEdgeVal cap_to_sink = get(m_res_cap_map, to_sink);
            if(cap_from_source > cap_to_sink){
              set_tree(current_node, tColorTraits::black());
              add_active_node(current_node);
              set_edge_to_parent(current_node, from_source);
              put(m_dist_map, current_node, 1);
              put(m_time_map, current_node, 1);
              // add stuff to flow and update residuals. we dont need to
              // update reverse_edges, as incoming/outgoing edges to/from
              // source/sink don't count for max-flow
              put(m_res_cap_map, from_source, get(m_res_cap_map, from_source) - cap_to_sink);
              put(m_res_cap_map, to_sink, 0);
              m_flow += cap_to_sink;
            } else if(cap_to_sink > 0){
              set_tree(current_node, tColorTraits::white());
              add_active_node(current_node);
              set_edge_to_parent(current_node, to_sink);
              put(m_dist_map, current_node, 1);
              put(m_time_map, current_node, 1);
              // add stuff to flow and update residuals. we dont need to update
              // reverse_edges, as incoming/outgoing edges to/from source/sink
              // don't count for max-flow
              put(m_res_cap_map, to_sink, get(m_res_cap_map, to_sink) - cap_from_source);
              put(m_res_cap_map, from_source, 0);
              m_flow += cap_from_source;
            }
          } else if(get(m_res_cap_map, from_source)){
            // there is no sink connect, so we can't augment this path, but to
            // avoid adding m_source to the active nodes, we just activate this
            // node and set the approciate things
            set_tree(current_node, tColorTraits::black());
            set_edge_to_parent(current_node, from_source);
            put(m_dist_map, current_node, 1);
            put(m_time_map, current_node, 1);
            add_active_node(current_node);
          }
        }
        for(boost::tie(ei, e_end) = out_edges(m_sink, m_g); ei != e_end; ++ei){
          edge_descriptor to_sink = get(m_rev_edge_map, *ei);
          vertex_descriptor current_node = source(to_sink, m_g);
          if(get(m_res_cap_map, to_sink)){
            set_tree(current_node, tColorTraits::white());
            set_edge_to_parent(current_node, to_sink);
            put(m_dist_map, current_node, 1);
            put(m_time_map, current_node, 1);
            add_active_node(current_node);
          }
        }
      }

template<class Graph,
         class CapacityEdgeMap,
         class ResidualCapacityEdgeMap,
         class ReverseEdgeMap, class PredecessorMap,
         class ColorMap,
         class DistanceMap,
         class IndexMap>
typename property_traits<CapacityEdgeMap>::value_type
boykov_kolmogorov_max_flow(Graph& g,
                           CapacityEdgeMap cap,
                           ResidualCapacityEdgeMap res_cap,
                           ReverseEdgeMap rev_map,
                           PredecessorMap pre_map,
                           ColorMap color,
                           DistanceMap dist,
                           IndexMap idx,
                           typename graph_traits<Graph>::vertex_descriptor src,
                           typename graph_traits<Graph>::vertex_descriptor sink)
{
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;

  //as this method is the last one before we instantiate the solver, we do the concept checks here
  BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> )); //to have vertices(), num_vertices(),
  BOOST_CONCEPT_ASSERT(( EdgeListGraphConcept<Graph> )); //to have edges()
  BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<Graph> )); //to have source(), target() and out_edges()
  BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<CapacityEdgeMap, edge_descriptor> )); //read flow-values from edges
  BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<ResidualCapacityEdgeMap, edge_descriptor> )); //write flow-values to residuals
  BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<ReverseEdgeMap, edge_descriptor> )); //read out reverse edges
  BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<PredecessorMap, vertex_descriptor> )); //store predecessor there
  BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<ColorMap, vertex_descriptor> )); //write corresponding tree
  BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<DistanceMap, vertex_descriptor> )); //write distance to source/sink
  BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<IndexMap, vertex_descriptor> )); //get index 0...|V|-1
  BOOST_ASSERT(num_vertices(g) >= 2 && src != sink);

  detail::bk_max_flow<
    Graph, CapacityEdgeMap, ResidualCapacityEdgeMap, ReverseEdgeMap,
    PredecessorMap, ColorMap, DistanceMap, IndexMap
  > algo(g, cap, res_cap, rev_map, pre_map, color, dist, idx, src, sink);

  return algo.max_flow();
}

template<class Graph,
         class CapacityEdgeMap,
         class ResidualCapacityEdgeMap,
         class ReverseEdgeMap,
         class IndexMap>
typename property_traits<CapacityEdgeMap>::value_type
boykov_kolmogorov_max_flow(Graph& g,
                           CapacityEdgeMap cap,
                           ResidualCapacityEdgeMap res_cap,
                           ReverseEdgeMap rev,
                           IndexMap idx,
                           typename graph_traits<Graph>::vertex_descriptor src,
                           typename graph_traits<Graph>::vertex_descriptor sink)
{
  typename graph_traits<Graph>::vertices_size_type n_verts = num_vertices(g);
  std::vector<typename graph_traits<Graph>::edge_descriptor> predecessor_vec(n_verts);
  std::vector<default_color_type> color_vec(n_verts);
  std::vector<typename graph_traits<Graph>::vertices_size_type> distance_vec(n_verts);
  return
    boykov_kolmogorov_max_flow(
      g, cap, res_cap, rev,
      make_iterator_property_map(predecessor_vec.begin(), idx),
      make_iterator_property_map(color_vec.begin(), idx),
      make_iterator_property_map(distance_vec.begin(), idx),
      idx, src, sink);
}

template<class Graph,
         class CapacityEdgeMap,
         class ResidualCapacityEdgeMap,
         class ReverseEdgeMap,
         class ColorMap,
         class IndexMap>
typename property_traits<CapacityEdgeMap>::value_type
boykov_kolmogorov_max_flow(Graph& g,
                           CapacityEdgeMap cap,
                           ResidualCapacityEdgeMap res_cap,
                           ReverseEdgeMap rev,
                           ColorMap color,
                           IndexMap idx,
                           typename graph_traits<Graph>::vertex_descriptor src,
                           typename graph_traits<Graph>::vertex_descriptor sink)
{
  typename graph_traits<Graph>::vertices_size_type n_verts = num_vertices(g);
  std::vector<typename graph_traits<Graph>::edge_descriptor> predecessor_vec(n_verts);
  std::vector<typename graph_traits<Graph>::vertices_size_type> distance_vec(n_verts);
  return
    boykov_kolmogorov_max_flow(
      g, cap, res_cap, rev,
      make_iterator_property_map(predecessor_vec.begin(), idx),
      color,
      make_iterator_property_map(distance_vec.begin(), idx),
      idx, src, sink);
}

        bad_graph(const std::string& what_arg)
            : std::invalid_argument(what_arg) { }

        not_a_dag()
            : bad_graph("The graph must be a DAG.")
        { }

        negative_edge()
            : bad_graph("The graph may not contain an edge with negative weight.")
        { }

        negative_cycle()
            : bad_graph("The graph may not contain negative cycles.")
        { }

        not_connected()
            : bad_graph("The graph must be connected.")
        { }

       not_complete()
           : bad_graph("The graph must be complete.")
       { }

    topo_sort_visitor(OutputIterator _iter)
      : m_iter(_iter) { }

    
    template <typename Edge, typename Graph>
    void back_edge(const Edge&, Graph&) { BOOST_THROW_EXCEPTION(not_a_dag()); }

    
    template <typename Vertex, typename Graph> 
    void finish_vertex(const Vertex& u, Graph&) { *m_iter++ = u; }


  template <typename VertexListGraph, typename OutputIterator,
    typename P, typename T, typename R>
  void topological_sort(VertexListGraph& g, OutputIterator result,
                        const bgl_named_params<P, T, R>& params)
  {
    typedef topo_sort_visitor<OutputIterator> TopoVisitor;
    depth_first_search(g, params.visitor(TopoVisitor(result)));
  }


  template <typename VertexListGraph, typename OutputIterator>
  void topological_sort(VertexListGraph& g, OutputIterator result)
  {
    topological_sort(g, result, 
                     bgl_named_params<int, buffer_param_t>(0)); // bogus
  }

      bfs_king_visitor(OutputIterator *iter, Buffer *b, Compare compare, 
                       PseudoDegreeMap deg, std::vector<int> loc, VecMap color, 
                       VertexIndexMap vertices): 
        permutation(iter), Qptr(b), degree(deg), comp(compare), 
        Qlocation(loc), colors(color), vertex_map(vertices) { }

      
      template <typename Vertex, typename Graph>
      void finish_vertex(Vertex, Graph& g) {
        typename graph_traits<Graph>::out_edge_iterator ei, ei_end;
        Vertex v, w;

        typedef typename std::deque<Vertex>::iterator iterator;
        typedef typename std::deque<Vertex>::reverse_iterator reverse_iterator;

        reverse_iterator rend = Qptr->rend()-index_begin;
        reverse_iterator rbegin = Qptr->rbegin();


        //heap the vertices already there
        std::make_heap(rbegin, rend, boost::bind<bool>(comp, _2, _1));

        unsigned i = 0;
        
        for(i = index_begin; i != Qptr->size(); ++i){
          colors[get(vertex_map, (*Qptr)[i])] = 1;
          Qlocation[get(vertex_map, (*Qptr)[i])] = i;
        }

        i = 0;

        for( ; rbegin != rend; rend--){
          percolate_down<Vertex>(i);
          w = (*Qptr)[index_begin+i];
          for (boost::tie(ei, ei_end) = out_edges(w, g); ei != ei_end; ++ei) {
            v = target(*ei, g);
            put(degree, v, get(degree, v) - 1);
    
            if (colors[get(vertex_map, v)] == 1) {
              percolate_up<Vertex>(get(vertex_map, v), i);            
            }
          }
          
          colors[get(vertex_map, w)] = 0;
          i++;
        }
      }

    
      template <typename Vertex, typename Graph>
      void examine_vertex(Vertex u, const Graph&) {
        
        *(*permutation)++ = u;
        index_begin = Qptr->size();
        
      }

      template <typename Vertex>
      void percolate_down(int offset){
        typedef typename std::deque<Vertex>::reverse_iterator reverse_iterator;
        
        int heap_last = index_begin + offset;
        int heap_first = Qptr->size() - 1;
        
        //pop_heap functionality:
        //swap first, last
        std::swap((*Qptr)[heap_last], (*Qptr)[heap_first]);
        
        //swap in the location queue
        std::swap(Qlocation[heap_first], Qlocation[heap_last]);

        //set drifter, children
        int drifter = heap_first;
        int drifter_heap = Qptr->size() - drifter;

        int right_child_heap = drifter_heap * 2 + 1;
        int right_child = Qptr->size() - right_child_heap;

        int left_child_heap = drifter_heap * 2;
        int left_child = Qptr->size() - left_child_heap;

        //check that we are staying in the heap
        bool valid = (right_child < heap_last) ? false : true;
        
        //pick smallest child of drifter, and keep in mind there might only be left child
        int smallest_child = (valid && get(degree, (*Qptr)[left_child]) > get(degree,(*Qptr)[right_child])) ? 
          right_child : left_child;
        
        while(valid && smallest_child < heap_last && comp((*Qptr)[drifter], (*Qptr)[smallest_child])){
          
          //if smallest child smaller than drifter, swap them
          std::swap((*Qptr)[smallest_child], (*Qptr)[drifter]);
          std::swap(Qlocation[drifter], Qlocation[smallest_child]);

          //update the values, run again, as necessary
          drifter = smallest_child;
          drifter_heap = Qptr->size() - drifter;

          right_child_heap = drifter_heap * 2 + 1;
          right_child = Qptr->size() - right_child_heap;

          left_child_heap = drifter_heap * 2;
          left_child = Qptr->size() - left_child_heap;

          valid = (right_child < heap_last) ? false : true;

          smallest_child = (valid && get(degree, (*Qptr)[left_child]) > get(degree,(*Qptr)[right_child])) ? 
            right_child : left_child;
        }

      }

      template <typename Vertex>
      void percolate_up(int vertex, int offset){
        
        int child_location = Qlocation[vertex];
        int heap_child_location = Qptr->size() - child_location;
        int heap_parent_location = (int)(heap_child_location/2);
        unsigned parent_location = Qptr->size() - heap_parent_location; 

        bool valid = (heap_parent_location != 0 && child_location > index_begin + offset && 
                      parent_location < Qptr->size());

        while(valid && comp((*Qptr)[child_location], (*Qptr)[parent_location])){
          
          //swap in the heap
          std::swap((*Qptr)[child_location], (*Qptr)[parent_location]);
          
          //swap in the location queue
          std::swap(Qlocation[child_location], Qlocation[parent_location]);

          child_location = parent_location;
          heap_child_location = heap_parent_location;
          heap_parent_location = (int)(heap_child_location/2);
          parent_location = Qptr->size() - heap_parent_location; 
          valid = (heap_parent_location != 0 && child_location > index_begin + offset);
        }
      }

  

  template<class Graph, class OutputIterator, class ColorMap, class DegreeMap,
           typename VertexIndexMap> 
  OutputIterator
  king_ordering(const Graph& g,
                std::deque< typename graph_traits<Graph>::vertex_descriptor >
                  vertex_queue,
                OutputIterator permutation, 
                ColorMap color, DegreeMap degree,
                VertexIndexMap index_map)
  {
    typedef typename property_traits<DegreeMap>::value_type ds_type;
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    typedef iterator_property_map<typename std::vector<ds_type>::iterator, VertexIndexMap, ds_type, ds_type&> PseudoDegreeMap;
    typedef indirect_cmp<PseudoDegreeMap, std::less<ds_type> > Compare;
    typedef typename boost::sparse::sparse_ordering_queue<Vertex> queue;
    typedef typename detail::bfs_king_visitor<OutputIterator, queue, Compare,             
      PseudoDegreeMap, std::vector<int>, VertexIndexMap > Visitor;
    typedef typename graph_traits<Graph>::vertices_size_type
      vertices_size_type;
    std::vector<ds_type> pseudo_degree_vec(num_vertices(g));
    PseudoDegreeMap pseudo_degree(pseudo_degree_vec.begin(), index_map);
    
    typename graph_traits<Graph>::vertex_iterator ui, ui_end;    
    queue Q;
    // Copy degree to pseudo_degree
    // initialize the color map
    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui){
      put(pseudo_degree, *ui, get(degree, *ui));
      put(color, *ui, Color::white());
    }
    
    Compare comp(pseudo_degree);
    std::vector<int> colors(num_vertices(g));

    for(vertices_size_type i = 0; i < num_vertices(g); i++) 
      colors[i] = 0;

    std::vector<int> loc(num_vertices(g));

    //create the visitor
    Visitor vis(&permutation, &Q, comp, pseudo_degree, loc, colors, index_map);
    
    while( !vertex_queue.empty() ) {
      Vertex s = vertex_queue.front();
      vertex_queue.pop_front();
      
      //call BFS with visitor
      breadth_first_visit(g, s, Q, vis, color);
    }

    return permutation;
  }

  template <class Graph, class OutputIterator,
            class ColorMap, class DegreeMap, typename VertexIndexMap>
  OutputIterator
  king_ordering(const Graph& g,
                typename graph_traits<Graph>::vertex_descriptor s,
                OutputIterator permutation, 
                ColorMap color, DegreeMap degree, VertexIndexMap index_map)
  {

    std::deque< typename graph_traits<Graph>::vertex_descriptor > vertex_queue;
    vertex_queue.push_front( s );
    return king_ordering(g, vertex_queue, permutation, color, degree,
                         index_map);
  }


  
  template < class Graph, class OutputIterator, 
             class ColorMap, class DegreeMap, class VertexIndexMap>
  OutputIterator 
  king_ordering(const Graph& G, OutputIterator permutation, 
                ColorMap color, DegreeMap degree, VertexIndexMap index_map)
  {
    if (has_no_vertices(G))
      return permutation;

    typedef typename boost::graph_traits<Graph>::vertex_descriptor Vertex;
    typedef typename boost::graph_traits<Graph>::vertex_iterator   VerIter;
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;

    std::deque<Vertex>      vertex_queue;

    // Mark everything white
    BGL_FORALL_VERTICES_T(v, G, Graph) put(color, v, Color::white());

    // Find one vertex from each connected component 
    BGL_FORALL_VERTICES_T(v, G, Graph) {
      if (get(color, v) == Color::white()) {
        depth_first_visit(G, v, dfs_visitor<>(), color);
        vertex_queue.push_back(v);
      }
    }

    // Find starting nodes for all vertices
    // TBD: How to do this with a directed graph?
    for (typename std::deque<Vertex>::iterator i = vertex_queue.begin();
         i != vertex_queue.end(); ++i)
      *i = find_starting_node(G, *i, color, degree);
    
    return king_ordering(G, vertex_queue, permutation, color, degree,
                         index_map);
  }


  template<typename Graph, typename OutputIterator, typename VertexIndexMap>
  OutputIterator 
  king_ordering(const Graph& G, OutputIterator permutation, 
                VertexIndexMap index_map)
  {
    if (has_no_vertices(G))
      return permutation;

    typedef out_degree_property_map<Graph> DegreeMap;
    std::vector<default_color_type> colors(num_vertices(G));
    return king_ordering(G, permutation, 
                         make_iterator_property_map(&colors[0], index_map,
                                                    colors[0]),
                         make_out_degree_map(G), index_map);
  }


  template<typename Graph, typename OutputIterator>
  inline OutputIterator 
  king_ordering(const Graph& G, OutputIterator permutation)
  { return king_ordering(G, permutation, get(vertex_index, G)); }

      Stacks(size_type n) : data(n) {}

        stack(Iterator _data, const value_type& head)
          :  data(_data), current(head) {}

        
        void pop() {
          BOOST_ASSERT(! empty());
          current = data[current];
        }

        void push(value_type v) {
          data[v] = current; 
          current = v;
        }

        bool empty() {
          return current == -(std::numeric_limits<value_type>::max)(); 
        }

        value_type& top() { return current; }

      stack make_stack()
        { return stack(data.begin()); }

      
      static value_type done() 
      { return (std::numeric_limits<value_type>::max)()/2; }

      Marker(size_type _num, VertexIndexMap index_map) 
        : tag(1 - (std::numeric_limits<value_type>::max)()),
          data(_num, - (std::numeric_limits<value_type>::max)()),
          id(index_map) {}

      
      void mark_done(Vertex node) { data[get(id, node)] = done(); }

      
      bool is_done(Vertex node) { return data[get(id, node)] == done(); }

      
      void mark_tagged(Vertex node) { data[get(id, node)] = tag; }

      
      void mark_multiple_tagged(Vertex node) { data[get(id, node)] = multiple_tag; }

  
      bool is_tagged(Vertex node) const { return data[get(id, node)] >= tag; }


      bool is_not_tagged(Vertex node) const { return data[get(id, node)] < tag; }


      bool is_multiple_tagged(Vertex node) const 
        { return data[get(id, node)] >= multiple_tag; }


      void increment_tag() {
        const size_type num = data.size();
        ++tag;
        if ( tag >= done() ) {
          tag = 1 - (std::numeric_limits<value_type>::max)();
          for (size_type i = 0; i < num; ++i)
            if ( data[i] < done() ) 
              data[i] = - (std::numeric_limits<value_type>::max)();
        }
      }

      
      void set_multiple_tag(value_type mdeg0) 
      { 
        const size_type num = data.size();
        multiple_tag = tag + mdeg0; 
        
        if ( multiple_tag >= done() ) {
          tag = 1-(std::numeric_limits<value_type>::max)();
          
          for (size_type i=0; i<num; i++)
            if ( data[i] < done() ) 
              data[i] = -(std::numeric_limits<value_type>::max)();
          
          multiple_tag = tag + mdeg0; 
        }
      }

      
      void set_tag_as_multiple_tag() { tag = multiple_tag; }

      Numbering(Iterator _data, number_type _max_num, VertexIndexMap id) 
        : num(1), data(_data), max_num(_max_num), id(id) {}

      void operator()(Vertex node) { data[get(id, node)] = -num; }

      bool all_done(number_type i = 0) const { return num + i > max_num; }

      void increment(number_type i = 1) { num += i; }

      bool is_numbered(Vertex node) const {
        return data[get(id, node)] < 0;
      }

      void indistinguishable(Vertex i, Vertex j) {
        data[get(id, i)] = - (get(id, j) + offset);
      }

      degreelists_marker(size_type n, VertexIndexMap id)
        : marks(n, 0), id(id) {}

      void mark_need_update(Vertex i) { marks[get(id, i)] = 1;  }

      bool need_update(Vertex i) { return marks[get(id, i)] == 1; }

      bool outmatched_or_done (Vertex i) { return marks[get(id, i)] == -1; }

      void mark(Vertex i) { marks[get(id, i)] = -1; }

      void unmark(Vertex i) { marks[get(id, i)] = 0; }

      predicateRemoveEdge1(Graph& _g, MarkerP& _marker, 
                           NumberD _numbering, Stack& n_e, VertexIndexMap id)
        : g(&_g), marker(&_marker), numbering(_numbering),
          neighbor_elements(&n_e), id(id) {}


      bool operator()(edge_t e) {
        vertex_t dist = target(e, *g);
        if ( marker->is_tagged(dist) )
          return true;
        marker->mark_tagged(dist);
        if (numbering.is_numbered(dist)) {
          neighbor_elements->push(get(id, dist));
          return true;
        }
        return false;
      }

      predicate_remove_tagged_edges(Graph& _g, MarkerP& _marker)
        : g(&_g), marker(&_marker) {}


      bool operator()(edge_t e) {
        vertex_t dist = target(e, *g);
        if ( marker->is_tagged(dist) )
          return true;
        return false;
      }

      mmd_impl(Graph& g, size_type n_, int delta, DegreeMap degree, 
               InversePermutationMap inverse_perm, 
               PermutationMap perm,
               SuperNodeMap supernode_size, 
               VertexIndexMap id) 
        : G(g), delta(delta), degree(degree), 
        inverse_perm(inverse_perm), 
        perm(perm), 
        supernode_size(supernode_size), 
        vertex_index_map(id),
        index_vertex_vec(n_), 
        n(n_),
        degreelists(n_ + 1, n_, degree, id),
        numbering(inverse_perm, n_, vertex_index_map),
        degree_lists_marker(n_, vertex_index_map), 
        marker(n_, vertex_index_map),
        work_space(n_)
      {
        typename graph_traits<Graph>::vertex_iterator v, vend;
        size_type vid = 0;
        for (boost::tie(v, vend) = vertices(G); v != vend; ++v, ++vid)
          index_vertex_vec[vid] = *v;
        index_vertex_map = IndexVertexMap(&index_vertex_vec[0]);

        // Initialize degreelists.  Degreelists organizes the nodes
        // according to their degree.
        for (boost::tie(v, vend) = vertices(G); v != vend; ++v) {
          put(degree, *v, out_degree(*v, G));
          degreelists.push(*v);
        }
      }


      void do_mmd()
      {
        // Eliminate the isolated nodes -- these are simply the nodes
        // with no neighbors, which are accessible as a list (really, a
        // stack) at location 0.  Since these don't affect any other
        // nodes, we can eliminate them without doing degree updates.
        typename DegreeLists::stack list_isolated = degreelists[0];
        while (!list_isolated.empty()) {
          vertex_t node = list_isolated.top();
          marker.mark_done(node);
          numbering(node);
          numbering.increment();
          list_isolated.pop();
        }
        size_type min_degree = 1;
        typename DegreeLists::stack list_min_degree = degreelists[min_degree];

        while (list_min_degree.empty()) {
          ++min_degree;
          list_min_degree = degreelists[min_degree];
        }

        // check if the whole eliminating process is done
        while (!numbering.all_done()) {

          size_type min_degree_limit = min_degree + delta; // WARNING
          typename Workspace::stack llist = work_space.make_stack();

          // multiple elimination
          while (delta >= 0) {

            // Find the next non-empty degree
            for (list_min_degree = degreelists[min_degree]; 
                 list_min_degree.empty() && min_degree <= min_degree_limit; 
                 ++min_degree, list_min_degree = degreelists[min_degree])
              ;
            if (min_degree > min_degree_limit)
              break;

            const vertex_t node = list_min_degree.top();
            const size_type node_id = get(vertex_index_map, node);
            list_min_degree.pop();
            numbering(node);

            // check if node is the last one
            if (numbering.all_done(supernode_size[node])) {
              numbering.increment(supernode_size[node]);
              break;
            }
            marker.increment_tag();
            marker.mark_tagged(node);

            this->eliminate(node);

            numbering.increment(supernode_size[node]);
            llist.push(node_id);
          } // multiple elimination

          if (numbering.all_done()) 
            break;

          this->update( llist, min_degree);
        }

      }


      void eliminate(vertex_t node)
      {
        typename Workspace::stack element_neighbor = work_space.make_stack();

        // Create two function objects for edge removal
        typedef typename Workspace::stack WorkStack;
        predicateRemoveEdge1<Graph, MarkerP, NumberingD, 
                             WorkStack, VertexIndexMap>
          p(G, marker, numbering, element_neighbor, vertex_index_map);

        predicate_remove_tagged_edges<Graph, MarkerP> p2(G, marker);

        // Reconstruct the adjacent node list, push element neighbor in a List.
        remove_out_edge_if(node, p, G);
        //during removal element neighbors are collected.

        while (!element_neighbor.empty()) {
          // element absorb
          size_type e_id = element_neighbor.top();
          vertex_t element = get(index_vertex_map, e_id);
          adj_iter i, i_end;
          for (boost::tie(i, i_end) = adjacent_vertices(element, G); i != i_end; ++i){
            vertex_t i_node = *i;
            if (!marker.is_tagged(i_node) && !numbering.is_numbered(i_node)) {
              marker.mark_tagged(i_node);
              add_edge(node, i_node, G);
            }
          }
          element_neighbor.pop();
        }
        adj_iter v, ve;
        for (boost::tie(v, ve) = adjacent_vertices(node, G); v != ve; ++v) {
          vertex_t v_node = *v;
          if (!degree_lists_marker.need_update(v_node) 
              && !degree_lists_marker.outmatched_or_done(v_node)) {
            degreelists.remove(v_node);
          }
          //update out edges of v_node
          remove_out_edge_if(v_node, p2, G);

          if ( out_degree(v_node, G) == 0 ) { // indistinguishable nodes
            supernode_size[node] += supernode_size[v_node];
            supernode_size[v_node] = 0;
            numbering.indistinguishable(v_node, node);
            marker.mark_done(v_node);
            degree_lists_marker.mark(v_node);
          } else {                           // not indistinguishable nodes
            add_edge(v_node, node, G);
            degree_lists_marker.mark_need_update(v_node);
          }
        }
      }



      template <class Stack>
      void update(Stack llist, size_type& min_degree)
      {
        size_type min_degree0 = min_degree + delta + 1;

        while (! llist.empty()) {
          size_type deg, deg0 = 0;

          marker.set_multiple_tag(min_degree0);
          typename Workspace::stack q2list = work_space.make_stack();
          typename Workspace::stack qxlist = work_space.make_stack();

          vertex_t current = get(index_vertex_map, llist.top());
          adj_iter i, ie;
          for (boost::tie(i,ie) = adjacent_vertices(current, G); i != ie; ++i) {
            vertex_t i_node = *i;
            const size_type i_id = get(vertex_index_map, i_node);
            if (supernode_size[i_node] != 0) {
              deg0 += supernode_size[i_node];
              marker.mark_multiple_tagged(i_node);
              if (degree_lists_marker.need_update(i_node)) {
                if (out_degree(i_node, G) == 2)
                  q2list.push(i_id);
                else
                  qxlist.push(i_id);
              }
            }
          }

          while (!q2list.empty()) {
            const size_type u_id = q2list.top();
            vertex_t u_node = get(index_vertex_map, u_id);
            // if u_id is outmatched by others, no need to update degree
            if (degree_lists_marker.outmatched_or_done(u_node)) {
              q2list.pop();
              continue;
            }
            marker.increment_tag();
            deg = deg0;

            adj_iter nu = adjacent_vertices(u_node, G).first;
            vertex_t neighbor = *nu;
            if (neighbor == u_node) {
              ++nu;
              neighbor = *nu;
            }
            if (numbering.is_numbered(neighbor)) {
              adj_iter i, ie;
              for (boost::tie(i,ie) = adjacent_vertices(neighbor, G);
                   i != ie; ++i) {
                const vertex_t i_node = *i;
                if (i_node == u_node || supernode_size[i_node] == 0)
                  continue;
                if (marker.is_tagged(i_node)) {
                  if (degree_lists_marker.need_update(i_node)) {
                    if ( out_degree(i_node, G) == 2 ) { // is indistinguishable
                      supernode_size[u_node] += supernode_size[i_node];
                      supernode_size[i_node] = 0;
                      numbering.indistinguishable(i_node, u_node);
                      marker.mark_done(i_node);
                      degree_lists_marker.mark(i_node);
                    } else                        // is outmatched
                      degree_lists_marker.mark(i_node);
                  }
                } else {
                  marker.mark_tagged(i_node);
                  deg += supernode_size[i_node];
                }
              }
            } else
              deg += supernode_size[neighbor];

            deg -= supernode_size[u_node];
            degree[u_node] = deg; //update degree
            degreelists[deg].push(u_node);
            //u_id has been pushed back into degreelists
            degree_lists_marker.unmark(u_node);
            if (min_degree > deg) 
              min_degree = deg;
            q2list.pop();
          } // while (!q2list.empty())

          while (!qxlist.empty()) {
            const size_type u_id = qxlist.top();
            const vertex_t u_node = get(index_vertex_map, u_id);

            // if u_id is outmatched by others, no need to update degree
            if (degree_lists_marker.outmatched_or_done(u_node)) {
              qxlist.pop();
              continue;
            }
            marker.increment_tag();
            deg = deg0;
            adj_iter i, ie;
            for (boost::tie(i, ie) = adjacent_vertices(u_node, G); i != ie; ++i) {
              vertex_t i_node = *i;
              if (marker.is_tagged(i_node)) 
                continue;
              marker.mark_tagged(i_node);

              if (numbering.is_numbered(i_node)) {
                adj_iter j, je;
                for (boost::tie(j, je) = adjacent_vertices(i_node, G); j != je; ++j) {
                  const vertex_t j_node = *j;
                  if (marker.is_not_tagged(j_node)) {
                    marker.mark_tagged(j_node);
                    deg += supernode_size[j_node];
                  }
                }
              } else
                deg += supernode_size[i_node];
            } // for adjacent vertices of u_node
            deg -= supernode_size[u_node];
            degree[u_node] = deg;
            degreelists[deg].push(u_node);
            // u_id has been pushed back into degreelists
            degree_lists_marker.unmark(u_node); 
            if (min_degree > deg)
              min_degree = deg;
            qxlist.pop();
          } // while (!qxlist.empty()) {

          marker.set_tag_as_multiple_tag();
          llist.pop();
        } // while (! llist.empty())

      }



      void build_permutation(InversePermutationMap next,
                             PermutationMap prev) 
      {
        // collect the permutation info
        size_type i;
        for (i = 0; i < n; ++i) {
          diff_t size = supernode_size[get(index_vertex_map, i)];
          if ( size <= 0 ) {
            prev[i] = next[i];
            supernode_size[get(index_vertex_map, i)]
              = next[i] + 1;  // record the supernode info
          } else
            prev[i] = - next[i];
        }
        for (i = 1; i < n + 1; ++i) {
          if ( prev[i-1] > 0 )
            continue;
          diff_t parent = i;
          while ( prev[parent - 1] < 0 ) {
            parent = - prev[parent - 1];
          }

          diff_t root = parent;
          diff_t num = prev[root - 1] + 1;
          next[i-1] = - num;
          prev[root-1] = num;

          parent = i;
          diff_t next_node = - prev[parent - 1];
          while (next_node > 0) {
            prev[parent-1] = - root;
            parent = next_node;
            next_node = - prev[parent - 1];
          }
        }
        for (i = 0; i < n; i++) {
          diff_t num = - next[i] - 1;
          next[i] = num;
          prev[num] = i;
        }
      }

  template<class Graph, class DegreeMap, 
           class InversePermutationMap, 
           class PermutationMap,
           class SuperNodeMap, class VertexIndexMap>
  void minimum_degree_ordering
    (Graph& G, 
     DegreeMap degree, 
     InversePermutationMap inverse_perm, 
     PermutationMap perm, 
     SuperNodeMap supernode_size, 
     int delta, 
     VertexIndexMap vertex_index_map)
  {
    detail::mmd_impl<Graph,DegreeMap,InversePermutationMap,
      PermutationMap, SuperNodeMap, VertexIndexMap> 
      impl(G, num_vertices(G), delta, degree, inverse_perm, 
           perm, supernode_size, vertex_index_map);
    impl.do_mmd();
    impl.build_permutation(inverse_perm, perm);
  }

    bridges_visitor(
        TreeMap tree,
        PredMap pred,
        DistMap dist,
        LowMap low,
        Buffer& buffer
      ): mTree(tree), mPred(pred), mDist(dist), mLow(low), mBuffer(buffer)
    { mNum = -1; }


    template <typename Vertex, typename Graph>
    void initialize_vertex(const Vertex& u, const Graph& g)
    {
      put(mPred, u, u);
      put(mDist, u, -1);
    }


    template <typename Vertex, typename Graph>
    void discover_vertex(const Vertex& u, const Graph& g)
    {
      put(mDist, u, ++mNum);
      put(mLow, u, get(mDist, u));
    }


    template <typename Edge, typename Graph>
    void tree_edge(const Edge& e, const Graph& g)
    {
      put(mPred, target(e, g), source(e, g));
      put(mTree, target(e, g), e);
    }


    template <typename Edge, typename Graph>
    void back_edge(const Edge& e, const Graph& g)
    {
      put(mLow, source(e, g),
        (std::min)(get(mLow, source(e, g)), get(mDist, target(e, g))));
    }


    template <typename Vertex, typename Graph>
    void finish_vertex(const Vertex& u, const Graph& g)
    {
      Vertex parent = get(mPred, u);
      if(get(mLow, u) > get(mDist, parent))
        mBuffer.push(get(mTree, u));
      put(mLow, parent,
        (std::min)(get(mLow, parent), get(mLow, u)));
    }

    cycle_finder(): mBuffer(0) { }

    cycle_finder(Buffer* buffer)
      : mBuffer(buffer) { }

    template <typename Edge, typename Graph>
    void operator()(const Edge& e, const Graph& g)
      {
        if(mBuffer)
          mBuffer->push(e);
      }

    deleted_edge_status() { }

    deleted_edge_status(DeletedMap map): mMap(map) { }

    template <typename Edge>
    bool operator()(const Edge& e) const
      { return (!get(mMap, e)); }

    inL_edge_status() { }

    inL_edge_status(InLMap map): mMap(map) { }

    template <typename Edge>
    bool operator()(const Edge& e) const
      { return get(mMap, e); }



  template <
    typename Graph,
    typename Func,
    typename Seq,
    typename Map
  >
  void rec_two_graphs_common_spanning_trees
    (
      const Graph& iG,
      bimap<
          bimaps::set_of<int>,
          bimaps::set_of< typename graph_traits<Graph>::edge_descriptor >
        > iG_bimap,
      Map aiG_inL,
      Map diG,
      const Graph& vG,
      bimap<
          bimaps::set_of<int>,
          bimaps::set_of< typename graph_traits<Graph>::edge_descriptor >
        > vG_bimap,
      Map avG_inL,
      Map dvG,
      Func func,
      Seq inL
    )
  {
    typedef graph_traits<Graph> GraphTraits;

    typedef typename GraphTraits::vertex_descriptor vertex_descriptor;
    typedef typename GraphTraits::edge_descriptor edge_descriptor;

    typedef typename Seq::size_type seq_size_type;

    int edges = num_vertices(iG) - 1;
//
//  [ Michele Caini ]
//
//  Using the condition (edges != 0) leads to the accidental submission of
//    sub-graphs ((V-1+1)-fake-tree, named here fat-tree).
//  Remove this condition is a workaround for the problem of fat-trees.
//  Please do not add that condition, even if it improves performance.
//
//  Here is proposed the previous guard (that was wrong):
//     for(seq_size_type i = 0; (i < inL.size()) && (edges != 0); ++i)
//
    {
      for(seq_size_type i = 0; i < inL.size(); ++i)
        if(inL[i])
          --edges;

      if(edges < 0)
        return;
    }

    bool is_tree = (edges == 0);
    if(is_tree) {
      func(inL);
    } else {
      std::map<vertex_descriptor, default_color_type> vertex_color;
      std::map<edge_descriptor, default_color_type> edge_color;

      std::stack<edge_descriptor> iG_buf, vG_buf;
      bool found = false;

      seq_size_type m;
      for(seq_size_type j = 0; j < inL.size() && !found; ++j) {
        if(!inL[j]
            && !get(diG, iG_bimap.left.at(j))
            && !get(dvG, vG_bimap.left.at(j)))
        {
          put(aiG_inL, iG_bimap.left.at(j), true);
          put(avG_inL, vG_bimap.left.at(j), true);

          undirected_dfs(
              make_filtered_graph(iG,
                detail::inL_edge_status< associative_property_map<
                  std::map<edge_descriptor, bool> > >(aiG_inL)),
              make_dfs_visitor(
                detail::cycle_finder< std::stack<edge_descriptor> > (&iG_buf)),
              associative_property_map<
                std::map<vertex_descriptor, default_color_type> >(vertex_color),
              associative_property_map<
                std::map<edge_descriptor, default_color_type> >(edge_color)
            );
          undirected_dfs(
              make_filtered_graph(vG,
                detail::inL_edge_status< associative_property_map<
                  std::map<edge_descriptor, bool> > >(avG_inL)),
              make_dfs_visitor(
                detail::cycle_finder< std::stack<edge_descriptor> > (&vG_buf)),
              associative_property_map<
                std::map<vertex_descriptor, default_color_type> >(vertex_color),
              associative_property_map<
                std::map<edge_descriptor, default_color_type> >(edge_color)
            );

          if(iG_buf.empty() && vG_buf.empty()) {
            inL[j] = true;
            found = true;
            m = j;
          } else {
            while(!iG_buf.empty()) iG_buf.pop();
            while(!vG_buf.empty()) vG_buf.pop();
            put(aiG_inL, iG_bimap.left.at(j), false);
            put(avG_inL, vG_bimap.left.at(j), false);
          }
        }
      }

      if(found) {

        std::stack<edge_descriptor> iG_buf_copy, vG_buf_copy;
        for(seq_size_type j = 0; j < inL.size(); ++j) {
          if(!inL[j]
              && !get(diG, iG_bimap.left.at(j))
              && !get(dvG, vG_bimap.left.at(j)))
          {

            put(aiG_inL, iG_bimap.left.at(j), true);
            put(avG_inL, vG_bimap.left.at(j), true);

            undirected_dfs(
                make_filtered_graph(iG,
                  detail::inL_edge_status< associative_property_map<
                    std::map<edge_descriptor, bool> > >(aiG_inL)),
                make_dfs_visitor(
                  detail::cycle_finder<
                    std::stack<edge_descriptor> > (&iG_buf)),
               associative_property_map< std::map<
                  vertex_descriptor, default_color_type> >(vertex_color),
                associative_property_map<
                  std::map<edge_descriptor, default_color_type> >(edge_color)
              );
            undirected_dfs(
                make_filtered_graph(vG,
                  detail::inL_edge_status< associative_property_map<
                    std::map<edge_descriptor, bool> > >(avG_inL)),
                make_dfs_visitor(
                  detail::cycle_finder<
                    std::stack<edge_descriptor> > (&vG_buf)),
                associative_property_map< std::map<
                  vertex_descriptor, default_color_type> >(vertex_color),
                associative_property_map<
                  std::map<edge_descriptor, default_color_type> >(edge_color)
              );

            if(!iG_buf.empty() || !vG_buf.empty()) {
              while(!iG_buf.empty()) iG_buf.pop();
              while(!vG_buf.empty()) vG_buf.pop();
              put(diG, iG_bimap.left.at(j), true);
              put(dvG, vG_bimap.left.at(j), true);
              iG_buf_copy.push(iG_bimap.left.at(j));
              vG_buf_copy.push(vG_bimap.left.at(j));
            }

            put(aiG_inL, iG_bimap.left.at(j), false);
            put(avG_inL, vG_bimap.left.at(j), false);
          }
        }

        // REC
        detail::rec_two_graphs_common_spanning_trees<Graph, Func, Seq, Map>
          (iG, iG_bimap, aiG_inL, diG, vG, vG_bimap, aiG_inL, dvG, func, inL);

        while(!iG_buf_copy.empty()) {
          put(diG, iG_buf_copy.top(), false);
          put(dvG, vG_bimap.left.at(
            iG_bimap.right.at(iG_buf_copy.top())), false);
          iG_buf_copy.pop();
        }
        while(!vG_buf_copy.empty()) {
          put(dvG, vG_buf_copy.top(), false);
          put(diG, iG_bimap.left.at(
            vG_bimap.right.at(vG_buf_copy.top())), false);
          vG_buf_copy.pop();
        }

        inL[m] = false;
        put(aiG_inL, iG_bimap.left.at(m), false);
        put(avG_inL, vG_bimap.left.at(m), false);

        put(diG, iG_bimap.left.at(m), true);
        put(dvG, vG_bimap.left.at(m), true);

        std::map<vertex_descriptor, edge_descriptor> tree_map;
        std::map<vertex_descriptor, vertex_descriptor> pred_map;
        std::map<vertex_descriptor, int> dist_map, low_map;

        detail::bridges_visitor<
            associative_property_map<
                std::map<vertex_descriptor, edge_descriptor>
              >,
            associative_property_map<
                std::map<vertex_descriptor, vertex_descriptor>
              >,
            associative_property_map< std::map<vertex_descriptor, int> >,
            associative_property_map< std::map<vertex_descriptor, int> >,
            std::stack<edge_descriptor>
          >
        iG_vis(
            associative_property_map<
              std::map< vertex_descriptor, edge_descriptor> >(tree_map),
            associative_property_map<
              std::map< vertex_descriptor, vertex_descriptor> >(pred_map),
            associative_property_map<
              std::map< vertex_descriptor, int> >(dist_map),
            associative_property_map<
              std::map< vertex_descriptor, int> >(low_map),
            iG_buf
          ),
        vG_vis(
            associative_property_map<
              std::map< vertex_descriptor, edge_descriptor> >(tree_map),
            associative_property_map<
              std::map< vertex_descriptor, vertex_descriptor> >(pred_map),
            associative_property_map<
              std::map< vertex_descriptor, int> >(dist_map),
            associative_property_map<
              std::map< vertex_descriptor, int> >(low_map),
            vG_buf
          );

        undirected_dfs(make_filtered_graph(iG,
              detail::deleted_edge_status< associative_property_map<
              std::map<edge_descriptor, bool> > >(diG)),
            iG_vis,
            associative_property_map<
              std::map<vertex_descriptor, default_color_type> >(vertex_color),
            associative_property_map<
              std::map<edge_descriptor, default_color_type> >(edge_color)
          );
        undirected_dfs(make_filtered_graph(vG,
              detail::deleted_edge_status< associative_property_map<
              std::map<edge_descriptor, bool> > >(dvG)),
            vG_vis,
            associative_property_map<
              std::map<vertex_descriptor, default_color_type> >(vertex_color),
            associative_property_map<
              std::map<edge_descriptor, default_color_type> >(edge_color)
          );

        found = false;
        std::stack<edge_descriptor> iG_buf_tmp, vG_buf_tmp;
        while(!iG_buf.empty() && !found) {
          if(!inL[iG_bimap.right.at(iG_buf.top())]) {
            put(aiG_inL, iG_buf.top(), true);
            put(avG_inL, vG_bimap.left.at(
              iG_bimap.right.at(iG_buf.top())), true);

            undirected_dfs(
                make_filtered_graph(iG,
                  detail::inL_edge_status< associative_property_map<
                    std::map<edge_descriptor, bool> > >(aiG_inL)),
                make_dfs_visitor(
                  detail::cycle_finder<
                    std::stack<edge_descriptor> > (&iG_buf_tmp)),
                associative_property_map<
                  std::map<
                    vertex_descriptor, default_color_type> >(vertex_color),
                associative_property_map<
                  std::map<edge_descriptor, default_color_type> >(edge_color)
              );
            undirected_dfs(
                make_filtered_graph(vG,
                  detail::inL_edge_status< associative_property_map<
                    std::map<edge_descriptor, bool> > >(avG_inL)),
                make_dfs_visitor(
                  detail::cycle_finder<
                    std::stack<edge_descriptor> > (&vG_buf_tmp)),
                associative_property_map<
                  std::map<
                    vertex_descriptor, default_color_type> >(vertex_color),
                associative_property_map<
                  std::map<edge_descriptor, default_color_type> >(edge_color)
              );

            if(!iG_buf_tmp.empty() || !vG_buf_tmp.empty()) {
              found = true;
            } else {
              while(!iG_buf_tmp.empty()) iG_buf_tmp.pop();
              while(!vG_buf_tmp.empty()) vG_buf_tmp.pop();
              iG_buf_copy.push(iG_buf.top());
            }

            put(aiG_inL, iG_buf.top(), false);
            put(avG_inL, vG_bimap.left.at(
              iG_bimap.right.at(iG_buf.top())), false);
          }
          iG_buf.pop();
        }
        while(!vG_buf.empty() && !found) {
          if(!inL[vG_bimap.right.at(vG_buf.top())]) {
            put(avG_inL, vG_buf.top(), true);
            put(aiG_inL, iG_bimap.left.at(
              vG_bimap.right.at(vG_buf.top())), true);

            undirected_dfs(
                make_filtered_graph(iG,
                  detail::inL_edge_status< associative_property_map<
                    std::map<edge_descriptor, bool> > >(aiG_inL)),
                make_dfs_visitor(
                  detail::cycle_finder<
                    std::stack<edge_descriptor> > (&iG_buf_tmp)),
                associative_property_map<
                  std::map<
                    vertex_descriptor, default_color_type> >(vertex_color),
                associative_property_map<
                  std::map<edge_descriptor, default_color_type> >(edge_color)
              );
            undirected_dfs(
                make_filtered_graph(vG,
                  detail::inL_edge_status< associative_property_map<
                    std::map<edge_descriptor, bool> > >(avG_inL)),
                make_dfs_visitor(
                  detail::cycle_finder<
                    std::stack<edge_descriptor> > (&vG_buf_tmp)),
                associative_property_map<
                  std::map<
                    vertex_descriptor, default_color_type> >(vertex_color),
                associative_property_map<
                  std::map<edge_descriptor, default_color_type> >(edge_color)
              );

            if(!iG_buf_tmp.empty() || !vG_buf_tmp.empty()) {
              found = true;
            } else {
              while(!iG_buf_tmp.empty()) iG_buf_tmp.pop();
              while(!vG_buf_tmp.empty()) vG_buf_tmp.pop();
              vG_buf_copy.push(vG_buf.top());
            }

            put(avG_inL, vG_buf.top(), false);
            put(aiG_inL, iG_bimap.left.at(
              vG_bimap.right.at(vG_buf.top())), false);
          }
          vG_buf.pop();
        }

        if(!found) {

          while(!iG_buf_copy.empty()) {
            inL[iG_bimap.right.at(iG_buf_copy.top())] = true;
            put(aiG_inL, iG_buf_copy.top(), true);
            put(avG_inL, vG_bimap.left.at(
              iG_bimap.right.at(iG_buf_copy.top())), true);
            iG_buf.push(iG_buf_copy.top());
            iG_buf_copy.pop();
          }
          while(!vG_buf_copy.empty()) {
            inL[vG_bimap.right.at(vG_buf_copy.top())] = true;
            put(avG_inL, vG_buf_copy.top(), true);
            put(aiG_inL, iG_bimap.left.at(
              vG_bimap.right.at(vG_buf_copy.top())), true);
            vG_buf.push(vG_buf_copy.top());
            vG_buf_copy.pop();
          }

          // REC
          detail::rec_two_graphs_common_spanning_trees<
              Graph, Func, Seq, Map>
            (iG, iG_bimap, aiG_inL, diG, vG, vG_bimap, aiG_inL, dvG, func, inL);

          while(!iG_buf.empty()) {
            inL[iG_bimap.right.at(iG_buf.top())] = false;
            put(aiG_inL, iG_buf.top(), false);
            put(avG_inL, vG_bimap.left.at(
              iG_bimap.right.at(iG_buf.top())), false);
            iG_buf.pop();
          }
          while(!vG_buf.empty()) {
            inL[vG_bimap.right.at(vG_buf.top())] = false;
            put(avG_inL, vG_buf.top(), false);
            put(aiG_inL, iG_bimap.left.at(
              vG_bimap.right.at(vG_buf.top())), false);
            vG_buf.pop();
          }

        }

        put(diG, iG_bimap.left.at(m), false);
        put(dvG, vG_bimap.left.at(m), false);

      }
    }
  }


  tree_collector(Coll& seqs): mSeqs(seqs) { }


  inline void operator()(Seq seq)
    { mSeqs.push_back(seq); }




template <
  typename Graph,
  typename Order,
  typename Func,
  typename Seq
>
BOOST_CONCEPT_REQUIRES(
  ((RandomAccessContainer<Order>))
  ((IncidenceGraphConcept<Graph>))
  ((UnaryFunction<Func, void, Seq>))
  ((Mutable_RandomAccessContainer<Seq>))
  ((VertexAndEdgeListGraphConcept<Graph>)),
  (void)
)
two_graphs_common_spanning_trees
  (
    const Graph& iG,
    Order iG_map,
    const Graph& vG,
    Order vG_map,
    Func func,
    Seq inL
  )
{
  typedef graph_traits<Graph> GraphTraits;

  typedef typename GraphTraits::directed_category directed_category;
  typedef typename GraphTraits::vertex_descriptor vertex_descriptor;
  typedef typename GraphTraits::edge_descriptor edge_descriptor;

  typedef typename GraphTraits::edges_size_type edges_size_type;
  typedef typename GraphTraits::edge_iterator edge_iterator;

  typedef typename Seq::const_iterator seq_const_iterator;
  typedef typename Seq::difference_type seq_diff_type;
  typedef typename Seq::value_type seq_value_type;
  typedef typename Seq::size_type seq_size_type;
  typedef typename Seq::iterator seq_iterator;

  typedef typename Order::const_iterator order_const_iterator;
  typedef typename Order::difference_type order_diff_type;
  typedef typename Order::value_type order_value_type;
  typedef typename Order::size_type order_size_type;
  typedef typename Order::iterator order_iterator;

  BOOST_STATIC_ASSERT((is_same<order_value_type, edge_descriptor>::value));
  BOOST_CONCEPT_ASSERT((Convertible<order_size_type, edges_size_type>));

  BOOST_CONCEPT_ASSERT((Convertible<seq_size_type, edges_size_type>));
  BOOST_STATIC_ASSERT((is_same<seq_value_type, bool>::value));

  BOOST_STATIC_ASSERT((is_same<directed_category, undirected_tag>::value));

  if(num_vertices(iG) != num_vertices(vG))
    return;

  if(inL.size() != num_edges(iG)
      || inL.size() != num_edges(vG))
    return;

  if(iG_map.size() != num_edges(iG)
      || vG_map.size() != num_edges(vG))
    return;

  typedef bimaps::bimap<
      bimaps::set_of< int >,
      bimaps::set_of< order_value_type >
    > bimap_type;
  typedef typename bimap_type::value_type bimap_value;

  bimap_type iG_bimap, vG_bimap;
  for(order_size_type i = 0; i < iG_map.size(); ++i)
    iG_bimap.insert(bimap_value(i, iG_map[i]));
  for(order_size_type i = 0; i < vG_map.size(); ++i)
    vG_bimap.insert(bimap_value(i, vG_map[i]));

  edge_iterator current, last;
  boost::tuples::tie(current, last) = edges(iG);
  for(; current != last; ++current)
    if(iG_bimap.right.find(*current) == iG_bimap.right.end())
      return;
  boost::tuples::tie(current, last) = edges(vG);
  for(; current != last; ++current)
    if(vG_bimap.right.find(*current) == vG_bimap.right.end())
      return;

  std::stack<edge_descriptor> iG_buf, vG_buf;

  std::map<vertex_descriptor, edge_descriptor> tree_map;
  std::map<vertex_descriptor, vertex_descriptor> pred_map;
  std::map<vertex_descriptor, int> dist_map, low_map;

  detail::bridges_visitor<
      associative_property_map<
          std::map<vertex_descriptor, edge_descriptor>
        >,
      associative_property_map<
          std::map<vertex_descriptor, vertex_descriptor>
        >,
      associative_property_map< std::map<vertex_descriptor, int> >,
      associative_property_map< std::map<vertex_descriptor, int> >,
      std::stack<edge_descriptor>
    >
  iG_vis(
      associative_property_map<
        std::map< vertex_descriptor, edge_descriptor> >(tree_map),
      associative_property_map<
        std::map< vertex_descriptor, vertex_descriptor> >(pred_map),
      associative_property_map<std::map< vertex_descriptor, int> >(dist_map),
      associative_property_map<std::map< vertex_descriptor, int> >(low_map),
      iG_buf
    ),
  vG_vis(
      associative_property_map<
        std::map< vertex_descriptor, edge_descriptor> >(tree_map),
      associative_property_map<
        std::map< vertex_descriptor, vertex_descriptor> >(pred_map),
      associative_property_map<std::map< vertex_descriptor, int> >(dist_map),
      associative_property_map<std::map< vertex_descriptor, int> >(low_map),
      vG_buf
    );

  std::map<vertex_descriptor, default_color_type> vertex_color;
  std::map<edge_descriptor, default_color_type> edge_color;

  undirected_dfs(iG, iG_vis,
      associative_property_map<
        std::map<vertex_descriptor, default_color_type> >(vertex_color),
      associative_property_map<
        std::map<edge_descriptor, default_color_type> >(edge_color)
    );
  undirected_dfs(vG, vG_vis,
      associative_property_map<
        std::map<vertex_descriptor, default_color_type> >(vertex_color),
      associative_property_map<
        std::map<edge_descriptor, default_color_type> >(edge_color)
    );

  while(!iG_buf.empty()) {
    inL[iG_bimap.right.at(iG_buf.top())] = true;
    iG_buf.pop();
  }
  while(!vG_buf.empty()) {
    inL[vG_bimap.right.at(vG_buf.top())] = true;
    vG_buf.pop();
  }

  std::map<edge_descriptor, bool> iG_inL, vG_inL;
  associative_property_map< std::map<edge_descriptor, bool> >
    aiG_inL(iG_inL), avG_inL(vG_inL);

  for(seq_size_type i = 0; i < inL.size(); ++i)
  {
    if(inL[i]) {
      put(aiG_inL, iG_bimap.left.at(i), true);
      put(avG_inL, vG_bimap.left.at(i), true);
    } else {
      put(aiG_inL, iG_bimap.left.at(i), false);
      put(avG_inL, vG_bimap.left.at(i), false);
    }
  }

  undirected_dfs(
      make_filtered_graph(iG,
        detail::inL_edge_status< associative_property_map<
          std::map<edge_descriptor, bool> > >(aiG_inL)),
      make_dfs_visitor(
        detail::cycle_finder< std::stack<edge_descriptor> > (&iG_buf)),
      associative_property_map<
        std::map<vertex_descriptor, default_color_type> >(vertex_color),
      associative_property_map<
        std::map<edge_descriptor, default_color_type> >(edge_color)
    );
  undirected_dfs(
      make_filtered_graph(vG,
        detail::inL_edge_status< associative_property_map<
          std::map<edge_descriptor, bool> > >(avG_inL)),
      make_dfs_visitor(
        detail::cycle_finder< std::stack<edge_descriptor> > (&vG_buf)),
      associative_property_map<
        std::map<vertex_descriptor, default_color_type> >(vertex_color),
      associative_property_map<
        std::map<edge_descriptor, default_color_type> >(edge_color)
    );

  if(iG_buf.empty() && vG_buf.empty()) {

    std::map<edge_descriptor, bool> iG_deleted, vG_deleted;
    associative_property_map< std::map<edge_descriptor, bool> > diG(iG_deleted);
    associative_property_map< std::map<edge_descriptor, bool> > dvG(vG_deleted);

    boost::tuples::tie(current, last) = edges(iG);
    for(; current != last; ++current)
      put(diG, *current, false);
    boost::tuples::tie(current, last) = edges(vG);
    for(; current != last; ++current)
      put(dvG, *current, false);

    for(seq_size_type j = 0; j < inL.size(); ++j) {
      if(!inL[j]) {
        put(aiG_inL, iG_bimap.left.at(j), true);
        put(avG_inL, vG_bimap.left.at(j), true);

        undirected_dfs(
            make_filtered_graph(iG,
              detail::inL_edge_status< associative_property_map<
                std::map<edge_descriptor, bool> > >(aiG_inL)),
            make_dfs_visitor(
              detail::cycle_finder< std::stack<edge_descriptor> > (&iG_buf)),
            associative_property_map<
              std::map<vertex_descriptor, default_color_type> >(vertex_color),
            associative_property_map<
              std::map<edge_descriptor, default_color_type> >(edge_color)
          );
        undirected_dfs(
            make_filtered_graph(vG,
              detail::inL_edge_status< associative_property_map<
                std::map<edge_descriptor, bool> > >(avG_inL)),
            make_dfs_visitor(
              detail::cycle_finder< std::stack<edge_descriptor> > (&vG_buf)),
            associative_property_map<
              std::map<vertex_descriptor, default_color_type> >(vertex_color),
            associative_property_map<
              std::map<edge_descriptor, default_color_type> >(edge_color)
          );

        if(!iG_buf.empty() || !vG_buf.empty()) {
          while(!iG_buf.empty()) iG_buf.pop();
          while(!vG_buf.empty()) vG_buf.pop();
          put(diG, iG_bimap.left.at(j), true);
          put(dvG, vG_bimap.left.at(j), true);
        }

        put(aiG_inL, iG_bimap.left.at(j), false);
        put(avG_inL, vG_bimap.left.at(j), false);
      }
    }

    int cc = 0;

    std::map<vertex_descriptor, int> com_map;
    cc += connected_components(
        make_filtered_graph(iG,
          detail::deleted_edge_status<associative_property_map<
            std::map<edge_descriptor, bool> > >(diG)),
        associative_property_map<std::map<vertex_descriptor, int> >(com_map)
      );
    cc += connected_components(
        make_filtered_graph(vG,
          detail::deleted_edge_status<associative_property_map<
            std::map<edge_descriptor, bool> > >(dvG)),
        associative_property_map< std::map<vertex_descriptor, int> >(com_map)
      );

    if(cc != 2)
      return;

    // REC
    detail::rec_two_graphs_common_spanning_trees<Graph, Func, Seq,
        associative_property_map< std::map<edge_descriptor, bool> > >
      (iG, iG_bimap, aiG_inL, diG, vG, vG_bimap, aiG_inL, dvG, func, inL);

  }

}



template <
  typename Graph,
  typename Func,
  typename Seq
>
BOOST_CONCEPT_REQUIRES(
  ((IncidenceGraphConcept<Graph>))
  ((EdgeListGraphConcept<Graph>)),
  (void)
)
two_graphs_common_spanning_trees
  (
    const Graph& iG,
    const Graph& vG,
    Func func,
    Seq inL
  )
{
  typedef graph_traits<Graph> GraphTraits;

  typedef typename GraphTraits::edge_descriptor edge_descriptor;
  typedef typename GraphTraits::edges_size_type edges_size_type;
  typedef typename GraphTraits::edge_iterator edge_iterator;

  std::vector<edge_descriptor> iGO, vGO;
  edge_iterator curr, last;

  boost::tuples::tie(curr, last) = edges(iG);
  for(; curr != last; ++curr)
    iGO.push_back(*curr);

  boost::tuples::tie(curr, last) = edges(vG);
  for(; curr != last; ++curr)
    vGO.push_back(*curr);

  two_graphs_common_spanning_trees(iG, iGO, vG, vGO, func, inL);
}


template <class Graph, class CapacityMap, class ReverseEdgeMap>
int read_dimacs_max_flow_internal(Graph& g,
                                  CapacityMap capacity,
                                  ReverseEdgeMap reverse_edge,
                                  typename graph_traits<Graph>::vertex_descriptor& src,
                                  typename graph_traits<Graph>::vertex_descriptor& sink,
                                  std::istream& in,
                                  bool require_source_and_sink,
                                  const std::string& problem_type)
{
  //  const int MAXLINE = 100;      /* max line length in the input file */
  const int ARC_FIELDS = 3;     /* no of fields in arc line  */
  const int NODE_FIELDS = 2;    /* no of fields in node line  */
  const int P_FIELDS = 3;       /* no of fields in problem line */

  typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;

  std::vector<vertex_descriptor> verts;

  long m, n,                    /*  number of edges and nodes */
    i, head, tail, cap;

  long no_lines=0,              /* no of current input line */
    no_plines=0,                /* no of problem-lines */
    no_nslines=0,               /* no of node-source-lines */
    no_nklines=0,               /* no of node-source-lines */
    no_alines=0;                /* no of arc-lines */

  std::string in_line;          /* for reading input line */
  char pr_type[4];              /* for reading type of the problem */
  char nd;                      /* source (s) or sink (t) */

  int k,                        /* temporary */
    err_no;                     /* no of detected error */

  /* -------------- error numbers & error messages ---------------- */
  const int EN1   = 0;
  const int EN2   = 1;
  const int EN3   = 2;
  const int EN4   = 3;
  //  const int EN6   = 4;
  //  const int EN10  = 5;
  //  const int EN7   = 6;
  const int EN8   = 7;
  const int EN9   = 8;
  const int EN11  = 9;
  const int EN12 = 10;
  //  const int EN13 = 11;
  const int EN14 = 12;
  const int EN16 = 13;
  const int EN15 = 14;
  const int EN17 = 15;
  const int EN18 = 16;
  const int EN21 = 17;
  const int EN19 = 18;
  const int EN20 = 19;
  const int EN22 = 20;

  static const char *err_message[] =
  {
    /* 0*/    "more than one problem line.",
    /* 1*/    "wrong number of parameters in the problem line.",
    /* 2*/    "it is not a Max Flow problem line.",
    /* 3*/    "bad value of a parameter in the problem line.",
    /* 4*/    "can't obtain enough memory to solve this problem.",
    /* 5*/    "more than one line with the problem name.",
    /* 6*/    "can't read problem name.",
    /* 7*/    "problem description must be before node description.",
    /* 8*/    "this parser doesn't support multiply sources and sinks.",
    /* 9*/    "wrong number of parameters in the node line.",
    /*10*/    "wrong value of parameters in the node line.",
    /*11*/    " ",
    /*12*/    "source and sink descriptions must be before arc descriptions.",
    /*13*/    "too many arcs in the input.",
    /*14*/    "wrong number of parameters in the arc line.",
    /*15*/    "wrong value of parameters in the arc line.",
    /*16*/    "unknown line type in the input.",
    /*17*/    "reading error.",
    /*18*/    "not enough arcs in the input.",
    /*19*/    "source or sink doesn't have incident arcs.",
    /*20*/    "can't read anything from the input file."
  };
  /* --------------------------------------------------------------- */

  /* The main loop:
     -  reads the line of the input,
     -  analyses its type,
     -  checks correctness of parameters,
     -  puts data to the arrays,
     -  does service functions
  */

  while (std::getline(in, in_line)) {
    ++no_lines;

    switch (in_line[0]) {
    case 'c':                  /* skip lines with comments */
    case '\n':                 /* skip empty lines   */
    case '\0':                 /* skip empty lines at the end of file */
      break;

    case 'p':                  /* problem description      */
      if ( no_plines > 0 )
        /* more than one problem line */
        { err_no = EN1 ; goto error; }

      no_plines = 1;

      if (
          /* reading problem line: type of problem, no of nodes, no of arcs */
          std::sscanf ( in_line.c_str(), "%*c %3s %ld %ld", pr_type, &n, &m )
          != P_FIELDS
          )
        /*wrong number of parameters in the problem line*/
        { err_no = EN2; goto error; }

      if ( pr_type != problem_type )
        /*wrong problem type*/
        { err_no = EN3; goto error; }

      if ( n <= 0  || m <= 0 )
        /*wrong value of no of arcs or nodes*/
        { err_no = EN4; goto error; }

      {
        for (long vi = 0; vi < n; ++vi)
          verts.push_back(add_vertex(g));
      }
      break;

    case 'n':                    /* source(s) description */
      if ( no_plines == 0 )
        /* there was not problem line above */
        { err_no = EN8; goto error; }

      /* reading source  or sink */
      k = std::sscanf ( in_line.c_str(),"%*c %ld %c", &i, &nd );
      --i; // index from 0
      if ( k < NODE_FIELDS )
        /* node line is incorrect */
        { err_no = EN11; goto error; }

      if ( i < 0 || i > n )
        /* wrong value of node */
        { err_no = EN12; goto error; }

      switch (nd) {
      case 's':  /* source line */

        if ( no_nslines != 0)
          /* more than one source line */
          { err_no = EN9; goto error; }

        no_nslines = 1;
        src = verts[i];
        break;

      case 't':  /* sink line */

        if ( no_nklines != 0)
          /* more than one sink line */
          { err_no = EN9; goto error; }

        no_nklines = 1;
        sink = verts[i];
        break;

      default:
        /* wrong type of node-line */
        err_no = EN12; goto error;
      }
      break;

    case 'a':                    /* arc description */
      if ( require_source_and_sink && (no_nslines == 0 || no_nklines == 0) )
        /* there was not source and sink description above */
        { err_no = EN14; goto error; }

      if ( no_alines >= m )
        /*too many arcs on input*/
        { err_no = EN16; goto error; }

      if (
          /* reading an arc description */
          std::sscanf ( in_line.c_str(),"%*c %ld %ld %ld",
                        &tail, &head, &cap )
          != ARC_FIELDS
          )
        /* arc description is not correct */
        { err_no = EN15; goto error; }

      --tail; // index from 0, not 1
      --head;
      if ( tail < 0  ||  tail > n  ||
           head < 0  ||  head > n
           )
        /* wrong value of nodes */
        { err_no = EN17; goto error; }

      {
        edge_descriptor e1, e2;
        bool in1, in2;
        boost::tie(e1, in1) = add_edge(verts[tail], verts[head], g);
        boost::tie(e2, in2) = add_edge(verts[head], verts[tail], g);
        if (!in1 || !in2) {
          std::cerr << "unable to add edge (" << head << "," << tail << ")"
                    << std::endl;
          return -1;
        }
        capacity[e1] = cap;
        capacity[e2] = 0;
        reverse_edge[e1] = e2;
        reverse_edge[e2] = e1;
      }
      ++no_alines;
      break;

    default:
      /* unknown type of line */
      err_no = EN18; goto error;

    } /* end of switch */
  }     /* end of input loop */

  /* ----- all is red  or  error while reading ----- */

  if ( in.eof() == 0 ) /* reading error */
    { err_no=EN21; goto error; }

  if ( no_lines == 0 ) /* empty input */
    { err_no = EN22; goto error; }

  if ( no_alines < m ) /* not enough arcs */
    { err_no = EN19; goto error; }

  if ( require_source_and_sink &&
       (out_degree(src, g) == 0 || out_degree(sink, g) == 0) )
    /* no arc goes out of the source */
    { err_no = EN20; goto error; }

  /* Thanks God! all is done */
  return (0);

  /* ---------------------------------- */
 error:  /* error found reading input */

  std::printf ( "\nline %ld of input - %s\n",
                no_lines, err_message[err_no] );

  return -1;
}


template <class Graph, class CapacityMap, class ReverseEdgeMap>
int read_dimacs_max_flow(Graph& g,
                         CapacityMap capacity,
                         ReverseEdgeMap reverse_edge,
                         typename graph_traits<Graph>::vertex_descriptor& src,
                         typename graph_traits<Graph>::vertex_descriptor& sink,
                         std::istream& in = std::cin) {
  return detail::read_dimacs_max_flow_internal(g, capacity, reverse_edge, src, sink, in, true, "max");
}


template <class Graph, class CapacityMap, class ReverseEdgeMap>
int read_dimacs_min_cut(Graph& g,
                        CapacityMap capacity,
                        ReverseEdgeMap reverse_edge,
                        std::istream& in = std::cin) {
  typename graph_traits<Graph>::vertex_descriptor dummy_src, dummy_sink; // Not filled in
  return detail::read_dimacs_max_flow_internal(g, capacity, reverse_edge, dummy_src, dummy_sink, in, false, "cut");
}

template <typename IntegerType>
inline int int_log2(IntegerType n) {
  int l = 0;
  while (n > 0) {++l; n >>= 1;}
  return l - 1;
}

  template <typename T>
  bool operator()(const T&, const T&) { return true; }


  keep_local_edges(const Distribution& distrib, const ProcessId& id)
    : distrib(distrib), id(id)
  { }


  template <typename T>
  bool operator()(const T& x, const T& y)
  { return distrib(x) == id || distrib(y) == id; }


template <typename RandomGenerator, typename T>
void
generate_permutation_vector(RandomGenerator& gen, std::vector<T>& vertexPermutation, T n)
{
  using boost::uniform_int;

  vertexPermutation.resize(n);

  // Generate permutation map of vertex numbers
  uniform_int<T> rand_vertex(0, n-1);
  for (T i = 0; i < n; ++i)
    vertexPermutation[i] = i;

  // Can't use std::random_shuffle unless we create another (synchronized) PRNG
  for (T i = 0; i < n; ++i)
    std::swap(vertexPermutation[i], vertexPermutation[rand_vertex(gen)]);
}

    bgl_named_params(T v = T()) : m_value(v) { }

    bgl_named_params(T v, const Base& b) : m_value(v), m_base(b) { }
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t), self> \
    name(PType& p) const { \
      typedef bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(boost::ref(p), *this); \
    } \

#define BOOST_BGL_ONE_PARAM_CREF(name, key) \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t), self> \
    name(PType& p) const { \
      typedef bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(boost::ref(p), *this); \
    } \

#define BOOST_BGL_ONE_PARAM_CREF(name, key) \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> \
    name(const PType& p) const { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t), self> Params; \
      return Params(p, *this); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS

    template <typename PType>
    bgl_named_params<PType, vertex_color_t, self>
    vertex_color_map(const PType& p) const {return this->color_map(p);}
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t)> \
    name(PType& p) { \
      typedef bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t)> Params; \
      return Params(boost::ref(p)); \
    } \

#define BOOST_BGL_ONE_PARAM_CREF(name, key) \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS
 \
    template <typename PType> \
    bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t)> \
    name(PType& p) { \
      typedef bgl_named_params<boost::reference_wrapper<PType>, BOOST_PP_CAT(key, _t)> Params; \
      return Params(boost::ref(p)); \
    } \

#define BOOST_BGL_ONE_PARAM_CREF(name, key) \
    template <typename PType> \
    bgl_named_params<PType, BOOST_PP_CAT(key, _t)> \
    name(const PType& p) { \
      typedef bgl_named_params<PType, BOOST_PP_CAT(key, _t)> Params; \
      return Params(p); \
    } \

BOOST_BGL_DECLARE_NAMED_PARAMS

  template <typename PType>
  bgl_named_params<PType, vertex_color_t>
  vertex_color_map(const PType& p) {return color_map(p);}

    static const T& get(const bgl_named_params<T, Tag, Base>& p) {
      return p.m_value;
    }

    static const type& get(const bgl_named_params<T, Tag, Base>& p) {
      return lookup_named_param<Tag1, Base>::get(p.m_base);
    }

    static const Def& get(const Args&, const Def& def) {return def;}

    static const type& get(const bgl_named_params<T, Tag, Base>& p, const Def&) {
      return p.m_value;
    }

    static const type& get(const bgl_named_params<T, Tag, Base>& p, const Def& def) {
      return lookup_named_param_def<Tag1, Base, Def>::get(p.m_base, def);
    }


  template <class Tag, typename Args>
  inline
  const typename lookup_named_param_def<Tag, Args, param_not_found>::type&
  get_param(const Args& p, Tag) {
    return lookup_named_param_def<Tag, Args, param_not_found>::get(p, param_not_found());
  }


  template <class P, class Default> 
  const P& choose_param(const P& param, const Default&) { 
    return param;
  }


  template <class Default>
  Default choose_param(const param_not_found&, const Default& d) {
    return d;
  }


  template <typename T>
  inline bool is_default_param(const T&) { return false; }


  inline bool is_default_param(const param_not_found&)
    { return true; }

      template <typename GraphIsConst, typename Param, typename Graph, typename PropertyTag>
      static Param f(GraphIsConst, const Graph&, const Param& p, PropertyTag) {
        return p;
      }


  template <typename Param, typename Graph, typename PropertyTag>
  typename detail::choose_impl_result<boost::mpl::true_, Graph, Param, PropertyTag>::type
  choose_const_pmap(const Param& p, const Graph& g, PropertyTag tag)
  { 
    return detail::choose_impl_helper<!boost::is_same<Param, param_not_found>::value>
             ::f(boost::mpl::true_(), g, p, tag);
  }


  template <typename Param, typename Graph, typename PropertyTag>
  typename detail::choose_impl_result<boost::mpl::false_, Graph, Param, PropertyTag>::type
  choose_pmap(const Param& p, Graph& g, PropertyTag tag)
  { 
    return detail::choose_impl_helper<!boost::is_same<Param, param_not_found>::value>
             ::f(boost::mpl::false_(), g, p, tag);
  }



















































      static type conv(const T& x) {
        return type(tagged_arg_type(x.m_value), rest_conv::conv(x.m_base));
      }

      static type conv(const bgl_named_params<P, int, R>& x) {
        return rest_conv::conv(x.m_base);
      }

      static type conv(const boost::no_property&) {return type();}

      static type conv(const boost::no_named_parameters&) {return type();}

      result_type operator()(const Graph&, const ArgType& a) const {return a;}

      result_type operator()(const Graph& g, const ArgType&) const {return get(Prop(), g);}


    template <typename ArgPack, typename Tag, typename Prop, typename Graph>
    typename override_const_property_result<ArgPack, Tag, Prop, Graph>::type
    override_const_property(const ArgPack& ap, const boost::parameter::keyword<Tag>& t, const Graph& g, Prop) {
    return override_const_property_t<
             typename boost::parameter::value_type<ArgPack, Tag, int>::type,
             Prop,
             Graph,
             boost::detail::parameter_exists<ArgPack, Tag>::value
           >()(g, ap[t | 0]);
    }

      result_type operator()(const Graph&, const typename boost::add_reference<ArgType>::type a) const {return a;}

      result_type operator()(const Graph& g, const ArgType&) const {return get(Prop(), g);}


    template <typename ArgPack, typename Tag, typename Prop, typename Graph>
    typename override_property_result<ArgPack, Tag, Prop, Graph>::type
    override_property(const ArgPack& ap, const boost::parameter::keyword<Tag>& t, const Graph& g, Prop) {
    return override_property_t<
             typename boost::parameter::value_type<ArgPack, Tag, int>::type,
             Prop,
             Graph,
             boost::detail::parameter_exists<ArgPack, Tag>::value
           >()(g, ap[t | 0]);
    }

      static PM make_map(const Graph&, Value, const PM& pm, const ArgPack&) {
        return pm;
      }

      static map_type make_map(const Graph& g,
                               Value v,
                               const PM&,
                               const ArgPack& ap) {
        return make_shared_array_property_map(
                 num_vertices(g), 
                 v,
                 override_const_property(
                   ap,
                   boost::graph::keywords::_vertex_index_map,
                   g, vertex_index));
      }

      static map_type make_map(const Graph& g, const ArgPack& ap, ValueType default_value) {
        return helper::make_map(g, default_value, ap[::boost::parameter::keyword<MapTag>::instance | 0], ap);
      }

      make_property_map_from_arg_pack_gen(ValueType default_value)
        : default_value(default_value) {}


      template <typename Graph, typename ArgPack>
      typename map_maker<Graph, ArgPack, MapTag, ValueType>::map_type
      operator()(const Graph& g, const ArgPack& ap) const {
        return map_maker<Graph, ArgPack, MapTag, ValueType>::make_map(g, ap, default_value);
      }

      template <typename ValueType, typename Graph, typename ArgPack>
      typename map_maker<Graph, ArgPack, MapTag, ValueType>::map_type
      operator()(const Graph& g, const ArgPack& ap, ValueType default_value) const {
        return map_maker<Graph, ArgPack, MapTag, ValueType>::make_map(g, ap, default_value);
      }


      static priority_queue_type
      make_queue(const Graph&, const ArgPack&, KeyT, const Q& q) {
        return q;
      }


      static priority_queue_type
      make_queue(const Graph& g, const ArgPack& ap, KeyT defaultKey, const Q&) {
        return priority_queue_type(
            map_maker<Graph, ArgPack, KeyMapTag, KeyT>::make_map(g, ap, defaultKey),
            map_maker<Graph, ArgPack, IndexInHeapMapTag, default_index_in_heap_type>::make_map(g, ap, typename boost::property_traits<index_in_heap_map>::value_type(-1))
          );
      }


      static priority_queue_type make_queue(const Graph& g, const ArgPack& ap, KeyT defaultKey) {
        return helper::make_queue(g, ap, defaultKey, ap[::boost::parameter::keyword<PriorityQueueTag>::instance | 0]);
      }


    template <typename G>
    typename boost::graph_traits<G>::vertex_descriptor
    get_null_vertex(const G&) {return boost::graph_traits<G>::null_vertex();}


    template <typename G>
    typename boost::graph_traits<G>::vertex_descriptor
    get_default_starting_vertex(const G& g) {
      std::pair<typename boost::graph_traits<G>::vertex_iterator, typename boost::graph_traits<G>::vertex_iterator> iters = vertices(g);
      return (iters.first == iters.second) ? boost::graph_traits<G>::null_vertex() : *iters.first;
    }

      get_default_starting_vertex_t(const G& g): g(g) {}

      result_type operator()() const {return get_default_starting_vertex(g);}

      T operator()() const {
        return (std::numeric_limits<T>::max)();
      }

    point() { }

    double& operator[](std::size_t i) {return values[i];}

    point_difference() {
      for (std::size_t i = 0; i < Dims; ++i) values[i] = 0.;
    }

    double& operator[](std::size_t i) {return values[i];}


  double distance(point a, point b) const 
  {
    double dist = 0.;
    for (std::size_t i = 0; i < Dims; ++i) {
      double diff = b[i] - a[i];
      dist = boost::math::hypot(dist, diff);
    }
    // Exact properties of the distance are not important, as long as
    // < on what this returns matches real distances; l_2 is used because
    // Fruchterman-Reingold also uses this code and it relies on l_2.
    return dist;
  }


  point move_position_toward(point a, double fraction, point b) const 
  {
    point result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = a[i] + (b[i] - a[i]) * fraction;
    return result;
  }


  point_difference difference(point a, point b) const {
    point_difference result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = a[i] - b[i];
    return result;
  }


  point adjust(point a, point_difference delta) const {
    point result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = a[i] + delta[i];
    return result;
  }


  point pointwise_min(point a, point b) const {
    BOOST_USING_STD_MIN();
    point result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = min BOOST_PREVENT_MACRO_SUBSTITUTION (a[i], b[i]);
    return result;
  }


  point pointwise_max(point a, point b) const {
    BOOST_USING_STD_MAX();
    point result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = max BOOST_PREVENT_MACRO_SUBSTITUTION (a[i], b[i]);
    return result;
  }


  double norm(point_difference delta) const {
    double n = 0.;
    for (std::size_t i = 0; i < Dims; ++i)
      n = boost::math::hypot(n, delta[i]);
    return n;
  }


  double volume(point_difference delta) const {
    double n = 1.;
    for (std::size_t i = 0; i < Dims; ++i)
      n *= delta[i];
    return n;
  }


  explicit hypercube_topology(double scaling = 1.0) 
    : gen_ptr(new RandomNumberGenerator), rand(new rand_t(*gen_ptr)), 
      scaling(scaling) 
  { }


  hypercube_topology(RandomNumberGenerator& gen, double scaling = 1.0) 
    : gen_ptr(), rand(new rand_t(gen)), scaling(scaling) { }

                     
  point_type random_point() const 
  {
    point_type p;
    for (std::size_t i = 0; i < Dims; ++i)
      p[i] = (*rand)() * scaling;
    return p;
  }


  point_type bound(point_type a) const
  {
    BOOST_USING_STD_MIN();
    BOOST_USING_STD_MAX();
    point_type p;
    for (std::size_t i = 0; i < Dims; ++i)
      p[i] = min BOOST_PREVENT_MACRO_SUBSTITUTION (scaling, max BOOST_PREVENT_MACRO_SUBSTITUTION (-scaling, a[i]));
    return p;
  }


  double distance_from_boundary(point_type a) const
  {
    BOOST_USING_STD_MIN();
    BOOST_USING_STD_MAX();
#ifndef BOOST_NO_STDC_NAMESPACE
    using std::abs;
#endif
    BOOST_STATIC_ASSERT (Dims >= 1);
    double dist = abs(scaling - a[0]);
    for (std::size_t i = 1; i < Dims; ++i)
      dist = min BOOST_PREVENT_MACRO_SUBSTITUTION (dist, abs(scaling - a[i]));
    return dist;
  }


  point_type center() const {
    point_type result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = scaling * .5;
    return result;
  }


  point_type origin() const {
    point_type result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = 0;
    return result;
  }


  point_difference_type extent() const {
    point_difference_type result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = scaling;
    return result;
  }

  explicit square_topology(double scaling = 1.0) : inherited(scaling) { }

  
  square_topology(RandomNumberGenerator& gen, double scaling = 1.0) 
    : inherited(gen, scaling) { }

  rectangle_topology(double left, double top, double right, double bottom)
    : gen_ptr(new RandomNumberGenerator), rand(new rand_t(*gen_ptr)),
      left(std::min BOOST_PREVENT_MACRO_SUBSTITUTION (left, right)),
      top(std::min BOOST_PREVENT_MACRO_SUBSTITUTION (top, bottom)),
      right(std::max BOOST_PREVENT_MACRO_SUBSTITUTION (left, right)),
      bottom(std::max BOOST_PREVENT_MACRO_SUBSTITUTION (top, bottom)) { }


  rectangle_topology(RandomNumberGenerator& gen, double left, double top, double right, double bottom)
    : gen_ptr(), rand(new rand_t(gen)),
      left(std::min BOOST_PREVENT_MACRO_SUBSTITUTION (left, right)),
      top(std::min BOOST_PREVENT_MACRO_SUBSTITUTION (top, bottom)),
      right(std::max BOOST_PREVENT_MACRO_SUBSTITUTION (left, right)),
      bottom(std::max BOOST_PREVENT_MACRO_SUBSTITUTION (top, bottom)) { }


  point_type random_point() const 
  {
    point_type p;
    p[0] = (*rand)() * (right - left) + left;
    p[1] = (*rand)() * (bottom - top) + top;
    return p;
  }


  point_type bound(point_type a) const
  {
    BOOST_USING_STD_MIN();
    BOOST_USING_STD_MAX();
    point_type p;
    p[0] = min BOOST_PREVENT_MACRO_SUBSTITUTION (right, max BOOST_PREVENT_MACRO_SUBSTITUTION (left, a[0]));
    p[1] = min BOOST_PREVENT_MACRO_SUBSTITUTION (bottom, max BOOST_PREVENT_MACRO_SUBSTITUTION (top, a[1]));
    return p;
  }


  double distance_from_boundary(point_type a) const
  {
    BOOST_USING_STD_MIN();
    BOOST_USING_STD_MAX();
#ifndef BOOST_NO_STDC_NAMESPACE
    using std::abs;
#endif
    double dist = abs(left - a[0]);
    dist = min BOOST_PREVENT_MACRO_SUBSTITUTION (dist, abs(right - a[0]));
    dist = min BOOST_PREVENT_MACRO_SUBSTITUTION (dist, abs(top - a[1]));
    dist = min BOOST_PREVENT_MACRO_SUBSTITUTION (dist, abs(bottom - a[1]));
    return dist;
  }


  point_type center() const {
    point_type result;
    result[0] = (left + right) / 2.;
    result[1] = (top + bottom) / 2.;
    return result;
  }


  point_type origin() const {
    point_type result;
    result[0] = left;
    result[1] = top;
    return result;
  }


  point_difference_type extent() const {
    point_difference_type result;
    result[0] = right - left;
    result[1] = bottom - top;
    return result;
  }

  explicit cube_topology(double scaling = 1.0) : inherited(scaling) { }

  
  cube_topology(RandomNumberGenerator& gen, double scaling = 1.0) 
    : inherited(gen, scaling) { }


  explicit ball_topology(double radius = 1.0) 
    : gen_ptr(new RandomNumberGenerator), rand(new rand_t(*gen_ptr)), 
      radius(radius) 
  { }


  ball_topology(RandomNumberGenerator& gen, double radius = 1.0) 
    : gen_ptr(), rand(new rand_t(gen)), radius(radius) { }

                     
  point_type random_point() const 
  {
    point_type p;
    double dist_sum;
    do {
      dist_sum = 0.0;
      for (std::size_t i = 0; i < Dims; ++i) {
        double x = (*rand)() * 2*radius - radius;
        p[i] = x;
        dist_sum += x * x;
      }
    } while (dist_sum > radius*radius);
    return p;
  }


  point_type bound(point_type a) const
  {
    BOOST_USING_STD_MIN();
    BOOST_USING_STD_MAX();
    double r = 0.;
    for (std::size_t i = 0; i < Dims; ++i)
      r = boost::math::hypot(r, a[i]);
    if (r <= radius) return a;
    double scaling_factor = radius / r;
    point_type p;
    for (std::size_t i = 0; i < Dims; ++i)
      p[i] = a[i] * scaling_factor;
    return p;
  }


  double distance_from_boundary(point_type a) const
  {
    double r = 0.;
    for (std::size_t i = 0; i < Dims; ++i)
      r = boost::math::hypot(r, a[i]);
    return radius - r;
  }


  point_type center() const {
    point_type result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = 0;
    return result;
  }


  point_type origin() const {
    point_type result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = -radius;
    return result;
  }


  point_difference_type extent() const {
    point_difference_type result;
    for (std::size_t i = 0; i < Dims; ++i)
      result[i] = 2. * radius;
    return result;
  }

  explicit circle_topology(double radius = 1.0) : inherited(radius) { }

  
  circle_topology(RandomNumberGenerator& gen, double radius = 1.0) 
    : inherited(gen, radius) { }

  explicit sphere_topology(double radius = 1.0) : inherited(radius) { }

  
  sphere_topology(RandomNumberGenerator& gen, double radius = 1.0) 
    : inherited(gen, radius) { }

    point() { values[0] = 0.0; values[1] = 0.0; }

    point(double x, double y) { values[0] = x; values[1] = y; }


    double& operator[](std::size_t i)       { return values[i]; }


  bool in_heart(point p) const 
  {
#ifndef BOOST_NO_STDC_NAMESPACE
    using std::abs;
#endif

    if (p[1] < abs(p[0]) - 2000) return false; // Bottom
    if (p[1] <= -1000) return true; // Diagonal of square
    if (boost::math::hypot(p[0] - -500, p[1] - -500) <= 500. * boost::math::constants::root_two<double>())
      return true; // Left circle
    if (boost::math::hypot(p[0] - 500, p[1] - -500) <= 500. * boost::math::constants::root_two<double>())
      return true; // Right circle
    return false;
  }


  bool segment_within_heart(point p1, point p2) const 
  {
    // Assumes that p1 and p2 are within the heart
    if ((p1[0] < 0) == (p2[0] < 0)) return true; // Same side of symmetry line
    if (p1[0] == p2[0]) return true; // Vertical
    double slope = (p2[1] - p1[1]) / (p2[0] - p1[0]);
    double intercept = p1[1] - p1[0] * slope;
    if (intercept > 0) return false; // Crosses between circles
    return true;
  }


  heart_topology() 
    : gen_ptr(new RandomNumberGenerator), rand(new rand_t(*gen_ptr)) { }


  heart_topology(RandomNumberGenerator& gen) 
    : gen_ptr(), rand(new rand_t(gen)) { }


  point random_point() const 
  {
    point result;
    do {
      result[0] = (*rand)() * (1000 + 1000 * boost::math::constants::root_two<double>()) - (500 + 500 * boost::math::constants::root_two<double>());
      result[1] = (*rand)() * (2000 + 500 * (boost::math::constants::root_two<double>() - 1)) - 2000;
    } while (!in_heart(result));
    return result;
  }


  double distance(point a, point b) const 
  {
    if (segment_within_heart(a, b)) {
      // Straight line
      return boost::math::hypot(b[0] - a[0], b[1] - a[1]);
    } else {
      // Straight line bending around (0, 0)
      return boost::math::hypot(a[0], a[1]) + boost::math::hypot(b[0], b[1]);
    }
  }


  point move_position_toward(point a, double fraction, point b) const 
  {
    if (segment_within_heart(a, b)) {
      // Straight line
      return point(a[0] + (b[0] - a[0]) * fraction,
                   a[1] + (b[1] - a[1]) * fraction);
    } else {
      double distance_to_point_a = boost::math::hypot(a[0], a[1]);
      double distance_to_point_b = boost::math::hypot(b[0], b[1]);
      double location_of_point = distance_to_point_a / 
                                   (distance_to_point_a + distance_to_point_b);
      if (fraction < location_of_point)
        return point(a[0] * (1 - fraction / location_of_point), 
                     a[1] * (1 - fraction / location_of_point));
      else
        return point(
          b[0] * ((fraction - location_of_point) / (1 - location_of_point)),
          b[1] * ((fraction - location_of_point) / (1 - location_of_point)));
    }
  }



void const_constraints(const G& cg) {
            p = out_edges(u, cg);
            n = out_degree(u, cg);
            e = *p.first;
            u = source(e, cg);
            v = target(e, cg);
        }

void const_constraints(const G& cg) {
        p = in_edges(v, cg);
        n = in_degree(v, cg);
        e = *p.first;
        }

void const_constraints(const G& cg) {
        p = adjacent_vertices(v, cg);
        }

void const_constraints(const G& cg) {
#ifdef BOOST_VECTOR_AS_GRAPH_GRAPH_ADL_HACK
        // dwa 2003/7/11 -- This clearly shouldn't be necessary, but if
        // you want to use vector_as_graph, it is!  I'm sure the graph
        // library leaves these out all over the place.  Probably a
        // redesign involving specializing a template with a static
        // member function is in order :(
        using boost::vertices;
#endif

        p = vertices(cg);
        v = *p.first;
        V = num_vertices(cg);
        }

void const_constraints(const G& cg) {
        p = edges(cg);
        E = num_edges(cg);
        e = *p.first;
        u = source(e, cg);
        v = target(e, cg);
        }



        bool operator()(const edge_descriptor&) const {
        return false;
        }






void const_constraints(const G& cg) {
        p = edge(u, v, cg);
        }

void const_constraints(const G& cg) {
        const_Map pmap = get(Property(), cg);
        pval = get(Property(), cg, x);
        ignore_unused_variable_warning(pmap);
        }



void const_constraints(const Graph& g)
        {
            typedef typename property_map<Graph, vertex_index_t>::const_type Map;
            Map m = get(vertex_index, g);
            ignore_unused_variable_warning(m);
        }

void const_constraints(const Graph& g)
        {
            typedef typename property_map<Graph, edge_index_t>::const_type Map;
            Map m = get(edge_index, g);
            ignore_unused_variable_warning(m);
        }


void const_constraints(const M& cA) {
        const V& elt = cA[i][j];
        ignore_unused_variable_warning(elt);
        }





      closed_plus() : inf((std::numeric_limits<T>::max)()) { }

      closed_plus(T inf) : inf(inf) { }


      T operator()(const T& a, const T& b) const {
        using namespace std;
       if (a == inf) return inf;
       if (b == inf) return inf;
       return a + b;
      }

    
    template <class Graph, class WeightMap, 
            class PredecessorMap, class DistanceMap, 
            class BinaryFunction, class BinaryPredicate>
    bool relax(typename graph_traits<Graph>::edge_descriptor e, 
               const Graph& g, const WeightMap& w, 
               PredecessorMap& p, DistanceMap& d, 
               const BinaryFunction& combine, const BinaryPredicate& compare)
    {
      typedef typename graph_traits<Graph>::directed_category DirCat;
      bool is_undirected = is_same<DirCat, undirected_tag>::value;
      typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
      Vertex u = source(e, g), v = target(e, g);
      typedef typename property_traits<DistanceMap>::value_type D;
      typedef typename property_traits<WeightMap>::value_type W;
      const D d_u = get(d, u);
      const D d_v = get(d, v);
      const W& w_e = get(w, e);
      
      // The seemingly redundant comparisons after the distance puts are to
      // ensure that extra floating-point precision in x87 registers does not
      // lead to relax() returning true when the distance did not actually
      // change.
      if ( compare(combine(d_u, w_e), d_v) ) {
        put(d, v, combine(d_u, w_e));
        if (compare(get(d, v), d_v)) {
          put(p, v, u);
          return true;
        } else {
          return false;
        }
      } else if (is_undirected && compare(combine(d_v, w_e), d_u)) {
        put(d, u, combine(d_v, w_e));
        if (compare(get(d, u), d_u)) {
          put(p, u, v);
          return true;
        } else {
          return false;
        }
      } else
        return false;
    }

    
    template <class Graph, class WeightMap, 
      class PredecessorMap, class DistanceMap>
    bool relax(typename graph_traits<Graph>::edge_descriptor e,
               const Graph& g, WeightMap w, PredecessorMap p, DistanceMap d)
    {
      typedef typename property_traits<DistanceMap>::value_type D;
      typedef closed_plus<D> Combine;
      typedef std::less<D> Compare;
      return relax(e, g, w, p, d, Combine(), Compare());
    }

template <typename Graph,
            typename DistanceMap,
            typename Combinator>
inline typename property_traits<DistanceMap>::value_type
eccentricity(const Graph& g, DistanceMap dist, Combinator combine)
{
    BOOST_CONCEPT_ASSERT(( GraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<DistanceMap,Vertex> ));
    typedef typename property_traits<DistanceMap>::value_type Distance;

    return detail::combine_distances(g, dist, combine, Distance(0));
}


template <typename Graph, typename DistanceMap>
inline typename property_traits<DistanceMap>::value_type
eccentricity(const Graph& g, DistanceMap dist)
{
    BOOST_CONCEPT_ASSERT(( GraphConcept<Graph> ));
    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<DistanceMap,Vertex> ));
    typedef typename property_traits<DistanceMap>::value_type Distance;

    return eccentricity(g, dist, detail::maximize<Distance>());
}

    void constraints() {
      BOOST_CONCEPT_ASSERT(( CopyConstructibleConcept<Visitor> ));
      vis.initialize_vertex(u, g);
      vis.start_vertex(u, g);
      vis.discover_vertex(u, g);
      vis.examine_edge(e, g);
      vis.tree_edge(e, g);
      vis.back_edge(e, g);
      vis.forward_or_cross_edge(e, g);
      vis.finish_vertex(u, g);
    }

      template<class T, class T2>
      bool operator()(const T&, const T2&) const { return false; }


    template <class IncidenceGraph, class DFSVisitor, class ColorMap,
            class TerminatorFunc>
    void depth_first_visit_impl
      (const IncidenceGraph& g,
       typename graph_traits<IncidenceGraph>::vertex_descriptor u,
       DFSVisitor& vis,
       ColorMap color, TerminatorFunc func = TerminatorFunc())
    {
      BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<IncidenceGraph> ));
      BOOST_CONCEPT_ASSERT(( DFSVisitorConcept<DFSVisitor, IncidenceGraph> ));
      typedef typename graph_traits<IncidenceGraph>::vertex_descriptor Vertex;
      BOOST_CONCEPT_ASSERT(( ReadWritePropertyMapConcept<ColorMap, Vertex> ));
      typedef typename property_traits<ColorMap>::value_type ColorValue;
      BOOST_CONCEPT_ASSERT(( ColorValueConcept<ColorValue> ));
      typedef color_traits<ColorValue> Color;
      typedef typename graph_traits<IncidenceGraph>::out_edge_iterator Iter;
      typedef std::pair<Vertex, std::pair<Iter, Iter> > VertexInfo;

      Iter ei, ei_end;
      std::vector<VertexInfo> stack;

      // Possible optimization for vector
      //stack.reserve(num_vertices(g));

      typedef typename unwrap_reference<TerminatorFunc>::type TF;

      put(color, u, Color::gray());
      vis.discover_vertex(u, g);
      boost::tie(ei, ei_end) = out_edges(u, g);
      // Variable is needed to workaround a borland bug.
      TF& fn = static_cast<TF&>(func);
      if (fn(u, g)) {
          // If this vertex terminates the search, we push empty range
          stack.push_back(std::make_pair(u, std::make_pair(ei_end, ei_end)));
      } else {
          stack.push_back(std::make_pair(u, std::make_pair(ei, ei_end)));
      }
      while (!stack.empty()) {
        VertexInfo& back = stack.back();
        u = back.first;
        boost::tie(ei, ei_end) = back.second;
        stack.pop_back();
        while (ei != ei_end) {
          Vertex v = target(*ei, g);
          vis.examine_edge(*ei, g);
          ColorValue v_color = get(color, v);
          if (v_color == Color::white()) {
            vis.tree_edge(*ei, g);
            stack.push_back(std::make_pair(u, std::make_pair(++ei, ei_end)));
            u = v;
            put(color, u, Color::gray());
            vis.discover_vertex(u, g);
            boost::tie(ei, ei_end) = out_edges(u, g);
            if (fn(u, g)) {
                ei = ei_end;
            }
          } else if (v_color == Color::gray()) {
            vis.back_edge(*ei, g);
            ++ei;
          } else {
            vis.forward_or_cross_edge(*ei, g);
            ++ei;
          }
        }
        put(color, u, Color::black());
        vis.finish_vertex(u, g);
      }
    }


  template <class VertexListGraph, class DFSVisitor, class ColorMap>
  void
  depth_first_search(const VertexListGraph& g, DFSVisitor vis, ColorMap color,
                     typename graph_traits<VertexListGraph>::vertex_descriptor start_vertex)
  {
    typedef typename graph_traits<VertexListGraph>::vertex_descriptor Vertex;
    BOOST_CONCEPT_ASSERT(( DFSVisitorConcept<DFSVisitor, VertexListGraph> ));
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;

    typename graph_traits<VertexListGraph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
      Vertex u = implicit_cast<Vertex>(*ui);
      put(color, u, Color::white()); vis.initialize_vertex(u, g);
    }

    if (start_vertex != detail::get_default_starting_vertex(g)){ vis.start_vertex(start_vertex, g);
      detail::depth_first_visit_impl(g, start_vertex, vis, color,
                                     detail::nontruth2());
    }

    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
      Vertex u = implicit_cast<Vertex>(*ui);
      ColorValue u_color = get(color, u);
      if (u_color == Color::white()) {       vis.start_vertex(u, g);
        detail::depth_first_visit_impl(g, u, vis, color, detail::nontruth2());
      }
    }
  }


  template <class VertexListGraph, class DFSVisitor, class ColorMap>
  void
  depth_first_search(const VertexListGraph& g, DFSVisitor vis, ColorMap color)
  {
    typedef typename boost::graph_traits<VertexListGraph>::vertex_iterator vi;
    std::pair<vi, vi> verts = vertices(g);
    if (verts.first == verts.second)
      return;

    depth_first_search(g, vis, color, detail::get_default_starting_vertex(g));
  }

    dfs_visitor() { }

    dfs_visitor(Visitors vis) : m_vis(vis) { }


    template <class Vertex, class Graph>
    void initialize_vertex(Vertex u, const Graph& g) {
      invoke_visitors(m_vis, u, g, ::boost::on_initialize_vertex());
    }

    template <class Vertex, class Graph>
    void start_vertex(Vertex u, const Graph& g) {
      invoke_visitors(m_vis, u, g, ::boost::on_start_vertex());
    }

    template <class Vertex, class Graph>
    void discover_vertex(Vertex u, const Graph& g) {
      invoke_visitors(m_vis, u, g, ::boost::on_discover_vertex());
    }

    template <class Edge, class Graph>
    void examine_edge(Edge u, const Graph& g) {
      invoke_visitors(m_vis, u, g, ::boost::on_examine_edge());
    }

    template <class Edge, class Graph>
    void tree_edge(Edge u, const Graph& g) {
      invoke_visitors(m_vis, u, g, ::boost::on_tree_edge());
    }

    template <class Edge, class Graph>
    void back_edge(Edge u, const Graph& g) {
      invoke_visitors(m_vis, u, g, ::boost::on_back_edge());
    }

    template <class Edge, class Graph>
    void forward_or_cross_edge(Edge u, const Graph& g) {
      invoke_visitors(m_vis, u, g, ::boost::on_forward_or_cross_edge());
    }

    template <class Vertex, class Graph>
    void finish_vertex(Vertex u, const Graph& g) {
      invoke_visitors(m_vis, u, g, ::boost::on_finish_vertex());
    }

  template <class Visitors>
  dfs_visitor<Visitors>
  make_dfs_visitor(Visitors vis) {
    return dfs_visitor<Visitors>(vis);
  }

        template <typename ArgPack>
        void operator()(const Graph& g, const ArgPack& arg_pack) const {
          using namespace boost::graph::keywords;
          boost::depth_first_search(g,
                                    arg_pack[_visitor | make_dfs_visitor(null_visitor())],
                                    boost::detail::make_color_map_from_arg_pack(g, arg_pack),
                                    arg_pack[_root_vertex || boost::detail::get_default_starting_vertex_t<Graph>(g)]);
        }










  template <class IncidenceGraph, class DFSVisitor, class ColorMap>
  void depth_first_visit
    (const IncidenceGraph& g,
     typename graph_traits<IncidenceGraph>::vertex_descriptor u,
     DFSVisitor vis, ColorMap color)
  {
    vis.start_vertex(u, g);
    detail::depth_first_visit_impl(g, u, vis, color, detail::nontruth2());
  }


  template <class IncidenceGraph, class DFSVisitor, class ColorMap,
            class TerminatorFunc>
  void depth_first_visit
    (const IncidenceGraph& g,
     typename graph_traits<IncidenceGraph>::vertex_descriptor u,
     DFSVisitor vis, ColorMap color, TerminatorFunc func = TerminatorFunc())
  {
    vis.start_vertex(u, g);
    detail::depth_first_visit_impl(g, u, vis, color, func);
  }


  template <class VertexListGraph, class MutableGraph> 
  void transpose_graph(const VertexListGraph& G, MutableGraph& G_T)
  {
    reverse_graph<VertexListGraph> R(G);
    copy_graph(R, G_T);
  }

  
  template <class VertexListGraph, class MutableGraph, 
    class P, class T, class R> 
  void transpose_graph(const VertexListGraph& G, MutableGraph& G_T,
                       const bgl_named_params<P, T, R>& params)
  {
    reverse_graph<VertexListGraph> Rev(G);
    copy_graph(Rev, G_T, params);
  }


    mesh_iterator()
      : x(0), y(0), done(true) { }

    mesh_iterator(vertices_size_type x, vertices_size_type y, 
                  bool toroidal = true)
      : x(x), y(y), n(x*y), source(0), target(1), current(0,1), 
        toroidal(toroidal), done(false)
    { BOOST_ASSERT(x > 1 && y > 1); }


    reference operator*() const { return current; }

    pointer operator->() const { return &current; }

    
    mesh_iterator& operator++()
    {
      if (is_undirected) {
        if (!toroidal) {
          if (target == source + 1)
            if (source < x * (y - 1))
              target = source + x;
            else {
              source++;
              target = (source % x) < x - 1 ? source + 1 : source + x;
              if (target > n) 
                done = true;
            }
          else if (target == source + x) {
            source++;
            target = (source % x) < x - 1 ? source + 1 : source + x;
          }
        } else {
          if (target == source + 1 || target == source - (source % x))
            target = (source + x) % n;
          else if (target == (source + x) % n) {
            if (source == n - 1)
              done = true;
            else {
              source++;
              target = (source % x) < (x - 1) ? source + 1 : source - (source % x);
            }
          }
        }
      } else { // Directed
        if ( !toroidal ) {
          if (target == source - x) 
            target = source % x > 0 ? source - 1 : source + 1;
          else if (target == source - 1)
            if ((source % x) < (x - 1))
              target = source + 1;
            else if (source < x * (y - 1))
              target = source + x;
            else {
              done = true;
            }
          else if (target == source + 1)
            if (source < x * (y - 1))
              target = source + x;
            else {
              source++;
              target = source - x;
            }
          else if (target == source + x) {
            source++;
            target = (source >= x) ? source - x : source - 1;
          }
        } else {
          if (source == n - 1 && target == (source + x) % n)
            done = true;
          else if (target == source - 1 || target == source + x - 1)
            target = (source + x) % n;
          else if (target == source + 1 || target == source - (source % x))
            target = (source - x + n) % n;
          else if (target == (source - x + n) % n)
            target = (source % x > 0) ? source - 1 : source + x - 1;
          else if (target == (source + x) % n) {
            source++;
            target = (source % x) < (x - 1) ? source + 1 : source - (source % x);
          }
        }
      }

      current.first = source;
      current.second = target;

      return *this;
    }


    mesh_iterator operator++(int)
    {
      mesh_iterator temp(*this);
      ++(*this);
      return temp;
    }


    bool operator==(const mesh_iterator& other) const
    {
      return done == other.done;
    }


    bool operator!=(const mesh_iterator& other) const
    { return !(*this == other); }

  template<typename Buffer, typename Vertex, typename DistanceType>
  inline void 
  dijkstra_queue_update(Buffer& Q, Vertex vertex, DistanceType old_distance)
  {
    (void)old_distance;
    Q.update(vertex);
  }

    void constraints() {
      BOOST_CONCEPT_ASSERT(( CopyConstructibleConcept<Visitor> ));
      vis.initialize_vertex(u, g);
      vis.discover_vertex(u, g);
      vis.examine_vertex(u, g);
      vis.examine_edge(e, g);
      vis.edge_relaxed(e, g);
      vis.edge_not_relaxed(e, g);
      vis.finish_vertex(u, g);
    }

    dijkstra_visitor() { }

    dijkstra_visitor(Visitors vis)
      : bfs_visitor<Visitors>(vis) { }


    template <class Edge, class Graph>
    void edge_relaxed(Edge e, Graph& g) {
      invoke_visitors(this->m_vis, e, g, on_edge_relaxed());
    }

    template <class Edge, class Graph>
    void edge_not_relaxed(Edge e, Graph& g) {
      invoke_visitors(this->m_vis, e, g, on_edge_not_relaxed());
    }

    template <class Edge, class Graph>
    void tree_edge(Edge u, Graph& g) { }

  template <class Visitors>
  dijkstra_visitor<Visitors>
  make_dijkstra_visitor(Visitors vis) {
    return dijkstra_visitor<Visitors>(vis);
  }


      dijkstra_bfs_visitor(UniformCostVisitor vis, UpdatableQueue& Q,
                           WeightMap w, PredecessorMap p, DistanceMap d,
                           BinaryFunction combine, BinaryPredicate compare,
                           D zero)
        : m_vis(vis), m_Q(Q), m_weight(w), m_predecessor(p), m_distance(d),
          m_combine(combine), m_compare(compare), m_zero(zero)  { }


      template <class Edge, class Graph>
      void tree_edge(Edge e, Graph& g) {
        bool decreased = relax(e, g, m_weight, m_predecessor, m_distance,
                               m_combine, m_compare);
        if (decreased)
          m_vis.edge_relaxed(e, g);
        else
          m_vis.edge_not_relaxed(e, g);
      }

      template <class Edge, class Graph>
      void gray_target(Edge e, Graph& g) {
        D old_distance = get(m_distance, target(e, g));

        bool decreased = relax(e, g, m_weight, m_predecessor, m_distance,
                               m_combine, m_compare);
        if (decreased) {
          dijkstra_queue_update(m_Q, target(e, g), old_distance);
          m_vis.edge_relaxed(e, g);
        } else
          m_vis.edge_not_relaxed(e, g);
      }


      template <class Vertex, class Graph>
      void initialize_vertex(Vertex u, Graph& g)
        { m_vis.initialize_vertex(u, g); }

      template <class Edge, class Graph>
      void non_tree_edge(Edge, Graph&) { }

      template <class Vertex, class Graph>
      void discover_vertex(Vertex u, Graph& g) { m_vis.discover_vertex(u, g); }

      template <class Vertex, class Graph>
      void examine_vertex(Vertex u, Graph& g) { m_vis.examine_vertex(u, g); }

      template <class Edge, class Graph>
      void examine_edge(Edge e, Graph& g) {
        // Comparison needs to be more complicated because distance and weight
        // types may not be the same; see bug 8398
        // (https://svn.boost.org/trac/boost/ticket/8398)
        D source_dist = get(m_distance, source(e, g));
        if (m_compare(m_combine(source_dist, get(m_weight, e)), source_dist))
            boost::throw_exception(negative_edge());
        m_vis.examine_edge(e, g);
      }

      template <class Edge, class Graph>
      void black_target(Edge, Graph&) { }

      template <class Vertex, class Graph>
      void finish_vertex(Vertex u, Graph& g) { m_vis.finish_vertex(u, g); }

      static type build(const Graph& g, const IndexMap& index, boost::scoped_array<Value>& array_holder) {
        array_holder.reset(new Value[num_vertices(g)]);
        std::fill(array_holder.get(), array_holder.get() + num_vertices(g), Value());
        return make_iterator_property_map(array_holder.get(), index);
      }

      static type build(const Graph& g, const IndexMap& index, boost::scoped_array<Value>& array_holder) {
        return boost::make_vector_property_map<Value>(index);
      }

      static type build(const Graph& g, const IndexMap& index, boost::scoped_array<Value>& array_holder) {
        return helper::build(g, index, array_holder);
      }

      static type build(const Graph& g, const IndexMap& index) {
        size_t nv = num_vertices(g);
        return boost::two_bit_color_map<IndexMap>(nv, index);
      }

      static type build(const Graph& g, const IndexMap& index) {
        return boost::make_vector_property_map<boost::two_bit_color_type>(index);
      }

      static type build(const Graph& g, const IndexMap& index) {
        return helper::build(g, index);
      }

  template <class Graph, class DijkstraVisitor,
            class PredecessorMap, class DistanceMap,
            class WeightMap, class IndexMap, class Compare, class Combine,
            class DistZero>
  inline void
  dijkstra_shortest_paths_no_init
    (const Graph& g,
     typename graph_traits<Graph>::vertex_descriptor s,
     PredecessorMap predecessor, DistanceMap distance, WeightMap weight,
     IndexMap index_map,
     Compare compare, Combine combine, DistZero zero,
     DijkstraVisitor vis)
  {
    typedef
      detail::default_color_map_generator<Graph, IndexMap>
      ColorMapHelper;
    typedef typename ColorMapHelper::type ColorMap;
    ColorMap color =
      ColorMapHelper::build(g, index_map);
    dijkstra_shortest_paths_no_init( g, s, predecessor, distance, weight,
      index_map, compare, combine, zero, vis,
        color);
  }

  template <class Graph, class DijkstraVisitor,
            class PredecessorMap, class DistanceMap,
            class WeightMap, class IndexMap, class Compare, class Combine,
            class DistZero, class ColorMap>
  inline void
  dijkstra_shortest_paths_no_init
    (const Graph& g,
     typename graph_traits<Graph>::vertex_descriptor s,
     PredecessorMap predecessor, DistanceMap distance, WeightMap weight,
     IndexMap index_map,
     Compare compare, Combine combine, DistZero zero,
     DijkstraVisitor vis, ColorMap color)
  {
    typedef indirect_cmp<DistanceMap, Compare> IndirectCmp;
    IndirectCmp icmp(distance, compare);

    typedef typename graph_traits<Graph>::vertex_descriptor Vertex;

#ifdef BOOST_GRAPH_DIJKSTRA_TESTING
    if (!dijkstra_relaxed_heap) {
      typedef mutable_queue<Vertex, std::vector<Vertex>, IndirectCmp, IndexMap>
        MutableQueue;

      MutableQueue Q(num_vertices(g), icmp, index_map);
      detail::dijkstra_bfs_visitor<DijkstraVisitor, MutableQueue, WeightMap,
        PredecessorMap, DistanceMap, Combine, Compare>
      bfs_vis(vis, Q, weight, predecessor, distance, combine, compare, zero);

      breadth_first_visit(g, s, Q, bfs_vis, color);
      return;
    }
#endif // BOOST_GRAPH_DIJKSTRA_TESTING

#ifdef BOOST_GRAPH_DIJKSTRA_USE_RELAXED_HEAP
    typedef relaxed_heap<Vertex, IndirectCmp, IndexMap> MutableQueue;
    MutableQueue Q(num_vertices(g), icmp, index_map);
#else // Now the default: use a d-ary heap
      boost::scoped_array<std::size_t> index_in_heap_map_holder;
      typedef
        detail::vertex_property_map_generator<Graph, IndexMap, std::size_t>
        IndexInHeapMapHelper;
      typedef typename IndexInHeapMapHelper::type IndexInHeapMap;
      IndexInHeapMap index_in_heap =
        IndexInHeapMapHelper::build(g, index_map, index_in_heap_map_holder);
      typedef d_ary_heap_indirect<Vertex, 4, IndexInHeapMap, DistanceMap, Compare>
        MutableQueue;
      MutableQueue Q(distance, index_in_heap, compare);
#endif // Relaxed heap

    detail::dijkstra_bfs_visitor<DijkstraVisitor, MutableQueue, WeightMap,
      PredecessorMap, DistanceMap, Combine, Compare>
        bfs_vis(vis, Q, weight, predecessor, distance, combine, compare, zero);

    breadth_first_visit(g, s, Q, bfs_vis, color);
  }

  template <class VertexListGraph, class DijkstraVisitor,
            class PredecessorMap, class DistanceMap,
            class WeightMap, class IndexMap, class Compare, class Combine,
            class DistInf, class DistZero, typename T, typename Tag, 
            typename Base>
  inline void
  dijkstra_shortest_paths
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     PredecessorMap predecessor, DistanceMap distance, WeightMap weight,
     IndexMap index_map,
     Compare compare, Combine combine, DistInf inf, DistZero zero,
     DijkstraVisitor vis,
     const bgl_named_params<T, Tag, Base>&
     BOOST_GRAPH_ENABLE_IF_MODELS_PARM(VertexListGraph,vertex_list_graph_tag))
  {
    boost::two_bit_color_map<IndexMap> color(num_vertices(g), index_map);
    dijkstra_shortest_paths(g, s, predecessor, distance, weight, index_map,
                            compare, combine, inf, zero, vis,
                            color);
  }

  template <class VertexListGraph, class DijkstraVisitor,
            class PredecessorMap, class DistanceMap,
            class WeightMap, class IndexMap, class Compare, class Combine,
            class DistInf, class DistZero, class ColorMap>
  inline void
  dijkstra_shortest_paths
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     PredecessorMap predecessor, DistanceMap distance, WeightMap weight,
     IndexMap index_map,
     Compare compare, Combine combine, DistInf inf, DistZero zero,
     DijkstraVisitor vis, ColorMap color)
  {
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;
    typename graph_traits<VertexListGraph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
      vis.initialize_vertex(*ui, g);
      put(distance, *ui, inf);
      put(predecessor, *ui, *ui);
      put(color, *ui, Color::white());
    }
    put(distance, s, zero);

    dijkstra_shortest_paths_no_init(g, s, predecessor, distance, weight,
                            index_map, compare, combine, zero, vis, color);
  }

  template <class VertexListGraph, class DijkstraVisitor,
            class PredecessorMap, class DistanceMap,
            class WeightMap, class IndexMap, class Compare, class Combine,
            class DistInf, class DistZero>
  inline void
  dijkstra_shortest_paths
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     PredecessorMap predecessor, DistanceMap distance, WeightMap weight,
     IndexMap index_map,
     Compare compare, Combine combine, DistInf inf, DistZero zero,
     DijkstraVisitor vis)
  {
    dijkstra_shortest_paths(g, s, predecessor, distance, weight, index_map,
                            compare, combine, inf, zero, vis,
                            no_named_parameters());
  }

    template <class VertexListGraph, class DistanceMap, class WeightMap,
              class IndexMap, class Params>
    inline void
    dijkstra_dispatch2
      (const VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s,
       DistanceMap distance, WeightMap weight, IndexMap index_map,
       const Params& params)
    {
      // Default for predecessor map
      dummy_property_map p_map;

      typedef typename property_traits<DistanceMap>::value_type D;
      D inf = choose_param(get_param(params, distance_inf_t()),
                           (std::numeric_limits<D>::max)());

      dijkstra_shortest_paths
        (g, s,
         choose_param(get_param(params, vertex_predecessor), p_map),
         distance, weight, index_map,
         choose_param(get_param(params, distance_compare_t()),
                      std::less<D>()),
         choose_param(get_param(params, distance_combine_t()),
                      closed_plus<D>(inf)),
         inf,
         choose_param(get_param(params, distance_zero_t()),
                      D()),
         choose_param(get_param(params, graph_visitor),
                      make_dijkstra_visitor(null_visitor())),
         params);
    }


    template <class VertexListGraph, class DistanceMap, class WeightMap,
              class IndexMap, class Params>
    inline void
    dijkstra_dispatch1
      (const VertexListGraph& g,
       typename graph_traits<VertexListGraph>::vertex_descriptor s,
       DistanceMap distance, WeightMap weight, IndexMap index_map,
       const Params& params)
    {
      // Default for distance map
      typedef typename property_traits<WeightMap>::value_type D;
      typename std::vector<D>::size_type
        n = is_default_param(distance) ? num_vertices(g) : 1;
      std::vector<D> distance_map(n);

      detail::dijkstra_dispatch2
        (g, s, choose_param(distance, make_iterator_property_map
                            (distance_map.begin(), index_map,
                             distance_map[0])),
         weight, index_map, params);
    }

  template <class VertexListGraph, class Param, class Tag, class Rest>
  inline void
  dijkstra_shortest_paths
    (const VertexListGraph& g,
     typename graph_traits<VertexListGraph>::vertex_descriptor s,
     const bgl_named_params<Param,Tag,Rest>& params)
  {
    // Default for edge weight and vertex index map is to ask for them
    // from the graph.  Default for the visitor is null_visitor.
    detail::dijkstra_dispatch1
      (g, s,
       get_param(params, vertex_distance),
       choose_const_pmap(get_param(params, edge_weight), g, edge_weight),
       choose_const_pmap(get_param(params, vertex_index), g, vertex_index),
       params);
  }

  
    property_map_equivalent(const PropertyMapFirst property_map1,
                            const PropertyMapSecond property_map2) :
      m_property_map1(property_map1),
      m_property_map2(property_map2) { }


    template <typename ItemFirst,
              typename ItemSecond>
    bool operator()(const ItemFirst item1, const ItemSecond item2) {
      return (get(m_property_map1, item1) == get(m_property_map2, item2));
    }

  template <typename PropertyMapFirst,
            typename PropertyMapSecond>
  property_map_equivalent<PropertyMapFirst,
                          PropertyMapSecond>
  make_property_map_equivalent
  (const PropertyMapFirst property_map1,
   const PropertyMapSecond property_map2) {

    return (property_map_equivalent<PropertyMapFirst, PropertyMapSecond>
            (property_map1, property_map2));
  }

  
    template <typename ItemFirst,
              typename ItemSecond>
    bool operator()(const ItemFirst&, const ItemSecond&) {
      return (true);
    }

    template <typename GraphFirst,
              typename GraphSecond,
              typename CorrespondenceMapFirstToSecond,
              typename CorrespondenceMapSecondToFirst,
              typename EdgeEquivalencePredicate,
              typename VertexEquivalencePredicate>
    bool can_extend_graph
    (const GraphFirst& graph1,
     const GraphSecond& graph2,
     CorrespondenceMapFirstToSecond correspondence_map_1_to_2,
     CorrespondenceMapSecondToFirst /*correspondence_map_2_to_1*/,
     typename graph_traits<GraphFirst>::vertices_size_type subgraph_size,
     typename graph_traits<GraphFirst>::vertex_descriptor new_vertex1,
     typename graph_traits<GraphSecond>::vertex_descriptor new_vertex2,
     EdgeEquivalencePredicate edges_equivalent,
     VertexEquivalencePredicate vertices_equivalent,
     bool only_connected_subgraphs)
    {
      typedef typename graph_traits<GraphFirst>::vertex_descriptor VertexFirst;
      typedef typename graph_traits<GraphSecond>::vertex_descriptor VertexSecond;
      
      typedef typename graph_traits<GraphFirst>::edge_descriptor EdgeFirst;
      typedef typename graph_traits<GraphSecond>::edge_descriptor EdgeSecond;

      // Check vertex equality
      if (!vertices_equivalent(new_vertex1, new_vertex2)) {
        return (false);
      }

      // Vertices match and graph is empty, so we can extend the subgraph
      if (subgraph_size == 0) {
        return (true);
      }

      bool has_one_edge = false;

      // Verify edges with existing sub-graph
      BGL_FORALL_VERTICES_T(existing_vertex1, graph1, GraphFirst) {

        VertexSecond existing_vertex2 = get(correspondence_map_1_to_2, existing_vertex1);

        // Skip unassociated vertices
        if (existing_vertex2 == graph_traits<GraphSecond>::null_vertex()) {
          continue;
        }

        // NOTE: This will not work with parallel edges, since the
        // first matching edge is always chosen.
        EdgeFirst edge_to_new1, edge_from_new1;
        bool edge_to_new_exists1 = false, edge_from_new_exists1 = false;
        
        EdgeSecond edge_to_new2, edge_from_new2;
        bool edge_to_new_exists2 = false, edge_from_new_exists2 = false;

        // Search for edge from existing to new vertex (graph1)
        BGL_FORALL_OUTEDGES_T(existing_vertex1, edge1, graph1, GraphFirst) {
          if (target(edge1, graph1) == new_vertex1) {
            edge_to_new1 = edge1;
            edge_to_new_exists1 = true;
            break;
          }
        }

        // Search for edge from existing to new vertex (graph2)
        BGL_FORALL_OUTEDGES_T(existing_vertex2, edge2, graph2, GraphSecond) {
          if (target(edge2,  graph2) == new_vertex2) {
            edge_to_new2 = edge2;
            edge_to_new_exists2 = true;
            break;
          }
        }

        // Make sure edges from existing to new vertices are equivalent
        if ((edge_to_new_exists1 != edge_to_new_exists2) ||
            ((edge_to_new_exists1 && edge_to_new_exists2) &&
             !edges_equivalent(edge_to_new1, edge_to_new2))) {
              
          return (false);
        }

        bool is_undirected1 = is_undirected(graph1),
          is_undirected2 = is_undirected(graph2);

        if (is_undirected1 && is_undirected2) {

          // Edge in both graphs exists and both graphs are undirected
          if (edge_to_new_exists1 && edge_to_new_exists2) {
            has_one_edge = true;
          }

          continue;
        }
        else {

          if (!is_undirected1) {

            // Search for edge from new to existing vertex (graph1)
            BGL_FORALL_OUTEDGES_T(new_vertex1, edge1, graph1, GraphFirst) {
              if (target(edge1, graph1) == existing_vertex1) {
                edge_from_new1 = edge1;
                edge_from_new_exists1 = true;
                break;
              }
            }
          }

          if (!is_undirected2) {

            // Search for edge from new to existing vertex (graph2)
            BGL_FORALL_OUTEDGES_T(new_vertex2, edge2, graph2, GraphSecond) {
              if (target(edge2, graph2) == existing_vertex2) {
                edge_from_new2 = edge2;
                edge_from_new_exists2 = true;
                break;
              }
            }
          }

          // Make sure edges from new to existing vertices are equivalent
          if ((edge_from_new_exists1 != edge_from_new_exists2) ||
              ((edge_from_new_exists1 && edge_from_new_exists2) &&
               !edges_equivalent(edge_from_new1, edge_from_new2))) {
                
            return (false);
          }

          if ((edge_from_new_exists1 && edge_from_new_exists2) ||
              (edge_to_new_exists1 && edge_to_new_exists2)) {
            has_one_edge = true;
          }

        } // else

      } // BGL_FORALL_VERTICES_T

      // Make sure new vertices are connected to the existing subgraph
      if (only_connected_subgraphs && !has_one_edge) {
        return (false);
      }

      return (true);
    }

    template <typename GraphFirst,
              typename GraphSecond,
              typename VertexIndexMapFirst,
              typename VertexIndexMapSecond,
              typename CorrespondenceMapFirstToSecond,
              typename CorrespondenceMapSecondToFirst,
              typename VertexStackFirst,
              typename EdgeEquivalencePredicate,
              typename VertexEquivalencePredicate,
              typename SubGraphInternalCallback>
    bool mcgregor_common_subgraphs_internal
    (const GraphFirst& graph1,
     const GraphSecond& graph2,
     const VertexIndexMapFirst& vindex_map1,
     const VertexIndexMapSecond& vindex_map2,
     CorrespondenceMapFirstToSecond correspondence_map_1_to_2,
     CorrespondenceMapSecondToFirst correspondence_map_2_to_1,
     VertexStackFirst& vertex_stack1,
     EdgeEquivalencePredicate edges_equivalent,
     VertexEquivalencePredicate vertices_equivalent,
     bool only_connected_subgraphs,
     SubGraphInternalCallback subgraph_callback)
    {
      typedef typename graph_traits<GraphFirst>::vertex_descriptor VertexFirst;
      typedef typename graph_traits<GraphSecond>::vertex_descriptor VertexSecond;
      typedef typename graph_traits<GraphFirst>::vertices_size_type VertexSizeFirst;

      // Get iterators for vertices from both graphs
      typename graph_traits<GraphFirst>::vertex_iterator
        vertex1_iter, vertex1_end;
  
      typename graph_traits<GraphSecond>::vertex_iterator
        vertex2_begin, vertex2_end, vertex2_iter;
  
      boost::tie(vertex1_iter, vertex1_end) = vertices(graph1);
      boost::tie(vertex2_begin, vertex2_end) = vertices(graph2);
      vertex2_iter = vertex2_begin;
  
      // Iterate until all vertices have been visited
      BGL_FORALL_VERTICES_T(new_vertex1, graph1, GraphFirst) {

        VertexSecond existing_vertex2 = get(correspondence_map_1_to_2, new_vertex1);

        // Skip already matched vertices in first graph
        if (existing_vertex2 != graph_traits<GraphSecond>::null_vertex()) {
          continue;
        }
    
        BGL_FORALL_VERTICES_T(new_vertex2, graph2, GraphSecond) {

          VertexFirst existing_vertex1 = get(correspondence_map_2_to_1, new_vertex2);

          // Skip already matched vertices in second graph
          if (existing_vertex1 != graph_traits<GraphFirst>::null_vertex()) {
            continue;
          }

          // Check if current sub-graph can be extended with the matched vertex pair
          if (can_extend_graph(graph1, graph2,
                               correspondence_map_1_to_2, correspondence_map_2_to_1,
                               (VertexSizeFirst)vertex_stack1.size(),
                               new_vertex1, new_vertex2,
                               edges_equivalent, vertices_equivalent,
                               only_connected_subgraphs)) {

            // Keep track of old graph size for restoring later
            VertexSizeFirst old_graph_size = (VertexSizeFirst)vertex_stack1.size(),
              new_graph_size = old_graph_size + 1;

            // Extend subgraph
            put(correspondence_map_1_to_2, new_vertex1, new_vertex2);
            put(correspondence_map_2_to_1, new_vertex2, new_vertex1);
            vertex_stack1.push(new_vertex1);

            // Only output sub-graphs larger than a single vertex
            if (new_graph_size > 1) {
            
              // Returning false from the callback will cancel iteration
              if (!subgraph_callback(correspondence_map_1_to_2,
                                     correspondence_map_2_to_1,
                                     new_graph_size)) {
                return (false);
              }
            }
      
            // Depth-first search into the state space of possible sub-graphs
            bool continue_iteration =
              mcgregor_common_subgraphs_internal
              (graph1, graph2,
               vindex_map1, vindex_map2,
               correspondence_map_1_to_2, correspondence_map_2_to_1,
               vertex_stack1,
               edges_equivalent, vertices_equivalent,
               only_connected_subgraphs, subgraph_callback);

            if (!continue_iteration) {
              return (false);
            }
      
            // Restore previous state
            if (vertex_stack1.size() > old_graph_size) {
              
              VertexFirst stack_vertex1 = vertex_stack1.top();
              VertexSecond stack_vertex2 = get(correspondence_map_1_to_2,
                                               stack_vertex1);

              // Contract subgraph
              put(correspondence_map_1_to_2, stack_vertex1,
                  graph_traits<GraphSecond>::null_vertex());
            
              put(correspondence_map_2_to_1, stack_vertex2,
                  graph_traits<GraphFirst>::null_vertex());
                  
              vertex_stack1.pop();
           }

          } // if can_extend_graph

        } // BGL_FORALL_VERTICES_T (graph2)

      } // BGL_FORALL_VERTICES_T (graph1)

      return (true);
    }

    template <typename GraphFirst,
              typename GraphSecond,
              typename VertexIndexMapFirst,
              typename VertexIndexMapSecond,
              typename EdgeEquivalencePredicate,
              typename VertexEquivalencePredicate,
              typename SubGraphInternalCallback>
    inline void mcgregor_common_subgraphs_internal_init
    (const GraphFirst& graph1,
     const GraphSecond& graph2,
     const VertexIndexMapFirst vindex_map1,
     const VertexIndexMapSecond vindex_map2,
     EdgeEquivalencePredicate edges_equivalent,
     VertexEquivalencePredicate vertices_equivalent,
     bool only_connected_subgraphs,
     SubGraphInternalCallback subgraph_callback)
    {
      typedef mcgregor_common_subgraph_traits<GraphFirst,
        GraphSecond, VertexIndexMapFirst,
        VertexIndexMapSecond> SubGraphTraits;
        
      typename SubGraphTraits::correspondence_map_first_to_second_type
        correspondence_map_1_to_2(num_vertices(graph1), vindex_map1);

      BGL_FORALL_VERTICES_T(vertex1, graph1, GraphFirst) {
        put(correspondence_map_1_to_2, vertex1,
            graph_traits<GraphSecond>::null_vertex());
      }
                                                 
      typename SubGraphTraits::correspondence_map_second_to_first_type
        correspondence_map_2_to_1(num_vertices(graph2), vindex_map2);

      BGL_FORALL_VERTICES_T(vertex2, graph2, GraphSecond) {
        put(correspondence_map_2_to_1, vertex2,
            graph_traits<GraphFirst>::null_vertex());
      }

      typedef typename graph_traits<GraphFirst>::vertex_descriptor
        VertexFirst;
        
      std::stack<VertexFirst> vertex_stack1;

      mcgregor_common_subgraphs_internal
        (graph1, graph2,
         vindex_map1, vindex_map2,
         correspondence_map_1_to_2, correspondence_map_2_to_1,
         vertex_stack1,
         edges_equivalent, vertices_equivalent,
         only_connected_subgraphs,
         subgraph_callback);
    }

  template <typename GraphFirst,
            typename GraphSecond,
            typename VertexIndexMapFirst,
            typename VertexIndexMapSecond,
            typename EdgeEquivalencePredicate,
            typename VertexEquivalencePredicate,
            typename SubGraphCallback>
  void mcgregor_common_subgraphs
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   const VertexIndexMapFirst vindex_map1,
   const VertexIndexMapSecond vindex_map2,
   EdgeEquivalencePredicate edges_equivalent,
   VertexEquivalencePredicate vertices_equivalent,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback)
  {
      
    detail::mcgregor_common_subgraphs_internal_init
      (graph1, graph2,
       vindex_map1, vindex_map2,
       edges_equivalent, vertices_equivalent,
       only_connected_subgraphs,
       user_callback);
  }

  template <typename GraphFirst,
            typename GraphSecond,
            typename SubGraphCallback>
  void mcgregor_common_subgraphs
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback)
  {
      
    detail::mcgregor_common_subgraphs_internal_init
      (graph1, graph2,
       get(vertex_index, graph1), get(vertex_index, graph2),
       always_equivalent(), always_equivalent(),
       only_connected_subgraphs, user_callback);
  }

  template <typename GraphFirst,
            typename GraphSecond,
            typename SubGraphCallback,
            typename Param,
            typename Tag,
            typename Rest>
  void mcgregor_common_subgraphs
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback,
   const bgl_named_params<Param, Tag, Rest>& params)
  {
      
    detail::mcgregor_common_subgraphs_internal_init
      (graph1, graph2,
       choose_const_pmap(get_param(params, vertex_index1),
                         graph1, vertex_index),
       choose_const_pmap(get_param(params, vertex_index2),
                         graph2, vertex_index),
       choose_param(get_param(params, edges_equivalent_t()),
                    always_equivalent()),
       choose_param(get_param(params, vertices_equivalent_t()),
                    always_equivalent()),
       only_connected_subgraphs, user_callback);
  }


      unique_subgraph_interceptor(const GraphFirst& graph1,
                                  const GraphSecond& graph2,
                                  const VertexIndexMapFirst vindex_map1,
                                  const VertexIndexMapSecond vindex_map2,
                                  SubGraphCallback user_callback) :                                  
        m_graph1(graph1), m_graph2(graph2),
        m_vindex_map1(vindex_map1), m_vindex_map2(vindex_map2),
        m_subgraphs(make_shared<SubGraphList>()),
        m_user_callback(user_callback) { }

      
      template <typename CorrespondenceMapFirstToSecond,
                typename CorrespondenceMapSecondToFirst>
      bool operator()(CorrespondenceMapFirstToSecond correspondence_map_1_to_2,
                      CorrespondenceMapSecondToFirst correspondence_map_2_to_1,
                      VertexSizeFirst subgraph_size) {

        for (typename SubGraphList::const_iterator
               subgraph_iter = m_subgraphs->begin();
             subgraph_iter != m_subgraphs->end();
             ++subgraph_iter) {

          SubGraph subgraph_cached = *subgraph_iter;

          // Compare subgraph sizes
          if (subgraph_size != subgraph_cached.first) {
            continue;
          }
          
          if (!are_property_maps_different(correspondence_map_1_to_2,
                                           subgraph_cached.second.first,
                                           m_graph1)) {
                                    
            // New subgraph is a duplicate
            return (true);
          }
        }
  
        // Subgraph is unique, so make a cached copy
        CachedCorrespondenceMapFirstToSecond
          new_subgraph_1_to_2 = CachedCorrespondenceMapFirstToSecond
          (num_vertices(m_graph1), m_vindex_map1);

        CachedCorrespondenceMapSecondToFirst
          new_subgraph_2_to_1 = CorrespondenceMapSecondToFirst
          (num_vertices(m_graph2), m_vindex_map2);

        BGL_FORALL_VERTICES_T(vertex1, m_graph1, GraphFirst) {
          put(new_subgraph_1_to_2, vertex1, get(correspondence_map_1_to_2, vertex1));
        }

        BGL_FORALL_VERTICES_T(vertex2, m_graph2, GraphFirst) {
          put(new_subgraph_2_to_1, vertex2, get(correspondence_map_2_to_1, vertex2));
        }

        m_subgraphs->push_back(std::make_pair(subgraph_size,
          std::make_pair(new_subgraph_1_to_2,
                         new_subgraph_2_to_1)));
        
        return (m_user_callback(correspondence_map_1_to_2,
                                correspondence_map_2_to_1,
                                subgraph_size));
      }

  template <typename GraphFirst,
            typename GraphSecond,
            typename VertexIndexMapFirst,
            typename VertexIndexMapSecond,
            typename EdgeEquivalencePredicate,
            typename VertexEquivalencePredicate,
            typename SubGraphCallback>
  void mcgregor_common_subgraphs_unique
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   const VertexIndexMapFirst vindex_map1,
   const VertexIndexMapSecond vindex_map2,
   EdgeEquivalencePredicate edges_equivalent,
   VertexEquivalencePredicate vertices_equivalent,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback)
  {
    detail::unique_subgraph_interceptor<GraphFirst, GraphSecond,
      VertexIndexMapFirst, VertexIndexMapSecond,
      SubGraphCallback> unique_callback
      (graph1, graph2,
       vindex_map1, vindex_map2,
       user_callback);
      
    detail::mcgregor_common_subgraphs_internal_init
      (graph1, graph2,
       vindex_map1, vindex_map2,
       edges_equivalent, vertices_equivalent,
       only_connected_subgraphs, unique_callback);
  }

  template <typename GraphFirst,
            typename GraphSecond,
            typename SubGraphCallback>
  void mcgregor_common_subgraphs_unique
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback)
  {
    mcgregor_common_subgraphs_unique
      (graph1, graph2,
       get(vertex_index, graph1), get(vertex_index, graph2),
       always_equivalent(), always_equivalent(),
       only_connected_subgraphs, user_callback);
  }

  template <typename GraphFirst,
            typename GraphSecond,
            typename SubGraphCallback,
            typename Param,
            typename Tag,
            typename Rest>
  void mcgregor_common_subgraphs_unique
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback,
   const bgl_named_params<Param, Tag, Rest>& params)
  {
    mcgregor_common_subgraphs_unique
      (graph1, graph2,
       choose_const_pmap(get_param(params, vertex_index1),
                         graph1, vertex_index),
       choose_const_pmap(get_param(params, vertex_index2),
                         graph2, vertex_index),
       choose_param(get_param(params, edges_equivalent_t()),
                    always_equivalent()),
       choose_param(get_param(params, vertices_equivalent_t()),
                    always_equivalent()),
       only_connected_subgraphs, user_callback);
  }


      maximum_subgraph_interceptor(const GraphFirst& graph1,
                                   const GraphSecond& graph2,
                                   const VertexIndexMapFirst vindex_map1,
                                   const VertexIndexMapSecond vindex_map2,
                                   SubGraphCallback user_callback) :
        m_graph1(graph1), m_graph2(graph2),
        m_vindex_map1(vindex_map1), m_vindex_map2(vindex_map2),
        m_subgraphs(make_shared<SubGraphList>()),
        m_largest_size_so_far(make_shared<VertexSizeFirst>(0)),
        m_user_callback(user_callback) { }


      template <typename CorrespondenceMapFirstToSecond,
                typename CorrespondenceMapSecondToFirst>
      bool operator()(CorrespondenceMapFirstToSecond correspondence_map_1_to_2,
                      CorrespondenceMapSecondToFirst correspondence_map_2_to_1,
                      VertexSizeFirst subgraph_size) {

        if (subgraph_size > *m_largest_size_so_far) {
          m_subgraphs->clear();
          *m_largest_size_so_far = subgraph_size;
        }

        if (subgraph_size == *m_largest_size_so_far) {
        
          // Make a cached copy
          CachedCorrespondenceMapFirstToSecond
            new_subgraph_1_to_2 = CachedCorrespondenceMapFirstToSecond
            (num_vertices(m_graph1), m_vindex_map1);

          CachedCorrespondenceMapSecondToFirst
            new_subgraph_2_to_1 = CachedCorrespondenceMapSecondToFirst
            (num_vertices(m_graph2), m_vindex_map2);

          BGL_FORALL_VERTICES_T(vertex1, m_graph1, GraphFirst) {
            put(new_subgraph_1_to_2, vertex1, get(correspondence_map_1_to_2, vertex1));
          }

          BGL_FORALL_VERTICES_T(vertex2, m_graph2, GraphFirst) {
            put(new_subgraph_2_to_1, vertex2, get(correspondence_map_2_to_1, vertex2));
          }

          m_subgraphs->push_back(std::make_pair(subgraph_size,
            std::make_pair(new_subgraph_1_to_2,
                           new_subgraph_2_to_1)));
        }

        return (true);
      }


      void output_subgraphs() {
        for (typename SubGraphList::const_iterator
               subgraph_iter = m_subgraphs->begin();
             subgraph_iter != m_subgraphs->end();
             ++subgraph_iter) {

          SubGraph subgraph_cached = *subgraph_iter;
          m_user_callback(subgraph_cached.second.first,
                          subgraph_cached.second.second,
                          subgraph_cached.first);
        }
      }

  template <typename GraphFirst,
            typename GraphSecond,
            typename VertexIndexMapFirst,
            typename VertexIndexMapSecond,
            typename EdgeEquivalencePredicate,
            typename VertexEquivalencePredicate,
            typename SubGraphCallback>
  void mcgregor_common_subgraphs_maximum
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   const VertexIndexMapFirst vindex_map1,
   const VertexIndexMapSecond vindex_map2,
   EdgeEquivalencePredicate edges_equivalent,
   VertexEquivalencePredicate vertices_equivalent,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback)
  {
    detail::maximum_subgraph_interceptor<GraphFirst, GraphSecond,
      VertexIndexMapFirst, VertexIndexMapSecond, SubGraphCallback>
      max_interceptor
      (graph1, graph2, vindex_map1, vindex_map2, user_callback);
      
    detail::mcgregor_common_subgraphs_internal_init
      (graph1, graph2,
       vindex_map1, vindex_map2,
       edges_equivalent, vertices_equivalent,
       only_connected_subgraphs, max_interceptor);

    // Only output the largest subgraphs
    max_interceptor.output_subgraphs();
  }

  template <typename GraphFirst,
            typename GraphSecond,
            typename SubGraphCallback>
  void mcgregor_common_subgraphs_maximum
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback)
  {
    mcgregor_common_subgraphs_maximum
      (graph1, graph2,
       get(vertex_index, graph1), get(vertex_index, graph2),
       always_equivalent(), always_equivalent(),
       only_connected_subgraphs, user_callback);
  }

  template <typename GraphFirst,
            typename GraphSecond,
            typename SubGraphCallback,
            typename Param,
            typename Tag,
            typename Rest>
  void mcgregor_common_subgraphs_maximum
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback,
   const bgl_named_params<Param, Tag, Rest>& params)
  {
    mcgregor_common_subgraphs_maximum
      (graph1, graph2,
       choose_const_pmap(get_param(params, vertex_index1),
                         graph1, vertex_index),
       choose_const_pmap(get_param(params, vertex_index2),
                         graph2, vertex_index),
       choose_param(get_param(params, edges_equivalent_t()),
                    always_equivalent()),
       choose_param(get_param(params, vertices_equivalent_t()),
                    always_equivalent()),
       only_connected_subgraphs, user_callback);
  }


      unique_maximum_subgraph_interceptor(const GraphFirst& graph1,
                                          const GraphSecond& graph2,
                                          const VertexIndexMapFirst vindex_map1,
                                          const VertexIndexMapSecond vindex_map2,
                                          SubGraphCallback user_callback) :                                  
        m_graph1(graph1), m_graph2(graph2),
        m_vindex_map1(vindex_map1), m_vindex_map2(vindex_map2),
        m_subgraphs(make_shared<SubGraphList>()),
        m_largest_size_so_far(make_shared<VertexSizeFirst>(0)),
        m_user_callback(user_callback) { }
        
      
      template <typename CorrespondenceMapFirstToSecond,
                typename CorrespondenceMapSecondToFirst>
      bool operator()(CorrespondenceMapFirstToSecond correspondence_map_1_to_2,
                      CorrespondenceMapSecondToFirst correspondence_map_2_to_1,
                      VertexSizeFirst subgraph_size) {

        if (subgraph_size > *m_largest_size_so_far) {
          m_subgraphs->clear();
          *m_largest_size_so_far = subgraph_size;
        }

        if (subgraph_size == *m_largest_size_so_far) {

          // Check if subgraph is unique
          for (typename SubGraphList::const_iterator
                 subgraph_iter = m_subgraphs->begin();
               subgraph_iter != m_subgraphs->end();
               ++subgraph_iter) {
  
            SubGraph subgraph_cached = *subgraph_iter;
  
            if (!are_property_maps_different(correspondence_map_1_to_2,
                                             subgraph_cached.second.first,
                                             m_graph1)) {
                                      
              // New subgraph is a duplicate
              return (true);
            }
          }
    
          // Subgraph is unique, so make a cached copy
          CachedCorrespondenceMapFirstToSecond
            new_subgraph_1_to_2 = CachedCorrespondenceMapFirstToSecond
            (num_vertices(m_graph1), m_vindex_map1);

          CachedCorrespondenceMapSecondToFirst
            new_subgraph_2_to_1 = CachedCorrespondenceMapSecondToFirst
            (num_vertices(m_graph2), m_vindex_map2);

          BGL_FORALL_VERTICES_T(vertex1, m_graph1, GraphFirst) {
            put(new_subgraph_1_to_2, vertex1, get(correspondence_map_1_to_2, vertex1));
          }

          BGL_FORALL_VERTICES_T(vertex2, m_graph2, GraphFirst) {
            put(new_subgraph_2_to_1, vertex2, get(correspondence_map_2_to_1, vertex2));
          }

          m_subgraphs->push_back(std::make_pair(subgraph_size,
            std::make_pair(new_subgraph_1_to_2,
                           new_subgraph_2_to_1)));
        }
    
        return (true);
      }


      void output_subgraphs() {
        for (typename SubGraphList::const_iterator
               subgraph_iter = m_subgraphs->begin();
             subgraph_iter != m_subgraphs->end();
             ++subgraph_iter) {

          SubGraph subgraph_cached = *subgraph_iter;
          m_user_callback(subgraph_cached.second.first,
                          subgraph_cached.second.second,
                          subgraph_cached.first);
        }
      }

  template <typename GraphFirst,
            typename GraphSecond,
            typename VertexIndexMapFirst,
            typename VertexIndexMapSecond,
            typename EdgeEquivalencePredicate,
            typename VertexEquivalencePredicate,
            typename SubGraphCallback>
  void mcgregor_common_subgraphs_maximum_unique
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   const VertexIndexMapFirst vindex_map1,
   const VertexIndexMapSecond vindex_map2,
   EdgeEquivalencePredicate edges_equivalent,
   VertexEquivalencePredicate vertices_equivalent,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback)
  {
    detail::unique_maximum_subgraph_interceptor<GraphFirst, GraphSecond,
      VertexIndexMapFirst, VertexIndexMapSecond, SubGraphCallback>
      unique_max_interceptor
      (graph1, graph2, vindex_map1, vindex_map2, user_callback);
      
    detail::mcgregor_common_subgraphs_internal_init
      (graph1, graph2,
       vindex_map1, vindex_map2,
       edges_equivalent, vertices_equivalent,
       only_connected_subgraphs, unique_max_interceptor);

    // Only output the largest, unique subgraphs
    unique_max_interceptor.output_subgraphs();
  }

  template <typename GraphFirst,
            typename GraphSecond,
            typename SubGraphCallback>
  void mcgregor_common_subgraphs_maximum_unique
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback)
  {

    mcgregor_common_subgraphs_maximum_unique
      (graph1, graph2,
       get(vertex_index, graph1), get(vertex_index, graph2),
       always_equivalent(), always_equivalent(),
       only_connected_subgraphs, user_callback);
  }

  template <typename GraphFirst,
            typename GraphSecond,
            typename SubGraphCallback,
            typename Param,
            typename Tag,
            typename Rest>
  void mcgregor_common_subgraphs_maximum_unique
  (const GraphFirst& graph1,
   const GraphSecond& graph2,
   bool only_connected_subgraphs,
   SubGraphCallback user_callback,
   const bgl_named_params<Param, Tag, Rest>& params)
  {
    mcgregor_common_subgraphs_maximum_unique
      (graph1, graph2,
       choose_const_pmap(get_param(params, vertex_index1),
                         graph1, vertex_index),
       choose_const_pmap(get_param(params, vertex_index2),
                         graph2, vertex_index),
       choose_param(get_param(params, edges_equivalent_t()),
                    always_equivalent()),
       choose_param(get_param(params, vertices_equivalent_t()),
                    always_equivalent()),
       only_connected_subgraphs, user_callback);
  }

  template <typename GraphSecond,
            typename GraphFirst,
            typename CorrespondenceMapFirstToSecond,
            typename MembershipMapFirst>
  void fill_membership_map
  (const GraphFirst& graph1,
   const CorrespondenceMapFirstToSecond correspondence_map_1_to_2,
   MembershipMapFirst membership_map1) {

    BGL_FORALL_VERTICES_T(vertex1, graph1, GraphFirst) {
      put(membership_map1, vertex1,
          get(correspondence_map_1_to_2, vertex1) != graph_traits<GraphSecond>::null_vertex());
    }

  }

  template <typename Graph,
            typename MembershipMap>            
  typename membership_filtered_graph_traits<Graph, MembershipMap>::graph_type
  make_membership_filtered_graph
  (const Graph& graph,
   MembershipMap& membership_map) {

    typedef membership_filtered_graph_traits<Graph, MembershipMap> MFGTraits;
    typedef typename MFGTraits::graph_type MembershipFilteredGraph;

    typename MFGTraits::vertex_filter_type v_filter(membership_map);

    return (MembershipFilteredGraph(graph, keep_all(), v_filter));
    
  }






        
      template <typename ArgumentPack>
      bool dispatched_boyer_myrvold(ArgumentPack const& args, 
                                    mpl::true_, 
                                    mpl::true_
                                    )
      {
        //Dispatch for no planar embedding, no kuratowski subgraph isolation

        typedef typename remove_const
                < 
                    typename remove_reference
                    < typename parameter::binding
                        < ArgumentPack, tag::graph>::type 
                    >::type 
                >::type graph_t;

        typedef typename parameter::binding
          < ArgumentPack, 
            tag::vertex_index_map,
            typename property_map
              < typename remove_reference<graph_t>::type, 
                vertex_index_t>::const_type
          >::type vertex_index_map_t;

        boyer_myrvold_impl
          <graph_t, 
           vertex_index_map_t,
           graph::detail::no_old_handles,
           graph::detail::no_embedding
          >
          planarity_tester(args[graph], 
                           args[vertex_index_map | 
                                get(vertex_index, args[graph])
                                ]
                           );

        return planarity_tester.is_planar() ? true : false;
      }



    
      template <typename ArgumentPack>
      bool dispatched_boyer_myrvold(ArgumentPack const& args, 
                                    mpl::true_, 
                                    mpl::false_
                                    )
      {
        //Dispatch for no planar embedding, kuratowski subgraph isolation
        typedef typename remove_const
                < 
                    typename remove_reference
                    < typename parameter::binding
                        < ArgumentPack, tag::graph>::type 
                    >::type 
                >::type graph_t;
        
        typedef typename parameter::binding
          < ArgumentPack, 
            tag::vertex_index_map,
            typename property_map<graph_t, vertex_index_t>::type
          >::type vertex_index_map_t;
      
        boyer_myrvold_impl 
          <graph_t, 
           vertex_index_map_t,
           graph::detail::store_old_handles,
           graph::detail::no_embedding
          >
          planarity_tester(args[graph], 
                           args[vertex_index_map | 
                                get(vertex_index, args[graph])
                                ]
                           );

        if (planarity_tester.is_planar())
          return true;
        else
          {
            planarity_tester.extract_kuratowski_subgraph
              (args[kuratowski_subgraph],
               args[edge_index_map|get(edge_index, args[graph])]
               );          
            return false;
          }
      }




    
      template <typename ArgumentPack>
      bool dispatched_boyer_myrvold(ArgumentPack const& args, 
                                    mpl::false_, 
                                    mpl::true_
                                    )
      {
        //Dispatch for planar embedding, no kuratowski subgraph isolation
        typedef typename remove_const
                < 
                    typename remove_reference
                    < typename parameter::binding
                        < ArgumentPack, tag::graph>::type 
                    >::type 
                >::type graph_t;        
        
        typedef typename parameter::binding
          < ArgumentPack, 
          tag::vertex_index_map,
          typename property_map<graph_t, vertex_index_t>::type
          >::type  vertex_index_map_t;

        boyer_myrvold_impl
          <graph_t, 
           vertex_index_map_t,
           graph::detail::no_old_handles,
#ifdef BOOST_GRAPH_PREFER_STD_LIB
           graph::detail::std_list
#else
           graph::detail::recursive_lazy_list
#endif
          >
          planarity_tester(args[graph], 
                           args[vertex_index_map | 
                                get(vertex_index, args[graph])
                                ]
                           );

        if (planarity_tester.is_planar())
          {
            planarity_tester.make_edge_permutation(args[embedding]);
            return true;
          }
        else
          return false;
      }

    


      template <typename ArgumentPack>
      bool dispatched_boyer_myrvold(ArgumentPack const& args, 
                                    mpl::false_, 
                                    mpl::false_
                                    )
      {
        //Dispatch for planar embedding, kuratowski subgraph isolation
        typedef typename remove_const
                < 
                    typename remove_reference
                    < typename parameter::binding
                        < ArgumentPack, tag::graph>::type 
                    >::type 
                >::type graph_t;        
        
        typedef typename parameter::binding
          < ArgumentPack, 
          tag::vertex_index_map, 
          typename property_map<graph_t, vertex_index_t>::type
          >::type vertex_index_map_t;
        
        boyer_myrvold_impl
          <graph_t, 
          vertex_index_map_t,
          graph::detail::store_old_handles,
#ifdef BOOST_BGL_PREFER_STD_LIB
           graph::detail::std_list
#else
           graph::detail::recursive_lazy_list
#endif
          >
          planarity_tester(args[graph], 
                           args[vertex_index_map | 
                                get(vertex_index, args[graph])
                                ]
                           );

        if (planarity_tester.is_planar())
          {
            planarity_tester.make_edge_permutation(args[embedding]);
            return true;
          }
        else
          {
            planarity_tester.extract_kuratowski_subgraph
              (args[kuratowski_subgraph], 
               args[edge_index_map | get(edge_index, args[graph])]
               );          
            return false;
          } 
      }





      template <typename ArgumentPack>
      bool boyer_myrvold_planarity_test(ArgumentPack const& args)
      {
        
        typedef typename parameter::binding 
          < ArgumentPack, 
            tag::kuratowski_subgraph,
            const no_kuratowski_subgraph_isolation&
          >::type 
          kuratowski_arg_t;
       
        typedef typename parameter::binding 
          < ArgumentPack, 
            tag::embedding,
            const no_planar_embedding&
          >::type 
          embedding_arg_t;
      
         return dispatched_boyer_myrvold
           (args, 
            boost::is_same
              <embedding_arg_t, const no_planar_embedding&>(),
            boost::is_same
              <kuratowski_arg_t, const no_kuratowski_subgraph_isolation&>() 
            );
      }

  
    
  template <typename A0>
  bool boyer_myrvold_planarity_test(A0 const& arg0)
  {
    return boyer_myrvold_params::core::boyer_myrvold_planarity_test
      (boyer_myrvold_params::boyer_myrvold_params_t()(arg0));
  }

  
  template <typename A0, typename A1>
  //  bool boyer_myrvold_planarity_test(A0 const& arg0, A1 const& arg1)
  bool boyer_myrvold_planarity_test(A0 const& arg0, A1 const& arg1)
  {
    return boyer_myrvold_params::core::boyer_myrvold_planarity_test
      (boyer_myrvold_params::boyer_myrvold_params_t()(arg0,arg1));
  }

  
  template <typename A0, typename A1, typename A2>
  bool boyer_myrvold_planarity_test(A0 const& arg0, 
                                    A1 const& arg1, 
                                    A2 const& arg2
                                    )
  {
    return boyer_myrvold_params::core::boyer_myrvold_planarity_test
      (boyer_myrvold_params::boyer_myrvold_params_t()(arg0,arg1,arg2));
  }

    
  template <typename A0, typename A1, typename A2, typename A3>
  bool boyer_myrvold_planarity_test(A0 const& arg0,
                                    A1 const& arg1, 
                                    A2 const& arg2, 
                                    A3 const& arg3
                                    )
  {
    return boyer_myrvold_params::core::boyer_myrvold_planarity_test
      (boyer_myrvold_params::boyer_myrvold_params_t()(arg0,arg1,arg2,arg3));
  }


  template <typename A0, typename A1, typename A2, typename A3, typename A4>
  bool boyer_myrvold_planarity_test(A0 const& arg0, 
                                    A1 const& arg1, 
                                    A2 const& arg2, 
                                    A3 const& arg3, 
                                    A4 const& arg4
                                    )
  {
    return boyer_myrvold_params::core::boyer_myrvold_planarity_test
      (boyer_myrvold_params::boyer_myrvold_params_t()
       (arg0,arg1,arg2,arg3,arg4)
       );
  }

    template<typename T, typename BinaryPredicate>
    T min_with_compare(const T& x, const T& y, const BinaryPredicate& compare)
    {
      if (compare(x, y)) return x; 
      else return y;
    }


    template<typename VertexListGraph, typename DistanceMatrix, 
      typename BinaryPredicate, typename BinaryFunction,
      typename Infinity, typename Zero>
    bool floyd_warshall_dispatch(const VertexListGraph& g, 
      DistanceMatrix& d, const BinaryPredicate &compare, 
      const BinaryFunction &combine, const Infinity& inf, 
      const Zero& zero)
    {
      typename graph_traits<VertexListGraph>::vertex_iterator 
        i, lasti, j, lastj, k, lastk;
    
      
      for (boost::tie(k, lastk) = vertices(g); k != lastk; k++)
        for (boost::tie(i, lasti) = vertices(g); i != lasti; i++)
          if(d[*i][*k] != inf)
            for (boost::tie(j, lastj) = vertices(g); j != lastj; j++)
              if(d[*k][*j] != inf)
                d[*i][*j] = 
                  detail::min_with_compare(d[*i][*j], 
                                           combine(d[*i][*k], d[*k][*j]),
                                           compare);
      
      
      for (boost::tie(i, lasti) = vertices(g); i != lasti; i++)
        if (compare(d[*i][*i], zero))
          return false;
      return true;
    }


  template <typename VertexListGraph, typename DistanceMatrix, 
    typename BinaryPredicate, typename BinaryFunction,
    typename Infinity, typename Zero>
  bool floyd_warshall_initialized_all_pairs_shortest_paths(
    const VertexListGraph& g, DistanceMatrix& d, 
    const BinaryPredicate& compare, 
    const BinaryFunction& combine, const Infinity& inf, 
    const Zero& zero)
  {
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<VertexListGraph> ));
  
    return detail::floyd_warshall_dispatch(g, d, compare, combine, 
    inf, zero);
  }

  

  
  template <typename VertexAndEdgeListGraph, typename DistanceMatrix, 
    typename WeightMap, typename BinaryPredicate, 
    typename BinaryFunction, typename Infinity, typename Zero>
  bool floyd_warshall_all_pairs_shortest_paths(
    const VertexAndEdgeListGraph& g, 
    DistanceMatrix& d, const WeightMap& w, 
    const BinaryPredicate& compare, const BinaryFunction& combine, 
    const Infinity& inf, const Zero& zero)
  {
    BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<VertexAndEdgeListGraph> ));
    BOOST_CONCEPT_ASSERT(( EdgeListGraphConcept<VertexAndEdgeListGraph> ));
    BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<VertexAndEdgeListGraph> ));
  
    typename graph_traits<VertexAndEdgeListGraph>::vertex_iterator 
      firstv, lastv, firstv2, lastv2;
    typename graph_traits<VertexAndEdgeListGraph>::edge_iterator first, last;
  
    
    for(boost::tie(firstv, lastv) = vertices(g); firstv != lastv; firstv++)
      for(boost::tie(firstv2, lastv2) = vertices(g); firstv2 != lastv2; firstv2++)
        d[*firstv][*firstv2] = inf;
    
    
    for(boost::tie(firstv, lastv) = vertices(g); firstv != lastv; firstv++)
      d[*firstv][*firstv] = zero;
    
    
    for(boost::tie(first, last) = edges(g); first != last; first++)
    {
      if (d[source(*first, g)][target(*first, g)] != inf) {
        d[source(*first, g)][target(*first, g)] = 
          detail::min_with_compare(
            get(w, *first), 
            d[source(*first, g)][target(*first, g)],
            compare);
      } else 
        d[source(*first, g)][target(*first, g)] = get(w, *first);
    }
    
    bool is_undirected = is_same<typename 
      graph_traits<VertexAndEdgeListGraph>::directed_category, 
      undirected_tag>::value;
    if (is_undirected)
    {
      for(boost::tie(first, last) = edges(g); first != last; first++)
      {
        if (d[target(*first, g)][source(*first, g)] != inf)
          d[target(*first, g)][source(*first, g)] = 
            detail::min_with_compare(
              get(w, *first), 
              d[target(*first, g)][source(*first, g)],
              compare);
        else 
          d[target(*first, g)][source(*first, g)] = get(w, *first);
      }
    }
    
  
    return detail::floyd_warshall_dispatch(g, d, compare, combine, 
      inf, zero);
  }
        
    template <class VertexListGraph, class DistanceMatrix, 
      class WeightMap, class P, class T, class R>
    bool floyd_warshall_init_dispatch(const VertexListGraph& g, 
      DistanceMatrix& d, WeightMap /*w*/, 
      const bgl_named_params<P, T, R>& params)
    {
      typedef typename property_traits<WeightMap>::value_type WM;
      WM inf =
        choose_param(get_param(params, distance_inf_t()), 
          std::numeric_limits<WM>::max BOOST_PREVENT_MACRO_SUBSTITUTION());
    
      return floyd_warshall_initialized_all_pairs_shortest_paths(g, d,
        choose_param(get_param(params, distance_compare_t()), 
          std::less<WM>()),
        choose_param(get_param(params, distance_combine_t()), 
          closed_plus<WM>(inf)),
        inf,
        choose_param(get_param(params, distance_zero_t()), 
          WM()));
    }

    

    
    template <class VertexAndEdgeListGraph, class DistanceMatrix, 
      class WeightMap, class P, class T, class R>
    bool floyd_warshall_noninit_dispatch(const VertexAndEdgeListGraph& g, 
      DistanceMatrix& d, WeightMap w, 
      const bgl_named_params<P, T, R>& params)
    {
      typedef typename property_traits<WeightMap>::value_type WM;
    
      WM inf =
        choose_param(get_param(params, distance_inf_t()), 
          std::numeric_limits<WM>::max BOOST_PREVENT_MACRO_SUBSTITUTION());
      return floyd_warshall_all_pairs_shortest_paths(g, d, w,
        choose_param(get_param(params, distance_compare_t()), 
          std::less<WM>()),
        choose_param(get_param(params, distance_combine_t()), 
          closed_plus<WM>(inf)),
        inf,
        choose_param(get_param(params, distance_zero_t()), 
          WM()));
    }


  
  
  template <class VertexListGraph, class DistanceMatrix, class P, 
    class T, class R>
  bool floyd_warshall_initialized_all_pairs_shortest_paths(
    const VertexListGraph& g, DistanceMatrix& d, 
    const bgl_named_params<P, T, R>& params)
  {
    return detail::floyd_warshall_init_dispatch(g, d, 
      choose_const_pmap(get_param(params, edge_weight), g, edge_weight), 
      params);
  }

  
  template <class VertexListGraph, class DistanceMatrix>
  bool floyd_warshall_initialized_all_pairs_shortest_paths(
    const VertexListGraph& g, DistanceMatrix& d)
  {
    bgl_named_params<int,int> params(0);
    return detail::floyd_warshall_init_dispatch(g, d,
      get(edge_weight, g), params);
  }

  

  
  
  template <class VertexAndEdgeListGraph, class DistanceMatrix, 
    class P, class T, class R>
  bool floyd_warshall_all_pairs_shortest_paths(
    const VertexAndEdgeListGraph& g, DistanceMatrix& d, 
    const bgl_named_params<P, T, R>& params)
  {
    return detail::floyd_warshall_noninit_dispatch(g, d, 
      choose_const_pmap(get_param(params, edge_weight), g, edge_weight), 
      params);
  }

  
  template <class VertexAndEdgeListGraph, class DistanceMatrix>
  bool floyd_warshall_all_pairs_shortest_paths(
    const VertexAndEdgeListGraph& g, DistanceMatrix& d)
  {
    bgl_named_params<int,int> params(0);
    return detail::floyd_warshall_noninit_dispatch(g, d,
      get(edge_weight, g), params);
  }


  template <class VertexAndEdgeListGraph, class DistanceMatrix,
            class VertexID, class Weight, typename BinaryPredicate, 
            typename BinaryFunction, typename Infinity, class DistanceZero>
  bool
  johnson_all_pairs_shortest_paths(VertexAndEdgeListGraph& g1, 
               DistanceMatrix& D,
               VertexID id1, Weight w1, const BinaryPredicate& compare, 
               const BinaryFunction& combine, const Infinity& inf,
               DistanceZero zero)
  {
    typedef graph_traits<VertexAndEdgeListGraph> Traits1;
    typedef typename property_traits<Weight>::value_type DT;
    BOOST_CONCEPT_ASSERT(( BasicMatrixConcept<DistanceMatrix,
      typename Traits1::vertices_size_type, DT> ));

    typedef typename Traits1::directed_category DirCat;
    bool is_undirected = is_same<DirCat, undirected_tag>::value;

    typedef adjacency_list<vecS, vecS, directedS, 
      property< vertex_distance_t, DT>,
      property< edge_weight_t, DT, 
      property< edge_weight2_t, DT > > > Graph2;
    typedef graph_traits<Graph2> Traits2;

    Graph2 g2(num_vertices(g1) + 1);
    typename property_map<Graph2, edge_weight_t>::type 
      w = get(edge_weight, g2);
    typename property_map<Graph2, edge_weight2_t>::type 
      w_hat = get(edge_weight2, g2);
    typename property_map<Graph2, vertex_distance_t>::type 
      d = get(vertex_distance, g2);
    typedef typename property_map<Graph2, vertex_index_t>::type VertexID2;
    VertexID2 id2 = get(vertex_index, g2);

    // Construct g2 where V[g2] = V[g1] U {s}
    //   and  E[g2] = E[g1] U {(s,v)| v in V[g1]}
    std::vector<typename Traits1::vertex_descriptor> 
      verts1(num_vertices(g1) + 1);
    typename Traits2::vertex_descriptor s = *vertices(g2).first;
    {
      typename Traits1::vertex_iterator v, v_end;
      int i = 1;
      for (boost::tie(v, v_end) = vertices(g1); v != v_end; ++v, ++i) {
        typename Traits2::edge_descriptor e; bool z;
        boost::tie(e, z) = add_edge(s, get(id1, *v) + 1, g2);
        put(w, e, zero);
        verts1[i] = *v;
      }
      typename Traits1::edge_iterator e, e_end;
      for (boost::tie(e, e_end) = edges(g1); e != e_end; ++e) {
        typename Traits2::edge_descriptor e2; bool z;
        boost::tie(e2, z) = add_edge(get(id1, source(*e, g1)) + 1, 
                                     get(id1, target(*e, g1)) + 1, g2);
        put(w, e2, get(w1, *e));
        if (is_undirected) {
          boost::tie(e2, z) = add_edge(get(id1, target(*e, g1)) + 1, 
                                       get(id1, source(*e, g1)) + 1, g2);
          put(w, e2, get(w1, *e));
        }
      }
    }
    typename Traits2::vertex_iterator v, v_end, u, u_end;
    typename Traits2::edge_iterator e, e_end;
    shared_array_property_map<DT,VertexID2> h(num_vertices(g2), id2);

    for (boost::tie(v, v_end) = vertices(g2); v != v_end; ++v)
      put(d, *v, inf);

    put(d, s, zero);
    // Using the non-named parameter versions of bellman_ford and
    // dijkstra for portability reasons.
    dummy_property_map pred; bellman_visitor<> bvis;
    if (bellman_ford_shortest_paths
        (g2, num_vertices(g2), w, pred, d, combine, compare, bvis)) {
      for (boost::tie(v, v_end) = vertices(g2); v != v_end; ++v)
        put(h, *v, get(d, *v));
      // Reweight the edges to remove negatives
      for (boost::tie(e, e_end) = edges(g2); e != e_end; ++e) {
        typename Traits2::vertex_descriptor a = source(*e, g2),
          b = target(*e, g2);
        put(w_hat, *e, combine((get(h, a) - get(h, b)), get(w, *e)));
      }
      for (boost::tie(u, u_end) = vertices(g2); u != u_end; ++u) {
        dijkstra_visitor<> dvis;
        dijkstra_shortest_paths
          (g2, *u, pred, d, w_hat, id2, compare, combine, inf, zero,dvis);
        for (boost::tie(v, v_end) = vertices(g2); v != v_end; ++v) {
          if (*u != s && *v != s) {
            D[get(id2, *u)-1][get(id2, *v)-1] = combine((get(h, *v) - get(h, *u)), get(d, *v));
          }
        }
      }
      return true;
    } else
      return false;
  }


  template <class VertexAndEdgeListGraph, class DistanceMatrix,
            class VertexID, class Weight, class DistanceZero>
  bool
  johnson_all_pairs_shortest_paths(VertexAndEdgeListGraph& g1, 
               DistanceMatrix& D,
               VertexID id1, Weight w1, DistanceZero zero)
  {
    typedef typename property_traits<Weight>::value_type WT;
    return johnson_all_pairs_shortest_paths(g1, D, id1, w1, 
                                            std::less<WT>(),
                                            closed_plus<WT>(),
                                            (std::numeric_limits<WT>::max)(),
                                            zero);
  }


    template <class VertexAndEdgeListGraph, class DistanceMatrix,
              class P, class T, class R, class Weight, 
              class VertexID>
    bool
    johnson_dispatch(VertexAndEdgeListGraph& g, 
                     DistanceMatrix& D,
                     const bgl_named_params<P, T, R>& params,
                     Weight w, VertexID id)
    {
      typedef typename property_traits<Weight>::value_type WT;
      
      return johnson_all_pairs_shortest_paths
        (g, D, id, w,
        choose_param(get_param(params, distance_compare_t()), 
          std::less<WT>()),
        choose_param(get_param(params, distance_combine_t()), 
          closed_plus<WT>()),
        choose_param(get_param(params, distance_inf_t()), 
          std::numeric_limits<WT>::max BOOST_PREVENT_MACRO_SUBSTITUTION()),
         choose_param(get_param(params, distance_zero_t()), WT()) );
    }


  template <class VertexAndEdgeListGraph, class DistanceMatrix,
            class P, class T, class R>
  bool
  johnson_all_pairs_shortest_paths
    (VertexAndEdgeListGraph& g, 
     DistanceMatrix& D,
     const bgl_named_params<P, T, R>& params)
  {
    return detail::johnson_dispatch
      (g, D, params,
       choose_const_pmap(get_param(params, edge_weight), g, edge_weight),
       choose_const_pmap(get_param(params, vertex_index), g, vertex_index)
       );
  }


  template <class VertexAndEdgeListGraph, class DistanceMatrix>
  bool
  johnson_all_pairs_shortest_paths
    (VertexAndEdgeListGraph& g, DistanceMatrix& D)
  {
    bgl_named_params<int,int> params(1);
    return detail::johnson_dispatch
      (g, D, params, get(edge_weight, g), get(vertex_index, g));
  }


  template <typename Graph, typename ComponentLists, 
    typename ComponentNumberMap,
    typename CondensationGraph, typename EdgeMultiplicityMap>
  void create_condensation_graph(const Graph& g, 
                                 const ComponentLists& components,
                                 ComponentNumberMap component_number,
                                 CondensationGraph& cg,
                                 EdgeMultiplicityMap edge_mult_map)
  {
    typedef typename graph_traits<Graph>::vertex_descriptor vertex;
    typedef typename graph_traits<Graph>::vertices_size_type size_type;
    typedef typename graph_traits<CondensationGraph>::vertex_descriptor 
      cg_vertex;
    std::vector<cg_vertex> to_cg_vertex(components.size());
    for (size_type s = 0; s < components.size(); ++s)
      to_cg_vertex[s] = add_vertex(cg);

    for (size_type si = 0; si < components.size(); ++si) {
      cg_vertex s = to_cg_vertex[si];
      std::vector<cg_vertex> adj;
      for (size_type i = 0; i < components[si].size(); ++i) {
        vertex u = components[s][i];
        typename graph_traits<Graph>::adjacency_iterator v, v_end;
        for (boost::tie(v, v_end) = adjacent_vertices(u, g); v != v_end; ++v) {
          cg_vertex t = to_cg_vertex[component_number[*v]];
          if (s != t) // Avoid loops in the condensation graph
            adj.push_back(t);
        }
      }
      std::sort(adj.begin(), adj.end());
      if (! adj.empty()) {
        size_type i = 0;
        cg_vertex t = adj[i];
        typename graph_traits<CondensationGraph>::edge_descriptor e;
        bool inserted;
        boost::tie(e, inserted) = add_edge(s, t, cg);
        put(edge_mult_map, e, 1);
        ++i;
        while (i < adj.size()) {
          if (adj[i] == t)
            put(edge_mult_map, e, get(edge_mult_map, e) + 1);
          else {
            t = adj[i];
            boost::tie(e, inserted) = add_edge(s, t, cg);
            put(edge_mult_map, e, 1);
          }
          ++i;
        }
      }
    }
  }

  
  template <typename Graph, typename ComponentLists, 
    typename ComponentNumberMap, typename CondensationGraph>
  void create_condensation_graph(const Graph& g, 
                                 const ComponentLists& components,
                                 ComponentNumberMap component_number,
                                 CondensationGraph& cg)
  {
    create_condensation_graph(g, components, component_number, cg, 
                              dummy_property_map());
  }

void const_constraints(const B& cbuf) {
      typedef typename boost::add_const<typename boost::remove_reference<value_type>::type>::type& const_reference;
      
      const_reference ct = cbuf.top();
      s = cbuf.size();
      if (cbuf.empty())
        dummy = __LINE__;
    }

void const_constraints(const Q& cq) {
      if (cq.contains(g_ct))
        dummy = __LINE__;
    }

void const_constraints(const Q& cq) {
      km = cq.keys();
      k = get(km, g_ct);
    }

        inline Graph* empty( long n ) /* and provide workaround */
        { return board(n,0L,0L,0L,2L,0L,0L); }

    sgb_edge() : _arc(0), _src(0) { }

    sgb_out_edge_iterator() : _src(0), _arc(0) {}

    boost::sgb_edge operator*() { return boost::sgb_edge(_arc, _src); }

    self& operator++() { _arc = _arc->next; return *this; }

    sgb_adj_iterator() : _arc(0) {}

    Vertex* operator*() { return _arc->tip; }

    self& operator++() { _arc = _arc->next; return *this; }

    sgb_vertex_iterator() : _v(0) { }

    Vertex* operator*() { return _v; }

    self& operator++() { ++_v; return *this; }


  inline boost::graph_traits<sgb_graph_ptr>::degree_size_type
  out_degree(Vertex* u, sgb_const_graph_ptr g)
  {
    boost::graph_traits<sgb_graph_ptr>::out_edge_iterator i, i_end;
    boost::tie(i, i_end) = out_edges(u, g);
    return std::distance(i, i_end);
  }


  inline long num_vertices(sgb_const_graph_ptr g) { return g->n; }

  inline long num_edges(sgb_const_graph_ptr g) { return g->m; }


  inline Vertex* vertex(long v, sgb_const_graph_ptr g)
    { return g->vertices + v; }

    sgb_vertex_id_map() : _g(0) { }

    sgb_vertex_id_map(sgb_graph_ptr g) : _g(g) { }

    long operator[](Vertex* v) const { return v - _g->vertices; }

  inline sgb_vertex_id_map get(vertex_index_t, sgb_graph_ptr g) {
    return sgb_vertex_id_map(g);
  }

    char* operator[](Vertex* v) const { return v->name; }

  inline sgb_vertex_name_map get(vertex_name_t, sgb_graph_ptr) {
    return sgb_vertex_name_map();
  }

  inline Vertex*& get_util(util& u, Vertex*) { return u.V; }
 \
  template <class T> \
  inline T& get_util_field(KIND* k, X##_property<T>) { \
    return get_util(k->X, T());  }

  SGB_GET_UTIL_FIELD(Vertex, u)

    explicit sgb_vertex_util_map(Tag tag = Tag()): tag(tag) {}

    reference operator[](Vertex* v) const {
      return get_util_field(v, tag); 
    }

    explicit sgb_edge_util_map(Tag tag = Tag()): tag(tag) {}

    reference operator[](const sgb_edge& e) const {
      return get_util_field(e._arc, tag); 
    }
  

  template <class Tag>
  inline sgb_vertex_util_map<Tag, const typename Tag::type&>
  get_property_map(Tag, const sgb_graph_ptr& g, vertex_property_tag) {
    return sgb_vertex_util_map<Tag, const typename Tag::type&>();
  }

  template <class Tag>
  inline sgb_vertex_util_map<Tag, typename Tag::type&>
  get_property_map(Tag, sgb_graph_ptr& g, vertex_property_tag) {
    return sgb_vertex_util_map<Tag, typename Tag::type&>();
  }


  template <class Tag>
  inline sgb_edge_util_map<Tag, const typename Tag::type&> 
  get_property_map(Tag, const sgb_graph_ptr& g, edge_property_tag) {
    return sgb_edge_util_map<Tag, const typename Tag::type&>();
  }

  template <class Tag>
  inline sgb_edge_util_map<Tag, typename Tag::type&> 
  get_property_map(Tag, sgb_graph_ptr& g, edge_property_tag) {
    return sgb_edge_util_map<Tag, typename Tag::type&>();
  }

    reference operator[](const sgb_edge& e) const { 
      return e._arc->len; 
    }


  inline sgb_edge_length_map<const long&>
  get(edge_length_t, const sgb_graph_ptr&) { 
    return sgb_edge_length_map<const long&>(); 
  }

  inline sgb_edge_length_map<const long&>
  get(edge_length_t, const sgb_const_graph_ptr&) { 
    return sgb_edge_length_map<const long&>(); 
  }

  inline sgb_edge_length_map<long&>
  get(edge_length_t, sgb_graph_ptr&) { 
    return sgb_edge_length_map<long&>(); 
  }

  inline long
  get(edge_length_t, const sgb_graph_ptr&, const sgb_edge& key) {
    return key._arc->len;
  }

  inline long
  get(edge_length_t, const sgb_const_graph_ptr&, const sgb_edge& key) {
    return key._arc->len;
  }

  inline void
  put(edge_length_t, sgb_graph_ptr&, const sgb_edge& key, long value)
  {
    key._arc->len = value;
  }
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, T&> \
  get(X##_property<T>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
 \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, T&> \
  get(X##_property<T>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
 \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, T&> \
  get(X##_property<T>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
 \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, T&> \
  get(X##_property<T>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
 \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, T&> \
  get(X##_property<T>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
 \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, T&> \
  get(X##_property<T>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)
 \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, T&> \
  get(X##_property<T>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
 \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, T&> \
  get(X##_property<T>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
  SGB_UTIL_ACCESSOR(edge, b)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
  SGB_UTIL_ACCESSOR(edge, b)
 \
  template <class T> \
  inline sgb_##KIND##_util_map< X##_property<T>, const T&> \
  get(X##_property<T>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>(); \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
  SGB_UTIL_ACCESSOR(edge, b)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
  SGB_UTIL_ACCESSOR(edge, b)
 \
  template <class T, class Key> \
  inline typename \
  sgb_##KIND##_util_map< X##_property<T>, const T&>::value_type \
  get(X##_property<T>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< X##_property<T>, const T&>()[key]; \
  } \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
  SGB_UTIL_ACCESSOR(edge, b)
 \
  template <class T, class Key, class Value> \
  inline  void \
  put(X##_property<T>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< X##_property<T>, T&>()[key] = value; \
  }

#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#define SGB_UTIL_ACCESSOR_TYPE(KIND,TAG,TYPE) \
  inline sgb_##KIND##_util_map< TAG<TYPE>, TYPE& > \
  get(TAG<TYPE>, sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  inline sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& > \
  get(TAG<TYPE>, const sgb_const_graph_ptr&) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >(); \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key> \
  inline typename sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >::value_type \
  get(TAG<TYPE>, const sgb_const_graph_ptr&, const Key& key) { \
    return sgb_##KIND##_util_map< TAG<TYPE>, const TYPE& >()[key]; \
  } \
  template <class Key, class Value> \
  inline  void \
  put(TAG<TYPE>, sgb_graph_ptr&, const Key& key, const Value& value) { \
    sgb_##KIND##_util_map< TAG<TYPE>, TYPE& >()[key] = value; \
  } \
  template <> struct property_map<sgb_graph_ptr, TAG<TYPE> > { \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, TYPE&> type; \
    typedef sgb_##KIND##_util_map< TAG<TYPE>, const TYPE&> const_type; \
  }

#define SGB_UTIL_ACCESSOR(KIND,TAG) \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Vertex*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, Arc*); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, sgb_graph_ptr); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, long); \
  SGB_UTIL_ACCESSOR_TYPE(KIND, TAG##_property, char*);

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

  SGB_UTIL_ACCESSOR(vertex, u)
  SGB_UTIL_ACCESSOR(vertex, v)
  SGB_UTIL_ACCESSOR(vertex, w)
  SGB_UTIL_ACCESSOR(vertex, x)
  SGB_UTIL_ACCESSOR(vertex, y)
  SGB_UTIL_ACCESSOR(vertex, z)

  SGB_UTIL_ACCESSOR(edge, a)
  SGB_UTIL_ACCESSOR(edge, b)


      inline adj_list_edge_iterator() {}


      inline adj_list_edge_iterator(const self& x) 
      : vBegin(x.vBegin), vCurr(x.vCurr), vEnd(x.vEnd),
        edges(x.edges), m_g(x.m_g) { }


      template <class G>
      inline adj_list_edge_iterator(VertexIterator b, 
                                    VertexIterator c,
                                    VertexIterator e,
                                    const G& g) 
        : vBegin(b), vCurr(c), vEnd(e), m_g(&g) {
        if ( vCurr != vEnd ) {
          while ( vCurr != vEnd && out_degree(*vCurr, *m_g) == 0 )
            ++vCurr;
          if ( vCurr != vEnd )
            edges = out_edges(*vCurr, *m_g);
        }
      }

      inline self& operator++() {
        ++edges BOOST_GRAPH_MEMBER first;
        if (edges BOOST_GRAPH_MEMBER first == edges BOOST_GRAPH_MEMBER second) 
        {
          ++vCurr;
          while ( vCurr != vEnd && out_degree(*vCurr, *m_g) == 0 )
            ++vCurr;
          if ( vCurr != vEnd )
            edges = out_edges(*vCurr, *m_g);
        }
        return *this;
      }

      inline self operator++(int) {
        self tmp = *this;
        ++(*this);
        return tmp;
      }

      inline value_type operator*() const 
      { return *edges BOOST_GRAPH_MEMBER first; }
 
      inline bool operator==(const self& x) const {
        return vCurr == x.vCurr 
          && (vCurr == vEnd 
              || edges BOOST_GRAPH_MEMBER first == x.edges BOOST_GRAPH_MEMBER first);
      }

      inline bool operator!=(const self& x) const {
        return vCurr != x.vCurr 
          || (vCurr != vEnd 
              && edges BOOST_GRAPH_MEMBER first != x.edges BOOST_GRAPH_MEMBER first);
      }


            static const_map_type index_map(const Graph& g)
            { return get(vertex_index, g); }


            static value_type index(key_type k, const Graph& g)
            { return get(vertex_index, g, k); }


            static const_map_type index_map(const Graph& g)
            { return get(edge_index, g); }


            static value_type index(key_type k, const Graph& g)
            { return get(edge_index, g, k); }

  template <typename PropMap>
  inline void property_map_swap(
         PropMap prop_map,
         const typename boost::property_traits<PropMap>::key_type& ka, 
         const typename boost::property_traits<PropMap>::key_type& kb) {
    typename boost::property_traits<PropMap>::value_type va = get(prop_map, ka);
    put(prop_map, ka, get(prop_map, kb));
    put(prop_map, kb, va);
  }

      fixed_max_size_vector(std::size_t max_size)
        : m_data(new Value[max_size]), m_size(0) {}

      std::size_t size() const {return m_size;}

      bool empty() const {return m_size == 0;}

      Value& operator[](std::size_t i) {return m_data[i];}

      void push_back(Value v) {m_data[m_size++] = v;}

      void pop_back() {--m_size;}

      Value& back() {return m_data[m_size - 1];}

      const Value& back() const {return m_data[m_size - 1];}


template <typename MutableGraph>
bool read_graphviz_new(const std::string& str,
                       MutableGraph& graph, boost::dynamic_properties& dp,
                       std::string const& node_id = "node_id") {
  boost::detail::graph::mutate_graph_impl<MutableGraph> mg(graph, dp, node_id);
  return detail::graph::read_graphviz_new(str, &mg);
}


    template <class Node, class Next>
    inline Node
    slist_insert_after(Node pos, Node x, 
                       Next next)
    {
      next(x) = next(pos);
      next(pos) = x;
      return x;
    }

    template <class Node, class Next>
    inline Node
    slist_remove_after(Node pos, 
                       Next next)
    {
      Node n = next(pos);
      next(pos) = next(n);
      return n;
    }


    template <class Node, class Next>
    inline Node
    slist_remove_range(Node before_first, Node last, 
                       Next next)
    {
      next(before_first) = last;
      return last;
    }


    template <class Node, class Next>
    inline Node
    slist_previous(Node head, Node x, Node nil, 
                   Next next)
    {
      while (head != nil && next(head) != x)
        head = next(head);
      return head;
    }


    template<class Node, class Next>
    inline void
    slist_splice_after(Node pos, Node before_first, Node before_last, 
                       Next next)
    {
      if (pos != before_first && pos != before_last) {
        Node first = next(before_first);
        Node after = next(pos);
        next(before_first) = next(before_last);
        next(pos) = first;
        next(before_last) = after;
      }
    }


    template <class Node, class Next>
    inline Node
    slist_reverse(Node node, Node nil, 
                  Next next)
    {
      Node result = node;
      node = next(node);
      next(result) = nil;
      while(node) {
        Node next = next(node);
        next(node) = result;
        result = node;
        node = next;
      }
      return result;
    }


    template <class Node, class Next>
    inline std::size_t
    slist_size(Node head, Node nil, 
               Next next)
    {
      std::size_t s = 0;
      for ( ; head != nil; head = next(head))
        ++s;
      return s;
    }

      explicit slist_iterator_policies(const Next& n, const Data& d)
        : m_next(n), m_data(d) { }


      template <class Reference, class Node>
      Reference dereference(type<Reference>, const Node& x) const
        { return m_data(x); }


      template <class Node>
      void increment(Node& x) const
        { x = m_next(x); }


      template <class Node>
      bool equal(Node& x, Node& y) const
        { return x == y; }


    template <class Node, class Next, class Prev>
    inline void
    dlist_insert_before(Node pos, Node x, 
                        Next next, Prev prev)
    {
      next(x) = pos;
      prev(x) = prev(pos);
      next(prev(pos)) = x;
      prev(pos) = x;
    }


    template <class Node, class Next, class Prev>
    void
    dlist_remove(Node pos, 
                 Next next, Prev prev)
    {
      Node next_node = next(pos);
      Node prev_node = prev(pos);
      next(prev_node) = next_node;
      prev(next_node) = prev_node;
    }

    template <class Node, class Delete>
    inline void
    dlist_clear(Node sentinel, Delete del)
    {
      Node i, tmp;
      i = next(sentinel);
      while (i != sentinel) {
        tmp = i;
        i = next(i);
        del(tmp);
      }
    }

    
    template <class Node>
    inline bool
    dlist_empty(Node dummy)
    {
      return next(dummy) == dummy;
    }


    template <class Node, class Next, class Prev>  
    void
    dlist_transfer(Node pos, Node first, Node last, 
                   Next next, Prev prev)
    {
      if (pos != last) {
        // Remove [first,last) from its old position
        next(prev(last)) = pos;
        next(prev(first)) = last;
        next(prev(pos)) = first;

        // Splice [first,last) into its new position
        Node tmp = prev(pos);
        prev(pos) = prev(last);
        prev(last) = prev(first);
        prev(first) = tmp;
      }
    }

      template <class Node>
      void decrement(Node& x) const
        { x = m_prev(x); }


      dlist_iterator_policies(Next n, Prev p, Data d) 
        : Base(n,d), m_prev(p) { }

  Property& operator[](Descriptor v)
  { return m_vertex_properties[get(vertex_index, derived(), v)]; }


  const Property& operator[](Descriptor v) const
  { return m_vertex_properties[get(vertex_index, derived(), v)]; }


  vertex_map_type get_vertex_bundle(const IndexMap& index_map = IndexMap()) {
    return vertex_map_type(m_vertex_properties.begin(), index_map);
  }

  indexed_vertex_properties() {}

  void clear()
  {
    m_vertex_properties.clear();
  }

  void resize(std::size_t n)
  {
    m_vertex_properties.resize(n);
  }

  void reserve(std::size_t n)
  {
    m_vertex_properties.reserve(n);
  }

  void push_back(const Property& prop)
  {
    m_vertex_properties.push_back(prop);
  }

  void write_by_index(std::size_t idx, const Property& prop)
  {
    m_vertex_properties[idx] = prop;
  }

  Derived& derived() { return *static_cast<Derived*>(this); }


  const Derived& derived() const
  { return *static_cast<const Derived*>(this); }


  secret operator[](secret) { return secret(); }


  vertex_map_type get_vertex_bundle() const {
    return vertex_map_type();
  }

  indexed_vertex_properties() { }

  void clear() { }

  void resize(std::size_t) { }

  void reserve(std::size_t) { }

  Property& operator[](Descriptor v)
  { return m_edge_properties[get(edge_index, derived(), v)]; }


  const Property& operator[](Descriptor v) const
  { return m_edge_properties[get(edge_index, derived(), v)]; }


  edge_map_type get_edge_bundle(const IndexMap& index_map = IndexMap()) {
    return edge_map_type(m_edge_properties.begin(), index_map);
  }

  indexed_edge_properties() {}

  std::size_t size() const
  {
    return m_edge_properties.size();
  }

  void clear()
  {
    m_edge_properties.clear();
  }

  void resize(std::size_t n)
  {
    m_edge_properties.resize(n);
  }

  void reserve(std::size_t n)
  {
    m_edge_properties.reserve(n);
  }

  void write_by_index(std::size_t idx, const Property& prop)
  {
    m_edge_properties[idx] = prop;
  }

  void push_back(const Property& prop)
  {
    m_edge_properties.push_back(prop);
  }

  void move_range(std::size_t src_begin, std::size_t src_end, std::size_t dest_begin) {
    std::copy_backward(
        m_edge_properties.begin() + src_begin,
        m_edge_properties.begin() + src_end,
        m_edge_properties.begin() + dest_begin + (src_end - src_begin));
  }

  iterator begin() {return m_edge_properties.begin();}

  iterator end() {return m_edge_properties.end();}

  Derived& derived() { return *static_cast<Derived*>(this); }


  const Derived& derived() const
  { return *static_cast<const Derived*>(this); }

  no_property& dereference() const {return prop;}

  bool equal(const dummy_no_property_iterator&) const {return true;}

  void increment() {}

  void decrement() {}

  void advance(std::ptrdiff_t) {}

  std::ptrdiff_t distance_to(const dummy_no_property_iterator) const {return 0;}


  secret operator[](secret) { return secret(); }

  void write_by_index(std::size_t /*idx*/, const no_property& /*prop*/) {}


  edge_map_type get_edge_bundle(const IndexMap& = IndexMap()) const {
    return edge_map_type();
  }

  indexed_edge_properties() { }

  std::size_t size() const {return 0;}

  void clear() { }

  void resize(std::size_t) { }

  void reserve(std::size_t) { }

  void push_back(const edge_push_back_type&) { }

  void move_range(std::size_t /*src_begin*/, std::size_t /*src_end*/, std::size_t /*dest_begin*/) {}

  iterator begin() {return dummy_no_property_iterator();}

  iterator end() {return dummy_no_property_iterator();}

  explicit dot_grammar(mutate_graph& graph) : graph_(graph) { }

   
    definition(dot_grammar const& self) : self(self), subgraph_depth(0),
    keyword_p("0-9a-zA-Z_") {
      using namespace boost::spirit::classic;
      using namespace phoenix;
      
      // RG - Future Work
      // - Handle multi-line strings using \ line continuation
      // - Make keywords case insensitive
      ID 
          = ( lexeme_d[((alpha_p | ch_p('_')) >> *(alnum_p | ch_p('_')))]
            | real_p
            | lexeme_d[confix_p('"', *c_escape_ch_p, '"')]
            | comment_nest_p('<', '>')
            )[ID.name = construct_<std::string>(arg1,arg2)]
          ; 

      a_list
          = list_p( ID[(a_list.key = arg1),
                       (a_list.value = "true")
                      ]
                    >> !( ch_p('=')
                          >> ID[a_list.value = arg1])
                          [phoenix::bind(&definition::call_prop_actor)
                          (var(*this),a_list.key,a_list.value)],!ch_p(','));
      
      attr_list = +(ch_p('[') >> !a_list >> ch_p(']'));

      // RG - disregard port id's for now.
      port_location 
          = (ch_p(':') >> ID)
          | (ch_p(':') >> ch_p('(') >> ID >> ch_p(',') >> ID >> ch_p(')'))
          ;

      port_angle = ch_p('@') >> ID;

      port
          = port_location >> (!port_angle)
          | port_angle >> (!port_location);


      node_id
          = ( ID[node_id.name = arg1] >> (!port) )
             [phoenix::bind(&definition::memoize_node)(var(*this))];

      graph_stmt
          = (ID[graph_stmt.key = arg1] >>
             ch_p('=') >>
             ID[graph_stmt.value = arg1])
        [phoenix::bind(&definition::call_graph_prop)
         (var(*this),graph_stmt.key,graph_stmt.value)]
        ; // Graph property.

      attr_stmt
          = (as_lower_d[keyword_p("graph")]
             >> attr_list(actor_t(phoenix::bind(&definition::default_graph_prop)
                                     (var(*this),arg1,arg2))))
          | (as_lower_d[keyword_p("node")]
             >> attr_list(actor_t(phoenix::bind(&definition::default_node_prop)
                                     (var(*this),arg1,arg2))))
          | (as_lower_d[keyword_p("edge")]
             >> attr_list(actor_t(phoenix::bind(&definition::default_edge_prop)
                                     (var(*this),arg1,arg2))))
          ;

      // edge_head is set depending on the graph type (directed/undirected)
      edgeop = ch_p('-') >> ch_p(boost::ref(edge_head));

      edgeRHS
          =  +(    edgeop[(data_stmt.sources = data_stmt.dests),
                          (data_stmt.dests = construct_<nodes_t>())]
                   >> ( subgraph[data_stmt.dests = arg1]
                      | node_id[phoenix::bind(&definition::insert_node)
                                (var(*this),data_stmt.dests,arg1)]
                      )
                   [phoenix::bind(&definition::activate_edge)
                    (var(*this),data_stmt.sources,data_stmt.dests,
                     var(edges), var(default_edge_props))]
              );
      

      // To avoid backtracking, edge, node, and subgraph statements are
      // processed as one nonterminal.
      data_stmt
          = ( subgraph[(data_stmt.dests = arg1),// will get moved in rhs
                       (data_stmt.saw_node = false)] 
            | node_id[(phoenix::bind(&definition::insert_node)
                       (var(*this),data_stmt.dests,arg1)),
                      (data_stmt.saw_node = true),
#ifdef BOOST_GRAPH_DEBUG
                      (std::cout << val("AcTive Node: ") << arg1 << "\n"),
#endif // BOOST_GRAPH_DEBUG
                      (data_stmt.active_node = arg1)]
            ) >> if_p(edgeRHS)[
                     !attr_list(
                       actor_t(phoenix::bind(&definition::edge_prop)
                               (var(*this),arg1,arg2)))
                  ].else_p[
                     if_p(data_stmt.saw_node)[
                         !attr_list(
                           actor_t(phoenix::bind(&definition::node_prop)
                                   (var(*this),arg1,arg2)))
                     ] // otherwise it's a subgraph, nothing more to do.
                  ];


      stmt
          = graph_stmt 
          | attr_stmt
          | data_stmt
          ;

      stmt_list = *( stmt >> !ch_p(';') );

      subgraph
          = !(  as_lower_d[keyword_p("subgraph")]
                >> (!ID[(subgraph.name = arg1), 
                        (subgraph.nodes = (var(subgraph_nodes))[arg1]),
                        (subgraph.edges = (var(subgraph_edges))[arg1])])
                )
          >> ch_p('{')[++var(subgraph_depth)]
          >> stmt_list 
          >> ch_p('}')[--var(subgraph_depth)]
                      [(var(subgraph_nodes))[subgraph.name] = subgraph.nodes]
                      [(var(subgraph_edges))[subgraph.name] = subgraph.edges]
                     
          | as_lower_d[keyword_p("subgraph")]
                >> ID[(subgraph.nodes = (var(subgraph_nodes))[arg1]),
                      (subgraph.edges = (var(subgraph_edges))[arg1])]
          ;

      the_grammar
          = (!as_lower_d[keyword_p("strict")])
            >>  ( as_lower_d[keyword_p("graph")][
                   (var(edge_head) = '-'),
                   (phoenix::bind(&definition::check_undirected)(var(*this)))]
                | as_lower_d[keyword_p("digraph")][
                   (var(edge_head) = '>'),
                   (phoenix::bind(&definition::check_directed)(var(*this)))]
                )
            >> (!ID) >> ch_p('{') >> stmt_list >> ch_p('}');

    }


    rule_t const& start() const { return the_grammar; }


    void check_undirected() {
      if(self.graph_.is_directed())
          boost::throw_exception(boost::undirected_graph_error());
    }


    void check_directed() {
      if(!self.graph_.is_directed())
          boost::throw_exception(boost::directed_graph_error());
    }

    
    void memoize_node() {
      id_t const& node = node_id.name();
      props_t& node_props = default_node_props; 

      if(nodes.find(node) == nodes.end()) {
        nodes.insert(node);
        self.graph_.do_add_vertex(node);

        node_map.insert(std::make_pair(node,ids_t()));

#ifdef BOOST_GRAPH_DEBUG
        std::cout << "Add new node " << node << std::endl;
#endif // BOOST_GRAPH_DEBUG
        // Set the default properties for this edge
        // RG: Here I  would actually set the properties
        for(props_t::iterator i = node_props.begin();
            i != node_props.end(); ++i) {
          set_node_property(node,i->first,i->second);
        }
        if(subgraph_depth > 0) {
          subgraph.nodes().insert(node);
          // Set the subgraph's default properties as well
          props_t& props = subgraph_node_props[subgraph.name()];
          for(props_t::iterator i = props.begin(); i != props.end(); ++i) {
            set_node_property(node,i->first,i->second);
          }
        }
      } else {
#ifdef BOOST_GRAPH_DEBUG
        std::cout << "See node " << node << std::endl;
#endif // BOOST_GRAPH_DEBUG
      }
    }


    void activate_edge(nodes_t& sources, nodes_t& dests, edges_t& edges,
                       props_t& edge_props) {
      edge_stack_t& edge_stack = data_stmt.edge_stack();
      for(nodes_t::iterator i = sources.begin(); i != sources.end(); ++i) {
        for(nodes_t::iterator j = dests.begin(); j != dests.end(); ++j) {
          // Create the edge and push onto the edge stack.
#ifdef BOOST_GRAPH_DEBUG
          std::cout << "Edge " << *i << " to " << *j << std::endl;
#endif // BOOST_GRAPH_DEBUG

          edge_t edge = edge_t::new_edge();
          edge_stack.push_back(edge);
          edges.insert(edge);
          edge_map.insert(std::make_pair(edge,ids_t()));

          // Add the real edge.
          self.graph_.do_add_edge(edge, *i, *j);

          // Set the default properties for this edge
          for(props_t::iterator k = edge_props.begin();
              k != edge_props.end(); ++k) {
            set_edge_property(edge,k->first,k->second);
          }
          if(subgraph_depth > 0) {
            subgraph.edges().insert(edge);
            // Set the subgraph's default properties as well
            props_t& props = subgraph_edge_props[subgraph.name()];
            for(props_t::iterator k = props.begin(); k != props.end(); ++k) {
              set_edge_property(edge,k->first,k->second);
            }
          }
        }
      }
    }

    void node_prop(id_t const& key, id_t const& value) {
      node_t& active_object = data_stmt.active_node();
      set_node_property(active_object, key, value);
    }

    void edge_prop(id_t const& key, id_t const& value) {
      edge_stack_t const& active_edges_ = data_stmt.edge_stack();
      for (edge_stack_t::const_iterator i = active_edges_.begin();
           i != active_edges_.end(); ++i) {
        set_edge_property(*i,key,value);
      }
    }

    void default_graph_prop(id_t const& key, id_t const& value) {
#ifdef BOOST_GRAPH_DEBUG
      std::cout << key << " = " << value << std::endl;
#endif // BOOST_GRAPH_DEBUG
        self.graph_.set_graph_property(key, value);
    }

    void default_node_prop(id_t const& key, id_t const& value) {
      nodes_t& nodes_ =
        subgraph_depth == 0 ? nodes : subgraph.nodes();
      props_t& node_props_ =
        subgraph_depth == 0 ?
        default_node_props :
        subgraph_node_props[subgraph.name()];

      // add this to the selected list of default node properties.
      node_props_[key] = value;
      // for each node, set its property to default-constructed value 
      //   if it hasn't been set already.
      // set the dynamic property map value
      for(nodes_t::iterator i = nodes_.begin(); i != nodes_.end(); ++i)
        if(node_map[*i].find(key) == node_map[*i].end()) {
          set_node_property(*i,key,id_t());
        }
    }

   void default_edge_prop(id_t const& key, id_t const& value) {
      edges_t& edges_ =
        subgraph_depth == 0 ? edges : subgraph.edges();
      props_t& edge_props_ =
        subgraph_depth == 0 ?
        default_edge_props :
        subgraph_edge_props[subgraph.name()];
  
      // add this to the list of default edge properties.
      edge_props_[key] = value;
      // for each edge, set its property to be empty string
      // set the dynamic property map value
      for(edges_t::iterator i = edges_.begin(); i != edges_.end(); ++i)
        if(edge_map[*i].find(key) == edge_map[*i].end())
          set_edge_property(*i,key,id_t());
    }

    void insert_node(nodes_t& nodes, id_t const& name) {
      nodes.insert(name);
    }


    void call_prop_actor(std::string const& lhs, std::string const& rhs) {
      actor_t& actor = attr_list.prop_actor();
      // If first and last characters of the rhs are double-quotes,
      // remove them.
      if (!rhs.empty() && rhs[0] == '"' && rhs[rhs.size() - 1] == '"')
        actor(lhs, rhs.substr(1, rhs.size()-2));
      else
        actor(lhs,rhs);
    }


    void call_graph_prop(std::string const& lhs, std::string const& rhs) {
      // If first and last characters of the rhs are double-quotes,
      // remove them.
      if (!rhs.empty() && rhs[0] == '"' && rhs[rhs.size() - 1] == '"')
        this->default_graph_prop(lhs, rhs.substr(1, rhs.size()-2));
      else
        this->default_graph_prop(lhs,rhs);
    }


    void set_node_property(node_t const& node, id_t const& key,
                           id_t const& value) {

      // Add the property key to the "set" table to avoid default overwrite
      node_map[node].insert(key);
      // Set the user's property map
      self.graph_.set_node_property(key, node, value);
#ifdef BOOST_GRAPH_DEBUG
      // Tell the world
      std::cout << node << ": " << key << " = " << value << std::endl;
#endif // BOOST_GRAPH_DEBUG
    }


    void set_edge_property(edge_t const& edge, id_t const& key,
                           id_t const& value) {

      // Add the property key to the "set" table to avoid default overwrite
      edge_map[edge].insert(key);
      // Set the user's property map
      self.graph_.set_edge_property(key, edge, value);
#ifdef BOOST_GRAPH_DEBUG
      // Tell the world
#if 0 // RG - edge representation changed, 
            std::cout << "(" << edge.first << "," << edge.second << "): "
#else
            std::cout << "an edge: " 
#endif // 0
                << key << " = " << value << std::endl;
#endif // BOOST_GRAPH_DEBUG
    }

    dot_skipper() {}

        definition(dot_skipper const& /*self*/)  {
          using namespace boost::spirit::classic;
          using namespace phoenix;
          // comment forms
          skip = eol_p >> comment_p("#")  
               | space_p
               | comment_p("//")                 
#if BOOST_WORKAROUND(BOOST_MSVC, <= 1400)
               | confix_p(str_p("/*") ,*anychar_p, str_p("*/"))
#else
               | confix_p("/*" ,*anychar_p, "*/")
#endif
               ;

#ifdef BOOST_SPIRIT_DEBUG
               BOOST_SPIRIT_DEBUG_RULE(skip);
#endif
        }

      boost::spirit::classic::rule<ScannerT> const&
      start() const { return skip; }


template <typename MultiPassIterator, typename MutableGraph>
bool read_graphviz_spirit(MultiPassIterator begin, MultiPassIterator end,
                          MutableGraph& graph, dynamic_properties& dp,
                          std::string const& node_id = "node_id") {
  using namespace boost;
  using namespace boost::spirit::classic;

  typedef MultiPassIterator iterator_t;
  typedef skip_parser_iteration_policy< boost::detail::graph::dot_skipper>
    iter_policy_t;
  typedef scanner_policies<iter_policy_t> scanner_policies_t;
  typedef scanner<iterator_t, scanner_policies_t> scanner_t;

  ::boost::detail::graph::mutate_graph_impl<MutableGraph> 
      m_graph(graph, dp, node_id);

  ::boost::detail::graph::dot_grammar p(m_graph);
  ::boost::detail::graph::dot_skipper skip_p;

  iter_policy_t iter_policy(skip_p);
  scanner_policies_t policies(iter_policy);

  scanner_t scan(begin, end, policies);

  bool ok = p.parse(scan);
  m_graph.finish_building_graph();
  return ok;
}


    template <class K, class C, class A, class T>
    bool set_contains(const std::set<K,C,A>& s, const T& x) {
      return s.find(x) != s.end();
    }

    
    template <class K, class C, class A>
    bool set_equal(const std::set<K,C,A>& x,
                   const std::set<K,C,A>& y)
    {
      return x == y;
    }

    template <class K, class C, class A>
    int set_lex_order(const std::set<K,C,A>& x,
                      const std::set<K,C,A>& y)
    {
      typename std::set<K,C,A>::iterator
        xi = x.begin(), yi = y.begin(), xend = x.end(), yend = y.end();
      for (; xi != xend && yi != yend; ++xi, ++yi) {
        if (*xi < *yi)
          return 1;
        else if (*yi < *xi)
          return -1;
      }
      if (xi == xend)
        return (yi == yend) ? 0 : -1;
      else
        return 1;
    }


    template <class K, class C, class A>
    bool set_empty(const std::set<K,C,A>& x) {
      return x.empty();
    }

    
    template <class K, class C, class A>
    void set_intersect(const std::set<K,C,A>& x,
                       const std::set<K,C,A>& y,
                       std::set<K,C,A>& z)
    {
      z.clear();
      std::set_intersection(x.begin(), x.end(),
                            y.begin(), y.end(),
                            std::inserter(z));
    }


    template <class K, class C, class A>
    void set_union(const std::set<K,C,A>& x,
                   const std::set<K,C,A>& y,
                   std::set<K,C,A>& z)
    {
      z.clear();
      std::set_union(x.begin(), x.end(),
                     y.begin(), y.end(),
                     std::inserter(z));
    }


    template <class K, class C, class A>
    void set_difference(const std::set<K,C,A>& x,
                        const std::set<K,C,A>& y,
                        std::set<K,C,A>& z)
    {
      z.clear();
      std::set_difference(x.begin(), x.end(),
                          y.begin(), y.end(),
                          std::inserter(z, z.begin()));
    }


    template <class K, class C, class A>
    bool set_subset(const std::set<K,C,A>& x,
                    const std::set<K,C,A>& y)
    {
      return std::includes(x.begin(), x.end(), y.begin(), y.end());
    }

    template <class K, class C, class A>
    void set_compliment(const std::set<K,C,A>& /*x*/,
                        std::set<K,C,A>& z)
    {
      z.clear();
      
    }

  template <class Graph, class Vertex, class ColorMap, class DegreeMap>
  Vertex 
  pseudo_peripheral_pair(Graph const& G, const Vertex& u, int& ecc,
                         ColorMap color, DegreeMap degree)
  {
    typedef typename property_traits<ColorMap>::value_type ColorValue;
    typedef color_traits<ColorValue> Color;
    
    sparse::rcm_queue<Vertex, DegreeMap> Q(degree);

    typename boost::graph_traits<Graph>::vertex_iterator ui, ui_end;
    for (boost::tie(ui, ui_end) = vertices(G); ui != ui_end; ++ui)
      if (get(color, *ui) != Color::red()) put(color, *ui, Color::white());
    breadth_first_visit(G, u, buffer(Q).color_map(color));

    ecc = Q.eccentricity(); 
    return Q.spouse();
  }

  template <class Graph, class Vertex, class Color, class Degree> 
  Vertex find_starting_node(Graph const& G, Vertex r, Color color, Degree degree)
  {
    Vertex x, y;
    int eccen_r, eccen_x;

    x = pseudo_peripheral_pair(G, r, eccen_r, color, degree);
    y = pseudo_peripheral_pair(G, x, eccen_x, color, degree);

    while (eccen_x > eccen_r) {
      r = x;
      eccen_r = eccen_x;
      x = y;
      y = pseudo_peripheral_pair(G, x, eccen_x, color, degree);
    }
    return x;
  }

  out_degree_property_map(const Graph& g) : m_g(g) { }

  value_type operator[](const key_type& v) const {
    return out_degree(v, m_g);
  }

template <typename Graph>
inline out_degree_property_map<Graph>
make_out_degree_map(const Graph& g) {
  return out_degree_property_map<Graph>(g);
}


      inline iterator() : i(0), n(0) { }

      inline iterator(const iterator& x) : r(x.r), i(x.i), n(x.n), id(x.id) { }

      inline iterator& operator=(const iterator& x) {
        r = x.r; i = x.i; n = x.n;
        /*egcs generate a warning*/
        id = x.id;
        return *this;
      }

      inline iterator(rep_iterator rr,
                      size_type ii,
                      size_type nn,
                      const ID& _id) : r(rr), i(ii), n(nn), id(_id) { }

      inline array_binary_tree_node operator*() {
        return ArrayBinaryTreeNode(r, i, n, id); }

      inline iterator& operator++() { ++i; return *this; }

      inline iterator operator++(int)
        { iterator t = *this; ++(*this); return t; }

      inline bool operator==(const iterator& x) const { return i == x.i; }

      inline bool operator!=(const iterator& x) const
        { return !(*this == x); }

    inline children_type() : i(0), n(0) { }

    inline children_type(const children_type& x)
      : r(x.r), i(x.i), n(x.n), id(x.id) { }

    inline children_type& operator=(const children_type& x) {
      r = x.r; i = x.i; n = x.n;
      /*egcs generate a warning*/
      id = x.id;
      return *this;
    }

    inline children_type(rep_iterator rr,
                         size_type ii,
                         size_type nn,
                         const ID& _id) : r(rr), i(ii), n(nn), id(_id) { }

    inline iterator begin() { return iterator(r, 2 * i + 1, n, id); }

    inline iterator end() { return iterator(r, 2 * i + 1 + size(), n, id); }

    inline size_type size() const {
      size_type c = 2 * i + 1;
      size_type s;
      if      (c + 1 < n) s = 2;
      else if (c < n)     s = 1;
      else                s = 0;
      return s;
    }

  inline array_binary_tree_node() : i(0), n(0) { }

  inline array_binary_tree_node(const array_binary_tree_node& x)
    : r(x.r), i(x.i), n(x.n), id(x.id) { }

  inline ArrayBinaryTreeNode& operator=(const ArrayBinaryTreeNode& x) {
    r = x.r;
    i = x.i;
    n = x.n;
    /*egcs generate a warning*/
    id = x.id;
    return *this;
  }

  inline array_binary_tree_node(rep_iterator start,
                                rep_iterator end,
                                rep_iterator pos, const ID& _id)
    : r(start), i(pos - start), n(end - start), id(_id) { }

  inline array_binary_tree_node(rep_iterator rr,
                                size_type ii,
                                size_type nn, const ID& _id)
    : r(rr), i(ii), n(nn), id(_id) { }

  inline value_type& value() { return *(r + i); }

  inline ArrayBinaryTreeNode parent() const {
    return ArrayBinaryTreeNode(r, (i - 1) / 2, n, id);
  }

  inline bool has_parent() const { return i != 0; }

  inline children_type children() { return children_type(r, i, n, id); }

  template <class ExternalData>
  inline void swap(ArrayBinaryTreeNode x, ExternalData& edata ) {
    using boost::get;

    value_type tmp = x.value();

    /*swap external data*/
    edata[ get(id, tmp) ]     = i;
    edata[ get(id, value()) ] = x.i;

    x.value() = value();
    value() = tmp;
    i = x.i;
  }

   inline const children_type children() const {
    return children_type(r, i, n);
  }

  inline size_type index() const { return i; }

    triple(const T1& a, const T2& b, const T3& c) : first(a), second(b), third(c) {}

    triple() : first(SAW_SENTINAL), second(SAW_SENTINAL), third(SAW_SENTINAL) {}

  template <class Triangle, class Line>
  inline void get_sharing(const Triangle& a, const Triangle& b, Line& l)
  {
    l.first = SAW_SENTINAL;
    l.second = SAW_SENTINAL;

    if ( a.first == b.first ) {
      l.first = a.first;
      if ( a.second == b.second || a.second == b.third )
        l.second = a.second;
      else if ( a.third == b.second || a.third == b.third )
        l.second = a.third; 

    }  else if ( a.first == b.second ) {
      l.first = a.first;
      if ( a.second == b.third )
        l.second = a.second;
      else if ( a.third == b.third )
        l.second = a.third; 

    } else if ( a.first == b.third ) {
      l.first = a.first;


    } else if ( a.second == b.first ) {
      l.first = a.second;
      if ( a.third == b.second || a.third == b.third )
        l.second = a.third;

    } else if ( a.second == b.second ) {
      l.first = a.second;
      if ( a.third == b.third ) 
        l.second = a.third;

    } else if ( a.second == b.third ) {
      l.first = a.second;


    } else if ( a.third == b.first 
                || a.third == b.second  
                || a.third == b.third )
      l.first = a.third; 

    /*Make it in order*/
    if ( l.first > l.second ) {
      typename Line::first_type i = l.first;
      l.first = l.second;
      l.second = i;
    }

  }

    get_vertex_sharing(const TriangleDecorator& _td) : td(_td) {}

    inline Line operator()(const Vertex& u, const Vertex& v) const {
      Line l;
      get_sharing(td[u], td[v], l);
      return l;
    }


    inline SAW_visitor(TriangleDecorator _td, HList _hlist, IteratorD ia)
      : td(_td), hlist(_hlist), iter_d(ia) {}


    template <class Vertex, class Graph>
    inline void start_vertex(Vertex v, Graph&) {
      Line l1;
      l1.first = SAW_SENTINAL;
      l1.second = SAW_SENTINAL;
      hlist->push_front(std::make_pair(v, l1));
      iter_d[v] = hlist->begin();
    }

    template <class Edge, class Graph>
    bool tree_edge(Edge e, Graph& G) {
          using std::make_pair;
      typedef typename boost::graph_traits<Graph>::vertex_descriptor Vertex;
      Vertex tau = target(e, G);
      Vertex i   = source(e, G); 

      get_vertex_sharing<TriangleDecorator, Vertex, Line> get_sharing_line(td);
      
      Line tau_i = get_sharing_line(tau, i);
      
      iter w_end = hlist->end();

      iter w_i = iter_d[i];

      iter w_i_m_1 = w_i;
      iter w_i_p_1 = w_i;

      /*----------------------------------------------------------
       *             true             false
       *==========================================================
       *a       w(i-1) |- w(i)    w(i-1) ~> w(i) or w(i-1) is null
       *----------------------------------------------------------
       *b       w(i) |- w(i+1)    w(i) ~> w(i+1) or no w(i+1) yet
       *----------------------------------------------------------
       */
      
      bool a = false, b = false;

      --w_i_m_1;
      ++w_i_p_1;
      b = ( w_i->second.first != SAW_SENTINAL );

      if ( w_i_m_1 != w_end ) {
        a = ( w_i_m_1->second.first != SAW_SENTINAL );
      }      
      
      if ( a ) {
        
        if ( b ) {
          /*Case 1: 
            
            w(i-1) |- w(i) |- w(i+1)
          */
          Line l1 = get_sharing_line(*w_i_m_1, tau);

          iter w_i_m_2 = w_i_m_1;
          --w_i_m_2;

          bool c = true;
          
          if ( w_i_m_2 != w_end ) {
            c = w_i_m_2->second != l1;
          }

          if ( c ) {  /* w(i-1) ^ tau != w(i-2) ^ w(i-1)  */
            /*extension: w(i-1) -> tau |- w(i) */
            w_i_m_1->second = l1;
            /*insert(pos, const T&) is to insert before pos*/
            iter_d[tau] = hlist->insert(w_i, make_pair(tau, tau_i));  
            
          } else {  /* w(i-1) ^ tau == w(i-2) ^ w(i-1)  */
            /*must be w(i-2) ~> w(i-1) */
            
            bool d = true;
            //need to handle the case when w_i_p_1 is null
            Line l3 = get_sharing_line(*w_i_p_1, tau);
            if ( w_i_p_1 != w_end )
              d = w_i_p_1->second != l3;
            if ( d ) { /* w(i+1) ^ tau != w(i+1) ^ w(i+2) */
              /*extension: w(i) |- tau -> w(i+1) */
              w_i->second = tau_i;
              iter_d[tau] = hlist->insert(w_i_p_1, make_pair(tau, l3));
            } else { /* w(i+1) ^ tau == w(i+1) ^ w(i+2) */
              /*must be w(1+1) ~> w(i+2) */
              Line l5 = get_sharing_line(*w_i_m_1, *w_i_p_1);
              if ( l5 != w_i_p_1->second ) { /* w(i-1) ^ w(i+1) != w(i+1) ^ w(i+2) */
                /*extension: w(i-2) -> tau |- w(i) |- w(i-1) -> w(i+1) */
                w_i_m_2->second = get_sharing_line(*w_i_m_2, tau);
                iter_d[tau] = hlist->insert(w_i, make_pair(tau, tau_i));
                w_i->second = w_i_m_1->second;
                w_i_m_1->second = l5;
                iter_d[w_i_m_1->first] = hlist->insert(w_i_p_1, *w_i_m_1);
                hlist->erase(w_i_m_1);
              } else {
                /*mesh is tetrahedral*/
                // dont know what that means.
                ;
              }
            }
            
          }
        } else { 
          /*Case 2:
            
            w(i-1) |- w(i) ~> w(1+1)
          */
          
          if ( w_i->second.second == tau_i.first 
               || w_i->second.second == tau_i.second ) {  /*w(i) ^ w(i+1) < w(i) ^ tau*/
            /*extension: w(i) |- tau -> w(i+1) */
            w_i->second = tau_i;
            Line l1 = get_sharing_line(*w_i_p_1, tau);
            iter_d[tau] = hlist->insert(w_i_p_1, make_pair(tau, l1));
          } else { /*w(i) ^ w(i+1) !< w(i) ^ tau*/
            Line l1 = get_sharing_line(*w_i_m_1, tau);
            bool c = true;
            iter w_i_m_2 = w_i_m_1;
            --w_i_m_2;
            if ( w_i_m_2 != w_end )
              c =  l1 != w_i_m_2->second;
            if (c) { /*w(i-1) ^ tau != w(i-2) ^ w(i-1)*/
              /*extension: w(i-1) -> tau |- w(i)*/
              w_i_m_1->second = l1;
              iter_d[tau] = hlist->insert(w_i, make_pair(tau, tau_i));
            } else { /*w(i-1) ^ tau == w(i-2) ^ w(i-1)*/
              /*must be w(i-2)~>w(i-1)*/
              /*extension: w(i-2) -> tau |- w(i) |- w(i-1) -> w(i+1)*/
              w_i_m_2->second = get_sharing_line(*w_i_m_2, tau);
              iter_d[tau] = hlist->insert(w_i, make_pair(tau, tau_i));
              w_i->second = w_i_m_1->second;
              w_i_m_1->second = get_sharing_line(*w_i_m_1, *w_i_p_1);
              iter_d[w_i_m_1->first] = hlist->insert(w_i_p_1, *w_i_m_1);
              hlist->erase(w_i_m_1);
            }
            
          }    
          
        }
        
      } else {
        
        if ( b ) {
          /*Case 3:
            
            w(i-1) ~> w(i) |- w(i+1)
          */
          bool c = false;
          if ( w_i_m_1 != w_end )
            c = ( w_i_m_1->second.second == tau_i.first)
              || ( w_i_m_1->second.second == tau_i.second);
          
          if ( c ) {  /*w(i-1) ^ w(i) < w(i) ^ tau*/
            /* extension: w(i-1) -> tau |- w(i) */
            if ( w_i_m_1 != w_end )
              w_i_m_1->second = get_sharing_line(*w_i_m_1, tau);
            iter_d[tau] = hlist->insert(w_i, make_pair(tau, tau_i));
          } else {
            bool d = true;
            Line l1;
            l1.first = SAW_SENTINAL;
            l1.second = SAW_SENTINAL;
            if ( w_i_p_1 != w_end ) {
              l1 = get_sharing_line(*w_i_p_1, tau);
              d = l1 != w_i_p_1->second;
            }
            if (d) { /*w(i+1) ^ tau != w(i+1) ^ w(i+2)*/
              /*extension: w(i) |- tau -> w(i+1) */
              w_i->second = tau_i;
              iter_d[tau] = hlist->insert(w_i_p_1, make_pair(tau, l1));
            } else {
              /*must be w(i+1) ~> w(i+2)*/
              /*extension: w(i-1) -> w(i+1) |- w(i) |- tau -> w(i+2) */
              iter w_i_p_2 = w_i_p_1;
              ++w_i_p_2;
              
              w_i_p_1->second = w_i->second;
              iter_d[i] = hlist->insert(w_i_p_2, make_pair(i, tau_i));
              hlist->erase(w_i);
              Line l2 = get_sharing_line(*w_i_p_2, tau);
              iter_d[tau] = hlist->insert(w_i_p_2, make_pair(tau, l2));
            }
          }
          
        } else {
          /*Case 4:
            
            w(i-1) ~> w(i) ~> w(i+1)
            
          */
          bool c = false;
          if ( w_i_m_1 != w_end ) {
            c = (w_i_m_1->second.second == tau_i.first) 
              || (w_i_m_1->second.second == tau_i.second);
          }
          if ( c ) {   /*w(i-1) ^ w(i) < w(i) ^ tau */
            /*extension: w(i-1) -> tau |- w(i) */
            if ( w_i_m_1 != w_end )
              w_i_m_1->second = get_sharing_line(*w_i_m_1, tau);
            iter_d[tau] = hlist->insert(w_i, make_pair(tau, tau_i));
          } else { 
            /*extension: w(i) |- tau -> w(i+1) */
            w_i->second = tau_i;
            Line l1;
            l1.first = SAW_SENTINAL;
            l1.second = SAW_SENTINAL;
            if ( w_i_p_1 != w_end ) 
              l1 = get_sharing_line(*w_i_p_1, tau);
            iter_d[tau] = hlist->insert(w_i_p_1, make_pair(tau, l1));
          }
        }
        
      }

      return true;
    }


  template <class Triangle, class HList, class Iterator>
  inline 
  SAW_visitor<Triangle, HList, Iterator>
  visit_SAW(Triangle t, HList hl, Iterator i) {
    return SAW_visitor<Triangle, HList, Iterator>(t, hl, i);
  }

      inline shadow_proxy(A aa, B bb) : a(aa), b(bb) { }

      inline shadow_proxy(const self& x) : a(x.a), b(x.b) { }

      template <class Self>
      inline shadow_proxy(Self x) : a(x.a), b(x.b) { }

      inline self& operator=(const self& x) { a = x.a; b = x.b; return *this; }

      inline self& operator++() { ++a; return *this; }

      inline self& operator--() { --a; return *this; }

      inline self& operator+=(const self& x) { a += x.a; return *this; }

      inline self& operator-=(const self& x) { a -= x.a; return *this; }

      inline self& operator*=(const self& x) { a *= x.a; return *this; }

      inline self& operator/=(const self& x) { a /= x.a; return *this; }

      inline self& operator%=(const self& x) { return *this; }

      inline self& operator&=(const self& x) { return *this; }

      inline self& operator|=(const self& x) { return *this; }

      inline self& operator^=(const self& x) { return *this; }
 
      inline bool operator==(const self& x) const { return a == x.a;  }

      inline bool operator<(const self& x) const { return a < x.a;  }

      template <typename iter_pair>
      void initialize(const iter_pair&) { }


      template <typename Iter>
      typename Iter::reference dereference(const Iter& i) const { 
        typedef typename Iter::reference R;
        return R(*i.base().first, *i.base().second); 
      }

      template <typename Iter>
      bool equal(const Iter& p1, const Iter& p2) const { 
        return p1.base().first == p2.base().first;  
      }

      template <typename Iter>
      void increment(Iter& i) { ++i.base().first; ++i.base().second; }


      template <typename Iter>
      void decrement(Iter& i) { --i.base().first; --i.base().second; }


      template <typename Iter>
      bool less(const Iter& x, const Iter& y) const { 
        return x.base().first < y.base().first;  
      }

      template <typename Iter>
      typename Iter::difference_type
      distance(const Iter& x, const Iter& y) const { 
        return y.base().first - x.base().first; 
      }

      template <typename D, typename Iter>
      void advance(Iter& p, D n) { p.base().first += n; p.base().second += n; }

  template <class IterA, class IterB>
  inline typename shadow_iterator_generator<IterA,IterB>::type
  make_shadow_iter(IterA a, IterB b) {
    typedef typename shadow_iterator_generator<IterA,IterB>::type Iter;
    return Iter(std::make_pair(a,b)); 
  }

    inline shadow_cmp(const Cmp& c) : cmp(c) { }

    template <class ShadowProxy1, class ShadowProxy2>
    inline bool operator()(const ShadowProxy1& x, const ShadowProxy2& y) const
    {
      return cmp(x.a, y.a);
    }

  template <class A1, class B1, class D1,
            class A2, class B2, class D2>
  void swap(boost::detail::shadow_proxy<A1&,B1&,D1> x,
            boost::detail::shadow_proxy<A2&,B2&,D2> y)
  {
    std::swap(x.a, y.a);
    std::swap(x.b, y.b);
  }


template <class Iter1, class Iter2>
void permute_serial(Iter1 permuter, Iter1 last, Iter2 result)
{
#ifdef BOOST_NO_STD_ITERATOR_TRAITS
  typedef std::ptrdiff_t D:
#else
  typedef typename std::iterator_traits<Iter1>::difference_type D;
#endif

  D n = 0;
  while (permuter != last) {
    std::swap(result[n], result[*permuter]);
    ++n;
    ++permuter;
  }
}


template <class InIter, class RandIterP, class RandIterR>
void permute_copy(InIter first, InIter last, RandIterP p, RandIterR result)
{
#ifdef BOOST_NO_STD_ITERATOR_TRAITS
  typedef std::ptrdiff_t i = 0;
#else
  typename std::iterator_traits<RandIterP>::difference_type i = 0;
#endif
  for (; first != last; ++first, ++i)
    result[p[i]] = *first;
}


template <class RandIter, class RandIterPerm, class D, class T>
void permute_helper(RandIter first, RandIter last, RandIterPerm p, D, T)
{
  D i = 0, pi, n = last - first, cycle_start;
  T tmp;
  std::vector<int> visited(n, false);

  while (i != n) { // continue until all elements have been processed
    cycle_start = i;
    tmp = first[i];
    do { // walk around a cycle
      pi = p[i];
      visited[pi] = true;
      std::swap(tmp, first[pi]);
      i = pi;
    } while (i != cycle_start);
    
    // find the next cycle
    for (i = 0; i < n; ++i)
      if (visited[i] == false)
        break;
  }
}


template <class RandIter, class RandIterPerm>
void permute(RandIter first, RandIter last, RandIterPerm p)
{
  detail::permute_helper(first, last, p, last - first, *first);
}

template <class PermIter>
void invert_permutation(PermIter X, PermIter Xend)
{
#ifdef BOOST_NO_STD_ITERATOR_TRAITS
  typedef std::ptrdiff_t T:
#else
  typedef typename std::iterator_traits<PermIter>::value_type T;
#endif
  T n = Xend - X;
  T m = n;
  T j = -1;

  while (m > 0) {
    T i = X[m-1] + 1;
    if (i > 0) {
      do {
        X[m-1] = j - 1;
        j = -m;
        m = i;
        i = X[m-1] + 1;
      } while (i > 0);
      i = j;
    }
    X[m-1] = -i - 1;
    --m;
  }
}

template <class Iter1, class Iter2, class Iter3>
inline void serialize_permutation(Iter1 q, Iter1 q_end, Iter2 q_inv, Iter3 p)
{
#ifdef BOOST_NO_STD_ITERATOR_TRAITS
  typedef std::ptrdiff_t P1;
  typedef std::ptrdiff_t P2;
  typedef std::ptrdiff_t D;
#else
  typedef typename std::iterator_traits<Iter1>::value_type P1;
  typedef typename std::iterator_traits<Iter2>::value_type P2;
  typedef typename std::iterator_traits<Iter1>::difference_type D;
#endif
  D n = q_end - q;
  for (D i = 0; i < n; ++i) {
    P1 qi = q[i];
    P2 qii = q_inv[i];
    *p++ = qii;
    std::swap(q[i], q[qii]);
    std::swap(q_inv[i], q_inv[qi]);
  }
}

template <typename Iter, typename Compare>
void merge_sort(Iter first, Iter last, Compare cmp)
{
  if (first + 1 < last) {
    Iter mid = first + (last - first)/2;
    merge_sort(first, mid, cmp);
    merge_sort(mid, last, cmp);
    std::inplace_merge(first, mid, last, cmp);
  }
}

template <class Iter, class IterP, class Cmp, class Alloc>
inline void sortp(Iter first, Iter last, IterP p, Cmp cmp, Alloc alloc)
{
  typedef typename std::iterator_traits<IterP>::value_type P;
  typedef typename std::iterator_traits<IterP>::difference_type D;
  D n = last - first;
  std::vector<P, Alloc> q(n);
  for (D i = 0; i < n; ++i) 
    q[i] = i;
  std::sort(make_shadow_iter(first, q.begin()),
            make_shadow_iter(last, q.end()),
            shadow_cmp<Cmp>(cmp));
  invert_permutation(q.begin(), q.end());
  std::copy(q.begin(), q.end(), p);
}


template <class Iter, class IterP, class Cmp>
inline void sortp(Iter first, Iter last, IterP p, Cmp cmp)
{
  typedef typename std::iterator_traits<IterP>::value_type P;  
  sortp(first, last, p, cmp, std::allocator<P>());
}


template <class Iter, class IterP>
inline void sortp(Iter first, Iter last, IterP p)
{
  typedef typename std::iterator_traits<Iter>::value_type T;  
  typedef typename std::iterator_traits<IterP>::value_type P;  
  sortp(first, last, p, std::less<T>(), std::allocator<P>());
}


template <class Iter, class IterP, class Cmp, class Alloc>
inline void sortv(Iter first, Iter last, IterP p, Cmp cmp, Alloc alloc)
{
  typedef typename std::iterator_traits<IterP>::value_type P;
  typedef typename std::iterator_traits<IterP>::difference_type D;
  D n = last - first;
  std::vector<P, Alloc> q(n), q_inv(n);
  for (D i = 0; i < n; ++i) 
    q_inv[i] = i;
  std::sort(make_shadow_iter(first, q_inv.begin()), 
            make_shadow_iter(last, q_inv.end()), 
            shadow_cmp<Cmp>(cmp));
  std::copy(q_inv, q_inv.end(), q.begin());
  invert_permutation(q.begin(), q.end());
  serialize_permutation(q.begin(), q.end(), q_inv.end(), p);
}

      target_is(const Vertex& v) : m_target(v) { }

      template <class StoredEdge>
      bool operator()(const StoredEdge& e) const {
        return e.get_target() == m_target;
      }

    template <class EdgeList, class vertex_descriptor>
    void erase_from_incidence_list(EdgeList& el, vertex_descriptor v,
                                   allow_parallel_edge_tag)
    {
      boost::graph_detail::erase_if(el, detail::target_is<vertex_descriptor>(v));
    }

    template <class EdgeList, class vertex_descriptor>
    void erase_from_incidence_list(EdgeList& el, vertex_descriptor v,
                                   disallow_parallel_edge_tag)
    {
      typedef typename EdgeList::value_type StoredEdge;
      el.erase(StoredEdge(v));
    }


      inline out_edge_iter() { }

        inline out_edge_iter(const BaseIter& i, const VertexDescriptor& src)
          : super_t(i), m_src(src) { }


      inline EdgeDescriptor
      dereference() const
      {
        return EdgeDescriptor(m_src, (*this->base()).get_target(),
                              &(*this->base()).get_property());
      }


      inline in_edge_iter() { }

      inline in_edge_iter(const BaseIter& i, const VertexDescriptor& src)
        : super_t(i), m_src(src) { }


      inline EdgeDescriptor
      dereference() const
      {
        return EdgeDescriptor((*this->base()).get_target(), m_src,
                              &this->base()->get_property());
      }


      undirected_edge_iter() {}


      explicit undirected_edge_iter(EdgeIter i)
          : super_t(i) {}


      inline EdgeDescriptor
      dereference() const {
        return EdgeDescriptor(
            (*this->base()).m_source
          , (*this->base()).m_target
          , &this->base()->get_property());
      }

      inline stored_edge() { }

      inline stored_edge(Vertex target, const no_property& = no_property())
        : m_target(target) { }

      inline stored_edge& operator=(const stored_edge& x) {
        m_target = x.m_target;
        return *this;
      }

      inline Vertex& get_target() const { return m_target; }

      inline const no_property& get_property() const { return s_prop; }

      inline bool operator==(const stored_edge& x) const
        { return m_target == x.get_target(); }

      inline bool operator<(const stored_edge& x) const
        { return m_target < x.get_target(); }

      inline stored_edge_property() { }

      inline stored_edge_property(Vertex target,
                                  const Property& p = Property())
        : stored_edge<Vertex>(target), m_property(new Property(p)) { }

      stored_edge_property(const self& x)
        : Base(x), m_property(const_cast<self&>(x).m_property) { }

      self& operator=(const self& x) {
        Base::operator=(x);
        m_property = const_cast<self&>(x).m_property;
        return *this;
      }

      inline Property& get_property() { return *m_property; }

      inline const Property& get_property() const { return *m_property; }

      inline stored_edge_iter() { }

      inline stored_edge_iter(Vertex v)
        : stored_edge<Vertex>(v) { }

      inline stored_edge_iter(Vertex v, Iter i, void* = 0)
        : stored_edge<Vertex>(v), m_iter(i) { }

      inline Property& get_property() { return m_iter->get_property(); }

      inline const Property& get_property() const {
        return m_iter->get_property();
      }

      inline Iter get_iter() const { return m_iter; }

      inline stored_ra_edge_iter() { }

      inline explicit stored_ra_edge_iter(Vertex v) // Only used for comparisons
        : stored_edge<Vertex>(v), m_i(0), m_vec(0){ }

      inline stored_ra_edge_iter(Vertex v, Iter i, EdgeVec* edge_vec)
        : stored_edge<Vertex>(v), m_i(i - edge_vec->begin()), m_vec(edge_vec){ }

      inline Property& get_property() { BOOST_ASSERT ((m_vec != 0)); return (*m_vec)[m_i].get_property(); }

      inline const Property& get_property() const {
        BOOST_ASSERT ((m_vec != 0));
        return (*m_vec)[m_i].get_property();
      }

      inline Iter get_iter() const { BOOST_ASSERT ((m_vec != 0)); return m_vec->begin() + m_i; }


  template <class Tag, class Vertex, class Property>
  const typename property_value<Property,Tag>::type&
  get(Tag property_tag,
      const detail::stored_edge_property<Vertex, Property>& e)
  {
    return get_property_value(e.get_property(), property_tag);
  }


  template <class Tag, class Vertex, class Iter, class Property>
  const typename property_value<Property,Tag>::type&
  get(Tag property_tag,
      const detail::stored_edge_iter<Vertex, Iter, Property>& e)
  {
    return get_property_value(e.get_property(), property_tag);
  }


  template <class Tag, class Vertex, class EdgeVec, class Property>
  const typename property_value<Property,Tag>::type&
  get(Tag property_tag,
      const detail::stored_ra_edge_iter<Vertex, EdgeVec, Property>& e)
  {
    return get_property_value(e.get_property(), property_tag);
  }

      template <class edge_descriptor, class EdgeList, class StoredProperty>
      inline void
      remove_directed_edge_dispatch(edge_descriptor, EdgeList& el,
                                    StoredProperty& p)
      {
        for (typename EdgeList::iterator i = el.begin();
             i != el.end(); ++i)
          if (&(*i).get_property() == &p) {
            el.erase(i);
            return;
          }
      }


      template <class incidence_iterator, class EdgeList, class Predicate>
      inline void
      remove_directed_edge_if_dispatch(incidence_iterator first,
                                       incidence_iterator last,
                                       EdgeList& el, Predicate pred,
                                       boost::allow_parallel_edge_tag)
      {
        // remove_if
        while (first != last && !pred(*first))
          ++first;
        incidence_iterator i = first;
        if (first != last)
          for (++i; i != last; ++i)
            if (!pred(*i)) {
              *first.base() = *i.base();
              ++first;
            }
        el.erase(first.base(), el.end());
      }

      template <class incidence_iterator, class EdgeList, class Predicate>
      inline void
      remove_directed_edge_if_dispatch(incidence_iterator first,
                                       incidence_iterator last,
                                       EdgeList& el,
                                       Predicate pred,
                                       boost::disallow_parallel_edge_tag)
      {
        for (incidence_iterator next = first;
             first != last; first = next) {
          ++next;
          if (pred(*first))
            el.erase( first.base() );
        }
      }


      template <class PropT, class Graph, class incidence_iterator,
                class EdgeList, class Predicate>
      inline void
      undirected_remove_out_edge_if_dispatch(Graph& g,
                                             incidence_iterator first,
                                             incidence_iterator last,
                                             EdgeList& el, Predicate pred,
                                             boost::allow_parallel_edge_tag)
      {
        typedef typename Graph::global_edgelist_selector EdgeListS;
        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

        // remove_if
        while (first != last && !pred(*first))
          ++first;
        incidence_iterator i = first;
        bool self_loop_removed = false;
        if (first != last)
          for (; i != last; ++i) {
            if (self_loop_removed) {
              /* With self loops, the descriptor will show up
               * twice. The first time it will be removed, and now it
               * will be skipped.
               */
              self_loop_removed = false;
            }
            else if (!pred(*i)) {
              *first.base() = *i.base();
              ++first;
            } else {
              if (source(*i, g) == target(*i, g)) self_loop_removed = true;
              else {
                // Remove the edge from the target
                detail::remove_directed_edge_dispatch
                  (*i,
                   g.out_edge_list(target(*i, g)),
                   *(PropT*)(*i).get_property());
              }

              // Erase the edge property
              g.m_edges.erase( (*i.base()).get_iter() );
            }
          }
        el.erase(first.base(), el.end());
      }

      template <class PropT, class Graph, class incidence_iterator,
                class EdgeList, class Predicate>
      inline void
      undirected_remove_out_edge_if_dispatch(Graph& g,
                                             incidence_iterator first,
                                             incidence_iterator last,
                                             EdgeList& el,
                                             Predicate pred,
                                             boost::disallow_parallel_edge_tag)
      {
        typedef typename Graph::global_edgelist_selector EdgeListS;
        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

        for (incidence_iterator next = first;
             first != last; first = next) {
          ++next;
          if (pred(*first)) {
            if (source(*first, g) != target(*first, g)) {
              // Remove the edge from the target
              detail::remove_directed_edge_dispatch
                (*first,
                 g.out_edge_list(target(*first, g)),
                 *(PropT*)(*first).get_property());
            }

            // Erase the edge property
            g.m_edges.erase( (*first.base()).get_iter() );

            // Erase the edge in the source
            el.erase( first.base() );
          }
        }
      }

      template <class edge_descriptor, class EdgeList, class StoredProperty>
      inline void
      remove_directed_edge_dispatch(edge_descriptor e, EdgeList& el,
                                    no_property&)
      {
        for (typename EdgeList::iterator i = el.begin();
             i != el.end(); ++i)
          if ((*i).get_target() == e.m_target) {
            el.erase(i);
            return;
          }
      }

      inline void
      remove_edge(typename Config::edge_descriptor e)
      {
        typedef typename Config::graph_type graph_type;
        graph_type& g = static_cast<graph_type&>(*this);
        typename Config::OutEdgeList& el = g.out_edge_list(source(e, g));
        typedef typename Config::OutEdgeList::value_type::property_type PType;
        detail::remove_directed_edge_dispatch(e, el,
                                              *(PType*)e.get_property());
      }

      inline void
      remove_edge(typename Config::out_edge_iterator iter)
      {
        typedef typename Config::graph_type graph_type;
        graph_type& g = static_cast<graph_type&>(*this);
        typename Config::edge_descriptor e = *iter;
        typename Config::OutEdgeList& el = g.out_edge_list(source(e, g));
        el.erase(iter.base());
      }

    template <class Config>
    inline void
    remove_edge(typename Config::vertex_descriptor u,
                typename Config::vertex_descriptor v,
                directed_graph_helper<Config>& g_)
    {
      typedef typename Config::graph_type graph_type;
      typedef typename Config::edge_parallel_category Cat;
      graph_type& g = static_cast<graph_type&>(g_);
      detail::erase_from_incidence_list(g.out_edge_list(u), v, Cat());
    }


    template <class Config, class Predicate>
    inline void
    remove_out_edge_if(typename Config::vertex_descriptor u, Predicate pred,
                       directed_graph_helper<Config>& g_)
    {
      typedef typename Config::graph_type graph_type;
      graph_type& g = static_cast<graph_type&>(g_);
      typename Config::out_edge_iterator first, last;
      boost::tie(first, last) = out_edges(u, g);
      typedef typename Config::edge_parallel_category edge_parallel_category;
      detail::remove_directed_edge_if_dispatch
        (first, last, g.out_edge_list(u), pred, edge_parallel_category());
    }


    template <class Config, class Predicate>
    inline void
    remove_edge_if(Predicate pred, directed_graph_helper<Config>& g_)
    {
      typedef typename Config::graph_type graph_type;
      graph_type& g = static_cast<graph_type&>(g_);

      typename Config::vertex_iterator vi, vi_end;
      for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi)
        remove_out_edge_if(*vi, pred, g);
    }


    template <class EdgeOrIter, class Config>
    inline void
    remove_edge(EdgeOrIter e_or_iter, directed_graph_helper<Config>& g_)
    {
      g_.remove_edge(e_or_iter);
    }

    template <class Config>
    inline void
    clear_vertex(typename Config::vertex_descriptor u,
                 directed_graph_helper<Config>& g_)
    {
      typedef typename Config::graph_type graph_type;
      typedef typename Config::edge_parallel_category Cat;
      graph_type& g = static_cast<graph_type&>(g_);
      typename Config::vertex_iterator vi, viend;
      for (boost::tie(vi, viend) = vertices(g); vi != viend; ++vi)
        detail::erase_from_incidence_list(g.out_edge_list(*vi), u, Cat());
      g.out_edge_list(u).clear();
      // clear() should be a req of Sequence and AssociativeContainer,
      // or maybe just Container
    }


    template <class Config>
    inline void
    clear_out_edges(typename Config::vertex_descriptor u,
                    directed_graph_helper<Config>& g_)
    {
      typedef typename Config::graph_type graph_type;
      graph_type& g = static_cast<graph_type&>(g_);
      g.out_edge_list(u).clear();
      // clear() should be a req of Sequence and AssociativeContainer,
      // or maybe just Container
    }

    template <class Config>
    inline typename Config::edges_size_type
    num_edges(const directed_graph_helper<Config>& g_)
    {
      typedef typename Config::graph_type graph_type;
      const graph_type& g = static_cast<const graph_type&>(g_);
      typename Config::edges_size_type num_e = 0;
      typename Config::vertex_iterator vi, vi_end;
      for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi)
        num_e += out_degree(*vi, g);
      return num_e;
    }

        template <class edge_descriptor, class Config>
        static void
        apply(edge_descriptor e,
              undirected_graph_helper<Config>& g_,
              StoredProperty& p)
        {
          typedef typename Config::global_edgelist_selector EdgeListS;
          BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

          typedef typename Config::graph_type graph_type;
          graph_type& g = static_cast<graph_type&>(g_);

          typename Config::OutEdgeList& out_el = g.out_edge_list(source(e, g));
          typename Config::OutEdgeList::iterator out_i = out_el.begin();
          typename Config::EdgeIter edge_iter_to_erase;
          for (; out_i != out_el.end(); ++out_i)
            if (&(*out_i).get_property() == &p) {
              edge_iter_to_erase = (*out_i).get_iter();
              out_el.erase(out_i);
              break;
            }
          typename Config::OutEdgeList& in_el = g.out_edge_list(target(e, g));
          typename Config::OutEdgeList::iterator in_i = in_el.begin();
          for (; in_i != in_el.end(); ++in_i)
            if (&(*in_i).get_property() == &p) {
              in_el.erase(in_i);
              break;
            }
          g.m_edges.erase(edge_iter_to_erase);
        }

        template <class edge_descriptor, class Config>
        static void
        apply(edge_descriptor e,
              undirected_graph_helper<Config>& g_,
              no_property&)
        {
          typedef typename Config::global_edgelist_selector EdgeListS;
          BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

          typedef typename Config::graph_type graph_type;
          graph_type& g = static_cast<graph_type&>(g_);
          no_property* p = (no_property*)e.get_property();
          typename Config::OutEdgeList& out_el = g.out_edge_list(source(e, g));
          typename Config::OutEdgeList::iterator out_i = out_el.begin();
          typename Config::EdgeIter edge_iter_to_erase;
          for (; out_i != out_el.end(); ++out_i)
            if (&(*out_i).get_property() == p) {
              edge_iter_to_erase = (*out_i).get_iter();
              out_el.erase(out_i);
              break;
            }
          typename Config::OutEdgeList& in_el = g.out_edge_list(target(e, g));
          typename Config::OutEdgeList::iterator in_i = in_el.begin();
          for (; in_i != in_el.end(); ++in_i)
            if (&(*in_i).get_property() == p) {
              in_el.erase(in_i);
              break;
            }
          g.m_edges.erase(edge_iter_to_erase);
        }

      template <class Graph, class EdgeList, class Vertex>
      inline void
      remove_edge_and_property(Graph& g, EdgeList& el, Vertex v,
                               boost::allow_parallel_edge_tag cat)
      {
        typedef typename Graph::global_edgelist_selector EdgeListS;
        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

        typename EdgeList::iterator i = el.begin(), end = el.end();
        for (; i != end; ++i) {
          if ((*i).get_target() == v) {
            // NOTE: Wihtout this skip, this loop will double-delete properties
            // of loop edges. This solution is based on the observation that
            // the incidence edges of a vertex with a loop are adjacent in the
            // out edge list. This *may* actually hold for multisets also.
            bool skip = (boost::next(i) != end && i->get_iter() == boost::next(i)->get_iter());
            g.m_edges.erase((*i).get_iter());
            if (skip) ++i;
          }
        }
        detail::erase_from_incidence_list(el, v, cat);
      }

      template <class Graph, class EdgeList, class Vertex>
      inline void
      remove_edge_and_property(Graph& g, EdgeList& el, Vertex v,
                               boost::disallow_parallel_edge_tag)
      {
        typedef typename Graph::global_edgelist_selector EdgeListS;
        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

        typedef typename EdgeList::value_type StoredEdge;
        typename EdgeList::iterator i = el.find(StoredEdge(v)), end = el.end();
        BOOST_ASSERT ((i != end));
        if (i != end) {
          g.m_edges.erase((*i).get_iter());
          el.erase(i);
        }
      }

      list_edge(Vertex u, Vertex v, const EdgeProperty& p = EdgeProperty())
        : Base(u, v), m_property(p) { }

      EdgeProperty& get_property() { return m_property; }

      const EdgeProperty& get_property() const { return m_property; }

      list_edge() { }

      bool operator==(const list_edge&) const { return false; }

      bool operator<(const list_edge&) const { return false; }

      inline void
      remove_edge(typename Config::edge_descriptor e)
      {
        typedef typename Config::global_edgelist_selector EdgeListS;
        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

        typedef typename Config::OutEdgeList::value_type::property_type PType;
        detail::remove_undirected_edge_dispatch<PType>::apply
          (e, *this, *(PType*)e.get_property());
      }

      inline void
      remove_edge(typename Config::out_edge_iterator iter)
      {
        this->remove_edge(*iter);
      }

    template <class C>
    inline typename C::InEdgeList&
    in_edge_list(undirected_graph_helper<C>&,
                 typename C::vertex_descriptor v)
    {
      typename C::stored_vertex* sv = (typename C::stored_vertex*)v;
      return sv->m_out_edges;
    }

    template <class C>
    inline const typename C::InEdgeList&
    in_edge_list(const undirected_graph_helper<C>&,
                 typename C::vertex_descriptor v) {
      typename C::stored_vertex* sv = (typename C::stored_vertex*)v;
      return sv->m_out_edges;
    }

    template <class EdgeOrIter, class Config>
    inline void
    remove_edge(EdgeOrIter e, undirected_graph_helper<Config>& g_)
    {
      typedef typename Config::global_edgelist_selector EdgeListS;
      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

      g_.remove_edge(e);
    }

    template <class Config>
    void
    remove_edge(typename Config::vertex_descriptor u,
                typename Config::vertex_descriptor v,
                undirected_graph_helper<Config>& g_)
    {
      typedef typename Config::global_edgelist_selector EdgeListS;
      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

      typedef typename Config::graph_type graph_type;
      graph_type& g = static_cast<graph_type&>(g_);
      typedef typename Config::edge_parallel_category Cat;
      detail::remove_edge_and_property(g, g.out_edge_list(u), v, Cat());
      detail::erase_from_incidence_list(g.out_edge_list(v), u, Cat());
    }


    template <class Config, class Predicate>
    void
    remove_out_edge_if(typename Config::vertex_descriptor u, Predicate pred,
                       undirected_graph_helper<Config>& g_)
    {
      typedef typename Config::global_edgelist_selector EdgeListS;
      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

      typedef typename Config::graph_type graph_type;
      typedef typename Config::OutEdgeList::value_type::property_type PropT;
      graph_type& g = static_cast<graph_type&>(g_);
      typename Config::out_edge_iterator first, last;
      boost::tie(first, last) = out_edges(u, g);
      typedef typename Config::edge_parallel_category Cat;
      detail::undirected_remove_out_edge_if_dispatch<PropT>
        (g, first, last, g.out_edge_list(u), pred, Cat());
    }

    template <class Config, class Predicate>
    void
    remove_in_edge_if(typename Config::vertex_descriptor u, Predicate pred,
                      undirected_graph_helper<Config>& g_)
    {
      typedef typename Config::global_edgelist_selector EdgeListS;
      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

      remove_out_edge_if(u, pred, g_);
    }

    template <class Predicate, class Config>
    void
    remove_edge_if(Predicate pred, undirected_graph_helper<Config>& g_)
    {
      typedef typename Config::global_edgelist_selector EdgeListS;
      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

      typedef typename Config::graph_type graph_type;
      graph_type& g = static_cast<graph_type&>(g_);
      typename Config::edge_iterator ei, ei_end, next;
      boost::tie(ei, ei_end) = edges(g);
      for (next = ei; ei != ei_end; ei = next) {
        ++next;
        if (pred(*ei))
          remove_edge(*ei, g);
      }
    }

    template <class C>
    inline typename C::InEdgeList&
    in_edge_list(bidirectional_graph_helper<C>&,
                 typename C::vertex_descriptor v)
    {
      typename C::stored_vertex* sv = (typename C::stored_vertex*)v;
      return sv->m_in_edges;
    }

    template <class C>
    inline const typename C::InEdgeList&
    in_edge_list(const bidirectional_graph_helper<C>&,
                 typename C::vertex_descriptor v) {
      typename C::stored_vertex* sv = (typename C::stored_vertex*)v;
      return sv->m_in_edges;
    }


    template <class Predicate, class Config>
    inline void
    remove_edge_if(Predicate pred, bidirectional_graph_helper<Config>& g_)
    {
      typedef typename Config::global_edgelist_selector EdgeListS;
      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

      typedef typename Config::graph_type graph_type;
      graph_type& g = static_cast<graph_type&>(g_);
      typename Config::edge_iterator ei, ei_end, next;
      boost::tie(ei, ei_end) = edges(g);
      for (next = ei; ei != ei_end; ei = next) {
        ++next;
        if (pred(*ei))
          remove_edge(*ei, g);
      }
    }


    template <class Config>
    inline void
    clear_in_edges(typename Config::vertex_descriptor u,
                   bidirectional_graph_helper_with_property<Config>& g_)
    {
      typedef typename Config::global_edgelist_selector EdgeListS;
      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

      typedef typename Config::graph_type graph_type;
      typedef typename Config::edge_parallel_category Cat;
      graph_type& g = static_cast<graph_type&>(g_);
      typename Config::InEdgeList& in_el = in_edge_list(g, u);
      typename Config::InEdgeList::iterator
        in_ei = in_el.begin(), in_ei_end = in_el.end();
      for (; in_ei != in_ei_end; ++in_ei) {
        detail::erase_from_incidence_list
          (g.out_edge_list((*in_ei).get_target()), u, Cat());
        g.m_edges.erase((*in_ei).get_iter());
      }
      in_edge_list(g, u).clear();
    }


      static vertex_descriptor null_vertex()
      {
        return 0;
      }


      inline adj_list_impl() { }


      inline adj_list_impl(const adj_list_impl& x) {
        copy_impl(x);
      }

      inline adj_list_impl& operator=(const adj_list_impl& x) {
        this->clear();
        copy_impl(x);
        return *this;
      }

      inline void clear() {
        for (typename StoredVertexList::iterator i = m_vertices.begin();
             i != m_vertices.end(); ++i)
          delete (stored_vertex*)*i;
        m_vertices.clear();
        m_edges.clear();
      }

      inline adj_list_impl(vertices_size_type num_vertices) {
        for (vertices_size_type i = 0; i < num_vertices; ++i)
          add_vertex(static_cast<Derived&>(*this));
      }

      template <class EdgeIterator>
      inline adj_list_impl(vertices_size_type num_vertices,
                           EdgeIterator first, EdgeIterator last)
      {
        vertex_descriptor* v = new vertex_descriptor[num_vertices];
        for (vertices_size_type i = 0; i < num_vertices; ++i)
          v[i] = add_vertex(static_cast<Derived&>(*this));

        while (first != last) {
          add_edge(v[(*first).first], v[(*first).second], *this);
          ++first;
        }
        delete [] v;
      }

      template <class EdgeIterator, class EdgePropertyIterator>
      inline adj_list_impl(vertices_size_type num_vertices,
                           EdgeIterator first, EdgeIterator last,
                           EdgePropertyIterator ep_iter)
      {
        vertex_descriptor* v = new vertex_descriptor[num_vertices];
        for (vertices_size_type i = 0; i < num_vertices; ++i)
          v[i] = add_vertex(static_cast<Derived&>(*this));

        while (first != last) {
          add_edge(v[(*first).first], v[(*first).second], *ep_iter, *this);
          ++first;
          ++ep_iter;
        }
        delete [] v;
      }

      ~adj_list_impl() {
        for (typename StoredVertexList::iterator i = m_vertices.begin();
             i != m_vertices.end(); ++i)
          delete (stored_vertex*)*i;
      }

      inline OutEdgeList& out_edge_list(vertex_descriptor v) {
        stored_vertex* sv = (stored_vertex*)v;
        return sv->m_out_edges;
      }

      inline const OutEdgeList& out_edge_list(vertex_descriptor v) const {
        stored_vertex* sv = (stored_vertex*)v;
        return sv->m_out_edges;
      }

      inline StoredVertexList& vertex_set() { return m_vertices; }

      inline const StoredVertexList& vertex_set() const { return m_vertices; }


      inline void copy_impl(const adj_list_impl& x_)
      {
        const Derived& x = static_cast<const Derived&>(x_);

        // Would be better to have a constant time way to get from
        // vertices in x to the corresponding vertices in *this.
        std::map<stored_vertex*,stored_vertex*> vertex_map;

        // Copy the stored vertex objects by adding each vertex
        // and copying its property object.
        vertex_iterator vi, vi_end;
        for (boost::tie(vi, vi_end) = vertices(x); vi != vi_end; ++vi) {
          stored_vertex* v = (stored_vertex*)add_vertex(*this);
          v->m_property = ((stored_vertex*)*vi)->m_property;
          vertex_map[(stored_vertex*)*vi] = v;
        }
        // Copy the edges by adding each edge and copying its
        // property object.
        edge_iterator ei, ei_end;
        for (boost::tie(ei, ei_end) = edges(x); ei != ei_end; ++ei) {
          edge_descriptor e;
          bool inserted;
          vertex_descriptor s = source(*ei,x), t = target(*ei,x);
          boost::tie(e, inserted) = add_edge(vertex_map[(stored_vertex*)s],
                                             vertex_map[(stored_vertex*)t], *this);
          *((edge_property_type*)e.m_eproperty)
            = *((edge_property_type*)(*ei).m_eproperty);
        }
      }

    template <class Derived, class Config, class Base>
    inline typename Config::vertex_descriptor
    add_vertex(adj_list_impl<Derived, Config, Base>& g_)
    {
      Derived& g = static_cast<Derived&>(g_);
      typedef typename Config::stored_vertex stored_vertex;
      stored_vertex* v = new stored_vertex;
      typename Config::StoredVertexList::iterator pos;
      bool inserted;
      boost::tie(pos,inserted) = boost::graph_detail::push(g.m_vertices, v);
      v->m_position = pos;
      g.added_vertex(v);
      return v;
    }

    template <class Derived, class Config, class Base>
    inline typename Config::vertex_descriptor
    add_vertex(const typename Config::vertex_property_type& p,
               adj_list_impl<Derived, Config, Base>& g_)
    {
      typedef typename Config::vertex_descriptor vertex_descriptor;
      Derived& g = static_cast<Derived&>(g_);
      if (optional<vertex_descriptor> v
            = g.vertex_by_property(get_property_value(p, vertex_bundle)))
        return *v;

      typedef typename Config::stored_vertex stored_vertex;
      stored_vertex* v = new stored_vertex(p);
      typename Config::StoredVertexList::iterator pos;
      bool inserted;
      boost::tie(pos,inserted) = boost::graph_detail::push(g.m_vertices, v);
      v->m_position = pos;
      g.added_vertex(v);
      return v;
    }

    template <class Derived, class Config, class Base>
    inline void remove_vertex(typename Config::vertex_descriptor u,
                              adj_list_impl<Derived, Config, Base>& g_)
    {
      typedef typename Config::stored_vertex stored_vertex;
      Derived& g = static_cast<Derived&>(g_);
      g.removing_vertex(u, boost::graph_detail::iterator_stability(g_.m_vertices));
      stored_vertex* su = (stored_vertex*)u;
      g.m_vertices.erase(su->m_position);
      delete su;
    }

    template <class Derived, class Config, class Base>
    inline typename Config::vertex_descriptor
    vertex(typename Config::vertices_size_type n,
           const adj_list_impl<Derived, Config, Base>& g_)
    {
      const Derived& g = static_cast<const Derived&>(g_);
      typename Config::vertex_iterator i = vertices(g).first;
      while (n--) ++i; // std::advance(i, n); (not VC++ portable)
      return *i;
    }


      template <class Graph, class vertex_descriptor>
      inline void
      remove_vertex_dispatch(Graph& g, vertex_descriptor u,
                             boost::directed_tag)
      {
        typedef typename Graph::edge_parallel_category edge_parallel_category;
        g.m_vertices.erase(g.m_vertices.begin() + u);
        vertex_descriptor V = num_vertices(g);
        if (u != V) {
          for (vertex_descriptor v = 0; v < V; ++v)
            reindex_edge_list(g.out_edge_list(v), u, edge_parallel_category());
        }
      }


      template <class Graph, class vertex_descriptor>
      inline void
      remove_vertex_dispatch(Graph& g, vertex_descriptor u,
                             boost::undirected_tag)
      {
        typedef typename Graph::global_edgelist_selector EdgeListS;
        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

        typedef typename Graph::edge_parallel_category edge_parallel_category;
        g.m_vertices.erase(g.m_vertices.begin() + u);
        vertex_descriptor V = num_vertices(g);
        for (vertex_descriptor v = 0; v < V; ++v)
          reindex_edge_list(g.out_edge_list(v), u,
                            edge_parallel_category());
        typedef typename Graph::EdgeContainer Container;
        typedef typename Container::iterator Iter;
        Iter ei = g.m_edges.begin(), ei_end = g.m_edges.end();
        for (; ei != ei_end; ++ei) {
          if (ei->m_source > u)
            --ei->m_source;
          if (ei->m_target > u)
            --ei->m_target;
        }
      }

      template <class Graph, class vertex_descriptor>
      inline void
      remove_vertex_dispatch(Graph& g, vertex_descriptor u,
                             boost::bidirectional_tag)
      {
        typedef typename Graph::global_edgelist_selector EdgeListS;
        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));

        typedef typename Graph::edge_parallel_category edge_parallel_category;
        g.m_vertices.erase(g.m_vertices.begin() + u);
        vertex_descriptor V = num_vertices(g);
        vertex_descriptor v;
        if (u != V) {
          for (v = 0; v < V; ++v)
            reindex_edge_list(g.out_edge_list(v), u,
                              edge_parallel_category());
          for (v = 0; v < V; ++v)
            reindex_edge_list(in_edge_list(g, v), u,
                              edge_parallel_category());

          typedef typename Graph::EdgeContainer Container;
          typedef typename Container::iterator Iter;
          Iter ei = g.m_edges.begin(), ei_end = g.m_edges.end();
          for (; ei != ei_end; ++ei) {
            if (ei->m_source > u)
              --ei->m_source;
            if (ei->m_target > u)
              --ei->m_target;
          }
        }
      }


      template <class EdgeList, class vertex_descriptor>
      inline void
      reindex_edge_list(EdgeList& el, vertex_descriptor u,
                        boost::allow_parallel_edge_tag)
      {
        typename EdgeList::iterator ei = el.begin(), e_end = el.end();
        for (; ei != e_end; ++ei)
          if ((*ei).get_target() > u)
            --(*ei).get_target();
      }

      template <class EdgeList, class vertex_descriptor>
      inline void
      reindex_edge_list(EdgeList& el, vertex_descriptor u,
                        boost::disallow_parallel_edge_tag)
      {
        typename EdgeList::iterator ei = el.begin(), e_end = el.end();
        while (ei != e_end) {
          typename EdgeList::value_type ce = *ei;
          ++ei;
          if (ce.get_target() > u) {
            el.erase(ce);
            --ce.get_target();
            el.insert(ce);
          }
        }
      }


      static vertex_descriptor null_vertex()
      {
        return (std::numeric_limits<vertex_descriptor>::max)();
      }


      inline vec_adj_list_impl() { }


      inline vec_adj_list_impl(const vec_adj_list_impl& x) {
        copy_impl(x);
      }

      inline vec_adj_list_impl& operator=(const vec_adj_list_impl& x) {
        this->clear();
        copy_impl(x);
        return *this;
      }

      inline void clear() {
        m_vertices.clear();
        m_edges.clear();
      }


      inline vec_adj_list_impl(vertices_size_type _num_vertices)
        : m_vertices(_num_vertices) { }


      template <class EdgeIterator>
      inline vec_adj_list_impl(vertices_size_type num_vertices,
                               EdgeIterator first, EdgeIterator last)
        : m_vertices(num_vertices)
      {
        while (first != last) {
          add_edge((*first).first, (*first).second,
                   static_cast<Graph&>(*this));
          ++first;
        }
      }

      template <class EdgeIterator, class EdgePropertyIterator>
      inline vec_adj_list_impl(vertices_size_type num_vertices,
                               EdgeIterator first, EdgeIterator last,
                               EdgePropertyIterator ep_iter)
        : m_vertices(num_vertices)
      {
        while (first != last) {
          add_edge((*first).first, (*first).second, *ep_iter,
                   static_cast<Graph&>(*this));
          ++first;
          ++ep_iter;
        }
      }

      inline boost::integer_range<vertex_descriptor> vertex_set() const {
        return boost::integer_range<vertex_descriptor>(0, m_vertices.size());
      }

      inline OutEdgeList& out_edge_list(vertex_descriptor v) {
        return m_vertices[v].m_out_edges;
      }

      inline const OutEdgeList& out_edge_list(vertex_descriptor v) const {
        return m_vertices[v].m_out_edges;
      }

      inline void copy_impl(const vec_adj_list_impl& x_)
      {
        const Graph& x = static_cast<const Graph&>(x_);
        // Copy the stored vertex objects by adding each vertex
        // and copying its property object.
        for (vertices_size_type i = 0; i < num_vertices(x); ++i) {
          vertex_descriptor v = add_vertex(*this);
          m_vertices[v].m_property = x.m_vertices[i].m_property;
        }
        // Copy the edges by adding each edge and copying its
        // property object.
        edge_iterator ei, ei_end;
        for (boost::tie(ei, ei_end) = edges(x); ei != ei_end; ++ei) {
          edge_descriptor e;
          bool inserted;
          boost::tie(e, inserted) = add_edge(source(*ei,x), target(*ei,x) , *this);
          *((edge_property_type*)e.m_eproperty)
            = *((edge_property_type*)(*ei).m_eproperty);
        }
      }

    template <class G, class C, class B>
    inline typename C::InEdgeList&
    in_edge_list(vec_adj_list_impl<G,C,B>& g,
                 typename C::vertex_descriptor v) {
      return g.m_vertices[v].m_in_edges;
    }

    template <class G, class C, class B>
    inline const typename C::InEdgeList&
    in_edge_list(const vec_adj_list_impl<G,C,B>& g,
                 typename C::vertex_descriptor v) {
      return g.m_vertices[v].m_in_edges;
    }

    template <class Graph, class Config, class Base>
    inline typename Config::vertex_descriptor
    add_vertex(vec_adj_list_impl<Graph, Config, Base>& g_) {
      Graph& g = static_cast<Graph&>(g_);
      g.m_vertices.resize(g.m_vertices.size() + 1);
      g.added_vertex(g.m_vertices.size() - 1);
      return g.m_vertices.size() - 1;
    }


    template <class Graph, class Config, class Base>
    inline typename Config::vertex_descriptor
    add_vertex(const typename Config::vertex_property_type& p,
               vec_adj_list_impl<Graph, Config, Base>& g_) {
      typedef typename Config::vertex_descriptor vertex_descriptor;
      Graph& g = static_cast<Graph&>(g_);
      if (optional<vertex_descriptor> v
            = g.vertex_by_property(get_property_value(p, vertex_bundle)))
        return *v;
      typedef typename Config::stored_vertex stored_vertex;
      g.m_vertices.push_back(stored_vertex(p));
      g.added_vertex(g.m_vertices.size() - 1);
      return g.m_vertices.size() - 1;
    }

      inline adj_list_vertex_all_properties_map(const Graph* = 0, vertex_all_t = vertex_all_t()) { }

      inline PropRef operator[](key_type v) const {
        StoredVertex* sv = (StoredVertex*)v;
        return sv->m_property;
      }

      inline PropRef operator()(key_type v) const {
        return this->operator[](v);
      }

      vec_adj_list_vertex_property_map(GraphPtr g = 0, Tag tag = Tag()) : m_g(g), m_tag(tag) { }

      inline Reference operator[](key_type v) const {
        return get_property_value(m_g->m_vertices[v].m_property, m_tag);
      }

      inline Reference operator()(key_type v) const {
        return this->operator[](v);
      }

      vec_adj_list_vertex_all_properties_map(GraphPtr g = 0, vertex_all_t = vertex_all_t()) : m_g(g) { }

      inline PropertyRef operator[](key_type v) const {
        return m_g->m_vertices[v].m_property;
      }

      inline PropertyRef operator()(key_type v) const {
        return this->operator[](v);
      }

      inline vec_adj_list_vertex_id_map() { }

      template <class Graph>
      inline vec_adj_list_vertex_id_map(const Graph&, vertex_index_t) { }

      inline value_type operator[](key_type v) const { return v; }

      inline value_type operator()(key_type v) const { return v; }

      explicit adj_list_edge_property_map(Tag tag = Tag()): tag(tag) {}

      inline Ref operator[](key_type e) const {
        Property& p = *(Property*)e.get_property();
        return get_property_value(p, tag);
      }

      inline Ref operator()(key_type e) const {
        return this->operator[](e);
      }

      explicit adj_list_edge_all_properties_map(edge_all_t = edge_all_t()) {}

      inline PropRef operator[](key_type e) const {
        return *(PropPtr)e.get_property();
      }

      inline PropRef operator()(key_type e) const {
        return this->operator[](e);
      }

    std::size_t
    operator()(const boost::detail::stored_edge<V>& e) const
    {
      return hash<V>()(e.m_target);
    }

    std::size_t
    operator()(const boost::detail::stored_edge_property<V,P>& e) const
    {
      return hash<V>()(e.m_target);
    }

    std::size_t
    operator()(const boost::detail::stored_edge_iter<V,I,P>& e) const
    {
      return hash<V>()(e.m_target);
    }

      inline edge_base() {}
 
      inline edge_base(Vertex s, Vertex d)
        : m_source(s), m_target(d) { }

      
      inline edge_desc_impl() : m_eproperty(0) {}
 
      
      inline edge_desc_impl(Vertex s, Vertex d, const property_type* eplug)
        : Base(s,d), m_eproperty(const_cast<property_type*>(eplug)) { }

      
      property_type* get_property() { return m_eproperty; }

      const property_type* get_property() const { return m_eproperty; }


    template <class D, class V>
    inline bool
    operator==(const detail::edge_desc_impl<D,V>& a, 
               const detail::edge_desc_impl<D,V>& b)
    {
      return a.get_property() == b.get_property();
    }

    template <class D, class V>
    inline bool
    operator!=(const detail::edge_desc_impl<D,V>& a, 
               const detail::edge_desc_impl<D,V>& b)
    {
      return ! (a.get_property() == b.get_property());
    }

    template <class D, class V>
    inline bool
    operator<(const detail::edge_desc_impl<D,V>& a, 
               const detail::edge_desc_impl<D,V>& b)
    {
      return a.get_property() < b.get_property();
    }

    template <class D, class V>
    inline bool
    operator<=(const detail::edge_desc_impl<D,V>& a, 
               const detail::edge_desc_impl<D,V>& b)
    {
      return a.get_property() <= b.get_property();
    }

    template <class D, class V>
    inline bool
    operator>(const detail::edge_desc_impl<D,V>& a, 
               const detail::edge_desc_impl<D,V>& b)
    {
      return a.get_property() > b.get_property();
    }

    template <class D, class V>
    inline bool
    operator>=(const detail::edge_desc_impl<D,V>& a, 
               const detail::edge_desc_impl<D,V>& b)
    {
      return a.get_property() >= b.get_property();
    }


template<typename InputIterator>
size_t
reserve_count_for_single_pass_helper(InputIterator, InputIterator,
                                     std::input_iterator_tag)
{
  // Do nothing: we have no idea how much storage to reserve.
  return 0;
}


template<typename InputIterator>
size_t
reserve_count_for_single_pass(InputIterator first, InputIterator last) {
  typedef typename std::iterator_traits<InputIterator>::iterator_category
    category;
  return reserve_count_for_single_pass_helper(first, last, category());
}


template <typename KeyIterator, typename RowstartIterator,
          typename VerticesSize, typename KeyFilter, typename KeyTransform>
void
count_starts
  (KeyIterator begin, KeyIterator end,
   RowstartIterator starts, // Must support numverts + 1 elements
   VerticesSize numkeys,
   KeyFilter key_filter,
   KeyTransform key_transform) {

  typedef typename std::iterator_traits<RowstartIterator>::value_type EdgeIndex;

  // Put the degree of each vertex v into m_rowstart[v + 1]
  for (KeyIterator i = begin; i != end; ++i) {
    if (key_filter(*i)) {
      BOOST_ASSERT (key_transform(*i) < numkeys);
      ++starts[key_transform(*i) + 1];
    }
  }

  // Compute the partial sum of the degrees to get the actual values of
  // m_rowstart
  EdgeIndex start_of_this_row = 0;
  starts[0] = start_of_this_row;
  for (VerticesSize i = 1; i < numkeys + 1; ++i) {
    start_of_this_row += starts[i];
    starts[i] = start_of_this_row;
  }
}


template <typename KeyIterator, typename RowstartIterator,
          typename NumKeys,
          typename Value1InputIter,
          typename Value1OutputIter, typename KeyFilter, typename KeyTransform>
void
histogram_sort(KeyIterator key_begin, KeyIterator key_end,
               RowstartIterator rowstart, // Must support numkeys + 1 elements and be precomputed
               NumKeys numkeys,
               Value1InputIter values1_begin,
               Value1OutputIter values1_out,
               KeyFilter key_filter,
               KeyTransform key_transform) {

  typedef typename std::iterator_traits<RowstartIterator>::value_type EdgeIndex;

  // Histogram sort the edges by their source vertices, putting the targets
  // into m_column.  The index current_insert_positions[v] contains the next
  // location to insert out edges for vertex v.
  std::vector<EdgeIndex>
    current_insert_positions(rowstart, rowstart + numkeys);
  Value1InputIter v1i = values1_begin;
  for (KeyIterator i = key_begin; i != key_end; ++i, ++v1i) {
    if (key_filter(*i)) {
      NumKeys source = key_transform(*i);
      BOOST_ASSERT (source < numkeys);
      EdgeIndex insert_pos = current_insert_positions[source];
      ++current_insert_positions[source];
      values1_out[insert_pos] = *v1i;
    }
  }
}


template <typename KeyIterator, typename RowstartIterator,
          typename NumKeys,
          typename Value1InputIter,
          typename Value1OutputIter,
          typename Value2InputIter,
          typename Value2OutputIter,
          typename KeyFilter, typename KeyTransform>
void
histogram_sort(KeyIterator key_begin, KeyIterator key_end,
               RowstartIterator rowstart, // Must support numkeys + 1 elements and be precomputed
               NumKeys numkeys,
               Value1InputIter values1_begin,
               Value1OutputIter values1_out,
               Value2InputIter values2_begin,
               Value2OutputIter values2_out,
               KeyFilter key_filter,
               KeyTransform key_transform) {

  typedef typename std::iterator_traits<RowstartIterator>::value_type EdgeIndex;

  // Histogram sort the edges by their source vertices, putting the targets
  // into m_column.  The index current_insert_positions[v] contains the next
  // location to insert out edges for vertex v.
  std::vector<EdgeIndex>
    current_insert_positions(rowstart, rowstart + numkeys);
  Value1InputIter v1i = values1_begin;
  Value2InputIter v2i = values2_begin;
  for (KeyIterator i = key_begin; i != key_end; ++i, ++v1i, ++v2i) {
    if (key_filter(*i)) {
      NumKeys source = key_transform(*i);
      BOOST_ASSERT (source < numkeys);
      EdgeIndex insert_pos = current_insert_positions[source];
      ++current_insert_positions[source];
      values1_out[insert_pos] = *v1i;
      values2_out[insert_pos] = *v2i;
    }
  }
}


template <typename KeyIterator, typename RowstartIterator,
          typename NumKeys,
          typename Value1Iter,
          typename KeyTransform>
void
histogram_sort_inplace(KeyIterator key_begin,
                       RowstartIterator rowstart, // Must support numkeys + 1 elements and be precomputed
                       NumKeys numkeys,
                       Value1Iter values1,
                       KeyTransform key_transform) {

  typedef typename std::iterator_traits<RowstartIterator>::value_type EdgeIndex;

  // 1. Copy m_rowstart (except last element) to get insert positions
  std::vector<EdgeIndex> insert_positions(rowstart, rowstart + numkeys);
  // 2. Swap the sources and targets into place
  for (size_t i = 0; i < rowstart[numkeys]; ++i) {
    BOOST_ASSERT (key_transform(key_begin[i]) < numkeys);
    // While edge i is not in the right bucket:
    while (!(i >= rowstart[key_transform(key_begin[i])] && i < insert_positions[key_transform(key_begin[i])])) {
      // Add a slot in the right bucket
      size_t target_pos = insert_positions[key_transform(key_begin[i])]++;
      BOOST_ASSERT (target_pos < rowstart[key_transform(key_begin[i]) + 1]);
      if (target_pos == i) continue;
      // Swap this edge into place
      using std::swap;
      swap(key_begin[i], key_begin[target_pos]);
      swap(values1[i], values1[target_pos]);
    }
  }
}


template <typename KeyIterator, typename RowstartIterator,
          typename NumKeys,
          typename Value1Iter,
          typename Value2Iter,
          typename KeyTransform>
void
histogram_sort_inplace(KeyIterator key_begin,
                       RowstartIterator rowstart, // Must support numkeys + 1 elements and be precomputed
                       NumKeys numkeys,
                       Value1Iter values1,
                       Value2Iter values2,
                       KeyTransform key_transform) {

  typedef typename std::iterator_traits<RowstartIterator>::value_type EdgeIndex;

  // 1. Copy m_rowstart (except last element) to get insert positions
  std::vector<EdgeIndex> insert_positions(rowstart, rowstart + numkeys);
  // 2. Swap the sources and targets into place
  for (size_t i = 0; i < rowstart[numkeys]; ++i) {
    BOOST_ASSERT (key_transform(key_begin[i]) < numkeys);
    // While edge i is not in the right bucket:
    while (!(i >= rowstart[key_transform(key_begin[i])] && i < insert_positions[key_transform(key_begin[i])])) {
      // Add a slot in the right bucket
      size_t target_pos = insert_positions[key_transform(key_begin[i])]++;
      BOOST_ASSERT (target_pos < rowstart[key_transform(key_begin[i]) + 1]);
      if (target_pos == i) continue;
      // Swap this edge into place
      using std::swap;
      swap(key_begin[i], key_begin[target_pos]);
      swap(values1[i], values1[target_pos]);
      swap(values2[i], values2[target_pos]);
    }
  }
}


template <typename InputIterator, typename VerticesSize>
void split_into_separate_coords(InputIterator begin, InputIterator end,
                                std::vector<VerticesSize>& firsts,
                                std::vector<VerticesSize>& seconds) {
  firsts.clear();
  seconds.clear();
  size_t reserve_size
    = detail::reserve_count_for_single_pass(begin, end);
  firsts.reserve(reserve_size);
  seconds.reserve(reserve_size);
  for (; begin != end; ++begin) {
    std::pair<VerticesSize, VerticesSize> edge = *begin;
    firsts.push_back(edge.first);
    seconds.push_back(edge.second);
  }
}


template <typename InputIterator, typename VerticesSize, typename SourceFilter>
void split_into_separate_coords_filtered
  (InputIterator begin, InputIterator end,
   std::vector<VerticesSize>& firsts,
   std::vector<VerticesSize>& seconds,
   const SourceFilter& filter) {
  firsts.clear();
  seconds.clear();
  for (; begin != end; ++begin) {
    std::pair<VerticesSize, VerticesSize> edge = *begin;
    if (filter(edge.first)) {
      firsts.push_back(edge.first);
      seconds.push_back(edge.second);
    }
  }
}

  result_type operator()(const Pair& p) const {return p.first;}

  result_type operator()(const Pair& p) const {return p.second;}

      components_recorder(ComponentsPA c, 
                          comp_type& c_count, 
                          DFSVisitor v)
        : DFSVisitor(v), m_component(c), m_count(c_count) {}


      template <class Vertex, class Graph>
      void start_vertex(Vertex u, Graph& g) {
        ++m_count;
        DFSVisitor::start_vertex(u, g);
      }

      template <class Vertex, class Graph>
      void discover_vertex(Vertex u, Graph& g) {
        put(m_component, u, m_count);
        DFSVisitor::discover_vertex(u, g);
      }

      time_recorder(DiscoverTimeMap d, FinishTimeMap f, TimeT& t, DFSVisitor v)
        : DFSVisitor(v), m_discover_time(d), m_finish_time(f), m_t(t) {}


      template <class Vertex, class Graph>
      void discover_vertex(Vertex u, Graph& g) {
        put(m_discover_time, u, ++m_t);
        DFSVisitor::discover_vertex(u, g);
      }

      template <class Vertex, class Graph>
      void finish_vertex(Vertex u, Graph& g) {
        put(m_finish_time, u, ++m_t);
        DFSVisitor::discover_vertex(u, g);
      }

    template <class DiscoverTimeMap, class FinishTimeMap, class TimeT, 
      class DFSVisitor>
    time_recorder<DiscoverTimeMap, FinishTimeMap, TimeT, DFSVisitor>
    record_times(DiscoverTimeMap d, FinishTimeMap f, TimeT& t, DFSVisitor vis)
    {
      return time_recorder<DiscoverTimeMap, FinishTimeMap, TimeT, DFSVisitor>
        (d, f, t, vis);
    }

    
    template <class Parent, class OutputIterator, class Integer>
    inline void
    build_components_header(Parent p, 
                            OutputIterator header,
                            Integer num_nodes)
    {
      Parent component = p;
      Integer component_num = 0;
      for (Integer v = 0; v != num_nodes; ++v) 
        if (p[v] == v) {
          *header++ = v;
          component[v] = component_num++;
        }
    }

    template <class Next, class T, class V>
    inline void push_front(Next next, T& head, V x)
    {
      T tmp = head;
      head = x;
      next[x] = tmp;
    }

    template <class Parent1, class Parent2, 
              class Integer>
    void
    link_components(Parent1 component, Parent2 header, 
                    Integer num_nodes, Integer num_components)
    {
      // Make the non-representative vertices point to their component
      Parent1 representative = component;
      for (Integer v = 0; v != num_nodes; ++v)
        if (component[v] >= num_components || header[component[v]] != v)
          component[v] = component[representative[v]];
      
      // initialize the "head" of the lists to "NULL"
      std::fill_n(header, num_components, num_nodes);
      
      // Add each vertex to the linked list for its component
      Parent1 next = component;
      for (Integer k = 0; k != num_nodes; ++k)
        push_front(next, header[component[k]], k);
    }

    

    
    template <class IndexContainer, class HeaderContainer>
    void
    construct_component_index(IndexContainer& index, HeaderContainer& header)
    {
      build_components_header(index.begin(), 
                              std::back_inserter(header),
                              index.end() - index.begin());
      
      link_components(index.begin(), header.begin(),
                      index.end() - index.begin(), 
                      header.end() - header.begin());
    }

      
      component_iterator() {}

      component_iterator(IndexIterator x, Integer i) 
        : next(x), node(i) {}

      Integer operator*() const {
        return node;
      }

      self& operator++() {
        node = next[node];
        return *this;
      }

    
    template <class IndexIterator, class Integer, class Distance>
    inline bool 
    operator==(const component_iterator<IndexIterator, Integer, Distance>& x,
               const component_iterator<IndexIterator, Integer, Distance>& y)
    {
      return x.node == y.node;
    }


  template<typename Vertex, typename EdgeIndex>
  inline EdgeIndex
  get(const csr_edge_index_map<Vertex, EdgeIndex>&,
      const csr_edge_descriptor<Vertex, EdgeIndex>& key)
  {
    return key.idx;
  }


    static vertex_descriptor null_vertex() { return vertex_descriptor(-1); }


    compressed_sparse_row_structure(Vertex numverts = 0)
      : m_rowstart(numverts + 1, EdgeIndex(0)), m_column()
      {}

    template <typename MultiPassInputIterator, typename GlobalToLocal, typename SourcePred>
    void
    assign_unsorted_multi_pass_edges(MultiPassInputIterator edge_begin,
                                     MultiPassInputIterator edge_end,
                                     vertices_size_type numlocalverts,
                                     const GlobalToLocal& global_to_local,
                                     const SourcePred& source_pred) {
      m_rowstart.clear();
      m_rowstart.resize(numlocalverts + 1, 0);
      typedef std::pair<vertices_size_type, vertices_size_type> edge_type;
      typedef boost::transform_iterator<boost::graph::detail::project1st<edge_type>, MultiPassInputIterator> source_iterator;
      typedef boost::transform_iterator<boost::graph::detail::project2nd<edge_type>, MultiPassInputIterator> target_iterator;
      source_iterator sources_begin(edge_begin, boost::graph::detail::project1st<edge_type>());
      source_iterator sources_end(edge_end, boost::graph::detail::project1st<edge_type>());
      target_iterator targets_begin(edge_begin, boost::graph::detail::project2nd<edge_type>());
      target_iterator targets_end(edge_end, boost::graph::detail::project2nd<edge_type>());

      boost::graph::detail::count_starts
        (sources_begin, sources_end, m_rowstart.begin(), numlocalverts,
         source_pred, boost::make_property_map_function(global_to_local));

      m_column.resize(m_rowstart.back());
      inherited_edge_properties::resize(m_rowstart.back());

      boost::graph::detail::histogram_sort
        (sources_begin, sources_end, m_rowstart.begin(), numlocalverts,
         targets_begin, m_column.begin(),
         source_pred, boost::make_property_map_function(global_to_local));
    }

    template <typename MultiPassInputIterator, typename EdgePropertyIterator, typename GlobalToLocal, typename SourcePred>
    void
    assign_unsorted_multi_pass_edges(MultiPassInputIterator edge_begin,
                                     MultiPassInputIterator edge_end,
                                     EdgePropertyIterator ep_iter,
                                     vertices_size_type numlocalverts,
                                     const GlobalToLocal& global_to_local,
                                     const SourcePred& source_pred) {
      m_rowstart.clear();
      m_rowstart.resize(numlocalverts + 1, 0);
      typedef std::pair<vertices_size_type, vertices_size_type> edge_type;
      typedef boost::transform_iterator<boost::graph::detail::project1st<edge_type>, MultiPassInputIterator> source_iterator;
      typedef boost::transform_iterator<boost::graph::detail::project2nd<edge_type>, MultiPassInputIterator> target_iterator;
      source_iterator sources_begin(edge_begin, boost::graph::detail::project1st<edge_type>());
      source_iterator sources_end(edge_end, boost::graph::detail::project1st<edge_type>());
      target_iterator targets_begin(edge_begin, boost::graph::detail::project2nd<edge_type>());
      target_iterator targets_end(edge_end, boost::graph::detail::project2nd<edge_type>());

      boost::graph::detail::count_starts
        (sources_begin, sources_end, m_rowstart.begin(), numlocalverts,
         source_pred, boost::make_property_map_function(global_to_local));

      m_column.resize(m_rowstart.back());
      inherited_edge_properties::resize(m_rowstart.back());

      boost::graph::detail::histogram_sort
        (sources_begin, sources_end, m_rowstart.begin(), numlocalverts,
         targets_begin, m_column.begin(),
         ep_iter, inherited_edge_properties::begin(),
         source_pred, boost::make_property_map_function(global_to_local));
    }

    template<typename InputIterator, typename GlobalToLocal, typename SourcePred>
    void assign_from_sorted_edges(
           InputIterator edge_begin, InputIterator edge_end,
           const GlobalToLocal& global_to_local,
           const SourcePred& source_pred,
           vertices_size_type numlocalverts,
           edges_size_type numedges_or_zero) {
      m_column.clear();
      m_column.reserve(numedges_or_zero);
      m_rowstart.resize(numlocalverts + 1);
      EdgeIndex current_edge = 0;
      Vertex current_vertex_plus_one = 1;
      m_rowstart[0] = 0;
      for (InputIterator ei = edge_begin; ei != edge_end; ++ei) {
        if (!source_pred(ei->first)) continue;
        Vertex src = get(global_to_local, ei->first);
        Vertex tgt = ei->second;
        for (; current_vertex_plus_one != src + 1; ++current_vertex_plus_one)
          m_rowstart[current_vertex_plus_one] = current_edge;
        m_column.push_back(tgt);
        ++current_edge;
      }

      // The remaining vertices have no edges
      for (; current_vertex_plus_one != numlocalverts + 1; ++current_vertex_plus_one)
        m_rowstart[current_vertex_plus_one] = current_edge;

      // Default-construct properties for edges
      inherited_edge_properties::resize(m_column.size());
    }

    template<typename InputIterator, typename EdgePropertyIterator, typename GlobalToLocal, typename SourcePred>
    void assign_from_sorted_edges(
           InputIterator edge_begin, InputIterator edge_end,
           EdgePropertyIterator ep_iter,
           const GlobalToLocal& global_to_local,
           const SourcePred& source_pred,
           vertices_size_type numlocalverts,
           edges_size_type numedges_or_zero) {
      // Reserving storage in advance can save us lots of time and
      // memory, but it can only be done if we have forward iterators or
      // the user has supplied the number of edges.
      edges_size_type numedges = numedges_or_zero;
      if (numedges == 0) {
        numedges = boost::graph::detail::reserve_count_for_single_pass(edge_begin, edge_end);
      }
      m_column.clear();
      m_column.reserve(numedges_or_zero);
      inherited_edge_properties::clear();
      inherited_edge_properties::reserve(numedges_or_zero);
      m_rowstart.resize(numlocalverts + 1);
      EdgeIndex current_edge = 0;
      Vertex current_vertex_plus_one = 1;
      m_rowstart[0] = 0;
      for (InputIterator ei = edge_begin; ei != edge_end; ++ei, ++ep_iter) {
        if (!source_pred(ei->first)) continue;
        Vertex src = get(global_to_local, ei->first);
        Vertex tgt = ei->second;
        for (; current_vertex_plus_one != src + 1; ++current_vertex_plus_one)
          m_rowstart[current_vertex_plus_one] = current_edge;
        m_column.push_back(tgt);
        inherited_edge_properties::push_back(*ep_iter);
        ++current_edge;
      }

      // The remaining vertices have no edges
      for (; current_vertex_plus_one != numlocalverts + 1; ++current_vertex_plus_one)
        m_rowstart[current_vertex_plus_one] = current_edge;
    }

    template <typename GlobalToLocal>
    void assign_sources_and_targets_global(std::vector<vertex_descriptor>& sources,
                                           std::vector<vertex_descriptor>& targets,
                                           vertices_size_type numverts,
                                           GlobalToLocal global_to_local) {
      BOOST_ASSERT (sources.size() == targets.size());
      // Do an in-place histogram sort (at least that's what I think it is) to
      // sort sources and targets
      m_rowstart.clear();
      m_rowstart.resize(numverts + 1);
      boost::graph::detail::count_starts
        (sources.begin(), sources.end(), m_rowstart.begin(), numverts,
         keep_all(), boost::make_property_map_function(global_to_local));
      boost::graph::detail::histogram_sort_inplace
        (sources.begin(), m_rowstart.begin(), numverts,
         targets.begin(), boost::make_property_map_function(global_to_local));
      // Now targets is the correct vector (properly sorted by source) for
      // m_column
      m_column.swap(targets);
      inherited_edge_properties::resize(m_rowstart.back());
    }

    template<typename Graph, typename VertexIndexMap>
    void
    assign(const Graph& g, const VertexIndexMap& vi,
           vertices_size_type numverts, edges_size_type numedges)
    {
      m_rowstart.resize(numverts + 1);
      m_column.resize(numedges);
      inherited_edge_properties::resize(numedges);
      EdgeIndex current_edge = 0;
      typedef typename boost::graph_traits<Graph>::vertex_descriptor g_vertex;
      typedef typename boost::graph_traits<Graph>::out_edge_iterator
        g_out_edge_iter;

      std::vector<g_vertex> ordered_verts_of_g(numverts);
      BGL_FORALL_VERTICES_T(v, g, Graph) {
        ordered_verts_of_g[get(vertex_index, g, v)] = v;
      }
      for (Vertex i = 0; i != numverts; ++i) {
        m_rowstart[i] = current_edge;
        g_vertex v = ordered_verts_of_g[i];
        g_out_edge_iter ei, ei_end;
        for (boost::tie(ei, ei_end) = out_edges(v, g); ei != ei_end; ++ei) {
          m_column[current_edge++] = get(vi, target(*ei, g));
        }
      }
      m_rowstart[numverts] = current_edge;
    }

    template <typename BidirectionalIteratorOrig, typename EPIterOrig,
              typename GlobalToLocal>
    void
    add_edges_sorted_internal(
        BidirectionalIteratorOrig first_sorted,
        BidirectionalIteratorOrig last_sorted,
        EPIterOrig ep_iter_sorted,
        const GlobalToLocal& global_to_local) {
      typedef boost::reverse_iterator<BidirectionalIteratorOrig> BidirectionalIterator;
      typedef boost::reverse_iterator<EPIterOrig> EPIter;
      // Flip sequence
      BidirectionalIterator first(last_sorted);
      BidirectionalIterator last(first_sorted);
      typedef Vertex vertex_num;
      typedef EdgeIndex edge_num;
      edge_num new_edge_count = std::distance(first, last);

      EPIter ep_iter(ep_iter_sorted);
      std::advance(ep_iter, -(std::ptrdiff_t)new_edge_count);
      edge_num edges_added_before_i = new_edge_count; // Count increment to add to rowstarts
      m_column.resize(m_column.size() + new_edge_count);
      inherited_edge_properties::resize(inherited_edge_properties::size() + new_edge_count);
      BidirectionalIterator current_new_edge = first, prev_new_edge = first;
      EPIter current_new_edge_prop = ep_iter;
      for (vertex_num i_plus_1 = m_rowstart.size() - 1; i_plus_1 > 0; --i_plus_1) {
        vertex_num i = i_plus_1 - 1;
        prev_new_edge = current_new_edge;
        // edges_added_to_this_vertex = #mbrs of new_edges with first == i
        edge_num edges_added_to_this_vertex = 0;
        while (current_new_edge != last) {
          if (get(global_to_local, current_new_edge->first) != i) break;
          ++current_new_edge;
          ++current_new_edge_prop;
          ++edges_added_to_this_vertex;
        }
        edges_added_before_i -= edges_added_to_this_vertex;
        // Invariant: edges_added_before_i = #mbrs of new_edges with first < i
        edge_num old_rowstart = m_rowstart[i];
        edge_num new_rowstart = m_rowstart[i] + edges_added_before_i;
        edge_num old_degree = m_rowstart[i + 1] - m_rowstart[i];
        edge_num new_degree = old_degree + edges_added_to_this_vertex;
        // Move old edges forward (by #new_edges before this i) to make room
        // new_rowstart > old_rowstart, so use copy_backwards
        if (old_rowstart != new_rowstart) {
          std::copy_backward(m_column.begin() + old_rowstart,
                             m_column.begin() + old_rowstart + old_degree,
                             m_column.begin() + new_rowstart + old_degree);
          inherited_edge_properties::move_range(old_rowstart, old_rowstart + old_degree, new_rowstart);
        }
        // Add new edges (reversed because current_new_edge is a
        // const_reverse_iterator)
        BidirectionalIterator temp = current_new_edge;
        EPIter temp_prop = current_new_edge_prop;
        for (; temp != prev_new_edge; ++old_degree) {
          --temp;
          --temp_prop;
          m_column[new_rowstart + old_degree] = temp->second;
          inherited_edge_properties::write_by_index(new_rowstart + old_degree, *temp_prop);
        }
        m_rowstart[i + 1] = new_rowstart + new_degree;
        if (edges_added_before_i == 0) break; // No more edges inserted before this point
        // m_rowstart[i] will be fixed up on the next iteration (to avoid
        // changing the degree of vertex i - 1); the last iteration never changes
        // it (either because of the condition of the break or because
        // m_rowstart[0] is always 0)
      }
    }


    csr_edge_descriptor(Vertex src, EdgeIndex idx): src(src), idx(idx) {}

    csr_edge_descriptor(): src(0), idx(0) {}


    bool operator==(const csr_edge_descriptor& e) const {return idx == e.idx;}

    bool operator!=(const csr_edge_descriptor& e) const {return idx != e.idx;}

    bool operator<(const csr_edge_descriptor& e) const {return idx < e.idx;}

    bool operator>(const csr_edge_descriptor& e) const {return idx > e.idx;}

    bool operator<=(const csr_edge_descriptor& e) const {return idx <= e.idx;}

    bool operator>=(const csr_edge_descriptor& e) const {return idx >= e.idx;}


    template<typename Archiver>
    void serialize(Archiver& ar, const unsigned int /*version*/)
    {
      ar & src & idx;
    }


    csr_out_edge_iterator() {}

    explicit csr_out_edge_iterator(edge_descriptor edge) : m_edge(edge) { }

    const edge_descriptor& dereference() const { return m_edge; }


    bool equal(const csr_out_edge_iterator& other) const
    { return m_edge == other.m_edge; }


    void increment() { ++m_edge.idx; }

    void decrement() { --m_edge.idx; }

    void advance(difference_type n) { m_edge.idx += n; }


    difference_type distance_to(const csr_out_edge_iterator& other) const
    { return other.m_edge.idx - m_edge.idx; }

    csr_edge_iterator() : rowstart_array(0), current_edge(), end_of_this_vertex(0), total_num_edges(0) {}


    csr_edge_iterator(const CSRGraph& graph,
                      edge_descriptor current_edge,
                      EdgeIndex end_of_this_vertex)
      : rowstart_array(&graph.m_forward.m_rowstart[0]),
        current_edge(current_edge),
        end_of_this_vertex(end_of_this_vertex),
        total_num_edges(num_edges(graph)) {}


    edge_descriptor dereference() const {return current_edge;}


    bool equal(const csr_edge_iterator& o) const {
      return current_edge == o.current_edge;
    }


    void increment() {
      ++current_edge.idx;
      if (current_edge.idx == total_num_edges) return;
      while (current_edge.idx == end_of_this_vertex) {
        ++current_edge.src;
        end_of_this_vertex = rowstart_array[current_edge.src + 1];
      }
    }


    csr_in_edge_iterator(): m_graph(0) {}

    csr_in_edge_iterator(const CSRGraph& graph,
                         EdgeIndex index_in_backward_graph)
      : m_index_in_backward_graph(index_in_backward_graph), m_graph(&graph) {}

    edge_descriptor dereference() const {
      return edge_descriptor(
               m_graph->m_backward.m_column[m_index_in_backward_graph],
               m_graph->m_backward.m_edge_properties[m_index_in_backward_graph]);
    }


    bool equal(const csr_in_edge_iterator& other) const
    { return m_index_in_backward_graph == other.m_index_in_backward_graph; }


    void increment() { ++m_index_in_backward_graph; }

    void decrement() { --m_index_in_backward_graph; }

    void advance(std::ptrdiff_t n) { m_index_in_backward_graph += n; }


    std::ptrdiff_t distance_to(const csr_in_edge_iterator& other) const
    { return other.m_index_in_backward_graph - m_index_in_backward_graph; }

    result_type operator()(const std::pair<A, B>& p) const {
      return result_type(p.second, p.first);
    }

    static type make(Iter it) {
      return type(it, transpose());
    }


  template <typename Iter>
  typename transpose_iterator_gen<Iter>::type transpose_edges(Iter i) {
    return transpose_iterator_gen<Iter>::make(i);
  }


    edge_to_index_pair() : g(0), index() { }

    edge_to_index_pair(const GraphT& g, const VertexIndexMap& index)
      : g(&g), index(index)
    { }


    result_type operator()(edge_descriptor e) const
    {
      return result_type(get(index, source(e, *g)), get(index, target(e, *g)));
    }


  template<typename GraphT, typename VertexIndexMap>
  edge_to_index_pair<GraphT, VertexIndexMap>
  make_edge_to_index_pair(const GraphT& g, const VertexIndexMap& index)
  {
    return edge_to_index_pair<GraphT, VertexIndexMap>(g, index);
  }


  template<typename GraphT, typename VertexIndexMap, typename Iter>
  boost::transform_iterator<edge_to_index_pair<GraphT, VertexIndexMap>, Iter>
  make_edge_to_index_pair_iter(const GraphT& g, const VertexIndexMap& index,
                               Iter it) {
    return boost::transform_iterator<edge_to_index_pair<GraphT, VertexIndexMap>, Iter>(it, edge_to_index_pair<GraphT, VertexIndexMap>(g, index));
  }

    std::size_t operator()
                  (detail::csr_edge_descriptor<Vertex, EdgeIndex> const& x) const
    {
      std::size_t hash = hash_value(x.src);
      hash_combine(hash, x.idx);
      return hash;
    }

      component_index_iterator(IndexRandomAccessIterator index_iterator,
                               value_type begin_index) :
        m_index_iterator(index_iterator),
        m_current_index(begin_index) { }


      inline value_type operator*() const {
        return (m_current_index);
      }

    
      self& operator++() {
        // Move to the next element in the linked list
        m_current_index = m_index_iterator[m_current_index];
        return (*this);
      }


      bool operator==(const self& other_iterator) const {
        return (m_current_index == *other_iterator);
      }

    template <typename Graph,
                typename DistanceMap,
                typename Combinator,
                typename Distance>
    inline Distance
    combine_distances(const Graph& g,
                        DistanceMap dist,
                        Combinator combine,
                        Distance init)
    {
        BOOST_CONCEPT_ASSERT(( VertexListGraphConcept<Graph> ));
        typedef typename graph_traits<Graph>::vertex_descriptor Vertex;
        typedef typename graph_traits<Graph>::vertex_iterator VertexIterator;
        BOOST_CONCEPT_ASSERT(( ReadablePropertyMapConcept<DistanceMap,Vertex> ));
        BOOST_CONCEPT_ASSERT(( NumericValueConcept<Distance> ));
        typedef numeric_values<Distance> DistanceNumbers;
        BOOST_CONCEPT_ASSERT(( AdaptableBinaryFunction<Combinator,Distance,Distance,Distance> ));

        // If there's ever an infinite distance, then we simply return
        // infinity. Note that this /will/ include the a non-zero
        // distance-to-self in the combined values. However, this is usually
        // zero, so it shouldn't be too problematic.
        Distance ret = init;
        VertexIterator i, end;
        for(boost::tie(i, end) = vertices(g); i != end; ++i) {
            Vertex v = *i;
            if(get(dist, v) != DistanceNumbers::infinity()) {
                ret = combine(ret, get(dist, v));
            }
            else {
                ret = DistanceNumbers::infinity();
                break;
            }
        }
        return ret;
    }

        T operator ()(T x, T y) const
        { BOOST_USING_STD_MAX(); return max BOOST_PREVENT_MACRO_SUBSTITUTION (x, y); }

        T operator ()(T t)
        { return T(1) / t; }


    static inline distance_type infinite_distance()
    { return distance_values::infinity(); }


    static inline result_type infinite_result()
    { return result_values::infinity(); }


    static inline result_type zero_result()
    { return result_values::zero(); }

      inline bidir_incidence_iterator() {}

      inline bidir_incidence_iterator(Iterator1D ii, Vertex src) 
        : i(ii), _src(src) { }

      
      inline self& operator++() { ++i; return *this; }

      inline self operator++(int) { self tmp = *this; ++(*this); return tmp; }

      
      inline reference operator*() const {
        return deref_helper(EdgeDir());
      }

      inline self* operator->() { return this; }

      
      Iterator1D& iter() { return i; }

      const Iterator1D& iter() const { return i; }

      inline reference deref_helper(out_edge_tag) const {
        return edge_type( _src, (*i).get_target(), &(*i).get_property() );
      }

      inline reference deref_helper(in_edge_tag) const {
        return edge_type((*i).get_target(), _src, &(*i).get_property() );
      }


    template <class V, class E, class Iter, class Dir>
    inline bool operator==(const bidir_incidence_iterator<V,E,Iter,Dir>& x,
                           const bidir_incidence_iterator<V,E,Iter,Dir>& y)
    {
      return x.i == y.i;
    }

    template <class V, class E, class Iter, class Dir>
    inline bool operator!=(const bidir_incidence_iterator<V,E,Iter,Dir>& x,
                           const bidir_incidence_iterator<V,E,Iter,Dir>& y)
    {
      return x.i != y.i;
    }

        inline container_property_map()
            : m_map()
        { }

        inline container_property_map(Container& c, const Graph& g)
            : m_map(c.begin(), indexer_type::index_map(const_cast<Graph&>(g)))
        { }

        inline container_property_map(const container_property_map& x)
            : m_map(x.m_map)
        { }

        inline reference operator [](const key_type& k) const
        { return m_map[k];  }


        matrix_property_map()
            : m_matrix(0), m_graph(0)
        { }


        matrix_property_map(Matrix& m, const Graph& g)
            : m_matrix(&m), m_graph(const_cast<Graph*>(&g))
        { }


        matrix_property_map(const matrix_property_map& x)
            : m_matrix(x.m_matrix), m_graph(x.m_graph)
        { }


        inline reference operator [](key_type k) const
        {
            typedef typename indexer_type::value_type Index;
            Index x = indexer_type::index(k, *m_graph);
            return map_type((*m_matrix)[x], *m_graph);
        }

    template <typename K, typename V>
    void put(null_property_map<K,V>& /*pm*/, const K& /*key*/, const V& /*value*/)
    { }

    template <typename Key, typename Value>
    inline null_property_map<Key, Value> make_null_property()
    { return null_property_map<Key, Value>(); }


    constant_property_map()
        : m_value()
    { }


    constant_property_map(const value_type &value)
        : m_value(value)
    { }


    constant_property_map(const constant_property_map& copy)
        : m_value(copy.m_value)
    { }


    inline reference operator [](const key_type&) const
    { return m_value; }


template <typename Key, typename Value>
inline constant_property_map<Key, Value>
make_constant_property(const Value& value)
{ return constant_property_map<Key, Value>(value); }


    constant_writable_property_map()
        : m_value()
    { }


    constant_writable_property_map(const value_type &value)
        : m_value(value)
    { }


    constant_writable_property_map(const constant_writable_property_map& copy)
        : m_value(copy.m_value)
    { }


template <typename Key, typename Value>
inline constant_writable_property_map<Key, Value>
make_constant_writable_property(const Value& value)
{ return constant_writable_property_map<Key, Value>(value); }

  two_bit_color_map(std::size_t inital_size, 
                    const index_map_type& index = index_map_type())
    : inherited(index.process_group(),  index.global(),
                local_map(inital_size, index.base())) { }


  inherited&       base()       { return *this; }

  const inherited& base() const { return *this; }


template<typename ProcessGroup, typename GlobalMap, typename StorageMap>
inline two_bit_color_type
get(two_bit_color_map<local_property_map<ProcessGroup,GlobalMap,StorageMap> >
      const& pm,
    typename property_traits<GlobalMap>::key_type key)
{
  return get(pm.base(), key);
}


template<typename ProcessGroup, typename GlobalMap, typename StorageMap>
inline void
put(two_bit_color_map<local_property_map<ProcessGroup,GlobalMap,StorageMap> >
      const& pm, 
    typename property_traits<GlobalMap>::key_type key,
    two_bit_color_type value)
{
  put(pm.base(), key, value);
}

  two_bit_color_map(std::size_t inital_size, 
                    const index_map_type& index = index_map_type())
    : inherited(index.process_group(),  index.global(),
                local_map(inital_size, index.base())) { }


  inherited&       base()       { return *this; }

  const inherited& base() const { return *this; }


template<typename ProcessGroup, typename GlobalMap, typename StorageMap>
inline two_bit_color_type
get(two_bit_color_map<
      parallel::distributed_property_map<
        ProcessGroup, GlobalMap, two_bit_color_map<StorageMap> > > const& pm,
    typename property_traits<GlobalMap>::key_type key)
{
  return get(pm.base(), key);
}


template<typename ProcessGroup, typename GlobalMap, typename StorageMap>
inline void
put(two_bit_color_map<
      parallel::distributed_property_map<
        ProcessGroup, GlobalMap, two_bit_color_map<StorageMap> > > const& pm, 
    typename property_traits<GlobalMap>::key_type key,
    two_bit_color_type value)
{
  put(pm.base(), key, value);
}

  simple_tiling(int columns, int rows, bool flip = true) 
    : columns(columns), rows(rows), flip(flip)
  {
  }

  int operator()(int x, int y) const
  {
    return flip? (rows - y - 1) * columns + x : y * columns + x;
  }

  template<typename Graph, typename ApplyForce>
  void operator()(const Graph&, const ApplyForce&)
  {
  }

  distributed_force_pairs_proxy(const PositionMap& position, 
                                const DisplacementMap& displacement,
                                const LocalForces& local_forces,
                                const NonLocalForces& nonlocal_forces = NonLocalForces())
    : position(position), displacement(displacement), 
      local_forces(local_forces), nonlocal_forces(nonlocal_forces)
  {
  }


  template<typename Graph, typename ApplyForce>
  void operator()(const Graph& g, ApplyForce apply_force)
  {
    // Flush remote displacements
    displacement.flush();

    // Receive updated positions for all of our neighbors
    synchronize(position);

    // Reset remote displacements 
    displacement.reset();

    // Compute local repulsive forces
    local_forces(g, apply_force);

    // Compute neighbor repulsive forces
    nonlocal_forces(g, apply_force);
  }


template<typename PositionMap, typename DisplacementMap, typename LocalForces>
inline 
distributed_force_pairs_proxy<PositionMap, DisplacementMap, LocalForces>
make_distributed_force_pairs(const PositionMap& position, 
                             const DisplacementMap& displacement,
                             const LocalForces& local_forces)
{
  typedef 
    distributed_force_pairs_proxy<PositionMap, DisplacementMap, LocalForces>
    result_type;
  return result_type(position, displacement, local_forces);
}


template<typename PositionMap, typename DisplacementMap, typename LocalForces,
         typename NonLocalForces>
inline 
distributed_force_pairs_proxy<PositionMap, DisplacementMap, LocalForces,
                              NonLocalForces>
make_distributed_force_pairs(const PositionMap& position, 
                             const DisplacementMap& displacement,
                             const LocalForces& local_forces,
                             const NonLocalForces& nonlocal_forces)
{
  typedef 
    distributed_force_pairs_proxy<PositionMap, DisplacementMap, LocalForces,
                                  NonLocalForces>
      result_type;
  return result_type(position, displacement, local_forces, nonlocal_forces);
}

  
  neighboring_tiles_force_pairs(PositionMap position, Point origin,
                                Point extent, simple_tiling tiling)
    : position(position), origin(origin), extent(extent), tiling(tiling)
  {
  }


  template<typename Graph, typename ApplyForce>
  void operator()(const Graph& g, ApplyForce apply_force)
  {
    // TBD: Do this some smarter way
    if (tiling.columns == 1 && tiling.rows == 1)
      return;

    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
#ifndef BOOST_NO_STDC_NAMESPACE
    using std::sqrt;
#endif // BOOST_NO_STDC_NAMESPACE

    // TBD: num_vertices(g) should be the global number of vertices?
    Dim two_k = Dim(2) * sqrt(extent[0] * extent[1] / num_vertices(g));

    std::vector<vertex_descriptor> my_vertices[4];
    std::vector<vertex_descriptor> neighbor_vertices[4];
   
    // Compute cutoff positions
    Dim cutoffs[4];
    cutoffs[left] = origin[0] + two_k;
    cutoffs[top] = origin[1] + two_k;
    cutoffs[right] = origin[0] + extent[0] - two_k;
    cutoffs[bottom] = origin[1] + extent[1] - two_k;

    // Compute neighbors
    typename PositionMap::process_group_type pg = position.process_group();
    std::pair<int, int> my_tile = tiling(process_id(pg));
    int neighbors[4] = { -1, -1, -1, -1 } ;
    if (my_tile.first > 0)
      neighbors[left] = tiling(my_tile.first - 1, my_tile.second);
    if (my_tile.second > 0)
      neighbors[top] = tiling(my_tile.first, my_tile.second - 1);
    if (my_tile.first < tiling.columns - 1)
      neighbors[right] = tiling(my_tile.first + 1, my_tile.second);
    if (my_tile.second < tiling.rows - 1)
      neighbors[bottom] = tiling(my_tile.first, my_tile.second + 1);

    // Sort vertices along the edges into buckets
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      if (position[v][0] <= cutoffs[left]) my_vertices[left].push_back(v); 
      if (position[v][1] <= cutoffs[top]) my_vertices[top].push_back(v); 
      if (position[v][0] >= cutoffs[right]) my_vertices[right].push_back(v); 
      if (position[v][1] >= cutoffs[bottom]) my_vertices[bottom].push_back(v); 
    }

    // Send vertices to neighbors, and gather our neighbors' vertices
    bucket_position pos;
    for (pos = left; pos < end_position; pos = bucket_position(pos + 1)) {
      if (neighbors[pos] != -1) {
        send(pg, neighbors[pos], 0, my_vertices[pos].size());
        if (!my_vertices[pos].empty())
          send(pg, neighbors[pos], 1, 
               &my_vertices[pos].front(), my_vertices[pos].size());
      }
    }

    // Pass messages around
    synchronize(pg);
    
    // Receive neighboring vertices
    for (pos = left; pos < end_position; pos = bucket_position(pos + 1)) {
      if (neighbors[pos] != -1) {
        std::size_t incoming_vertices;
        receive(pg, neighbors[pos], 0, incoming_vertices);

        if (incoming_vertices) {
          neighbor_vertices[pos].resize(incoming_vertices);
          receive(pg, neighbors[pos], 1, &neighbor_vertices[pos].front(),
                  incoming_vertices);
        }
      }
    }

    // For each neighboring vertex, we need to get its current position
    for (pos = left; pos < end_position; pos = bucket_position(pos + 1))
      for (typename std::vector<vertex_descriptor>::iterator i = 
             neighbor_vertices[pos].begin(); 
           i != neighbor_vertices[pos].end();
           ++i)
        request(position, *i);
    synchronize(position);

    // Apply forces in adjacent bins. This is O(n^2) in the worst
    // case. Oh well.
    for (pos = left; pos < end_position; pos = bucket_position(pos + 1)) {
      for (typename std::vector<vertex_descriptor>::iterator i = 
             my_vertices[pos].begin(); 
           i != my_vertices[pos].end();
           ++i)
        for (typename std::vector<vertex_descriptor>::iterator j = 
               neighbor_vertices[pos].begin(); 
             j != neighbor_vertices[pos].end();
             ++j)
          apply_force(*i, *j);
    }
  }


template<typename PositionMap>
inline neighboring_tiles_force_pairs<PositionMap>
make_neighboring_tiles_force_pairs
 (PositionMap position, 
  typename property_traits<PositionMap>::value_type origin,
  typename property_traits<PositionMap>::value_type extent,
  simple_tiling tiling)
{
  return neighboring_tiles_force_pairs<PositionMap>(position, origin, extent,
                                                    tiling);
}


  distributed_cooling_proxy(const DisplacementMap& displacement,
                            const Cooling& cooling)
    : displacement(displacement), cooling(cooling)
  {
  }


  result_type operator()()
  {
    // Accumulate displacements computed on each processor
    synchronize(displacement.data->process_group);

    // Allow the underlying cooling to occur
    return cooling();
  }


template<typename DisplacementMap, typename Cooling>
inline distributed_cooling_proxy<DisplacementMap, Cooling>
make_distributed_cooling(const DisplacementMap& displacement,
                         const Cooling& cooling)
{
  typedef distributed_cooling_proxy<DisplacementMap, Cooling> result_type;
  return result_type(displacement, cooling);
}


  template<typename K>
  Point operator()(const K&) const { return Point(); }


  template<typename K>
  Point operator()(const K&, const Point& p1, const Point& p2) const 
  { return Point(p1[0] + p2[0], p1[1] + p2[1]); }


template<typename Graph, typename PositionMap, 
         typename AttractiveForce, typename RepulsiveForce,
         typename ForcePairs, typename Cooling, typename DisplacementMap>
void
fruchterman_reingold_force_directed_layout
 (const Graph&    g,
  PositionMap     position,
  typename property_traits<PositionMap>::value_type const& origin,
  typename property_traits<PositionMap>::value_type const& extent,
  AttractiveForce attractive_force,
  RepulsiveForce  repulsive_force,
  ForcePairs      force_pairs,
  Cooling         cool,
  DisplacementMap displacement)
{
  typedef typename property_traits<PositionMap>::value_type Point;

  // Reduction in the displacement map involves summing the forces
  displacement.set_reduce(point_accumulating_reducer<Point>());

  // We need to track the positions of all of our neighbors
  BGL_FORALL_VERTICES_T(u, g, Graph)
    BGL_FORALL_ADJ_T(u, v, g, Graph)
      request(position, v);

  // Invoke the "sequential" Fruchterman-Reingold implementation
  boost::fruchterman_reingold_force_directed_layout
    (g, position, origin, extent,
     attractive_force, repulsive_force,
     make_distributed_force_pairs(position, displacement, force_pairs),
     make_distributed_cooling(displacement, cool),
     displacement);
}


template<typename Graph, typename PositionMap, 
         typename AttractiveForce, typename RepulsiveForce,
         typename ForcePairs, typename Cooling, typename DisplacementMap>
void
fruchterman_reingold_force_directed_layout
 (const Graph&    g,
  PositionMap     position,
  typename property_traits<PositionMap>::value_type const& origin,
  typename property_traits<PositionMap>::value_type const& extent,
  AttractiveForce attractive_force,
  RepulsiveForce  repulsive_force,
  ForcePairs      force_pairs,
  Cooling         cool,
  DisplacementMap displacement,
  simple_tiling   tiling)
{
  typedef typename property_traits<PositionMap>::value_type Point;

  // Reduction in the displacement map involves summing the forces
  displacement.set_reduce(point_accumulating_reducer<Point>());

  // We need to track the positions of all of our neighbors
  BGL_FORALL_VERTICES_T(u, g, Graph)
    BGL_FORALL_ADJ_T(u, v, g, Graph)
      request(position, v);

  // Invoke the "sequential" Fruchterman-Reingold implementation
  boost::fruchterman_reingold_force_directed_layout
    (g, position, origin, extent,
     attractive_force, repulsive_force,
     make_distributed_force_pairs
      (position, displacement, force_pairs,
       make_neighboring_tiles_force_pairs(position, origin, extent, tiling)),
     make_distributed_cooling(displacement, cool),
     displacement);
}


    template<typename K>
    T operator()(const K&) const { return T(0); }


    template<typename K>
    T operator()(const K&, const T& x, const T& y) const { return x + y; }


template<typename Graph, typename RankMap, typename Done, typename RankMap2>
void
page_rank_impl(const Graph& g, RankMap rank_map, Done done, 
               typename property_traits<RankMap>::value_type damping,
               typename graph_traits<Graph>::vertices_size_type n,
               RankMap2 rank_map2)
{
  typedef typename property_traits<RankMap>::value_type rank_type;

  int me;
  MPI_Comm_rank(MPI_COMM_WORLD, &me);

  typedef typename property_map<Graph, vertex_owner_t>
    ::const_type vertex_owner_map;
  typename property_map<Graph, vertex_owner_t>::const_type
    owner = get(vertex_owner, g);
  (void)owner;

  typedef typename boost::graph::parallel::process_group_type<Graph>
    ::type process_group_type;
  typedef typename process_group_type::process_id_type process_id_type;

  process_group_type pg = process_group(g);
  process_id_type id = process_id(pg);

  BOOST_ASSERT(me == id);

  rank_type initial_rank = rank_type(rank_type(1) / n);
  BGL_FORALL_VERTICES_T(v, g, Graph) put(rank_map, v, initial_rank);

#ifdef WANT_MPI_ONESIDED

  BOOST_ASSERT(sizeof(rank_type) == sizeof(double));

  bool to_map_2 = true;
  MPI_Win win, win2;

  MPI_Win_create(&(rank_map[*(vertices(g).first)]), 
                 sizeof(double) * num_vertices(g),
                 sizeof(double), 
                 MPI_INFO_NULL, MPI_COMM_WORLD, &win);
  MPI_Win_set_name(win, "rank_map_win");
  MPI_Win_create(&(rank_map2[*(vertices(g).first)]), 
                 sizeof(double) * num_vertices(g),
                 sizeof(double), 
                 MPI_INFO_NULL, MPI_COMM_WORLD, &win2);
  MPI_Win_set_name(win, "rank_map2_win");

  // set initial rank maps for the first iteration...
  BGL_FORALL_VERTICES_T(v, g, Graph) put(rank_map2, v, rank_type(1 - damping));

  MPI_Win_fence(0, win);
  MPI_Win_fence(0, win2);

  while ((to_map_2 && !done(rank_map, g)) ||
         (!to_map_2 && !done(rank_map2, g))) {
    if (to_map_2) {
      graph::distributed::detail::page_rank_step(g, rank_map, win2, damping, owner);
      to_map_2 = false;
    } else {
      graph::distributed::detail::page_rank_step(g, rank_map2, win, damping, owner);
      to_map_2 = true;
    }
  }
  synchronize(boost::graph::parallel::process_group(g));

  MPI_Win_free(&win);
  MPI_Win_free(&win2);

#else  
  // The ranks accumulate after each step.
  rank_map.set_reduce(detail::rank_accumulate_reducer<rank_type>());
  rank_map2.set_reduce(detail::rank_accumulate_reducer<rank_type>());
  rank_map.set_consistency_model(boost::parallel::cm_flush | boost::parallel::cm_reset);
  rank_map2.set_consistency_model(boost::parallel::cm_flush | boost::parallel::cm_reset);

  bool to_map_2 = true;
  while ((to_map_2 && !done(rank_map, g)) ||
         (!to_map_2 && !done(rank_map2, g))) {
    /**
     * PageRank can implemented slightly more efficiently on a
     * bidirectional graph than on an incidence graph. However,
     * distributed PageRank requires that we have the rank of the
     * source vertex available locally, so we force the incidence
     * graph implementation, which pushes rank from source to
     * target.
     */
    typedef incidence_graph_tag category;
    if (to_map_2) {
      graph::detail::page_rank_step(g, rank_map, rank_map2, damping,
                                    category());
      to_map_2 = false;
    } else {
      graph::detail::page_rank_step(g, rank_map2, rank_map, damping,
                                    category());
      to_map_2 = true;
    }
    using boost::graph::parallel::process_group;
    synchronize(process_group(g));
  }

  rank_map.reset();
#endif
      
  if (!to_map_2)
    BGL_FORALL_VERTICES_T(v, g, Graph) put(rank_map, v, get(rank_map2, v));
}


template<typename Graph, typename RankMap, typename Done, typename RankMap2>
void
page_rank(const Graph& g, RankMap rank_map, Done done, 
          typename property_traits<RankMap>::value_type damping,
          typename graph_traits<Graph>::vertices_size_type n,
          RankMap2 rank_map2
          BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, distributed_graph_tag)) 
{
  (page_rank_impl)(g, rank_map, done, damping, n, rank_map2);
}


template<typename MutableGraph>
void
remove_dangling_links(MutableGraph& g
                      BOOST_GRAPH_ENABLE_IF_MODELS_PARM(MutableGraph, 
                                                        distributed_graph_tag))
{
  typename graph_traits<MutableGraph>::vertices_size_type old_n;
  do {
    old_n = num_vertices(g);

    typename graph_traits<MutableGraph>::vertex_iterator vi, vi_end;
    for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; /* in loop */) {
      typename graph_traits<MutableGraph>::vertex_descriptor v = *vi++;
      if (out_degree(v, g) == 0) {
        clear_vertex(v, g);
        remove_vertex(v, g);
      }
    }
  } while (num_vertices(g) < old_n);
}

    
    template <class Archive>
    void serialize(Archive& ar, int)
    {
      ar & source & tag & offset & bytes;
    }

        outgoing_messages() {}

        ~outgoing_messages() {}

    
    template <class Archive>
    void serialize(Archive& ar, int)
    {
      ar & headers & buffer;
    }

    
    void swap(outgoing_messages& x) 
    {
      headers.swap(x.headers);
      buffer.swap(x.buffer);
    }

    explicit trigger_base(int tag) : tag_(tag) { }

    int tag() const { return tag_; }


    virtual ~trigger_base() { }

    explicit trigger_launcher(mpi_process_group& self, int tag, 
                              const Handler& handler) 
      : trigger_base(tag), self(self), handler(handler) 
      {}

    explicit reply_trigger_launcher(mpi_process_group& self, int tag, 
                                    const Handler& handler) 
      : trigger_base(tag), self(self), handler(handler) 
      {}

    explicit global_trigger_launcher(mpi_process_group& self, int tag, 
                              const Handler& handler) 
      : trigger_base(tag), handler(handler) 
      { 
      }

    explicit global_irecv_trigger_launcher(mpi_process_group& self, int tag, 
                              const Handler& handler, int sz) 
      : trigger_base(tag), handler(handler), buffer_size(sz)
      { 
        prepare_receive(self,tag);
      }

  explicit mpi_process_group(create_empty) {}

  int my_block_number() const { return block_num? *block_num : 0; }

  int encode_tag(int block_num, int tag) const
  { return block_num * max_tags + tag; }


  operator bool() { return bool(impl_); }

    block_type() { }




inline mpi_process_group::process_id_type 
process_id(const mpi_process_group& pg)
{ return pg.rank; }


inline mpi_process_group::process_size_type 
num_processes(const mpi_process_group& pg)
{ return pg.size; }


template<typename T>
inline void
send(const mpi_process_group& pg, mpi_process_group::process_id_type dest,
     int tag, T* first, T* last)
{ send(pg, dest, tag, first, last - first); }


template<typename T>
inline void
send(const mpi_process_group& pg, mpi_process_group::process_id_type dest,
     int tag, const T* first, const T* last)
{ send(pg, dest, tag, first, last - first); }

send_oob(const mpi_process_group& pg, mpi_process_group::process_id_type dest,
         int tag, const T& value, int block=-1)
{
  using boost::mpi::get_mpi_datatype;

  // Determine the actual message tag we will use for the send, and which
  // communicator we will use.
  std::pair<boost::mpi::communicator, int> actual
    = pg.actual_communicator_and_tag(tag, block);

#ifdef SEND_OOB_BSEND
  if (mpi_process_group::message_buffer_size()) {
    MPI_Bsend(const_cast<T*>(&value), 1, get_mpi_datatype<T>(value), dest, 
              actual.second, actual.first);
    return;
  }
#endif
  MPI_Request request;
  MPI_Isend(const_cast<T*>(&value), 1, get_mpi_datatype<T>(value), dest, 
            actual.second, actual.first, &request);
  
  int done=0;
  do {
    pg.poll();
    MPI_Test(&request,&done,MPI_STATUS_IGNORE);
  } while (!done);
}

inline void 
swap(boost::graph::distributed::mpi_process_group::outgoing_messages& x,
     boost::graph::distributed::mpi_process_group::outgoing_messages& y)
{
  x.swap(y);
}

    min_in_distance_compare(DistanceMap d, MinInWeightMap m,
                            Combine combine, Compare compare)
      : distance_map(d), min_in_weight(m), combine(combine),
        compare(compare)
    {
    }


    bool operator()(const Vertex& x, const Vertex& y) const
    {
      return compare(combine(get(distance_map, x), -get(min_in_weight, x)),
                     combine(get(distance_map, y), -get(min_in_weight, y)));
    }

    min_out_distance_compare(DistanceMap d, MinOutWeightMap m,
                             Combine combine, Compare compare)
      : distance_map(d), min_out_weight(m), combine(combine),
        compare(compare)
    {
    }


    bool operator()(const Vertex& x, const Vertex& y) const
    {
      return compare(combine(get(distance_map, x), get(min_out_weight, x)),
                     combine(get(distance_map, y), get(min_out_weight, y)));
    }


    crauser_et_al_dijkstra_queue(const Graph& g,
                                 const Combine& combine,
                                 const Compare& compare,
                                 const VertexIndexMap& id,
                                 const DistanceMap& distance_map,
                                 const PredecessorMap& predecessor_map,
                                 const MinOutWeightMap& min_out_weight,
                                 const MinInWeightMap& min_in_weight)
      : inherited(boost::graph::parallel::process_group(g), get(vertex_owner, g)),
        dist_queue(num_vertices(g),
                   dist_queue_compare_type(distance_map, compare),
                   id),
        out_queue(num_vertices(g),
                  out_queue_compare_type(distance_map, min_out_weight,
                                         combine, compare),
                  id),
        in_queue(num_vertices(g),
                 in_queue_compare_type(distance_map, min_in_weight,
                                       combine, compare),
                 id),
        g(g),
        distance_map(distance_map),
        predecessor_map(predecessor_map),
        min_out_weight(min_out_weight),
        min_in_weight(min_in_weight),
        min_distance(0),
        min_out_distance(0)
#ifdef PBGL_ACCOUNTING
        , local_deletions(0)
#endif
    { }


    void push(const value_type& x)
    {
      msg_value_type msg_value =
        msg_value_creator::create(get(distance_map, x),
                                  predecessor_value(get(predecessor_map, x)));
      inherited::update(x, msg_value);
    }


    void update(const value_type& x) { push(x); }


    void pop()
    {
      // Remove from distance queue
      dist_queue.remove(top_vertex);

      // Remove from OUT queue
      out_queue.remove(top_vertex);

      // Remove from IN queue
      in_queue.remove(top_vertex);

#ifdef PBGL_ACCOUNTING
      ++local_deletions;
#endif
    }


    vertex_descriptor& top() { return top_vertex; }

    const vertex_descriptor& top() const { return top_vertex; }


    bool empty()
    {
      inherited::collect();

      // If there are no suitable messages, wait until we get something
      while (!has_suitable_vertex()) {
        if (do_synchronize()) return true;
      }
      // Return true only if nobody has any messages; false if we
      // have suitable messages
      return false;
    }


    bool do_synchronize()
    {
      using boost::parallel::all_reduce;
      using boost::parallel::minimum;

      inherited::synchronize();

      // TBD: could use combine here, but then we need to stop using
      // minimum<distance_type>() as the function object.
      distance_type local_distances[2];
      local_distances[0] =
        dist_queue.empty()? (std::numeric_limits<distance_type>::max)()
        : get(distance_map, dist_queue.top());

      local_distances[1] =
        out_queue.empty()? (std::numeric_limits<distance_type>::max)()
        : (get(distance_map, out_queue.top())
           + get(min_out_weight, out_queue.top()));

      distance_type distances[2];
      all_reduce(this->process_group, local_distances, local_distances + 2,
                 distances, minimum<distance_type>());
      min_distance = distances[0];
      min_out_distance = distances[1];

#ifdef PBGL_ACCOUNTING
      std::size_t deletions = 0;
      all_reduce(this->process_group, &local_deletions, &local_deletions + 1,
                 &deletions, std::plus<std::size_t>());
      if (process_id(this->process_group) == 0) {
        crauser_et_al_shortest_paths_stats.deleted_vertices.push_back(deletions);
      }
      local_deletions = 0;
      BOOST_ASSERT(deletions > 0);
#endif

      return min_distance == (std::numeric_limits<distance_type>::max)();
    }

    vertex_descriptor predecessor_value(vertex_descriptor v) const
    { return v; }


    bool has_suitable_vertex() const
    {
      if (!dist_queue.empty()) {
        top_vertex = dist_queue.top();
        if (get(distance_map, dist_queue.top()) <= min_out_distance)
          return true;
      }

      if (!in_queue.empty()) {
        top_vertex = in_queue.top();
        return (get(distance_map, top_vertex)
                - get(min_in_weight, top_vertex)) <= min_distance;
      }
      return false;
    }

    void
    receive_update(process_id_type source, vertex_descriptor vertex,
                   distance_type distance)
    {
      // Update the queue if the received distance is better than
      // the distance we know locally
      if (distance < get(distance_map, vertex)
          || (distance == get(distance_map, vertex)
              && source == process_id(this->process_group))) {
        // Update the local distance map
        put(distance_map, vertex, distance);

        bool is_in_queue = dist_queue.contains(vertex);

        if (!is_in_queue) {
          dist_queue.push(vertex);
          out_queue.push(vertex);
          in_queue.push(vertex);
        }
        else {
          dist_queue.update(vertex);
          out_queue.update(vertex);
          in_queue.update(vertex);
        }
      }
    }

  template<typename Graph, typename MinInWeightMap, typename WeightMap,
           typename Inf, typename Compare>
  void
  initialize_min_in_weights(const Graph& g, MinInWeightMap min_in_weight,
                            WeightMap weight, Inf inf, Compare compare,
                            directed_tag, incidence_graph_tag)
  {
    // Send minimum weights off to the owners
    set_property_map_role(vertex_distance, min_in_weight);
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      BGL_FORALL_OUTEDGES_T(v, e, g, Graph) {
        if (get(weight, e) < get(min_in_weight, target(e, g)))
          put(min_in_weight, target(e, g), get(weight, e));
      }
    }

    using boost::graph::parallel::process_group;
    synchronize(process_group(g));

    // Replace any infinities with zeros
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      if (get(min_in_weight, v) == inf) put(min_in_weight, v, 0);
    }
  }


  template<typename Graph, typename MinInWeightMap, typename WeightMap,
           typename Inf, typename Compare>
  void
  initialize_min_in_weights(const Graph& g, MinInWeightMap min_in_weight,
                            WeightMap weight, Inf inf, Compare compare,
                            directed_tag, bidirectional_graph_tag)
  {
#if 0
    typename property_map<Graph, vertex_local_t>::const_type
      local = get(vertex_local, g);

    // This code assumes that the properties of the in-edges are
    // available locally. This is not necessarily the case, so don't
    // do this yet.
    set_property_map_role(vertex_distance, min_in_weight);
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      if (in_edges(v, g).first != in_edges(v, g).second) {
        std::cerr << "weights(" << g.distribution().global(get(local, v))
                  << ") = ";
        BGL_FORALL_INEDGES_T(v, e, g, Graph) {
          std::cerr << get(weight, e) << ' ';
        }
        std::cerr << std::endl;
        put(min_in_weight, v,
            *std::min_element
            (make_property_map_iterator(weight, in_edges(v, g).first),
             make_property_map_iterator(weight, in_edges(v, g).second),
             compare));
      } else {
        put(min_in_weight, v, 0);
      }
      std::cerr << "miw(" << g.distribution().global(get(local, v)) << ") = "
                << get(min_in_weight, v) << std::endl;
    }
#else
    initialize_min_in_weights(g, min_in_weight, weight, inf, compare,
                              directed_tag(), incidence_graph_tag());
#endif
  }


  template<typename Graph, typename MinInWeightMap, typename WeightMap,
           typename Inf, typename Compare>
  inline void
  initialize_min_in_weights(const Graph&, MinInWeightMap, WeightMap, Inf,
                            Compare, undirected_tag, bidirectional_graph_tag)
  {
    // In weights are the same as out weights, so do nothing
  }

  template<typename Graph, typename MinOutWeightMap, typename WeightMap,
           typename Compare>
  void
  initialize_min_out_weights(const Graph& g, MinOutWeightMap min_out_weight,
                             WeightMap weight, Compare compare)
  {
    typedef typename property_traits<WeightMap>::value_type weight_type;

    BGL_FORALL_VERTICES_T(v, g, Graph) {
      if (out_edges(v, g).first != out_edges(v, g).second) {
        put(min_out_weight, v,
            *std::min_element
            (make_property_map_iterator(weight, out_edges(v, g).first),
             make_property_map_iterator(weight, out_edges(v, g).second),
             compare));
        if (get(min_out_weight, v) < weight_type(0))
            boost::throw_exception(negative_edge());
      }
    }
  }


template<typename DistributedGraph, typename DijkstraVisitor,
         typename PredecessorMap, typename DistanceMap, typename WeightMap,
         typename IndexMap, typename ColorMap, typename Compare,
         typename Combine, typename DistInf, typename DistZero>
void
crauser_et_al_shortest_paths
  (const DistributedGraph& g,
   typename graph_traits<DistributedGraph>::vertex_descriptor s,
   PredecessorMap predecessor, DistanceMap distance, WeightMap weight,
   IndexMap index_map, ColorMap color_map,
   Compare compare, Combine combine, DistInf inf, DistZero zero,
   DijkstraVisitor vis)
{
  typedef typename boost::graph::parallel::process_group_type<DistributedGraph>::type
    process_group_type;
  typedef typename process_group_type::process_id_type process_id_type;
  typedef typename graph_traits<DistributedGraph>::vertex_descriptor
    Vertex;
  typedef typename graph_traits<DistributedGraph>::vertices_size_type
    vertices_size_type;

#ifdef PBGL_ACCOUNTING
  crauser_et_al_shortest_paths_stats.deleted_vertices.clear();
  crauser_et_al_shortest_paths_stats.execution_time = accounting::get_time();
#endif

  // Property map that stores the lowest edge weight outgoing from
  // each vertex. If a vertex has no out-edges, the stored weight
  // is zero.
  typedef typename property_traits<WeightMap>::value_type weight_type;
  typedef iterator_property_map<weight_type*, IndexMap> MinOutWeightMap;
  std::vector<weight_type> min_out_weights_vec(num_vertices(g), inf);
  MinOutWeightMap min_out_weight(&min_out_weights_vec.front(), index_map);
  detail::initialize_min_out_weights(g, min_out_weight, weight, compare);

  // Property map that stores the lowest edge weight incoming to
  // each vertex. For undirected graphs, this will just be a
  // shallow copy of the version for outgoing edges.
  typedef typename graph_traits<DistributedGraph>::directed_category
    directed_category;
  const bool is_undirected =
    is_same<directed_category, undirected_tag>::value;
  typedef MinOutWeightMap MinInWeightMap;
  std::vector<weight_type>
    min_in_weights_vec(is_undirected? 1 : num_vertices(g), inf);
  MinInWeightMap min_in_weight(&min_in_weights_vec.front(), index_map);
  typedef typename graph_traits<DistributedGraph>::traversal_category
    category;
  detail::initialize_min_in_weights(g, min_in_weight, weight, inf, compare,
                                    directed_category(), category());

  // Initialize local portion of property maps
  typename graph_traits<DistributedGraph>::vertex_iterator ui, ui_end;
  for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
    put(distance, *ui, inf);
    put(predecessor, *ui, *ui);
  }
  put(distance, s, zero);

  // Dijkstra Queue
  typedef detail::crauser_et_al_dijkstra_queue
            <DistributedGraph, Combine, Compare, IndexMap, DistanceMap, 
             PredecessorMap, MinOutWeightMap, MinInWeightMap>
    Queue;

  Queue Q(g, combine, compare, index_map, distance, predecessor,
          min_out_weight, is_undirected? min_out_weight : min_in_weight);

  // Parallel Dijkstra visitor
  ::boost::detail::dijkstra_bfs_visitor<
      DijkstraVisitor, Queue, WeightMap,
      boost::parallel::caching_property_map<PredecessorMap>,
      boost::parallel::caching_property_map<DistanceMap>, Combine, Compare
    > bfs_vis(vis, Q, weight,
              boost::parallel::make_caching_property_map(predecessor),
              boost::parallel::make_caching_property_map(distance),
              combine, compare, zero);

  set_property_map_role(vertex_color, color_map);
  set_property_map_role(vertex_distance, distance);

  breadth_first_search(g, s, Q, bfs_vis, color_map);

#ifdef PBGL_ACCOUNTING
  crauser_et_al_shortest_paths_stats.execution_time =
    accounting::get_time() - crauser_et_al_shortest_paths_stats.execution_time;
#endif
}


template<typename DistributedGraph, typename PredecessorMap,
         typename DistanceMap, typename WeightMap>
void
crauser_et_al_shortest_paths
  (const DistributedGraph& g,
   typename graph_traits<DistributedGraph>::vertex_descriptor s,
   PredecessorMap predecessor, DistanceMap distance, WeightMap weight)
{
  typedef typename property_traits<DistanceMap>::value_type distance_type;

  std::vector<default_color_type> colors(num_vertices(g), white_color);

  crauser_et_al_shortest_paths(g, s, predecessor, distance, weight,
                               get(vertex_index, g),
                               make_iterator_property_map(&colors[0],
                                                          get(vertex_index, g)),
                               std::less<distance_type>(),
                               closed_plus<distance_type>(),
                               (std::numeric_limits<distance_type>::max)(),
                               distance_type(),
                               dijkstra_visitor<>());
}


template<typename DistributedGraph, typename PredecessorMap,
         typename DistanceMap>
void
crauser_et_al_shortest_paths
  (const DistributedGraph& g,
   typename graph_traits<DistributedGraph>::vertex_descriptor s,
   PredecessorMap predecessor, DistanceMap distance)
{
  crauser_et_al_shortest_paths(g, s, predecessor, distance,
                               get(edge_weight, g));
}


    template<typename Archiver>
    void serialize(Archiver& ar, const unsigned int /*version*/)
    {
      ar & edge & path_length;
    }


    template<typename Archiver>
    void serialize(Archiver& ar, const unsigned int /*version*/)
    {
      ar & edge & gamma & bicomp_length;
    }


    template<typename Archiver>
    void serialize(Archiver& ar, const unsigned int /*version*/)
    {
      ar & edge & name;
    }

  template<typename T>
  T branch_point(const std::vector<T>& p1, const std::vector<T>& p2)
  {
    BOOST_ASSERT(!p1.empty());
    BOOST_ASSERT(!p2.empty());
    BOOST_ASSERT(p1.front() == p2.front());

    typedef typename std::vector<T>::const_iterator iterator;

    iterator mismatch_pos;
    if (p1.size() <= p2.size())
      mismatch_pos = std::mismatch(p1.begin(), p1.end(), p2.begin()).first;
    else
      mismatch_pos = std::mismatch(p2.begin(), p2.end(), p1.begin()).first;
    --mismatch_pos;
    return *mismatch_pos;
  }

  template<typename T>
  T infimum(const std::vector<T>& parent_path, T a, T b)
  {
    using std::swap;

    typedef typename std::vector<T>::const_iterator iterator;
    iterator first = parent_path.begin(), last = parent_path.end();

#if defined(PBGL_HOHBERG_DEBUG) and PBGL_HOHBERG_DEBUG > 2
    std::cerr << "infimum(";
    for (iterator i = first; i != last; ++i) {
      if (i != first) std::cerr << ' ';
      std::cerr << local(*i) << '@' << owner(*i);
    }
    std::cerr << ", " << local(a) << '@' << owner(a) << ", "
              << local(b) << '@' << owner(b) << ") = ";
#endif

    if (a == b) {
#if defined(PBGL_HOHBERG_DEBUG) && PBGL_HOHBERG_DEBUG > 2
      std::cerr << local(a) << '@' << owner(a) << std::endl;
#endif
      return a;
    }

    // Try to find a or b, whichever is closest to the end
    --last;
    while (*last != a) {
      // If we match b, swap the two so we'll be looking for b later.
      if (*last == b) { swap(a,b); break; }

      if (last == first) {
#if defined(PBGL_HOHBERG_DEBUG) && PBGL_HOHBERG_DEBUG > 2
        std::cerr << local(*first) << '@' << owner(*first) << std::endl;
#endif
        return *first;
      }
      else --last;
    }

    // Try to find b (which may originally have been a)
    while (*last != b) {
      if (last == first) {
#if defined(PBGL_HOHBERG_DEBUG) and PBGL_HOHBERG_DEBUG > 2
        std::cerr << local(*first) << '@' << owner(*first) << std::endl;
#endif
        return *first;
      }
      else --last;
    }

#if defined(PBGL_HOHBERG_DEBUG) && PBGL_HOHBERG_DEBUG > 2
    std::cerr << local(*last) << '@' << owner(*last) << std::endl;
#endif
    // We've found b; it's the infimum.
    return *last;
  }

  void assign(const std::vector<Vertex>& path)
  {
    gamma = graph_traits<Graph>::null_vertex();
    path_or_bicomp = path;
  }


  bool is_path() const { return gamma == graph_traits<Graph>::null_vertex(); }

  bool is_tree() const { return gamma != graph_traits<Graph>::null_vertex(); }

  hohberg_vertex_processor()
    : phase(1),
      parent(graph_traits<Graph>::null_vertex()),
      eta(graph_traits<Graph>::null_vertex())
  {
  }

  unsigned char get_phase() const { return phase; }

  template<typename Archiver>
  void serialize(Archiver&, const unsigned int /*version*/)
  {
    BOOST_ASSERT(false);
  }


template<typename Graph>
void
hohberg_vertex_processor<Graph>::initialize_leader(Vertex alpha,
                                                   const Graph& g)
{
  using namespace hohberg_detail;

  ProcessGroup pg = process_group(g);

  typename property_map<Graph, vertex_owner_t>::const_type
    owner = get(vertex_owner, g);

  path_header<Edge> header;
  header.path_length = 1;
  BGL_FORALL_OUTEDGES_T(alpha, e, g, Graph) {
    header.edge = e;
    send(pg, get(owner, target(e, g)), msg_path_header, header);
    send(pg, get(owner, target(e, g)), msg_path_vertices, alpha);
  }

  num_edges_not_transmitted = degree(alpha, g);
  edge_data.resize(num_edges_not_transmitted);
  phase = 2;
}


template<typename Graph>
void
hohberg_vertex_processor<Graph>::operator()(Edge e, edges_size_type name,
                                            const Graph& g)
{
  using namespace hohberg_detail;

#ifdef PBGL_HOHBERG_DEBUG
  std::cerr << local(source(e, g)) << '@' << owner(source(e, g)) << " -> "
            << local(target(e, g)) << '@' << owner(target(e, g)) << ": name("
            << name << "), phase = " << (int)phase << std::endl;
#endif

  BOOST_ASSERT(phase == 4);

  typename property_map<Graph, vertex_owner_t>::const_type
    owner = get(vertex_owner, g);

  // Send name messages along the spanning tree edges that are in the
  // same bicomponent as the edge to our parent.
  ProcessGroup pg = process_group(g);

  Vertex alpha = target(e, g);

  std::size_t idx = 0;
  BGL_FORALL_OUTEDGES_T(alpha, e, g, Graph) {
    per_edge_data& edata = edge_data[idx++];
    if (edata.is_tree_edge
        && find(edata.M.begin(), edata.M.end(), parent) != edata.M.end()
        && target(e, g) != parent) {
      // Notify our children in the spanning tree of this name
      name_header<Edge> header;
      header.edge = e;
      header.name = name;
      send(pg, get(owner, target(e, g)), msg_name, header);
    } else if (target(e, g) == parent) {
      // Map from local partition numbers to global bicomponent numbers
      local_to_global_partitions[edata.partition] = name;
    }
  }

  // Final stage
  phase = 5;
}


template<typename Graph>
typename hohberg_vertex_processor<Graph>::edges_size_type
hohberg_vertex_processor<Graph>::
num_starting_bicomponents(Vertex alpha, const Graph& g)
{
  edges_size_type not_mapped = (std::numeric_limits<edges_size_type>::max)();

  edges_size_type result = 0;
  std::size_t idx = 0;
  BGL_FORALL_OUTEDGES_T(alpha, e, g, Graph) {
    per_edge_data& edata = edge_data[idx++];
    if (edata.is_tree_edge
        && find(edata.M.begin(), edata.M.end(), parent) == edata.M.end()) {
      // Map from local partition numbers to global bicomponent numbers
      if (local_to_global_partitions[edata.partition] == not_mapped)
        local_to_global_partitions[edata.partition] = result++;
    }
  }

#ifdef PBGL_HOHBERG_DEBUG
  std::cerr << local(alpha) << '@' << owner(alpha) << " has " << result
            << " bicomponents originating at it." << std::endl;
#endif

  return result;
}

template<typename ComponentMap>
void
hohberg_vertex_processor<Graph>::
fill_edge_map(Vertex alpha, const Graph& g, ComponentMap& component)
{
  std::size_t idx = 0;
  BGL_FORALL_OUTEDGES_T(alpha, e, g, Graph) {
    per_edge_data& edata = edge_data[idx++];
    local_put(component, e, local_to_global_partitions[edata.partition]);

#if defined(PBGL_HOHBERG_DEBUG) && PBGL_HOHBERG_DEBUG > 2
    std::cerr << "component("
              << local(source(e, g)) << '@' << owner(source(e, g)) << " -> "
              << local(target(e, g)) << '@' << owner(target(e, g)) << ") = "
              << local_to_global_partitions[edata.partition]
              << " (partition = " << edata.partition << " of "
              << local_to_global_partitions.size() << ")" << std::endl;
#endif
  }
}


template<typename Graph>
void
hohberg_vertex_processor<Graph>::
start_naming_phase(Vertex alpha, const Graph& g, edges_size_type offset)
{
  using namespace hohberg_detail;

  BOOST_ASSERT(phase == 4);

  typename property_map<Graph, vertex_owner_t>::const_type
    owner = get(vertex_owner, g);

  // Send name messages along the spanning tree edges of the
  // components that we get to number.
  ProcessGroup pg = process_group(g);

  bool has_more_children_to_name = false;

  // Map from local partition numbers to global bicomponent numbers
  edges_size_type not_mapped = (std::numeric_limits<edges_size_type>::max)();
  for (std::size_t i = 0; i < local_to_global_partitions.size(); ++i) {
    if (local_to_global_partitions[i] != not_mapped)
      local_to_global_partitions[i] += offset;
  }

  std::size_t idx = 0;
  BGL_FORALL_OUTEDGES_T(alpha, e, g, Graph) {
    per_edge_data& edata = edge_data[idx++];
    if (edata.is_tree_edge
        && find(edata.M.begin(), edata.M.end(), parent) == edata.M.end()) {
      // Notify our children in the spanning tree of this new name
      name_header<Edge> header;
      header.edge = e;
      header.name = local_to_global_partitions[edata.partition];
      send(pg, get(owner, target(e, g)), msg_name, header);
    } else if (edata.is_tree_edge) {
      has_more_children_to_name = true;
    }
#if defined(PBGL_HOHBERG_DEBUG) && PBGL_HOHBERG_DEBUG > 2
    std::cerr << "M[" << local(source(e, g)) << '@' << owner(source(e, g))
              << " -> " << local(target(e, g)) << '@' << owner(target(e, g))
              << "] = ";
    for (std::size_t i = 0; i < edata.M.size(); ++i) {
      std::cerr << local(edata.M[i]) << '@' << owner(edata.M[i]) << ' ';
    }
    std::cerr << std::endl;
#endif
  }

  // See if we're done.
  if (!has_more_children_to_name)
    // Final stage
    phase = 5;
}


template<typename Graph>
void
hohberg_vertex_processor<Graph>::echo_phase(Vertex alpha, const Graph& g)
{
  using namespace hohberg_detail;

  typename property_map<Graph, vertex_owner_t>::const_type
    owner = get(vertex_owner, g);

  /* We're entering the echo phase. */
  phase = 3;

  if (parent != graph_traits<Graph>::null_vertex()) {
    Edge edge_to_parent;

#if defined(PBGL_HOHBERG_DEBUG) && PBGL_HOHBERG_DEBUG > 1
     std::cerr << local(alpha) << '@' << owner(alpha) << " echo: parent = "
               << local(parent) << '@' << owner(parent) << ", eta = "
               << local(eta) << '@' << owner(eta) << ", Gamma = ";
#endif

    std::vector<Vertex> bicomp;
    std::size_t e_index = 0;
    BGL_FORALL_OUTEDGES_T(alpha, e, g, Graph) {
      if (target(e, g) == parent && parent == eta) {
        edge_to_parent = e;
        if (find(bicomp.begin(), bicomp.end(), alpha) == bicomp.end()) {
#if defined(PBGL_HOHBERG_DEBUG) && PBGL_HOHBERG_DEBUG > 1
          std::cerr << local(alpha) << '@' << owner(alpha) << ' ';
#endif
          bicomp.push_back(alpha);
        }
      } else {
        if (target(e, g) == parent) edge_to_parent = e;

        per_edge_data& edata = edge_data[e_index];

        if (edata.msg.is_path()) {
          path_iterator pos = std::find(edata.msg.path_or_bicomp.begin(),
                                        edata.msg.path_or_bicomp.end(),
                                        eta);
          if (pos != edata.msg.path_or_bicomp.end()) {
            ++pos;
            if (pos != edata.msg.path_or_bicomp.end()
                && find(bicomp.begin(), bicomp.end(), *pos) == bicomp.end()) {
#if defined(PBGL_HOHBERG_DEBUG) && PBGL_HOHBERG_DEBUG > 1
              std::cerr << local(*pos) << '@' << owner(*pos) << ' ';
#endif
              bicomp.push_back(*pos);
            }
          }
        } else if (edata.msg.is_tree() && edata.msg.gamma == eta) {
          for (path_iterator i = edata.msg.path_or_bicomp.begin();
               i != edata.msg.path_or_bicomp.end(); ++i) {
            if (find(bicomp.begin(), bicomp.end(), *i) == bicomp.end()) {
#if defined(PBGL_HOHBERG_DEBUG) && PBGL_HOHBERG_DEBUG > 1
              std::cerr << local(*i) << '@' << owner(*i) << ' ';
#endif
              bicomp.push_back(*i);
            }
          }
        }
      }
      ++e_index;
    }
#ifdef PBGL_HOHBERG_DEBUG
    std::cerr << std::endl;
#endif

    // Send tree(eta, bicomp) to parent
    tree_header<Vertex, Edge> header;
    header.edge = edge_to_parent;
    header.gamma = eta;
    header.bicomp_length = bicomp.size();
    ProcessGroup pg = process_group(g);
    send(pg, get(owner, parent), msg_tree_header, header);
    send(pg, get(owner, parent), msg_tree_vertices, &bicomp[0],
         header.bicomp_length);
  }

  // Compute the partition of edges such that iff two edges e1 and e2
  // are in different subsets then M(e1) is disjoint from M(e2).

  // Start by putting each edge in a different partition
  std::vector<degree_size_type> parent_vec(edge_data.size());
  degree_size_type idx = 0;
  for (idx = 0; idx < edge_data.size(); ++idx)
    parent_vec[idx] = idx;

  // Go through each edge e, performing a union() on the edges
  // incident on all vertices in M[e].
  idx = 0;
  BGL_FORALL_OUTEDGES_T(alpha, e, g, Graph) {
    per_edge_data& edata = edge_data[idx++];

    // Compute union of vertices in M
    if (!edata.M.empty()) {
      degree_size_type e1 = get_incident_edge_index(alpha, edata.M.front(), g);
      while (parent_vec[e1] != e1) e1 = parent_vec[e1];

      for (std::size_t i = 1; i < edata.M.size(); ++i) {
        degree_size_type e2 = get_incident_edge_index(alpha, edata.M[i], g);
        while (parent_vec[e2] != e2) e2 = parent_vec[e2];
        parent_vec[e2] = e1;
      }
    }
  }

  edges_size_type not_mapped = (std::numeric_limits<edges_size_type>::max)();

  // Determine the number of partitions
  for (idx = 0; idx < parent_vec.size(); ++idx) {
    if (parent_vec[idx] == idx) {
      edge_data[idx].partition = local_to_global_partitions.size();
      local_to_global_partitions.push_back(not_mapped);
    }
  }

  // Assign partition numbers to each edge
  for (idx = 0; idx < parent_vec.size(); ++idx) {
    degree_size_type rep = parent_vec[idx];
    while (rep != parent_vec[rep]) rep = parent_vec[rep];
    edge_data[idx].partition = edge_data[rep].partition;
  }

  // Enter the naming phase (but don't send anything yet).
  phase = 4;
}


template<typename Graph, typename InputIterator, typename ComponentMap,
         typename VertexProcessorMap>
typename graph_traits<Graph>::edges_size_type
hohberg_biconnected_components
  (const Graph& g,
   ComponentMap component,
   InputIterator first, InputIterator last,
   VertexProcessorMap vertex_processor)
{
  using namespace boost::graph::parallel;
  using namespace hohberg_detail;
  using boost::parallel::all_reduce;

  typename property_map<Graph, vertex_owner_t>::const_type
    owner = get(vertex_owner, g);

  // The graph must be undirected
  BOOST_STATIC_ASSERT(
    (is_convertible<typename graph_traits<Graph>::directed_category,
                    undirected_tag>::value));

  // The graph must model Incidence Graph
  BOOST_CONCEPT_ASSERT(( IncidenceGraphConcept<Graph> ));

  typedef typename graph_traits<Graph>::edges_size_type edges_size_type;
  typedef typename graph_traits<Graph>::degree_size_type degree_size_type;
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;

  // Retrieve the process group we will use for communication
  typedef typename process_group_type<Graph>::type process_group_type;
  process_group_type pg = process_group(g);

  // Keeps track of the edges that we know to be tree edges.
  std::vector<edge_descriptor> tree_edges;

  // The leaders send out a path message to initiate the algorithm
  while (first != last) {
    vertex_descriptor leader = *first;
    if (process_id(pg) == get(owner, leader))
      vertex_processor[leader].initialize_leader(leader, g);
    ++first;
  }
  synchronize(pg);

  // Will hold the number of bicomponents in the graph.
  edges_size_type num_bicomponents = 0;

  // Keep track of the path length that we should expect, based on the
  // level in the breadth-first search tree. At present, this is only
  // used as a sanity check. TBD: This could be used to decrease the
  // amount of communication required per-edge (by about 4 bytes).
  std::size_t path_length = 1;

  typedef std::vector<vertex_descriptor> path_t;
  typedef typename path_t::iterator path_iterator;

  unsigned char minimum_phase = 5;
  do {
    while (optional<std::pair<int, int> > msg = probe(pg)) {
      switch (msg->second) {
      case msg_path_header:
        {
          // Receive the path header
          path_header<edge_descriptor> header;
          receive(pg, msg->first, msg->second, header);
          BOOST_ASSERT(path_length == header.path_length);

          // Receive the path itself
          path_t path(path_length);
          receive(pg, msg->first, msg_path_vertices, &path[0], path_length);

          edge_descriptor e = header.edge;
          vertex_processor[target(e, g)](e, path, g);
        }
        break;

      case msg_path_vertices:
        // Should be handled in msg_path_header case, unless we're going
        // stateless.
        BOOST_ASSERT(false);
        break;

      case msg_tree_header:
        {
          // Receive the tree header
          tree_header<vertex_descriptor, edge_descriptor> header;
          receive(pg, msg->first, msg->second, header);

          // Receive the tree itself
          path_t in_same_bicomponent(header.bicomp_length);
          receive(pg, msg->first, msg_tree_vertices, &in_same_bicomponent[0],
                  header.bicomp_length);

          edge_descriptor e = header.edge;
          vertex_processor[target(e, g)](e, header.gamma, in_same_bicomponent,
                                         g);
        }
        break;

      case msg_tree_vertices:
        // Should be handled in msg_tree_header case, unless we're
        // going stateless.
        BOOST_ASSERT(false);
        break;

      case msg_name:
        {
          name_header<edge_descriptor> header;
          receive(pg, msg->first, msg->second, header);
          edge_descriptor e = header.edge;
          vertex_processor[target(e, g)](e, header.name, g);
        }
        break;

      default:
        BOOST_ASSERT(false);
      }
    }
    ++path_length;

    // Compute minimum phase locally
    minimum_phase = 5;
    unsigned char maximum_phase = 1;
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      minimum_phase = (std::min)(minimum_phase, vertex_processor[v].get_phase());
      maximum_phase = (std::max)(maximum_phase, vertex_processor[v].get_phase());
    }

#ifdef PBGL_HOHBERG_DEBUG
    if (process_id(pg) == 0)
      std::cerr << "<---------End of stage------------->" << std::endl;
#endif
    // Compute minimum phase globally
    minimum_phase = all_reduce(pg, minimum_phase, boost::mpi::minimum<char>());

#ifdef PBGL_HOHBERG_DEBUG
    if (process_id(pg) == 0)
      std::cerr << "Minimum phase = " << (int)minimum_phase << std::endl;
#endif

    if (minimum_phase == 4
        && all_reduce(pg, maximum_phase, boost::mpi::maximum<char>()) == 4) {

#ifdef PBGL_HOHBERG_DEBUG
      if (process_id(pg) == 0)
        std::cerr << "<---------Naming phase------------->" << std::endl;
#endif
      // Compute the biconnected component number offsets for each
      // vertex.
      std::vector<edges_size_type> local_offsets;
      local_offsets.reserve(num_vertices(g));
      edges_size_type num_local_bicomponents = 0;
      BGL_FORALL_VERTICES_T(v, g, Graph) {
        local_offsets.push_back(num_local_bicomponents);
        num_local_bicomponents +=
          vertex_processor[v].num_starting_bicomponents(v, g);
      }

      synchronize(pg);

      // Find our the number of bicomponent names that will originate
      // from each process. This tells us how many bicomponents are in
      // the entire graph and what our global offset is for computing
      // our own biconnected component names.
      std::vector<edges_size_type> all_bicomponents(num_processes(pg));
      all_gather(pg, &num_local_bicomponents, &num_local_bicomponents + 1,
                 all_bicomponents);
      num_bicomponents = 0;
      edges_size_type my_global_offset = 0;
      for (std::size_t i = 0; i < all_bicomponents.size(); ++i) {
        if (i == (std::size_t)process_id(pg)) 
          my_global_offset = num_bicomponents;
        num_bicomponents += all_bicomponents[i];
      }

      std::size_t index = 0;
      BGL_FORALL_VERTICES_T(v, g, Graph) {
        edges_size_type offset = my_global_offset + local_offsets[index++];
        vertex_processor[v].start_naming_phase(v, g, offset);
      }
    }

    synchronize(pg);
  } while (minimum_phase < 5);

  // Number the edges appropriately.
  BGL_FORALL_VERTICES_T(v, g, Graph)
    vertex_processor[v].fill_edge_map(v, g, component);

  return num_bicomponents;
}


template<typename Graph, typename ComponentMap, typename InputIterator>
typename graph_traits<Graph>::edges_size_type
hohberg_biconnected_components
  (const Graph& g, ComponentMap component,
   InputIterator first, InputIterator last)

{
  std::vector<hohberg_vertex_processor<Graph> >
    vertex_processors(num_vertices(g));
  return hohberg_biconnected_components
           (g, component, first, last,
            make_iterator_property_map(vertex_processors.begin(),
                                       get(vertex_index, g)));
}


template<typename Graph, typename ComponentMap, typename ParentMap>
typename graph_traits<Graph>::edges_size_type
hohberg_biconnected_components(const Graph& g, ComponentMap component,
                               ParentMap parent)
{
  // We need the connected components of the graph, but we don't care
  // about component numbers.
  connected_components(g, dummy_property_map(), parent);

  // Each root in the parent map is a leader
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  std::vector<vertex_descriptor> leaders;
  BGL_FORALL_VERTICES_T(v, g, Graph)
    if (get(parent, v) == v) leaders.push_back(v);

  return hohberg_biconnected_components(g, component,
                                        leaders.begin(), leaders.end());
}


template<typename Graph, typename ComponentMap>
typename graph_traits<Graph>::edges_size_type
hohberg_biconnected_components(const Graph& g, ComponentMap component)
{
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  std::vector<vertex_descriptor> parents(num_vertices(g));
  return hohberg_biconnected_components
           (g, component, make_iterator_property_map(parents.begin(),
                                                     get(vertex_index, g)));
}

    
  template<typename T> inline T& unsafe_serialize(T& x) { return x; }

    unsafe_pair() { }

    unsafe_pair(const T& t, const U& u) : first(t), second(u) { }


    template<typename Archiver>
    void serialize(Archiver& ar, const unsigned /*version*/)
    {
      ar & unsafe_serialize(first) & unsafe_serialize(second);
    }


  template<typename T, typename U>
  bool operator<(unsafe_pair<T,U> const& x, unsafe_pair<T,U> const& y)
  {
    return std::make_pair(x.first, x.second) < 
      std::make_pair(y.first, y.second);  
  }


  is_local_edge() : g(0) {}

  is_local_edge(DistributedGraph& g) : g(&g), owner(get(vertex_owner, g)) {}

  result_type operator()(const argument_type& e) const
  { return get(owner, source(e, *g)) == get(owner, target(e, *g)); }


  is_local_vertex() : g(0) {}

  is_local_vertex(DistributedGraph& g) : g(&g), owner(get(vertex_owner, g)) { }

  result_type operator()(const argument_type& v) const
  { 
    return get(owner, v) == process_id(process_group(*g)); 
  }


  local_subgraph(DistributedGraph& g) 
    : inherited(g, 
                is_local_edge<DistributedGraph>(g),
                is_local_vertex<DistributedGraph>(g)), 
      g(g) 
  {
  }


  process_group_type&       process_group()       
  { 
    using boost::graph::parallel::process_group;
    return process_group(g); 
  }

  const process_group_type& process_group() const 
  { 
    using boost::graph::parallel::process_group;
    return boost::graph::parallel::process_group(g); 
  }

  
  DistributedGraph&         base()               { return g; }

  const DistributedGraph&   base() const         { return g; }
 

template<typename DistributedGraph>
inline local_subgraph<DistributedGraph> 
make_local_subgraph(DistributedGraph& g)
{ return local_subgraph<DistributedGraph>(g); }


    template<typename Key>
    T operator()(const Key&) const { return (std::numeric_limits<T>::max)(); }


    template<typename Key> T operator()(const Key&, T, T y) const { return y; }

  template<typename T>
  Color operator()(const std::vector<T>& marked, T marked_true)
  {
    Color k = 0;
    while (k < (Color)marked.size() && marked[k] == marked_true)
      ++k;
    return k;
  }


template<typename DistributedGraph, typename ColorMap, typename ChooseColor,
         typename VertexOrdering, typename VertexIndexMap>
typename property_traits<ColorMap>::value_type
boman_et_al_graph_coloring
  (const DistributedGraph& g,
   ColorMap color,
   typename graph_traits<DistributedGraph>::vertices_size_type s,
   ChooseColor choose_color,
   VertexOrdering ordering, VertexIndexMap vertex_index)
{
  using namespace boost::graph::parallel;
  using boost::parallel::all_reduce;

  typename property_map<DistributedGraph, vertex_owner_t>::const_type
    owner = get(vertex_owner, g);

  typedef typename process_group_type<DistributedGraph>::type 
    process_group_type;
  typedef typename process_group_type::process_id_type process_id_type;
  typedef typename graph_traits<DistributedGraph>::vertex_descriptor Vertex;
  typedef typename graph_traits<DistributedGraph>::edge_descriptor Edge;
  typedef typename graph_traits<DistributedGraph>::vertices_size_type 
    vertices_size_type;
  typedef typename property_traits<ColorMap>::value_type color_type;
  typedef unsigned long long iterations_type;
  typedef typename std::vector<Vertex>::iterator vertex_set_iterator;
  typedef std::pair<Vertex, color_type> message_type;

#ifdef PBGL_ACCOUNTING
  boman_et_al_graph_coloring_stats.block_size = s;
  boman_et_al_graph_coloring_stats.execution_time = accounting::get_time();
  boman_et_al_graph_coloring_stats.conflicts = 0;
  boman_et_al_graph_coloring_stats.supersteps = 0;
#endif

  // Initialize color map
  color_type no_color = (std::numeric_limits<color_type>::max)();
  BGL_FORALL_VERTICES_T(v, g, DistributedGraph)
    put(color, v, no_color);
  color.set_reduce(detail::graph_coloring_reduce<color_type>());
  
  // Determine if we'll be using synchronous or asynchronous communication.
  typedef typename process_group_type::communication_category
    communication_category;
  static const bool asynchronous = 
    is_convertible<communication_category, immediate_process_group_tag>::value;
  process_group_type pg = process_group(g);

  // U_i <- V_i
  std::vector<Vertex> vertices_to_color(vertices(g).first, vertices(g).second);

  iterations_type iter_num = 1, outer_iter_num = 1;
  std::vector<iterations_type> marked;
  std::vector<iterations_type> marked_conflicting(num_vertices(g), 0);
  std::vector<bool> sent_to_processors;

  std::size_t rounds = vertices_to_color.size() / s 
    + (vertices_to_color.size() % s == 0? 0 : 1);
  rounds = all_reduce(pg, rounds, boost::parallel::maximum<std::size_t>());

#ifdef PBGL_GRAPH_COLORING_DEBUG
  std::cerr << "Number of rounds = " << rounds << std::endl;
#endif

  while (rounds > 0) {
    if (!vertices_to_color.empty()) {
      // Set of conflicting vertices
      std::vector<Vertex> conflicting_vertices;

      vertex_set_iterator first = vertices_to_color.begin();
      while (first != vertices_to_color.end()) {
        // For each subset of size s (or smaller for the last subset)
        vertex_set_iterator start = first;
        for (vertices_size_type counter = s; 
             first != vertices_to_color.end() && counter > 0;
             ++first, --counter) {
          // This vertex hasn't been sent to anyone yet
          sent_to_processors.assign(num_processes(pg), false);
          sent_to_processors[process_id(pg)] = true;

          // Mark all of the colors that we see
          BGL_FORALL_OUTEDGES_T(*first, e, g, DistributedGraph) {
            color_type k = get(color, target(e, g));
            if (k != no_color) {
              if (k >= (color_type)marked.size()) marked.resize(k + 1, 0);
              marked[k] = iter_num;
            }
          }

          // Find a color for this vertex
          put(color, *first, choose_color(marked, iter_num));

#ifdef PBGL_GRAPH_COLORING_DEBUG
          std::cerr << "Chose color " << get(color, *first) << " for vertex "
                    << *first << std::endl;
#endif

          // Send this vertex's color to the owner of the edge target.
          BGL_FORALL_OUTEDGES_T(*first, e, g, DistributedGraph) {
            if (!sent_to_processors[get(owner, target(e, g))]) {
              send(pg, get(owner, target(e, g)), 17, 
                   message_type(source(e, g), get(color, source(e, g))));
              sent_to_processors[get(owner, target(e, g))] = true;
            }
          }

          ++iter_num;
        }

        // Synchronize for non-immediate process groups.
        if (!asynchronous) { 
          --rounds;
          synchronize(pg);
        }

        // Receive boundary colors from other processors
        while (optional<std::pair<process_id_type, int> > stp = probe(pg)) {
          BOOST_ASSERT(stp->second == 17);
          message_type msg;
          receive(pg, stp->first, stp->second, msg);
          cache(color, msg.first, msg.second);
#ifdef PBGL_GRAPH_COLORING_DEBUG
          std::cerr << "Cached color " << msg.second << " for vertex " 
                    << msg.first << std::endl;
#endif
        }

        // Compute the set of conflicting vertices
        // [start, first) contains all vertices in this subset
        for (vertex_set_iterator vi = start; vi != first; ++vi) {
          Vertex v = *vi;
          BGL_FORALL_OUTEDGES_T(v, e, g, DistributedGraph) {
            Vertex w = target(e, g);
            if (get(owner, w) != process_id(pg) // boundary vertex
                && marked_conflicting[get(vertex_index, v)] != outer_iter_num
                && get(color, v) == get(color, w)
                && ordering(v, w)) {
              conflicting_vertices.push_back(v);
              marked_conflicting[get(vertex_index, v)] = outer_iter_num;
              put(color, v, no_color);
#ifdef PBGL_GRAPH_COLORING_DEBUG
              std::cerr << "Vertex " << v << " has a conflict with vertex "
                        << w << std::endl;
#endif
              break;
            }
          }
        }

#ifdef PBGL_ACCOUNTING
        boman_et_al_graph_coloring_stats.conflicts += 
          conflicting_vertices.size();
#endif
      }

      if (asynchronous) synchronize(pg);
      else {
        while (rounds > 0) {
          synchronize(pg);
          --rounds;
        }
      }
      conflicting_vertices.swap(vertices_to_color);
      ++outer_iter_num;
    } else {
      if (asynchronous) synchronize(pg);
      else {
        while (rounds > 0) {
          synchronize(pg);
          --rounds;
        }
      }
    }

    // Receive boundary colors from other processors
    while (optional<std::pair<process_id_type, int> > stp = probe(pg)) {
      BOOST_ASSERT(stp->second == 17);
      message_type msg;
      receive(pg, stp->first, stp->second, msg);
      cache(color, msg.first, msg.second);
    }

    rounds = vertices_to_color.size() / s 
      + (vertices_to_color.size() % s == 0? 0 : 1);
    rounds = all_reduce(pg, rounds, boost::parallel::maximum<std::size_t>());

#ifdef PBGL_ACCOUNTING
    ++boman_et_al_graph_coloring_stats.supersteps;
#endif
  }

  // Determine the number of colors used.
  color_type num_colors = 0;
  BGL_FORALL_VERTICES_T(v, g, DistributedGraph) {
    color_type k = get(color, v);
    BOOST_ASSERT(k != no_color);
    if (k != no_color) {
      if (k >= (color_type)marked.size()) marked.resize(k + 1, 0); // TBD: perf?
      if (marked[k] != iter_num) {
        marked[k] = iter_num;
        ++num_colors;
      }
    }
  }

  num_colors = 
    all_reduce(pg, num_colors, boost::parallel::maximum<color_type>());


#ifdef PBGL_ACCOUNTING
  boman_et_al_graph_coloring_stats.execution_time = 
    accounting::get_time() - boman_et_al_graph_coloring_stats.execution_time;
  
  boman_et_al_graph_coloring_stats.conflicts = 
    all_reduce(pg, boman_et_al_graph_coloring_stats.conflicts,
               std::plus<color_type>());
  boman_et_al_graph_coloring_stats.num_colors = num_colors;
#endif

  return num_colors;
}



template<typename DistributedGraph, typename ColorMap, typename ChooseColor, 
         typename VertexOrdering>
inline typename property_traits<ColorMap>::value_type
boman_et_al_graph_coloring
  (const DistributedGraph& g, ColorMap color,
   typename graph_traits<DistributedGraph>::vertices_size_type s,
   ChooseColor choose_color, VertexOrdering ordering)
{
  return boman_et_al_graph_coloring(g, color, s, choose_color, ordering, 
                                    get(vertex_index, g));
}


template<typename DistributedGraph, typename ColorMap, typename ChooseColor>
inline typename property_traits<ColorMap>::value_type
boman_et_al_graph_coloring
  (const DistributedGraph& g,
   ColorMap color,
   typename graph_traits<DistributedGraph>::vertices_size_type s,
   ChooseColor choose_color)
{
  typedef typename graph_traits<DistributedGraph>::vertex_descriptor
    vertex_descriptor;
  return boman_et_al_graph_coloring(g, color, s, choose_color,
                                    std::less<vertex_descriptor>());
}


template<typename DistributedGraph, typename ColorMap>
inline typename property_traits<ColorMap>::value_type
boman_et_al_graph_coloring
  (const DistributedGraph& g,
   ColorMap color,
   typename graph_traits<DistributedGraph>::vertices_size_type s = 100)
{
  typedef typename property_traits<ColorMap>::value_type Color;
  return boman_et_al_graph_coloring(g, color, s, first_fit_color<Color>());
}


  template <class Property, class Graph>
  void property_on_inedges(Property p, const Graph& g) 
  {
    BGL_FORALL_VERTICES_T(u, g, Graph)
      BGL_FORALL_INEDGES_T(u, e, g, Graph)
      request(p, e);
    synchronize(p);
  }

  template <class Property, class Graph>
  void property_on_outedges(Property p, const Graph& g) 
  {
    BGL_FORALL_VERTICES_T(u, g, Graph)
      BGL_FORALL_OUTEDGES_T(u, e, g, Graph)
        request(p, e);
    synchronize(p);
  }


  template <class Property, class Graph>
  void property_on_successors(Property p, const Graph& g) 
  {
    BGL_FORALL_VERTICES_T(u, g, Graph)
      BGL_FORALL_OUTEDGES_T(u, e, g, Graph)
        request(p, target(e, g));
    synchronize(p);
  }

  
  template <class Property, class Graph>
  void property_on_predecessors(Property p, const Graph& g) 
  {
    BGL_FORALL_VERTICES_T(u, g, Graph)
      BGL_FORALL_INEDGES_T(u, e, g, Graph)
        request(p, source(e, g));
    synchronize(p);
  }

  template <class Property, class Graph>
  void property_on_adjacents(Property p, const Graph& g) 
  {
    BGL_FORALL_VERTICES_T(u, g, Graph) {
      BGL_FORALL_OUTEDGES_T(u, e, g, Graph)
        request(p, target(e, g));
      BGL_FORALL_INEDGES_T(u, e, g, Graph)
        request(p, source(e, g));
    }
    synchronize(p);
  }


  template <class PropertyIn, class PropertyOut, class Graph>
  void copy_vertex_property(PropertyIn p_in, PropertyOut p_out, Graph& g)
  {
    BGL_FORALL_VERTICES_T(u, g, Graph)
      put(p_out, u, get(p_in, g));
  }


  template <class PropertyIn, class PropertyOut, class Graph>
  void copy_edge_property(PropertyIn p_in, PropertyOut p_out, Graph& g)
  {
    BGL_FORALL_EDGES_T(e, g, Graph)
      put(p_out, e, get(p_in, g));
  }


      explicit global_index(Graph const& g)
        : global_index_map(process_group(g), num_vertices(g), get(vertex_index, g),
                           get(vertex_global, g)) {}


      int operator() (typename graph_traits<Graph>::vertex_descriptor v)
      { return get(global_index_map, v); }

      
      template<typename K>
      T operator()(const K&) const { return T(0); }

      
      template<typename K>
      T operator()(const K&, const T& local, const T& remote) const { return local + remote; }

      
      template<typename K>
      T operator()(const K&) const { return (std::numeric_limits<T>::max)(); }

      
      template<typename K>
      T operator()(const K&, const T& x, const T& y) const 
      { return x < y ? x : y; }

      explicit property_map_reader(PropertyMap pm) : pm(pm) {}


      template <typename T>
      typename PropertyMap::value_type
      operator() (const T& v)
      {
        return get(pm, v);
      }


    template <class ProcessGroup>
    shuffled_distribution(ProcessGroup const& pg, BaseDistribution const& base)
      : BaseDistribution(base)
      , n(num_processes(pg))
      , mapping_(make_counting_iterator(size_type(0)), make_counting_iterator(n))
      , reverse_mapping(mapping_)
    {}

    template<typename Archiver, typename Directed, typename Vertex>
    void
    serialize(Archiver& ar, edge_base<Directed, Vertex>& e,
              const unsigned int /*version*/)
    {
      ar & unsafe_serialize(e.m_source)
         & unsafe_serialize(e.m_target);
    }


    template<typename Archiver, typename Directed, typename Vertex>
    void
    serialize(Archiver& ar, edge_desc_impl<Directed, Vertex>& e,
              const unsigned int /*version*/)
    {
      ar & boost::serialization::base_object<edge_base<Directed, Vertex> >(e)
         & unsafe_serialize(e.m_eproperty);
    }


      global_descriptor() : owner(), local() { }


      global_descriptor(processor_id_type owner, LocalDescriptor local)
        : owner(owner), local(local) { }


        generator() {}

        generator(processor_id_type owner) : owner(owner) {}


        result_type operator()(argument_type v) const
        { return result_type(owner, v); }


      template<typename Archiver>
      void serialize(Archiver& ar, const unsigned int /*version*/)
      {
        ar & owner & unsafe_serialize(local);
      }

    template<typename LocalDescriptor>
    inline processor_id_type owner(const global_descriptor<LocalDescriptor>& v)
    { return v.owner; }

    template<typename LocalDescriptor>
    inline LocalDescriptor local(const global_descriptor<LocalDescriptor>& v)
    { return v.local; }

    template<typename LocalDescriptor>
    inline bool
    operator==(const global_descriptor<LocalDescriptor>& u,
               const global_descriptor<LocalDescriptor>& v)
    {
      return u.owner == v.owner && u.local == v.local;
    }

    template<typename LocalDescriptor>
    inline bool
    operator!=(const global_descriptor<LocalDescriptor>& u,
               const global_descriptor<LocalDescriptor>& v)
    { return !(u == v); }


    template<typename LocalDescriptor>
    inline bool
    operator<(const global_descriptor<LocalDescriptor>& u,
              const global_descriptor<LocalDescriptor>& v)
    {
      return (u.owner) < v.owner || (u.owner == v.owner && (u.local) < v.local);
    }


    template<typename LocalDescriptor>
    inline bool
    operator<=(const global_descriptor<LocalDescriptor>& u,
               const global_descriptor<LocalDescriptor>& v)
    {
      return u.owner <= v.owner || (u.owner == v.owner && u.local <= v.local);
    }


    template<typename LocalDescriptor>
    inline bool
    operator>(const global_descriptor<LocalDescriptor>& u,
              const global_descriptor<LocalDescriptor>& v)
    {
      return v < u;
    }


    template<typename LocalDescriptor>
    inline bool
    operator>=(const global_descriptor<LocalDescriptor>& u,
               const global_descriptor<LocalDescriptor>& v)
    {
      return v <= u;
    }

      stored_in_edge(processor_id_type sp, Edge e)
        : source_processor(sp), e(e) {}

      edge_descriptor(processor_id_type sp = processor_id_type(),
                      processor_id_type tp = processor_id_type(),
                      bool owns = false, Edge ld = Edge())
        : source_processor(sp), target_processor(tp),
          source_owns_edge(owns), local(ld) {}


      processor_id_type owner() const
      {
        return source_owns_edge? source_processor : target_processor;
      }


        out_generator() : g(0) {}

        explicit out_generator(const Graph& g) : g(&g) {}


        result_type operator()(argument_type e) const
        { return map(e, directed_selector()); }

        result_type map(argument_type e, directedS) const
        {
          return result_type(g->processor(),
                             get(edge_target_processor_id, g->base(), e),
                             true, e);
        }


        result_type map(argument_type e, bidirectionalS) const
        {
          return result_type(g->processor(),
                             get(edge_target_processor_id, g->base(), e),
                             true, e);
        }


        result_type map(argument_type e, undirectedS) const
        {
          return result_type(g->processor(),
                             get(edge_target_processor_id, g->base(), e),
                             get(edge_locally_owned, g->base(), e),
                             e);
        }


        in_generator() : g(0) {}

        explicit in_generator(const Graph& g) : g(&g) {}


        result_type operator()(argument_type e) const
        { return map(e, DirectedS()); }

        result_type map(argument_type e, bidirectionalS) const
        {
          return result_type(e.source_processor,
                             g->processor(),
                             true,
                             e.e);
        }

        result_type map(argument_type e, undirectedS) const
        {
          typename Graph::local_edge_descriptor local_edge(e);
          // TBD: This is a very, VERY lame hack that takes advantage
          // of our knowledge of the internals of the BGL
          // adjacency_list. There should be a cleaner way to handle
          // this...
          using std::swap;
          swap(local_edge.m_source, local_edge.m_target);
          return result_type(get(edge_target_processor_id, g->base(), e),
                             g->processor(),
                             !get(edge_locally_owned, g->base(), e),
                             local_edge);
        }


      template<typename Archiver>
      void serialize(Archiver& ar, const unsigned int /*version*/)
      {
        ar
          & source_processor
          & target_processor
          & source_owns_edge
          & local;
      }

    template<typename Edge>
    inline processor_id_type
    owner(const edge_descriptor<Edge>& e)
    { return e.source_owns_edge? e.source_processor : e.target_processor; }

    template<typename Edge>
    inline Edge
    local(const edge_descriptor<Edge>& e)
    { return e.local; }

    template<typename Edge>
    inline bool
    operator==(const edge_descriptor<Edge>& e1,
               const edge_descriptor<Edge>& e2)
    {
      return (e1.source_processor == e2.source_processor
              && e1.target_processor == e2.target_processor
              && e1.local == e2.local);
    }

    template<typename Edge>
    inline bool
    operator!=(const edge_descriptor<Edge>& e1,
               const edge_descriptor<Edge>& e2)
    { return !(e1 == e2); }

    template<typename IteratorPair, typename VertexIndexMap>
    void
    maybe_initialize_vertex_indices(IteratorPair p, VertexIndexMap to_index,
                                    read_write_property_map_tag)
    {
      typedef typename property_traits<VertexIndexMap>::value_type index_t;
      index_t next_index = 0;
      while (p.first != p.second)
        put(to_index, *p.first++, next_index++);
    }


    template<typename IteratorPair, typename VertexIndexMap>
    inline void
    maybe_initialize_vertex_indices(IteratorPair p, VertexIndexMap to_index,
                                    readable_property_map_tag)
    {
      // Do nothing
    }


    template<typename IteratorPair, typename VertexIndexMap>
    inline void
    maybe_initialize_vertex_indices(IteratorPair p, VertexIndexMap to_index)
    {
      typedef typename property_traits<VertexIndexMap>::category category;
      maybe_initialize_vertex_indices(p, to_index, category());
    }


    template<typename IteratorPair>
    inline void
    maybe_initialize_vertex_indices(IteratorPair p,
                                    ::boost::detail::error_property_not_found)
    { }

      msg_add_edge_data() { }


      msg_add_edge_data(Vertex source, Vertex target)
        : source(source.local), target(target) { }

        
      template<typename Archiver>
      void serialize(Archiver& ar, const unsigned int /*version*/)
      {
        ar & unsafe_serialize(source) & target;
      }

      msg_add_edge_with_property_data() { }


      msg_add_edge_with_property_data(Vertex source, 
                                      Vertex target,
                                      const EdgeProperty& property)
        : inherited_data(source, target),
          inherited_property(property) { }

      
      template<typename Archiver>
      void serialize(Archiver& ar, const unsigned int /*version*/)
      {
        ar & boost::serialization::base_object<inherited_data>(*this) 
           & boost::serialization::base_object<inherited_property>(*this);
      }

    template<typename Graph>
    inline void
    remove_in_edge(typename Graph::edge_descriptor, Graph&, directedS)
    { }

    template<typename Graph>
    inline void
    remove_in_edge(typename Graph::edge_descriptor e, Graph& g, bidirectionalS)
    {
      typedef typename Graph::in_edge_list_type in_edge_list_type;
      in_edge_list_type& in_edges =
        get(vertex_in_edges, g.base())[target(e, g).local];
      typename in_edge_list_type::iterator i = in_edges.begin();
      while (i != in_edges.end()
             && !(i->source_processor == source(e, g).owner)
             && i->e == e.local)
        ++i;

      BOOST_ASSERT(i != in_edges.end());
      in_edges.erase(i);
    }

    template<typename Graph>
    inline void
    remove_in_edge(typename Graph::edge_descriptor e, Graph& g, undirectedS)
    {
      typedef typename Graph::inherited base_type;
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;

      // TBD: can we make this more efficient?
      // Removing edge (v, u). v is local
      base_type& bg = g.base();
      vertex_descriptor u = source(e, g);
      vertex_descriptor v = target(e, g);
      if (v.owner != process_id(g.process_group())) {
        using std::swap;
        swap(u, v);
      }

      typename graph_traits<base_type>::out_edge_iterator ei, ei_end;
      for (boost::tie(ei, ei_end) = out_edges(v.local, bg); ei != ei_end; ++ei)
      {
        if (target(*ei, g.base()) == u.local
            // TBD: deal with parallel edges properly && *ei == e
            && get(edge_target_processor_id, bg, *ei) == u.owner) {
          remove_edge(ei, bg);
          return;
        }
      }

      if (v.owner == process_id(g.process_group())) {

      }
    }

      msg_remove_edge_data() {}

      explicit msg_remove_edge_data(edge_descriptor e) : e(e) {}


      template<typename Archiver>
      void serialize(Archiver& ar, const unsigned int /*version*/)
      {
        ar & e;
      }

  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
  inline processor_id_type
  get(vertex_owner_t, PBGL_DISTRIB_ADJLIST_TYPE&,
      typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v)
  {
    return v.owner;
  }

  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
  inline processor_id_type
  get(vertex_owner_t, const PBGL_DISTRIB_ADJLIST_TYPE&,
      typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v)
  {
    return v.owner;
  }

  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
  inline typename PBGL_DISTRIB_ADJLIST_TYPE::local_vertex_descriptor
  get(vertex_local_t, PBGL_DISTRIB_ADJLIST_TYPE&,
      typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v)
  {
    return v.local;
  }

  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
  inline typename PBGL_DISTRIB_ADJLIST_TYPE::local_vertex_descriptor
  get(vertex_local_t, const PBGL_DISTRIB_ADJLIST_TYPE&,
      typename PBGL_DISTRIB_ADJLIST_TYPE::vertex_descriptor v)
  {
    return v.local;
  }


  template<typename Property, PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS,
           typename Key, typename Value>
  void
  put(Property p, PBGL_DISTRIB_ADJLIST_TYPE& g, const Key& key, const Value& v)
  {
    if (owner(key) == process_id(g.process_group()))
      put(p, g.base(), local(key), v);
    else
      BOOST_ASSERT(false);
  }

  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
  void synchronize(const PBGL_DISTRIB_ADJLIST_TYPE& g)
  {
    typedef PBGL_DISTRIB_ADJLIST_TYPE graph_type;
    synchronize(g.process_group());
  }


  template<PBGL_DISTRIB_ADJLIST_TEMPLATE_PARMS>
  ProcessGroup
  process_group(const PBGL_DISTRIB_ADJLIST_TYPE& g)
  { return g.process_group(); }

    std::size_t operator()(argument_type const& x) const
    {
      std::size_t hash = hash_value(x.owner);
      hash_combine(hash, x.local);
      return hash;
    }


    std::size_t operator()(argument_type const& x) const
    {
      std::size_t hash = hash_value(x.owner());
      hash_combine(hash, x.local);
      return hash;
    }

  void handle_relax_message(Vertex v, Dist x) { relax(v, v, x); }


  void handle_msg_relax(int /*source*/, int /*tag*/,
                        const std::pair<Vertex, typename MessageValue::type>& data,
                        trigger_receive_context)
  { handle_relax_message(data.first, data.second); }


template<typename Graph, typename PredecessorMap, typename DistanceMap, 
         typename EdgeWeightMap>
delta_stepping_impl<Graph, PredecessorMap, DistanceMap, EdgeWeightMap>::
delta_stepping_impl(const Graph& g,
                    PredecessorMap predecessor, 
                    DistanceMap distance, 
                    EdgeWeightMap weight,
                    Dist delta)
    : g(g),
      predecessor(predecessor),
      distance(distance),
      weight(weight),
      delta(delta),
      pg(boost::graph::parallel::process_group_adl(g), attach_distributed_object()),
      owner(get(vertex_owner, g)),
      local(get(vertex_local, g))
{
  setup_triggers();
}


template<typename Graph, typename PredecessorMap, typename DistanceMap, 
         typename EdgeWeightMap>
delta_stepping_impl<Graph, PredecessorMap, DistanceMap, EdgeWeightMap>::
delta_stepping_impl(const Graph& g,
                    PredecessorMap predecessor, 
                    DistanceMap distance, 
                    EdgeWeightMap weight)
    : g(g),
      predecessor(predecessor),
      distance(distance),
      weight(weight),
      pg(boost::graph::parallel::process_group_adl(g), attach_distributed_object()),
      owner(get(vertex_owner, g)),
      local(get(vertex_local, g))
{
  using boost::parallel::all_reduce;
  using boost::parallel::maximum;
  using std::max;

  // Compute the maximum edge weight and degree
  Dist max_edge_weight = 0;
  Degree max_degree = 0;
  BGL_FORALL_VERTICES_T(u, g, Graph) {
    max_degree = max BOOST_PREVENT_MACRO_SUBSTITUTION (max_degree, out_degree(u, g));
    BGL_FORALL_OUTEDGES_T(u, e, g, Graph)
      max_edge_weight = max BOOST_PREVENT_MACRO_SUBSTITUTION (max_edge_weight, get(weight, e));
  }

  max_edge_weight = all_reduce(pg, max_edge_weight, maximum<Dist>());
  max_degree = all_reduce(pg, max_degree, maximum<Degree>());

  // Take a guess at delta, based on what works well for random
  // graphs.
  delta = max_edge_weight / max_degree;
  if (delta == 0)
    delta = 1;

  setup_triggers();
}


template<typename Graph, typename PredecessorMap, typename DistanceMap, 
         typename EdgeWeightMap>
void
delta_stepping_impl<Graph, PredecessorMap, DistanceMap, EdgeWeightMap>::
run(Vertex s)
{
  Dist inf = (std::numeric_limits<Dist>::max)();

  // None of the vertices are stored in the bucket.
  position_in_bucket.clear();
  position_in_bucket.resize(num_vertices(g), dummy_list.end());

  // None of the vertices have been deleted
  vertex_was_deleted.clear();
  vertex_was_deleted.resize(num_vertices(g), false);

  // No path from s to any other vertex, yet
  BGL_FORALL_VERTICES_T(v, g, Graph)
    put(distance, v, inf);

  // The distance to the starting node is zero
  if (get(owner, s) == process_id(pg))
    // Put "s" into its bucket (bucket 0)
    relax(s, s, 0);
  else
    // Note that we know the distance to s is zero
    cache(distance, s, 0);

  BucketIndex max_bucket = (std::numeric_limits<BucketIndex>::max)();
  BucketIndex current_bucket = 0;
  do {
    // Synchronize with all of the other processes.
    synchronize();

    // Find the next bucket that has something in it.
    while (current_bucket < buckets.size() 
           && (!buckets[current_bucket] || buckets[current_bucket]->empty()))
      ++current_bucket;
    if (current_bucket >= buckets.size())
      current_bucket = max_bucket;

#ifdef PBGL_DELTA_STEPPING_DEBUG
    std::cerr << "#" << process_id(pg) << ": lowest bucket is #" 
              << current_bucket << std::endl;
#endif
    // Find the smallest bucket (over all processes) that has vertices
    // that need to be processed.
    using boost::parallel::all_reduce;
    using boost::parallel::minimum;
    current_bucket = all_reduce(pg, current_bucket, minimum<BucketIndex>());

    if (current_bucket == max_bucket)
      // There are no non-empty buckets in any process; exit. 
      break;

#ifdef PBGL_DELTA_STEPPING_DEBUG
    if (process_id(pg) == 0)
      std::cerr << "Processing bucket #" << current_bucket << std::endl;
#endif

    // Contains the set of vertices that have been deleted in the
    // relaxation of "light" edges. Note that we keep track of which
    // vertices were deleted with the property map
    // "vertex_was_deleted".
    std::vector<Vertex> deleted_vertices;

    // Repeatedly relax light edges
    bool nonempty_bucket;
    do {
      // Someone has work to do in this bucket.

      if (current_bucket < buckets.size() && buckets[current_bucket]) {
        Bucket& bucket = *buckets[current_bucket];
        // For each element in the bucket
        while (!bucket.empty()) {
          Vertex u = bucket.front();

#ifdef PBGL_DELTA_STEPPING_DEBUG
          std::cerr << "#" << process_id(pg) << ": processing vertex " 
                    << get(vertex_global, g, u).second << "@" 
                    << get(vertex_global, g, u).first
                    << std::endl;
#endif

          // Remove u from the front of the bucket
          bucket.pop_front();
          
          // Insert u into the set of deleted vertices, if it hasn't
          // been done already.
          if (!vertex_was_deleted[get(local, u)]) {
            vertex_was_deleted[get(local, u)] = true;
            deleted_vertices.push_back(u);
          }

          // Relax each light edge. 
          Dist u_dist = get(distance, u);
          BGL_FORALL_OUTEDGES_T(u, e, g, Graph)
            if (get(weight, e) <= delta) // light edge
              relax(u, target(e, g), u_dist + get(weight, e));
        }
      }

      // Synchronize with all of the other processes.
      synchronize();

      // Is the bucket empty now?
      nonempty_bucket = (current_bucket < buckets.size() 
                         && buckets[current_bucket]
                         && !buckets[current_bucket]->empty());
     } while (all_reduce(pg, nonempty_bucket, std::logical_or<bool>()));

    // Relax heavy edges for each of the vertices that we previously
    // deleted.
    for (typename std::vector<Vertex>::iterator iter = deleted_vertices.begin();
         iter != deleted_vertices.end(); ++iter) {
      // Relax each heavy edge. 
      Vertex u = *iter;
      Dist u_dist = get(distance, u);
      BGL_FORALL_OUTEDGES_T(u, e, g, Graph)
        if (get(weight, e) > delta) // heavy edge
          relax(u, target(e, g), u_dist + get(weight, e)); 
    }

    // Go to the next bucket: the current bucket must already be empty.
    ++current_bucket;
  } while (true);

  // Delete all of the buckets.
  for (typename std::vector<Bucket*>::iterator iter = buckets.begin();
       iter != buckets.end(); ++iter) {
    if (*iter) {
      delete *iter;
      *iter = 0;
    }
  }
}


template<typename Graph, typename PredecessorMap, typename DistanceMap, 
         typename EdgeWeightMap>
void
delta_stepping_impl<Graph, PredecessorMap, DistanceMap, EdgeWeightMap>::
relax(Vertex u, Vertex v, Dist x) 
{
#ifdef PBGL_DELTA_STEPPING_DEBUG
  std::cerr << "#" << process_id(pg) << ": relax(" 
            << get(vertex_global, g, u).second << "@" 
            << get(vertex_global, g, u).first << ", " 
            << get(vertex_global, g, v).second << "@" 
            << get(vertex_global, g, v).first << ", "
            << x << ")" << std::endl;
#endif

  if (x < get(distance, v)) {
    // We're relaxing the edge to vertex v.
    if (get(owner, v) == process_id(pg)) {
      // Compute the new bucket index for v
      BucketIndex new_index = static_cast<BucketIndex>(x / delta);
      
      // Make sure there is enough room in the buckets data structure.
      if (new_index >= buckets.size()) buckets.resize(new_index + 1, 0);

      // Make sure that we have allocated the bucket itself.
      if (!buckets[new_index]) buckets[new_index] = new Bucket;

      if (get(distance, v) != (std::numeric_limits<Dist>::max)()
          && !vertex_was_deleted[get(local, v)]) {
        // We're moving v from an old bucket into a new one. Compute
        // the old index, then splice it in.
        BucketIndex old_index 
          = static_cast<BucketIndex>(get(distance, v) / delta);
        buckets[new_index]->splice(buckets[new_index]->end(),
                                   *buckets[old_index],
                                   position_in_bucket[get(local, v)]);
      } else {
        // We're inserting v into a bucket for the first time. Put it
        // at the end.
        buckets[new_index]->push_back(v);
      }

      // v is now at the last position in the new bucket
      position_in_bucket[get(local, v)] = buckets[new_index]->end();
      --position_in_bucket[get(local, v)];

      // Update predecessor and tentative distance information
      put(predecessor, v, u);
      put(distance, v, x);
    } else {
#ifdef PBGL_DELTA_STEPPING_DEBUG
      std::cerr << "#" << process_id(pg) << ": sending relax(" 
                << get(vertex_global, g, u).second << "@" 
                << get(vertex_global, g, u).first << ", " 
                << get(vertex_global, g, v).second << "@" 
                << get(vertex_global, g, v).first << ", "
            << x << ") to " << get(owner, v) << std::endl;
      
#endif
      // The vertex is remote: send a request to the vertex's owner
      send(pg, get(owner, v), msg_relax, 
           std::make_pair(v, MessageValue::create(x, u)));

      // Cache tentative distance information
      cache(distance, v, x);
    }
  }
}


template<typename Graph, typename PredecessorMap, typename DistanceMap, 
         typename EdgeWeightMap>
void
delta_stepping_impl<Graph, PredecessorMap, DistanceMap, EdgeWeightMap>::
synchronize()
{
  using boost::graph::parallel::synchronize;

  // Synchronize at the process group level.
  synchronize(pg);

  // Receive any relaxation request messages.
//   typedef typename ProcessGroup::process_id_type process_id_type;
//   while (optional<std::pair<process_id_type, int> > stp = probe(pg)) {
//     // Receive the relaxation message
//     assert(stp->second == msg_relax);
//     std::pair<Vertex, typename MessageValue::type> data;
//     receive(pg, stp->first, stp->second, data);

//     // Turn it into a "relax" call
//     handle_relax_message(data.first, data.second);
//   }
}


template<typename Graph, typename PredecessorMap, typename DistanceMap, 
         typename EdgeWeightMap>
void 
delta_stepping_impl<Graph, PredecessorMap, DistanceMap, EdgeWeightMap>::
setup_triggers() 
{
  using boost::graph::parallel::simple_trigger;
        
  simple_trigger(pg, msg_relax, this, 
                 &delta_stepping_impl::handle_msg_relax);
}


template<typename Graph, typename PredecessorMap, typename DistanceMap, 
         typename EdgeWeightMap>
void 
delta_stepping_shortest_paths
  (const Graph& g,
   typename graph_traits<Graph>::vertex_descriptor s,
   PredecessorMap predecessor, DistanceMap distance, EdgeWeightMap weight,
   typename property_traits<EdgeWeightMap>::value_type delta)
{
  // The "distance" map needs to act like one, retrieving the default
  // value of infinity.
  set_property_map_role(vertex_distance, distance);

  // Construct the implementation object, which will perform all of
  // the actual work.
  delta_stepping_impl<Graph, PredecessorMap, DistanceMap, EdgeWeightMap>
    impl(g, predecessor, distance, weight, delta);

  // Run the delta-stepping algorithm. The results will show up in
  // "predecessor" and "weight".
  impl.run(s);
}


template<typename Graph, typename PredecessorMap, typename DistanceMap, 
         typename EdgeWeightMap>
void 
delta_stepping_shortest_paths
  (const Graph& g,
   typename graph_traits<Graph>::vertex_descriptor s,
   PredecessorMap predecessor, DistanceMap distance, EdgeWeightMap weight)
{
  // The "distance" map needs to act like one, retrieving the default
  // value of infinity.
  set_property_map_role(vertex_distance, distance);

  // Construct the implementation object, which will perform all of
  // the actual work.
  delta_stepping_impl<Graph, PredecessorMap, DistanceMap, EdgeWeightMap>
    impl(g, predecessor, distance, weight);

  // Run the delta-stepping algorithm. The results will show up in
  // "predecessor" and "weight".
  impl.run(s);
}


      explicit darken_and_push(const ColorMap& color) : color(color) { }


      bool operator()(const argument_type& value) const
      {
        typedef color_traits<typename property_traits<ColorMap>::value_type>
          Color;
        if (get(color, value) == Color::white()) {
          put(color, value, Color::gray());
          return true;
        } else {
          return false;
        }
      }


      has_not_been_seen() { }


      template<typename Key>
      result_type operator()(Key key)
      {
        bool result = seen[get(index_map, key)];
        seen[get(index_map, key)] = true;
        return !result;
      }


      void swap(has_not_been_seen& other)
      {
        using std::swap;
        swap(seen, other.seen);
        swap(index_map, other.index_map);
      }


    template<typename IndexMap>
    inline void
    swap(has_not_been_seen<IndexMap>& x, has_not_been_seen<IndexMap>& y)
    {
      x.swap(y);
    }


    template <class DistributedGraph, class ColorMap, class BFSVisitor,
              class BufferRef, class VertexIndexMap>
    inline void
    parallel_bfs_helper
      (DistributedGraph& g,
       typename graph_traits<DistributedGraph>::vertex_descriptor s,
       ColorMap color,
       BFSVisitor vis,
       BufferRef Q,
       VertexIndexMap)
    {
      set_property_map_role(vertex_color, color);
      color.set_consistency_model(0);
      breadth_first_search(g, s, Q.ref, vis, color);
    }


    template <class DistributedGraph, class ColorMap, class BFSVisitor,
              class VertexIndexMap>
    void parallel_bfs_helper
      (DistributedGraph& g,
       typename graph_traits<DistributedGraph>::vertex_descriptor s,
       ColorMap color,
       BFSVisitor vis,
       boost::param_not_found,
       VertexIndexMap vertex_index)
    {
      using boost::graph::parallel::process_group;

      typedef graph_traits<DistributedGraph> Traits;
      typedef typename Traits::vertex_descriptor Vertex;
      typedef typename boost::graph::parallel::process_group_type<DistributedGraph>::type 
        process_group_type;

      set_property_map_role(vertex_color, color);
      color.set_consistency_model(0);

      // Buffer default
      typedef typename property_map<DistributedGraph, vertex_owner_t>
        ::const_type vertex_owner_map;
      typedef boost::graph::distributed::distributed_queue<
                process_group_type, vertex_owner_map, queue<Vertex>, 
                detail::darken_and_push<ColorMap> > queue_t;
      queue_t Q(process_group(g),
                get(vertex_owner, g),
                detail::darken_and_push<ColorMap>(color));
      breadth_first_search(g, s, Q, vis, color);
    }


    template <class DistributedGraph, class ColorMap, class BFSVisitor,
              class P, class T, class R>
    void bfs_helper
      (DistributedGraph& g,
       typename graph_traits<DistributedGraph>::vertex_descriptor s,
       ColorMap color,
       BFSVisitor vis,
       const bgl_named_params<P, T, R>& params,
       BOOST_GRAPH_ENABLE_IF_MODELS(DistributedGraph, distributed_graph_tag,
                                    void)*)
        {
            parallel_bfs_helper
        (g, s, color, vis, get_param(params, buffer_param_t()),
         choose_const_pmap(get_param(params, vertex_index),  g, vertex_index));
        }

  template<typename T> bool operator()(const T&) const { return true; }

  virtual ~distributed_queue() {}

  void pop() { buffer.pop(); }

  value_type& top() { return buffer.top(); }

  const value_type& top() const { return buffer.top(); }

template<BOOST_DISTRIBUTED_QUEUE_PARMS>
inline void
synchronize(const BOOST_DISTRIBUTED_QUEUE_TYPE& Q)
{ Q.do_synchronize(); }

template<typename ProcessGroup, typename OwnerMap, typename Buffer>
inline distributed_queue<ProcessGroup, OwnerMap, Buffer>
make_distributed_queue(const ProcessGroup& process_group,
                       const OwnerMap& owner,
                       const Buffer& buffer,
                       bool polling = false)
{
  typedef distributed_queue<ProcessGroup, OwnerMap, Buffer> result_type;
  return result_type(process_group, owner, buffer, polling);
}

  compressed_sparse_row_graph(const ProcessGroup& pg = ProcessGroup())
    : m_process_group(pg), m_distribution(parallel::block(pg, 0)) {}


  compressed_sparse_row_graph(const GraphProperty& prop,
                              const ProcessGroup& pg = ProcessGroup())
    : m_process_group(pg), m_distribution(parallel::block(pg, 0)) {}


  compressed_sparse_row_graph(vertices_size_type numverts,
                              const ProcessGroup& pg = ProcessGroup())
    : m_process_group(pg), m_distribution(parallel::block(pg, 0)),
      m_base(numverts) 
  {}


  compressed_sparse_row_graph(vertices_size_type numverts,
                              const GraphProperty& prop,
                              const ProcessGroup& pg = ProcessGroup())
    : m_process_group(pg), m_distribution(parallel::block(pg, 0)),
      m_base(numverts) 
  {}


  template <typename Distribution>
  compressed_sparse_row_graph(vertices_size_type numverts,
                              const ProcessGroup& pg,
                              const Distribution& dist)
    : m_process_group(pg), m_distribution(dist), m_base(numverts) {}


  template <typename Distribution>
  compressed_sparse_row_graph(vertices_size_type numverts,
                              const GraphProperty& prop,
                              const ProcessGroup& pg,
                              const Distribution& dist)
    : m_process_group(pg), m_distribution(dist), m_base(numverts) {}


  base_type&       base()       { return m_base; }

  const base_type& base() const { return m_base; }


  process_group_type process_group() const { return m_process_group.base(); }


  distribution_type&       distribution()       { return m_distribution; }

  const distribution_type& distribution() const { return m_distribution; }

  vertex_bundled& operator[](vertex_descriptor v)
  {
    return get(vertex_bundle, *this, v);
  }


  const vertex_bundled& operator[](vertex_descriptor v) const
  {
    return get(vertex_bundle, *this, v);
  }

  vertex_descriptor 
  make_vertex_descriptor(process_id_type p, vertex_descriptor v) const
  {
    vertex_descriptor vertex_local_index_bits = 
      sizeof(vertex_descriptor) * CHAR_BIT - processor_bits;
    return v | ((vertex_descriptor)p << vertex_local_index_bits);
  }

  vertex_descriptor local_to_global_vertex(vertex_descriptor v) const
  {
    return make_vertex_descriptor(process_id(m_process_group), v);
  }

  vertex_descriptor add_vertex()
  {
    typename graph_traits<base_type>::vertex_descriptor v 
      = boost::add_vertex(m_base);

    return make_vertex_descriptor(process_id(m_process_group), v);
  }


  vertex_descriptor add_vertex(const vertex_bundled& p)
  {
    typename graph_traits<base_type>::vertex_descriptor v 
      = boost::add_vertex(m_base, p);

    return make_vertex_descriptor(process_id(m_process_group), v);
  }


  vertex_descriptor add_vertices(vertices_size_type count)
  {
    typename graph_traits<base_type>::vertex_descriptor v 
      = boost::add_vertices(count, m_base);

    return make_vertex_descriptor(process_id(m_process_group), v);
  }


  template <typename InputIterator>
  void 
  add_edges(InputIterator first, InputIterator last)
  { boost::add_edges_global(first, last, get(vertex_local, *this), m_base); }


  template <typename InputIterator, typename EdgePropertyIterator>
  void 
  add_edges(InputIterator first, InputIterator last,
            EdgePropertyIterator ep_iter,
            EdgePropertyIterator ep_iter_end)
  { boost::add_edges_global(first, last, ep_iter, ep_iter_end, 
                            get(vertex_local, *this), m_base); }


  template <typename InputIterator>
  void 
  add_edges_sorted(InputIterator first, InputIterator last)
  { boost::add_edges_sorted_global(first, last, 
                                   get(vertex_local, *this), m_base); }


  template <typename InputIterator, typename EdgePropertyIterator>
  void 
  add_edges_sorted(InputIterator first_sorted, InputIterator last_sorted,
                   EdgePropertyIterator ep_iter_sorted)
  { boost::add_edges_sorted_global(first_sorted, last_sorted, ep_iter_sorted, 
                                   get(vertex_local, *this), m_base); }

template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor
BOOST_DISTRIB_CSR_GRAPH_TYPE::null_vertex()
{
  return graph_traits<base_type>::null_vertex();
}

template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor
source(typename BOOST_DISTRIB_CSR_GRAPH_TYPE::edge_descriptor e,
       const BOOST_DISTRIB_CSR_GRAPH_TYPE&)
{ return e.src; }


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor
target(typename BOOST_DISTRIB_CSR_GRAPH_TYPE::edge_descriptor e,
       const BOOST_DISTRIB_CSR_GRAPH_TYPE& g)
{ return target(e, g.base()); }


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::degree_size_type
num_vertices(const BOOST_DISTRIB_CSR_GRAPH_TYPE& g)
{
  return num_vertices(g.base());
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::edges_size_type
num_edges(const BOOST_DISTRIB_CSR_GRAPH_TYPE& g)
{
  return g.base().m_forward.m_column.size();
}


  local_edge(OwnerMap owner, ProcessId id) 
    : owner(owner), id(id) {}


  template <typename Vertex>
  bool operator()(std::pair<Vertex, Vertex>& x) 
  { return get(owner, x.first) == id; }


  index_to_vertex_iterator(IndexIterator index,
                           const Graph& g) 
    : index(index), g(g), current(to_edge(*index)) {}


  reference operator*() { current = to_edge(*index); return current; }

  pointer operator->() { current = to_edge(*index); return &current; }


  index_to_vertex_iterator& operator++()
  {
    ++index;
    return *this;
  }


  index_to_vertex_iterator operator++(int)
  {
    index_to_vertex_iterator temp(*this);
    ++(*this);
    return temp;
  }


  bool operator==(const index_to_vertex_iterator& other) const
  { return index == other.index; }

  
  bool operator!=(const index_to_vertex_iterator& other) const
  { return !(*this == other); }

  value_type to_edge(const typename std::iterator_traits<IndexIterator>::value_type& x)
  { return std::make_pair(vertex(x.first, g), vertex(x.second, g)); }


  index_to_vertex_func(const Distribution& dist, const Graph& g)
    : dist(dist), g(g) {}



  result_type operator()(const base_iterator_type& p) const 
  {
    return std::make_pair(vertex(p.first, g), vertex(p.second, g));
  }

template <typename IndexIterator, typename Distribution, typename Graph>
boost::transform_iterator<index_to_vertex_func<Distribution, Graph>, IndexIterator>
make_index_to_vertex_iterator(IndexIterator it, const Distribution& dist, 
                              const Graph& g) {
  return boost::make_transform_iterator(
    it, index_to_vertex_func<Distribution, Graph>(dist, g));
}

template<typename InputIterator>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_unsorted_t,
                            InputIterator edge_begin, InputIterator edge_end,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(parallel::block(m_process_group, numverts)),
    m_base(edges_are_unsorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{ }

template <typename InputIterator, typename Distribution>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_unsorted_t,
                            InputIterator edge_begin, InputIterator edge_end,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const Distribution& dist,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(dist),
    m_base(edges_are_unsorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{ }

template<typename InputIterator, typename EdgePropertyIterator>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_unsorted_t,
                            InputIterator edge_begin, InputIterator edge_end,
                            EdgePropertyIterator ep_iter,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(parallel::block(m_process_group, numverts)),
    m_base(edges_are_unsorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           ep_iter,
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{ }

template <typename InputIterator, typename EdgePropertyIterator,
          typename Distribution>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_unsorted_t,
                            InputIterator edge_begin, InputIterator edge_end,
                            EdgePropertyIterator ep_iter,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const Distribution& dist,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(dist),
    m_base(edges_are_unsorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           ep_iter,
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{ }

template<typename InputIterator>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_sorted_t,
                            InputIterator edge_begin, InputIterator edge_end,
                            vertices_size_type numverts,
                            edges_size_type numedges, // This is not used as there is no appropriate BGL ctor
                            const ProcessGroup& pg,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(parallel::block(m_process_group, numverts)),
    m_base(edges_are_sorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           m_distribution.block_size(process_id(m_process_group), numverts),
           prop)
{ }

template <typename InputIterator, typename Distribution>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_sorted_t,
                            InputIterator edge_begin, InputIterator edge_end,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const Distribution& dist,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(dist),
    m_base(edges_are_sorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           m_distribution.block_size(process_id(m_process_group), numverts),
           prop)
{ }

template<typename InputIterator, typename EdgePropertyIterator>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_sorted_t,
                            InputIterator edge_begin, InputIterator edge_end,
                            EdgePropertyIterator ep_iter,
                            vertices_size_type numverts,
                            edges_size_type numedges, // This is not used as there is no appropriate BGL ctor
                            const ProcessGroup& pg,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(parallel::block(m_process_group, numverts)),
    m_base(edges_are_sorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           ep_iter,
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           m_distribution.block_size(process_id(m_process_group), numverts),
           prop)
{ }

template<typename InputIterator, typename EdgePropertyIterator,
         typename Distribution>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_sorted_t,
                            InputIterator edge_begin, InputIterator edge_end,
                            EdgePropertyIterator ep_iter,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const Distribution& dist,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(dist),
    m_base(edges_are_sorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           ep_iter,
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           m_distribution.block_size(process_id(m_process_group), numverts),
           prop)
{ }

template<typename MultiPassInputIterator>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_unsorted_multi_pass_t,
                            MultiPassInputIterator edge_begin, 
                            MultiPassInputIterator edge_end,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(parallel::block(m_process_group, numverts)),
    m_base(edges_are_unsorted_multi_pass_global,
           make_index_to_vertex_iterator(edge_begin, parallel::block(m_process_group, numverts), *this),
           make_index_to_vertex_iterator(edge_end, parallel::block(m_process_group, numverts), *this),
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{ }

template <typename MultiPassInputIterator, typename Distribution>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_unsorted_multi_pass_t,
                            MultiPassInputIterator edge_begin, 
                            MultiPassInputIterator edge_end,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const Distribution& dist,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(dist),
    m_base(edges_are_unsorted_multi_pass_global,
           make_index_to_vertex_iterator(edge_begin, parallel::block(m_process_group, numverts), *this),
           make_index_to_vertex_iterator(edge_end, parallel::block(m_process_group, numverts), *this),
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{ }

template<typename MultiPassInputIterator, typename EdgePropertyIterator>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_unsorted_multi_pass_t,
                            MultiPassInputIterator edge_begin, 
                            MultiPassInputIterator edge_end,
                            EdgePropertyIterator ep_iter,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(parallel::block(m_process_group, numverts)),
    m_base(edges_are_unsorted_multi_pass_global,
           make_index_to_vertex_iterator(edge_begin, parallel::block(m_process_group, numverts), *this),
           make_index_to_vertex_iterator(edge_end, parallel::block(m_process_group, numverts), *this),
           ep_iter,
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{ }

template <typename MultiPassInputIterator, typename EdgePropertyIterator,
          typename Distribution>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(edges_are_unsorted_multi_pass_t,
                            MultiPassInputIterator edge_begin, 
                            MultiPassInputIterator edge_end,
                            EdgePropertyIterator ep_iter,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const Distribution& dist,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(dist),
    m_base(edges_are_unsorted_multi_pass_global,
           make_index_to_vertex_iterator(edge_begin, parallel::block(m_process_group, numverts), *this),
           make_index_to_vertex_iterator(edge_end, parallel::block(m_process_group, numverts), *this),
           ep_iter,
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{ }

template<typename InputIterator>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(InputIterator edge_begin, InputIterator edge_end,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(parallel::block(m_process_group, numverts)),
    m_base(edges_are_unsorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
           
{
}

template<typename InputIterator, typename EdgePropertyIterator>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(InputIterator edge_begin, InputIterator edge_end,
                            EdgePropertyIterator ep_iter,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const GraphProperty& prop)
  : m_process_group(pg),

    m_distribution(parallel::block(m_process_group, numverts)),
    m_base(edges_are_unsorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           ep_iter,
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{
}

template<typename InputIterator, typename Distribution>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(InputIterator edge_begin, InputIterator edge_end,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const Distribution& dist,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(dist),
    m_base(edges_are_unsorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{
}

template<typename InputIterator, typename EdgePropertyIterator, 
         typename Distribution>
BOOST_DISTRIB_CSR_GRAPH_TYPE::
compressed_sparse_row_graph(InputIterator edge_begin, InputIterator edge_end,
                            EdgePropertyIterator ep_iter,
                            vertices_size_type numverts,
                            const ProcessGroup& pg,
                            const Distribution& dist,
                            const GraphProperty& prop)
  : m_process_group(pg),
    m_distribution(dist),
    m_base(edges_are_unsorted_global,
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_begin, *this),
           index_to_vertex_iterator<InputIterator, BOOST_DISTRIB_CSR_GRAPH_TYPE>(edge_end, *this),
           m_distribution.block_size(process_id(m_process_group), numverts),
           get(vertex_local, *this),
           local_vertex<csr_vertex_owner_map<process_id_type, vertex_descriptor>, 
                        process_id_type> (get(vertex_owner, *this), process_id(pg)),
           prop)
{
}


template<typename ProcessID, typename Key>
inline ProcessID
get(csr_vertex_owner_map<ProcessID, Key> pm,
    typename csr_vertex_owner_map<ProcessID, Key>::key_type k)
{
  const int local_index_bits = sizeof(Key) * CHAR_BIT - processor_bits;
  return k >> local_index_bits;
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename ProcessGroup::process_id_type
get(vertex_owner_t, BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor k)
{
  return get(vertex_owner, 
             const_cast<const BOOST_DISTRIB_CSR_GRAPH_TYPE&>(g),
             k);
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename ProcessGroup::process_id_type
get(vertex_owner_t, const BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor k)
{
  typedef typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor
    vertex_descriptor;
  const int local_index_bits = 
    sizeof(vertex_descriptor) * CHAR_BIT - processor_bits;
  return k >> local_index_bits;
}


template<typename Key>
inline Key
get(csr_vertex_local_map<Key> pm,
    typename csr_vertex_local_map<Key>::key_type k)
{
  const Key local_index_mask = Key(-1) >> processor_bits;
  return k & local_index_mask;
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor
get(vertex_local_t, BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor k)
{
  return get(vertex_local, 
             const_cast<const BOOST_DISTRIB_CSR_GRAPH_TYPE&>(g),
             k);
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor
get(vertex_local_t, const BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor k)
{
  typedef typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor 
    vertex_descriptor;
  const vertex_descriptor local_index_mask = 
    vertex_descriptor(-1) >> processor_bits;
  return k & local_index_mask;
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertices_size_type
get(vertex_index_t, BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor k)
{
  return get(vertex_local, g, k);
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertices_size_type
get(vertex_index_t, const BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor k)
{
  return get(vertex_local, g, k);
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertices_size_type
get(vertex_local_index_t, BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor k)
{
  return get(vertex_local, g, k);
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertices_size_type
get(vertex_local_index_t, const BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::vertex_descriptor k)
{
  return get(vertex_local, g, k);
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::edges_size_type
get(edge_index_t, BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::edge_descriptor k)
{
  return k.idx;
}


template<BOOST_DISTRIB_CSR_GRAPH_TEMPLATE_PARMS>
inline typename BOOST_DISTRIB_CSR_GRAPH_TYPE::edges_size_type
get(edge_index_t, const BOOST_DISTRIB_CSR_GRAPH_TYPE& g,
    typename BOOST_DISTRIB_CSR_GRAPH_TYPE::edge_descriptor k)
{
  return k.idx;
}

  template<typename Graph, typename GraphRef>
  inline typename graph::parallel::process_group_type<Graph>::type
  process_group(reverse_graph<Graph, GraphRef> const& g) {
    return process_group(g.m_g);
  }


  distribution_global_index_map(const Distribution& distribution,
                                const OwnerPropertyMap& owner,
                                const LocalPropertyMap& local)
    : distribution_(distribution), owner(owner), local(local) { }


template<typename Distribution, typename OwnerPropertyMap, 
         typename LocalPropertyMap>
inline 
typename distribution_global_index_map<Distribution, OwnerPropertyMap,
                                       LocalPropertyMap>::value_type
get(const distribution_global_index_map<Distribution, OwnerPropertyMap,
                                        LocalPropertyMap>& p,
    typename distribution_global_index_map<Distribution, OwnerPropertyMap,
                                           LocalPropertyMap>::key_type x)
{ 
  using boost::get;
  return p.distribution_.global(get(p.owner, x), get(p.local, x));
}

  template<typename PropertyMap, typename ForwardIterator>
  inline void 
  initialize_global_index_map(const PropertyMap&, 
                              ForwardIterator, ForwardIterator) 
  { }


  vertex_list_adaptor(const Graph& g, 
                      const GlobalIndexMap& index_map = GlobalIndexMap())
    : g(&g), index_map(index_map)
  {
    using boost::vertices;

    all_vertices_.reset(new std::vector<vertex_descriptor>());
    all_gather(process_group(), vertices(g).first, vertices(g).second,
               *all_vertices_);
    detail::initialize_global_index_map(this->index_map, 
                                        all_vertices_->begin(),
                                        all_vertices_->end());
  }


  const Graph& base() const { return *g; }


  process_group_type process_group() const 
  { 
    using boost::graph::parallel::process_group;
    return process_group(*g); 
  }


template<typename Graph, typename GlobalIndexMap>
inline vertex_list_adaptor<Graph, GlobalIndexMap>
make_vertex_list_adaptor(const Graph& g, const GlobalIndexMap& index_map)
{ return vertex_list_adaptor<Graph, GlobalIndexMap>(g, index_map); }


template<typename Graph>
inline 
vertex_list_adaptor<Graph, 
                    typename detail::default_global_index_map<Graph>::type>
make_vertex_list_adaptor(const Graph& g)
{ 
  typedef typename detail::default_global_index_map<Graph>::type 
    GlobalIndexMap;
  typedef typename detail::default_global_index_map<Graph>::distributed_map
    DistributedMap;
  typedef vertex_list_adaptor<Graph, GlobalIndexMap> result_type;
  return result_type(g, 
                     GlobalIndexMap(DistributedMap(num_vertices(g), 
                                                   get(vertex_index, g))));
}

template<typename Graph, typename GlobalIndexMap>
inline typename vertex_list_adaptor<Graph, GlobalIndexMap>::vertex_descriptor
source(typename vertex_list_adaptor<Graph, GlobalIndexMap>::edge_descriptor e,
       const vertex_list_adaptor<Graph, GlobalIndexMap>& g)
{ return source(e, g.base()); }


template<typename Graph, typename GlobalIndexMap>
inline typename vertex_list_adaptor<Graph, GlobalIndexMap>::vertex_descriptor
target(typename vertex_list_adaptor<Graph, GlobalIndexMap>::edge_descriptor e,
       const vertex_list_adaptor<Graph, GlobalIndexMap>& g)
{ return target(e, g.base()); }

      metaVertex() {}

      metaVertex(const Vertex& v) : name(v) {}


      template<typename Archiver>
      void serialize(Archiver& ar, const unsigned int /*version*/)
      {
        ar & name;
      }

      cull_adjacency_list(const Vertex v, const ParentMap p) : v(v), p(p) {}

      bool operator() (const Vertex x) { return (get(p, x) == v || x == v); }

      hashed_vertex_compare (const OwnerMap& o, const LocalMap& l)
        : owner(o), local(l) { }


      template <typename Vertex>
      bool operator() (const Vertex x, const Vertex y) 
      { 
        if (get(local, x) < get(local, y))
          return true;
        else if (get(local, x) == get(local, y))
          return (get(owner, x) < get(owner, y));
        return false;
      }

    template <typename Graph, typename ParentMap, typename VertexList>
    void
    request_parent_map_entries(const Graph& g, ParentMap p,
                               std::vector<VertexList>& parent_requests)
    {
      typedef typename boost::graph::parallel::process_group_type<Graph>
        ::type process_group_type;
      typedef typename process_group_type::process_id_type process_id_type;

      typedef typename graph_traits<Graph>::vertex_descriptor
        vertex_descriptor;

      process_group_type pg = process_group(g);
      
      /*
        This should probably be send_oob_with_reply, especially when Dave 
        finishes prefetch-batching
      */

      // Send root requests
      for (process_id_type i = 0; i < num_processes(pg); ++i) {
        if (!parent_requests[i].empty()) {
          std::vector<vertex_descriptor> reqs(parent_requests[i].begin(),
                                              parent_requests[i].end());
          send(pg, i, req_parents_msg, reqs);
        }
      }
      
      synchronize(pg);
      
      // Receive root requests and reply to them
      while (optional<std::pair<process_id_type, int> > m = probe(pg)) {
        std::vector<vertex_descriptor> requests;
        receive(pg, m->first, m->second, requests);
        for (std::size_t i = 0; i < requests.size(); ++i)
          requests[i] = get(p, requests[i]);
        send(pg, m->first, parents_msg, requests);
      }
      
      synchronize(pg);
      
      // Receive requested parents
      std::vector<vertex_descriptor> responses;
      for (process_id_type i = 0; i < num_processes(pg); ++i) {
        if (!parent_requests[i].empty()) {
          receive(pg, i, parents_msg, responses);
          std::size_t parent_idx = 0;
          for (typename VertexList::iterator v = parent_requests[i].begin();
               v != parent_requests[i].end(); ++v, ++parent_idx)
            put(p, *v, responses[parent_idx]);
        }
      }
    }

    
    template<typename DistributedGraph, typename ParentMap>
    void
    parallel_connected_components(DistributedGraph& g, ParentMap p)
    {
      using boost::connected_components;

      typedef typename graph_traits<DistributedGraph>::adjacency_iterator
        adjacency_iterator;
      typedef typename graph_traits<DistributedGraph>::out_edge_iterator
        out_edge_iterator;
      typedef typename graph_traits<DistributedGraph>::edge_iterator
        edge_iterator;
      typedef typename graph_traits<DistributedGraph>::vertex_descriptor
        vertex_descriptor;
      typedef typename graph_traits<DistributedGraph>::edge_descriptor
        edge_descriptor;

      typedef typename boost::graph::parallel::process_group_type<DistributedGraph>
        ::type process_group_type;
      typedef typename process_group_type::process_id_type process_id_type;

      using boost::graph::parallel::process_group;

      process_group_type pg = process_group(g);
      process_id_type id = process_id(pg);

      // TODO (NGE): Should old_roots, roots, and completed_roots be std::list
      adjacency_iterator av1, av2;
      std::vector<vertex_descriptor> old_roots;
      typename std::vector<vertex_descriptor>::iterator liter;
      typename std::vector<vertex_descriptor>::iterator aliter;
      typename std::map<vertex_descriptor,
                        std::vector<vertex_descriptor> > adj;

      typedef typename property_map<DistributedGraph, vertex_owner_t>::const_type
        OwnerMap;
      OwnerMap owner = get(vertex_owner, g);
      typedef typename property_map<DistributedGraph, vertex_local_t>::const_type
        LocalMap;
      LocalMap local = get(vertex_local, g);

      // We need to hold on to all of the parent pointers
      p.set_max_ghost_cells(0);

      //
      // STAGE 1 : Compute local components
      //
      local_subgraph<const DistributedGraph> ls(g);
      typedef typename property_map<local_subgraph<const DistributedGraph>,
                                    vertex_index_t>::type local_index_map_type;
      local_index_map_type local_index = get(vertex_index, ls);

      // Compute local connected components
      std::vector<std::size_t> ls_components_vec(num_vertices(ls));
      typedef iterator_property_map<std::vector<std::size_t>::iterator,
                                    local_index_map_type>
        ls_components_map_type;
      ls_components_map_type ls_component(ls_components_vec.begin(),
                                          local_index);
      std::size_t num_comp = connected_components(ls, ls_component);

      std::vector<vertex_descriptor> 
        roots(num_comp, graph_traits<DistributedGraph>::null_vertex());

      BGL_FORALL_VERTICES_T(v, g, DistributedGraph) {
        size_t component = get(ls_component, v);
        if (roots[component] == graph_traits<DistributedGraph>::null_vertex() ||
            get(local_index, v) < get(local_index, roots[component])) 
          roots[component] = v;
      }

      // Set all the local parent pointers
      BGL_FORALL_VERTICES_T(v, g, DistributedGraph) {
        put(p, v, roots[get(ls_component, v)]);
      }

      if (num_processes(pg) == 1) return;

      // Build adjacency list for all roots
      BGL_FORALL_VERTICES_T(v, g, DistributedGraph) {
        std::vector<vertex_descriptor>& my_adj = adj[get(p, v)];
        for (boost::tie(av1, av2) = adjacent_vertices(v, g);
             av1 != av2; ++av1) {
          if (get(owner, *av1) != id) my_adj.push_back(*av1);
        }
      }

      // For all vertices adjacent to a local vertex get p(v)
      for ( liter = roots.begin(); liter != roots.end(); ++liter ) {
        std::vector<vertex_descriptor>& my_adj = adj[*liter];
        for ( aliter = my_adj.begin(); aliter != my_adj.end(); ++aliter )
          request(p, *aliter);
      }
      synchronize(p);

      // Update adjacency list at root to make sure all adjacent
      // vertices are roots of remote components
      for ( liter = roots.begin(); liter != roots.end(); ++liter )
        {
          std::vector<vertex_descriptor>& my_adj = adj[*liter];
          for ( aliter = my_adj.begin(); aliter != my_adj.end(); ++aliter )
            *aliter = get(p, *aliter);

          my_adj.erase
            (std::remove_if(my_adj.begin(), my_adj.end(),
                       cull_adjacency_list<vertex_descriptor, 
                                           ParentMap>(*liter, p) ),
             my_adj.end());
          // This sort needs to be here to make sure the initial
          // adjacency list is sorted
          std::sort(my_adj.begin(), my_adj.end(), std::less<vertex_descriptor>());
          my_adj.erase(std::unique(my_adj.begin(), my_adj.end()), my_adj.end());
        }

      // Get p(v) for the new adjacent roots
      p.clear();
      for ( liter = roots.begin(); liter != roots.end(); ++liter ) {
        std::vector<vertex_descriptor>& my_adj = adj[*liter];
        for ( aliter = my_adj.begin(); aliter != my_adj.end(); ++aliter )
          request(p, *aliter);
      }
#ifdef PBGL_EXPLICIT_SYNCH
      synchronize(p);
#endif

      // Lastly, remove roots with no adjacent vertices, this is
      // unnecessary but will speed up sparse graphs
      for ( liter = roots.begin(); liter != roots.end(); /*in loop*/)
        {
          if ( adj[*liter].empty() )
            liter = roots.erase(liter);
          else
            ++liter;
        }

#ifdef PBGL_CONSTRUCT_METAGRAPH
      /* TODO: If the number of roots is sufficiently small, we can 
               use a 'problem folding' approach like we do in MST
               to gather all the roots and their adjacencies on one proc
               and solve for the connected components of the meta-graph */
      using boost::parallel::all_reduce;
      std::size_t num_roots = all_reduce(pg, roots.size(), std::plus<std::size_t>());
      if (num_roots < MAX_VERTICES_IN_METAGRAPH) {
        build_local_metagraph(g, p, roots.begin(), roots.end(), adj);
        
        // For each vertex in g, p(v) = p(p(v)), assign parent of leaf
        // vertices from first step to final parent
        BGL_FORALL_VERTICES_T(v, g, DistributedGraph) {
          put(p, v, get(p, get(p, v)));
        }
        
        synchronize(p);
        
        return;
      }
#endif

      //
      // Parallel Phase
      //

      std::vector<vertex_descriptor> completed_roots;
      hashed_vertex_compare<OwnerMap, LocalMap> v_compare(owner, local);
      bool any_hooked;
      vertex_descriptor new_root;

      std::size_t steps = 0;

      do {
        ++steps;

        // Pull in new parents for hooking phase
        synchronize(p);

        //
        // Hooking
        //
        bool hooked = false;
        completed_roots.clear();
        for ( liter = roots.begin(); liter != roots.end(); )
          {
            new_root = graph_traits<DistributedGraph>::null_vertex();
            std::vector<vertex_descriptor>& my_adj = adj[*liter];
            for ( aliter = my_adj.begin(); aliter != my_adj.end(); ++aliter )
              // try to hook to better adjacent vertex
              if ( v_compare( get(p, *aliter), *liter ) )
                new_root = get(p, *aliter);

            if ( new_root != graph_traits<DistributedGraph>::null_vertex() )
              {
                hooked = true;
                put(p, *liter, new_root);
                old_roots.push_back(*liter);
                completed_roots.push_back(*liter);
                liter = roots.erase(liter);
              }
            else
              ++liter;
          }

        //
        // Pointer jumping, perform until new roots determined
        //

        // TODO: Implement cycle reduction rules to reduce this from
        // O(n) to O(log n) [n = cycle length]
        bool all_done;
        std::size_t parent_root_count;

        std::size_t double_steps = 0;

        do {
          ++double_steps;
#ifndef PBGL_EXPLICIT_SYNCH
          // Get p(p(v)) for all old roots, and p(v) for all current roots
          for ( liter = old_roots.begin(); liter != old_roots.end(); ++liter )
            request(p, get(p, *liter));

          synchronize(p);
#else
          // Build root requests
          typedef std::set<vertex_descriptor> VertexSet;
          std::vector<VertexSet> parent_requests(num_processes(pg));
          for ( liter = old_roots.begin(); liter != old_roots.end(); ++liter )
            {
              vertex_descriptor p1 = *liter;
              if (get(owner, p1) != id) parent_requests[get(owner, p1)].insert(p1);
              vertex_descriptor p2 = get(p, p1);
              if (get(owner, p2) != id) parent_requests[get(owner, p2)].insert(p2);
            }

          request_parent_map_entries(g, p, parent_requests);
#endif
          // Perform a pointer jumping step on all old roots
          for ( liter = old_roots.begin(); liter != old_roots.end(); ++liter )
              put(p, *liter, get(p, get(p, *liter)));

          // make sure the parent of all old roots is itself a root
          parent_root_count = 0;
          for ( liter = old_roots.begin(); liter != old_roots.end(); ++liter )
            if ( get(p, *liter) == get(p, get(p, *liter)) )
              parent_root_count++;

          bool done = parent_root_count == old_roots.size();

          all_reduce(pg, &done, &done+1, &all_done,
                     std::logical_and<bool>());
        } while ( !all_done );
#ifdef PARALLEL_BGL_DEBUG
        if (id == 0) std::cerr << double_steps << " doubling steps.\n";
#endif
        //
        // Add adjacent vertices of just completed roots to adjacent
        // vertex list at new parent
        //
        typename std::vector<vertex_descriptor> outgoing_edges;
        for ( liter = completed_roots.begin(); liter != completed_roots.end();
              ++liter )
          {
            vertex_descriptor new_parent = get(p, *liter);

            if ( get(owner, new_parent) == id )
              {
                std::vector<vertex_descriptor>& my_adj = adj[new_parent];
                my_adj.reserve(my_adj.size() + adj[*liter].size());
                my_adj.insert( my_adj.end(),
                               adj[*liter].begin(), adj[*liter].end() );
#ifdef PBGL_IN_PLACE_MERGE
#ifdef PBGL_SORT_ASSERT
                BOOST_ASSERT(::boost::detail::is_sorted(my_adj.begin(),
                                                  my_adj.end() - adj[*liter].size(),
                                                  std::less<vertex_descriptor>()));
                BOOST_ASSERT(::boost::detail::is_sorted(my_adj.end() - adj[*liter].size(),
                                                  my_adj.end(),
                                                  std::less<vertex_descriptor>()));
#endif
                std::inplace_merge(my_adj.begin(),
                                   my_adj.end() - adj[*liter].size(),
                                   my_adj.end(),
                                   std::less<vertex_descriptor>());
#endif


              }
            else if ( adj[*liter].begin() != adj[*liter].end() )
              {
                outgoing_edges.clear();
                outgoing_edges.reserve(adj[*liter].size() + 1);
                // First element is the destination of the adjacency list
                outgoing_edges.push_back(new_parent);
                outgoing_edges.insert(outgoing_edges.end(),
                                      adj[*liter].begin(), adj[*liter].end() );
                send(pg, get(owner, new_parent), edges_msg, outgoing_edges);
                adj[*liter].clear();
              }
          }
        synchronize(pg);

        // Receive edges sent by remote nodes and add them to the
        // indicated vertex's adjacency list
        while (optional<std::pair<process_id_type, int> > m
               = probe(pg))
          {
            std::vector<vertex_descriptor> incoming_edges;
            receive(pg, m->first, edges_msg, incoming_edges);
            typename std::vector<vertex_descriptor>::iterator aviter
              = incoming_edges.begin();
            ++aviter;

            std::vector<vertex_descriptor>& my_adj = adj[incoming_edges[0]];

            my_adj.reserve(my_adj.size() + incoming_edges.size() - 1);
            my_adj.insert( my_adj.end(), aviter, incoming_edges.end() );

#ifdef PBGL_IN_PLACE_MERGE
            std::size_t num_incoming_edges = incoming_edges.size();
#ifdef PBGL_SORT_ASSERT
            BOOST_ASSERT(::boost::detail::is_sorted(my_adj.begin(),
                                              my_adj.end() - (num_incoming_edges-1),
                                              std::less<vertex_descriptor>()));
            BOOST_ASSERT(::boost::detail::is_sorted(my_adj.end() - (num_incoming_edges-1),
                                              my_adj.end(),
                                              std::less<vertex_descriptor>()));
#endif
            std::inplace_merge(my_adj.begin(),
                               my_adj.end() - (num_incoming_edges - 1),
                               my_adj.end(),
                               std::less<vertex_descriptor>());
#endif

          }


        // Remove any adjacent vertices that are in the same component
        // as a root from that root's list
        for ( liter = roots.begin(); liter != roots.end(); ++liter )
          {
            // We can probably get away without sorting and removing
            // duplicates Though sorting *may* cause root
            // determination to occur faster by choosing the root with
            // the most potential to hook to at each step
            std::vector<vertex_descriptor>& my_adj = adj[*liter];
            my_adj.erase
              (std::remove_if(my_adj.begin(), my_adj.end(),
                         cull_adjacency_list<vertex_descriptor,
                                             ParentMap>(*liter, p) ),
               my_adj.end());
#ifndef PBGL_IN_PLACE_MERGE
            std::sort(my_adj.begin(), my_adj.end(),
                 std::less<vertex_descriptor>() );
#endif
            my_adj.erase(std::unique(my_adj.begin(), my_adj.end()), my_adj.end());
          }

        // Reduce result of empty root list test
        all_reduce(pg, &hooked, &hooked+1, &any_hooked,
                   std::logical_or<bool>());
      } while ( any_hooked );
#ifdef PARALLEL_BGL_DEBUG
      if (id == 0) std::cerr << steps << " iterations.\n";
#endif
      //
      // Finalize
      //

      // For each vertex in g, p(v) = p(p(v)), assign parent of leaf
      // vertices from first step to final parent
      BGL_FORALL_VERTICES_T(v, g, DistributedGraph) {
        put(p, v, get(p, get(p, v)));
      }
      
      synchronize(p);
    }


  template<typename Graph, typename ParentMap, typename ComponentMap>
  typename property_traits<ComponentMap>::value_type
  number_components_from_parents(const Graph& g, ParentMap p, ComponentMap c)
  {
    typedef typename graph_traits<Graph>::vertex_descriptor
      vertex_descriptor;
    typedef typename boost::graph::parallel::process_group_type<Graph>::type
      process_group_type;
    typedef typename property_traits<ComponentMap>::value_type
      ComponentMapType;

    process_group_type pg = process_group(g);

    /* Build list of roots */
    std::vector<vertex_descriptor> my_roots, all_roots;

    BGL_FORALL_VERTICES_T(v, g, Graph) {
      if( std::find( my_roots.begin(), my_roots.end(), get(p, v) )
          == my_roots.end() )
        my_roots.push_back( get(p, v) );
    }

    all_gather(pg, my_roots.begin(), my_roots.end(), all_roots);

    /* Number components */
    std::map<vertex_descriptor, ComponentMapType> comp_numbers;
    ComponentMapType c_num = 0;

    // Compute component numbers
    for (std::size_t i = 0; i < all_roots.size(); i++ )
      if ( comp_numbers.count(all_roots[i]) == 0 )
        comp_numbers[all_roots[i]] = c_num++;

    // Broadcast component numbers
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      put( c, v, comp_numbers[get(p, v)] );
    }

    // Broadcast number of components
    if (process_id(pg) == 0) {
      typedef typename process_group_type::process_size_type
        process_size_type;
      for (process_size_type dest = 1, n = num_processes(pg);
           dest != n; ++dest)
        send(pg, dest, 0, c_num);
    }
    synchronize(pg);

    if (process_id(pg) != 0) receive(pg, 0, 0, c_num);

    synchronize(c);

    return c_num;
  }


  template<typename Graph, typename ParentMap>
  int
  number_components_from_parents(const Graph& g, ParentMap p, 
                                 dummy_property_map)
  {
    using boost::parallel::all_reduce;

    // Count local roots.
    int num_roots = 0;
    BGL_FORALL_VERTICES_T(v, g, Graph)
      if (get(p, v) == v) ++num_roots;
    return all_reduce(g.process_group(), num_roots, std::plus<int>());
  }


  template<typename Graph, typename ComponentMap, typename ParentMap>
  typename property_traits<ComponentMap>::value_type
  connected_components
    (const Graph& g, ComponentMap c, ParentMap p
     BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, distributed_graph_tag))
  {
    cc_detail::parallel_connected_components(g, p);
    return number_components_from_parents(g, p, c);
  }

  template<typename Graph, typename ComponentMap>
  typename property_traits<ComponentMap>::value_type
  connected_components
    ( const Graph& g, ComponentMap c
      BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, distributed_graph_tag) )
  {
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;

    std::vector<vertex_descriptor> x(num_vertices(g));

    return connected_components
             (g, c,
              make_iterator_property_map(x.begin(), get(vertex_index, g)));
  }

  template<typename ProcessGroup>
  hashed_distribution(const ProcessGroup& pg, std::size_t /*num_vertices*/ = 0)
    : n(num_processes(pg)) { }


  int operator()(const T& value) const 
  {
    return hasher(value) % n;
  }

  Graph&       derived()       { return static_cast<Graph&>(*this); }

  const Graph& derived() const { return static_cast<const Graph&>(*this); }

  process_group_type&       process_group()       { return process_group_; }

  const process_group_type& process_group() const { return process_group_; }

  distribution_type&       named_distribution()       { return distribution_; }

  const distribution_type& named_distribution() const { return distribution_; }

  void added_vertex(Vertex) { }

  template <typename VertexIterStability>
  void removing_vertex(Vertex, VertexIterStability) { }

  void clearing_graph() { }

  lazy_add_vertex(named_graph& self, const vertex_name_type& name)
    : self(self), name(name), committed(false) { }

  lazy_add_vertex(const lazy_add_vertex& other)
    : self(self), name(other.name), committed(other.committed)
  {
    other.committed = true;
  }

  operator vertex_descriptor() const { return commit(); }


template<BGL_NAMED_GRAPH_PARAMS>
BGL_NAMED_GRAPH::lazy_add_vertex::~lazy_add_vertex()
{
  typedef typename BGL_NAMED_GRAPH::process_id_type process_id_type;

  /// If this vertex has already been created or will be created by
  /// someone else, or if someone threw an exception, we will not
  /// create the vertex now.
  if (committed || std::uncaught_exception())
    return;

  committed = true;

  process_id_type owner = self.named_distribution()(name);
  if (owner == process_id(self.process_group()))
    /// Add the vertex locally
    add_vertex(self.derived().base().vertex_constructor(name), self.derived()); 
  else
    /// Ask the owner of the vertex to add a vertex with this name
    send(self.process_group(), owner, msg_add_vertex_name, name);
}


template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::vertex_descriptor
BGL_NAMED_GRAPH::lazy_add_vertex::commit() const
{
  typedef typename BGL_NAMED_GRAPH::process_id_type process_id_type;
  BOOST_ASSERT (!committed);
  committed = true;

  process_id_type owner = self.named_distribution()(name);
  if (owner == process_id(self.process_group()))
    /// Add the vertex locally
    return add_vertex(self.derived().base().vertex_constructor(name),
                      self.derived()); 
  else {
    /// Ask the owner of the vertex to add a vertex with this name
    vertex_descriptor result;
    send_oob_with_reply(self.process_group(), owner, 
                        msg_add_vertex_name_with_reply, name, result);
    return result;
  }
}

  lazy_add_edge(BGL_NAMED_GRAPH& self, 
                const vertex_name_type& u_name,
                const vertex_name_type& v_name) 
    : self(self), u(u_name), v(v_name), committed(false) { }

  lazy_add_edge(BGL_NAMED_GRAPH& self,
                vertex_descriptor u,
                const vertex_name_type& v_name)
    : self(self), u(u), v(v_name), committed(false) { }

  lazy_add_edge(BGL_NAMED_GRAPH& self,
                const vertex_name_type& u_name,
                vertex_descriptor v)
    : self(self), u(u_name), v(v), committed(false) { }

  lazy_add_edge(BGL_NAMED_GRAPH& self,
                vertex_descriptor u,
                vertex_descriptor v)
    : self(self), u(u), v(v), committed(false) { }

  lazy_add_edge(const lazy_add_edge& other)
    : self(other.self), u(other.u), v(other.v), committed(other.committed)
  {
    other.committed = true;
  }


template<BGL_NAMED_GRAPH_PARAMS>
BGL_NAMED_GRAPH::lazy_add_edge::~lazy_add_edge()
{
  typedef typename BGL_NAMED_GRAPH::process_id_type process_id_type;

  using boost::parallel::detail::make_untracked_pair;

  /// If this edge has already been created or will be created by
  /// someone else, or if someone threw an exception, we will not
  /// create the edge now.
  if (committed || std::uncaught_exception())
    return;

  committed = true;

  if (vertex_name_type* v_name = boost::get<vertex_name_type>(&v)) {
    // We haven't resolved the target vertex to a descriptor yet, so
    // it must not be local. Send a message to the owner of the target
    // of the edge. If the owner of the target does not happen to own
    // the source, it will resolve the target to a vertex descriptor
    // and pass the message along to the owner of the source. 
    if (vertex_name_type* u_name = boost::get<vertex_name_type>(&u))
      send(self.process_group(), self.distribution_(*v_name),
           BGL_NAMED_GRAPH::msg_add_edge_name_name,
           make_untracked_pair(*u_name, *v_name));
    else
      send(self.process_group(), self.distribution_(*v_name),
           BGL_NAMED_GRAPH::msg_add_edge_vertex_name,
           make_untracked_pair(boost::get<vertex_descriptor>(u), *v_name));
  } else {
    if (vertex_name_type* u_name = boost::get<vertex_name_type>(&u))
      // We haven't resolved the source vertex to a descriptor yet, so
      // it must not be local. Send a message to the owner of the
      // source vertex requesting the edge addition.
      send(self.process_group(), self.distribution_(*u_name),
           BGL_NAMED_GRAPH::msg_add_edge_name_vertex,
           make_untracked_pair(*u_name, boost::get<vertex_descriptor>(v)));
    else
      // We have descriptors for both of the vertices, either of which
      // may be remote or local. Tell the owner of the source vertex
      // to add the edge (it may be us!).
      add_edge(boost::get<vertex_descriptor>(u), 
               boost::get<vertex_descriptor>(v), 
               self.derived());
  }
}

template<typename Graph>
typename Graph::named_graph_type::lazy_add_vertex
add_vertex(typename Graph::vertex_name_type const& name,
           Graph& g, 
           typename disable_if<
              not_is_named_graph<typename Graph::vertex_property_type>, 
              void*>::type = 0)
{
  return typename Graph::named_graph_type::lazy_add_vertex(g, name);
}

template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::lazy_add_edge
add_edge(typename BGL_NAMED_GRAPH::vertex_name_type const& u_name,
         typename BGL_NAMED_GRAPH::vertex_name_type const& v_name,
         BGL_NAMED_GRAPH& g)
{
  typedef typename BGL_NAMED_GRAPH::lazy_add_edge lazy_add_edge;
  typedef typename BGL_NAMED_GRAPH::process_id_type process_id_type;

  process_id_type rank = process_id(g.process_group());
  process_id_type u_owner = g.named_distribution()(u_name);
  process_id_type v_owner = g.named_distribution()(v_name);

  // Resolve local vertex names before building the "lazy" edge
  // addition structure.
  if (u_owner == rank && v_owner == rank)
    return lazy_add_edge(g, add_vertex(u_name, g), add_vertex(v_name, g));
  else if (u_owner == rank && v_owner != rank)
    return lazy_add_edge(g, add_vertex(u_name, g), v_name);
  else if (u_owner != rank && v_owner == rank)
    return lazy_add_edge(g, u_name, add_vertex(v_name, g));
  else
    return lazy_add_edge(g, u_name, v_name);
}


template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::lazy_add_edge
add_edge(typename BGL_NAMED_GRAPH::vertex_name_type const& u_name,
         typename BGL_NAMED_GRAPH::vertex_descriptor const& v,
         BGL_NAMED_GRAPH& g)
{
  // Resolve local vertex names before building the "lazy" edge
  // addition structure.
  typedef typename BGL_NAMED_GRAPH::lazy_add_edge lazy_add_edge;
  if (g.named_distribution()(u_name) == process_id(g.process_group()))
    return lazy_add_edge(g, add_vertex(u_name, g), v);
  else
    return lazy_add_edge(g, u_name, v);
}


template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::lazy_add_edge
add_edge(typename BGL_NAMED_GRAPH::vertex_descriptor const& u,
         typename BGL_NAMED_GRAPH::vertex_name_type const& v_name,
         BGL_NAMED_GRAPH& g)
{
  // Resolve local vertex names before building the "lazy" edge
  // addition structure.
  typedef typename BGL_NAMED_GRAPH::lazy_add_edge lazy_add_edge;
  if (g.named_distribution()(v_name) == process_id(g.process_group()))
    return lazy_add_edge(g, u, add_vertex(v_name, g));
  else
    return lazy_add_edge(g, u, v_name);
}

template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::lazy_add_edge_with_property
add_edge(typename BGL_NAMED_GRAPH::vertex_name_type const& u_name,
         typename BGL_NAMED_GRAPH::vertex_name_type const& v_name,
         typename Graph::edge_property_type const& property,
         BGL_NAMED_GRAPH& g)
{
  typedef typename BGL_NAMED_GRAPH::lazy_add_edge_with_property lazy_add_edge;
  typedef typename BGL_NAMED_GRAPH::process_id_type process_id_type;

  process_id_type rank = process_id(g.process_group());
  process_id_type u_owner = g.named_distribution()(u_name);
  process_id_type v_owner = g.named_distribution()(v_name);

  // Resolve local vertex names before building the "lazy" edge
  // addition structure.
  if (u_owner == rank && v_owner == rank)
    return lazy_add_edge(g, add_vertex(u_name, g), add_vertex(v_name, g), 
                         property);
  else if (u_owner == rank && v_owner != rank)
    return lazy_add_edge(g, add_vertex(u_name, g), v_name, property);
  else if (u_owner != rank && v_owner == rank)
    return lazy_add_edge(g, u_name, add_vertex(v_name, g), property);
  else
    return lazy_add_edge(g, u_name, v_name, property);
}


template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::lazy_add_edge_with_property
add_edge(typename BGL_NAMED_GRAPH::vertex_name_type const& u_name,
         typename BGL_NAMED_GRAPH::vertex_descriptor const& v,
         typename Graph::edge_property_type const& property,
         BGL_NAMED_GRAPH& g)
{
  // Resolve local vertex names before building the "lazy" edge
  // addition structure.
  typedef typename BGL_NAMED_GRAPH::lazy_add_edge_with_property lazy_add_edge;
  if (g.named_distribution()(u_name) == process_id(g.process_group()))
    return lazy_add_edge(g, add_vertex(u_name, g), v, property);
  else
    return lazy_add_edge(g, u_name, v, property);
}


template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::lazy_add_edge_with_property
add_edge(typename BGL_NAMED_GRAPH::vertex_descriptor const& u,
         typename BGL_NAMED_GRAPH::vertex_name_type const& v_name,
         typename Graph::edge_property_type const& property,
         BGL_NAMED_GRAPH& g)
{
  // Resolve local vertex names before building the "lazy" edge
  // addition structure.
  typedef typename BGL_NAMED_GRAPH::lazy_add_edge_with_property lazy_add_edge;
  if (g.named_distribution()(v_name) == process_id(g.process_group()))
    return lazy_add_edge(g, u, add_vertex(v_name, g), property);
  else
    return lazy_add_edge(g, u, v_name, property);
}


template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::process_id_type 
BGL_NAMED_GRAPH::owner_by_property(const vertex_property_type& property)
{
  return distribution_(derived().base().extract_name(property));
}


template<BGL_NAMED_GRAPH_PARAMS>
void 
BGL_NAMED_GRAPH::
handle_add_vertex_name(int /*source*/, int /*tag*/, 
                       const vertex_name_type& msg, trigger_receive_context)
{
  add_vertex(msg, derived());
}


template<BGL_NAMED_GRAPH_PARAMS>
typename BGL_NAMED_GRAPH::vertex_descriptor
BGL_NAMED_GRAPH::
handle_add_vertex_name_with_reply(int source, int /*tag*/, 
                                  const vertex_name_type& msg, 
                                  trigger_receive_context)
{
  return add_vertex(msg, derived());
}


template<BGL_NAMED_GRAPH_PARAMS>
boost::parallel::detail::untracked_pair<typename BGL_NAMED_GRAPH::vertex_descriptor, bool>
BGL_NAMED_GRAPH::
handle_find_vertex(int source, int /*tag*/, const vertex_name_type& msg, 
                   trigger_receive_context)
{
  using boost::parallel::detail::make_untracked_pair;

  optional<vertex_descriptor> v = find_vertex(msg, derived());
  if (v)
    return make_untracked_pair(*v, true);
  else
    return make_untracked_pair(graph_traits<Graph>::null_vertex(), false);
}

template<typename U, typename V>
void
BGL_NAMED_GRAPH::
handle_add_edge(int source, int /*tag*/, const boost::parallel::detail::untracked_pair<U, V>& msg, 
                trigger_receive_context)
{
  add_edge(msg.first, msg.second, derived());
}

template<typename U, typename V>
boost::parallel::detail::untracked_pair<typename BGL_NAMED_GRAPH::edge_descriptor, bool>
BGL_NAMED_GRAPH::
handle_add_edge_with_reply(int source, int /*tag*/, const boost::parallel::detail::untracked_pair<U, V>& msg,
                           trigger_receive_context)
{
  std::pair<typename BGL_NAMED_GRAPH::edge_descriptor, bool> p =
    add_edge(msg.first, msg.second, derived());
   return p;
}

template<typename U, typename V>
void 
BGL_NAMED_GRAPH::
handle_add_edge_with_property
  (int source, int tag, 
   const pair_with_property<U, V, edge_property_type>& msg,
   trigger_receive_context)
{
  add_edge(msg.first, msg.second, msg.get_property(), derived());
}

template<typename U, typename V>
boost::parallel::detail::untracked_pair<typename BGL_NAMED_GRAPH::edge_descriptor, bool>
BGL_NAMED_GRAPH::
handle_add_edge_with_reply_and_property
  (int source, int tag, 
   const pair_with_property<U, V, edge_property_type>& msg,
   trigger_receive_context)
{
  std:: pair<typename BGL_NAMED_GRAPH::edge_descriptor, bool> p =
    add_edge(msg.first, msg.second, msg.get_property(), derived());
  return p;
}

  
  explicit maybe_named_graph(const process_group_type& pg) : inherited(pg) { }


  maybe_named_graph(const process_group_type& pg, 
                    const base_distribution_type& distribution)
    : inherited(pg, distribution) { }
  

  distribution_type&       distribution()       { return this->distribution_; }

  const distribution_type& distribution() const { return this->distribution_; }


  explicit maybe_named_graph(const process_group_type&)  { }


  maybe_named_graph(const process_group_type& pg, 
                    const base_distribution_type& distribution) 
    : distribution_(pg, distribution) { }

  void added_vertex(Vertex) { }

  template <typename VertexIterStability>
  void removing_vertex(Vertex, VertexIterStability) { }

  void clearing_graph() { }

  process_id_type owner_by_property(const vertex_property_type&)
  {
    return process_id(pg);
  }


  distribution_type&       distribution()       { return distribution_; }

  const distribution_type& distribution() const { return distribution_; }

  in_subset() : m_s(0) { }

  in_subset(const Set& s) : m_s(&s) { }


  template <typename Elt>
  bool operator()(const Elt& x) const {
    return ((*m_s).find(x) != (*m_s).end());
  }


  inline value_type operator[](const key_type& v) const { return v; }

  inline void clear() { }


template <typename T>
inline void synchronize( vertex_identity_property_map<T> & ) { }

  scc_discovery_visitor(SourceMap& sourceM)
    : sourceM(sourceM) {}


  template<typename Edge>
  void tree_edge(Edge e, const Graph& g)
  {
    put(sourceM, target(e,g), get(sourceM, source(e,g)));
  }


    template<typename Graph, typename ReverseGraph,
             typename VertexComponentMap, typename IsoMapFR, typename IsoMapRF,
             typename VertexIndexMap>
    void
    fleischer_hendrickson_pinar_strong_components(const Graph& g,
                                                  VertexComponentMap c,
                                                  const ReverseGraph& gr,
                                                  IsoMapFR fr, IsoMapRF rf,
                                                  VertexIndexMap vertex_index_map)
    {
      typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
      typedef typename graph_traits<ReverseGraph>::vertex_iterator rev_vertex_iterator;
      typedef typename graph_traits<ReverseGraph>::vertex_descriptor rev_vertex_descriptor;
      typedef typename boost::graph::parallel::process_group_type<Graph>::type
        process_group_type;
      typedef typename process_group_type::process_id_type process_id_type;
      typedef iterator_property_map<typename std::vector<vertex_descriptor>::iterator,
                                    VertexIndexMap> ParentMap;
      typedef iterator_property_map<typename std::vector<default_color_type>::iterator,
                                    VertexIndexMap> ColorMap;
      typedef iterator_property_map<typename std::vector<vertex_descriptor>::iterator,
                                    VertexIndexMap> Rev_ParentMap;
      typedef std::vector<std::pair<vertex_descriptor, vertex_descriptor> > VertexPairVec;

      typedef typename property_map<Graph, vertex_owner_t>::const_type
        OwnerMap;

      OwnerMap owner = get(vertex_owner, g);

      using boost::graph::parallel::process_group;
      process_group_type pg = process_group(g);
      process_id_type id = process_id(pg);
      int num_procs = num_processes(pg);
      int n = 0;

      int my_n = num_vertices(g);
      all_reduce(pg, &my_n, &my_n+1, &n, std::plus<int>());

      //
      // Initialization
      //

#ifdef PBGL_SCC_DEBUG
  accounting::time_type start = accounting::get_time();
#endif

      vertex_iterator vstart, vend;
      rev_vertex_iterator rev_vstart, rev_vend;
      std::vector<std::vector<vertex_descriptor> > vertex_sets, new_vertex_sets;

      vertex_sets.push_back(std::vector<vertex_descriptor>());

      // Remove vertices that do not have at least one in edge and one out edge
      new_vertex_sets.push_back(std::vector<vertex_descriptor>());
      for( boost::tie(vstart, vend) = vertices(g); vstart != vend; vstart++ )
        if( out_degree( get(fr, *vstart), gr) > 0 && out_degree(*vstart, g) > 0 )
          new_vertex_sets[0].push_back( *vstart );

      // Perform sequential SCC on local subgraph, filter all components with external
      // edges, mark remaining components and remove them from vertex_sets
#ifdef FILTER_LOCAL_COMPONENTS  
      // This doesn't actually speed up SCC in connected graphs it seems, but it does work
      // and may help in the case where there are lots of small strong components.
      {
        local_subgraph<const Graph> ls(g);
        typedef typename property_map<local_subgraph<const Graph>, vertex_index_t>::type
          local_index_map_type;
        local_index_map_type local_index = get(vertex_index, ls);

        std::vector<int> ls_components_vec(num_vertices(ls));
        typedef iterator_property_map<std::vector<int>::iterator, local_index_map_type>
          ls_components_map_type;
        ls_components_map_type ls_component(ls_components_vec.begin(), local_index);
        int num_comp = boost::strong_components(ls, ls_component);

        // Create map of components
        std::map<int, std::vector<vertex_descriptor> > local_comp_map;
        typedef typename graph_traits<local_subgraph<const Graph> >::vertex_iterator ls_vertex_iterator;
        ls_vertex_iterator vstart, vend;
        for( boost::tie(vstart,vend) = vertices(ls); vstart != vend; vstart++ )
          local_comp_map[get(ls_component, *vstart)].push_back( *vstart );

        // Filter components that have no non-local edges
        typedef typename graph_traits<Graph>::adjacency_iterator adjacency_iterator;
        typedef typename graph_traits<ReverseGraph>::adjacency_iterator rev_adjacency_iterator;
        adjacency_iterator abegin, aend;
        rev_adjacency_iterator rev_abegin, rev_aend;
        for( std::size_t i = 0; i < num_comp; ++i ) {
          bool local = true;
          for( std::size_t j = 0; j < local_comp_map[i].size(); j++ ) {
            for( boost::tie(abegin,aend) = adjacent_vertices(local_comp_map[i][j], g);
                 abegin != aend; abegin++ )
              if( get(owner, *abegin) != id ) {
                local = false;
                break;
              }

            if( local )
              for( boost::tie(rev_abegin,rev_aend) = adjacent_vertices(get(fr, local_comp_map[i][j]), gr);
                   rev_abegin != rev_aend; rev_abegin++ )
                if( get(owner, *rev_abegin) != id ) {
                  local = false;
                  break;
                }

            if( !local ) break;
          }

          if( local ) // Mark and remove from new_vertex_sets
            for( std::size_t j = 0; j < local_comp_map[i].size(); j++ ) {
              put( c, local_comp_map[i][j], local_comp_map[i][0] );
              typename std::vector<vertex_descriptor>::iterator pos =
                std::find(new_vertex_sets[0].begin(), new_vertex_sets[0].end(), local_comp_map[i][j]);
              if( pos != new_vertex_sets[0].end() )
                new_vertex_sets[0].erase(pos);
            }
        }
      }
#endif // FILTER_LOCAL_COMPONENTS

      all_gather( pg, new_vertex_sets[0].begin(), new_vertex_sets[0].end(), vertex_sets[0] );
      new_vertex_sets.clear();

#ifdef PBGL_SCC_DEBUG
  accounting::time_type end = accounting::get_time();
  if(id == 0)
    std::cerr << "Trim local SCCs time = " << accounting::print_time(end - start) << " seconds.\n";
#endif

      if( vertex_sets[0].empty() ) return;

      //
      // Recursively determine SCCs
      //

#ifdef PBGL_SCC_DEBUG
  int iterations = 0;
#endif

      // Only need to be able to map starting vertices for BFS from now on
      fr.clear();

      do {

#ifdef PBGL_SCC_DEBUG
  if(id == 0) {
    printf("\n\nIteration %d:\n\n", iterations++);

    if( iterations > 1 ) {
      end = accounting::get_time();
      std::cerr << "Running main loop destructors time = " << accounting::print_time(end - start) << " seconds.\n";
    }

    start = accounting::get_time();
  }
#endif

        // Get forward->reverse mappings for BFS start vertices
       for (std::size_t i = 0; i < vertex_sets.size(); ++i)
          get(fr, vertex_sets[i][0]);
        synchronize(fr);

        // Determine local vertices to start BFS from
        std::vector<vertex_descriptor> local_start;
        for( std::size_t i = id; i < vertex_sets.size(); i += num_procs )
          local_start.push_back(vertex_sets[i][0]);

        if( local_start.empty() )
          local_start.push_back(vertex_sets[0][0]);


        // Make filtered graphs
        typedef std::set<vertex_descriptor> VertexSet;
        typedef std::set<rev_vertex_descriptor> Rev_VertexSet;

        VertexSet filter_set_g;
        Rev_VertexSet filter_set_gr;
        typename VertexSet::iterator fs;

        int active_vertices = 0;
        for (std::size_t i = 0; i < vertex_sets.size(); i++)
          active_vertices += vertex_sets[i].size();

        // This is a completely random bound
        if ( active_vertices < 0.05*n ) {
          // TODO: This set insertion is ridiculously inefficient, make it an in-place-merge?
          for (std::size_t i = 0; i < vertex_sets.size(); i++)
            filter_set_g.insert(vertex_sets[i].begin(), vertex_sets[i].end());

          for (fs = filter_set_g.begin(); fs != filter_set_g.end(); ++fs )
            filter_set_gr.insert(get(fr, *fs));
        }

        filtered_graph<const Graph, keep_all, detail::in_subset<VertexSet> >
          fg(g, keep_all(), detail::in_subset<VertexSet>(filter_set_g));

        filtered_graph<const ReverseGraph, keep_all, detail::in_subset<VertexSet> >
          fgr(gr, keep_all(), detail::in_subset<VertexSet>(filter_set_gr));

        // Add additional starting vertices to BFS queue
        typedef filtered_queue<queue<vertex_descriptor>, boost::detail::has_not_been_seen<VertexIndexMap> >
          local_queue_type;
        typedef boost::graph::distributed::distributed_queue<process_group_type, OwnerMap, local_queue_type>
          queue_t;

        typedef typename property_map<ReverseGraph, vertex_owner_t>::const_type
          RevOwnerMap;

        typedef filtered_queue<queue<rev_vertex_descriptor>, boost::detail::has_not_been_seen<VertexIndexMap> >
          rev_local_queue_type;
        typedef boost::graph::distributed::distributed_queue<process_group_type, RevOwnerMap, rev_local_queue_type>
          rev_queue_t;

        queue_t Q(process_group(g),
                  owner,
                  make_filtered_queue(queue<vertex_descriptor>(),
                                      boost::detail::has_not_been_seen<VertexIndexMap>
                                      (num_vertices(g), vertex_index_map)),
                  false);

        rev_queue_t Qr(process_group(gr),
                       get(vertex_owner, gr),
                       make_filtered_queue(queue<rev_vertex_descriptor>(),
                                           boost::detail::has_not_been_seen<VertexIndexMap>
                                           (num_vertices(gr), vertex_index_map)),
                       false);

        for( std::size_t i = 1; i < local_start.size(); ++i ) {
          Q.push(local_start[i]);
          Qr.push(get(fr, local_start[i]));
        }

#ifdef PBGL_SCC_DEBUG
  end = accounting::get_time();
  if(id == 0)
    std::cerr << "  Initialize BFS time = " << accounting::print_time(end - start) << " seconds.\n";
  start = accounting::get_time();
#endif

#ifdef PBGL_SCC_DEBUG
  accounting::time_type start2 = accounting::get_time();
#endif

        // Forward BFS
        std::vector<default_color_type> color_map_s(num_vertices(g));
        ColorMap color_map(color_map_s.begin(), vertex_index_map);
        std::vector<vertex_descriptor> succ_map_s(num_vertices(g), graph_traits<Graph>::null_vertex());
        ParentMap succ_map(succ_map_s.begin(), vertex_index_map);

        for( std::size_t i = 0; i < vertex_sets.size(); ++i )
          put(succ_map, vertex_sets[i][0], vertex_sets[i][0]);

#ifdef PBGL_SCC_DEBUG
  accounting::time_type end2 = accounting::get_time();
  if(id == 0)
    std::cerr << "  Initialize forward BFS time = " << accounting::print_time(end2 - start2) << " seconds.\n";
#endif

        if (active_vertices < 0.05*n)
          breadth_first_search(fg, local_start[0], Q,
                               detail::scc_discovery_visitor<filtered_graph<const Graph, keep_all,
                                                                            detail::in_subset<VertexSet> >, ParentMap>
                               (succ_map),
                               color_map);
        else
          breadth_first_search(g, local_start[0], Q,
                               detail::scc_discovery_visitor<const Graph, ParentMap>(succ_map),
                               color_map);

#ifdef PBGL_SCC_DEBUG
  start2 = accounting::get_time();
#endif

        // Reverse BFS
        color_map.clear(); // reuse color map since g and gr have same vertex index
        std::vector<vertex_descriptor> pred_map_s(num_vertices(gr), graph_traits<Graph>::null_vertex());
        Rev_ParentMap pred_map(pred_map_s.begin(), vertex_index_map);

        for( std::size_t i = 0; i < vertex_sets.size(); ++i )
          put(pred_map, get(fr, vertex_sets[i][0]), vertex_sets[i][0]);

#ifdef PBGL_SCC_DEBUG
  end2 = accounting::get_time();
  if(id == 0)
    std::cerr << "  Initialize reverse BFS time = " << accounting::print_time(end2 - start2) << " seconds.\n";
#endif

        if (active_vertices < 0.05*n)
          breadth_first_search(fgr, get(fr, local_start[0]),
                               Qr,
                               detail::scc_discovery_visitor<filtered_graph<const ReverseGraph, keep_all,
                                                                            detail::in_subset<Rev_VertexSet> >, Rev_ParentMap>
                               (pred_map),
                               color_map);
        else
          breadth_first_search(gr, get(fr, local_start[0]),
                               Qr,
                               detail::scc_discovery_visitor<const ReverseGraph, Rev_ParentMap>(pred_map),
                               color_map);

#ifdef PBGL_SCC_DEBUG
  end = accounting::get_time();
  if(id == 0)
    std::cerr << "  Perform forward and reverse BFS time = " << accounting::print_time(end - start) << " seconds.\n";
  start = accounting::get_time();
#endif

        // Send predecessors and successors discovered by this proc to the proc responsible for
        // this BFS tree
        typedef struct detail::v_sets<vertex_descriptor> Vsets;
        std::map<vertex_descriptor, Vsets> set_map;

        std::map<vertex_descriptor, int> dest_map;

        std::vector<VertexPairVec> successors(num_procs);
        std::vector<VertexPairVec> predecessors(num_procs);

        // Calculate destinations for messages
        for (std::size_t i = 0; i < vertex_sets.size(); ++i)
          dest_map[vertex_sets[i][0]] = i % num_procs;

        for( boost::tie(vstart, vend) = vertices(g); vstart != vend; vstart++ ) {
          vertex_descriptor v = get(succ_map, *vstart);
          if( v != graph_traits<Graph>::null_vertex() ) {
            if (dest_map[v] == id)
              set_map[v].succ.push_back(*vstart);
            else
              successors[dest_map[v]].push_back( std::make_pair(v, *vstart) );
          }
        }

        for( boost::tie(rev_vstart, rev_vend) = vertices(gr); rev_vstart != rev_vend; rev_vstart++ ) {
          vertex_descriptor v = get(pred_map, *rev_vstart);
          if( v != graph_traits<Graph>::null_vertex() ) {
            if (dest_map[v] == id)
              set_map[v].pred.push_back(get(rf, *rev_vstart));
            else
              predecessors[dest_map[v]].push_back( std::make_pair(v, get(rf, *rev_vstart)) );
          }
        }

        // Send predecessor and successor messages
        for (process_id_type i = 0; i < num_procs; ++i) {
          if (!successors[i].empty()) {
            send(pg, i, fhp_succ_size_msg, successors[i].size());
            send(pg, i, fhp_succ_msg, &successors[i][0], successors[i].size());
          }
          if (!predecessors[i].empty()) {
            send(pg, i, fhp_pred_size_msg, predecessors[i].size());
            send(pg, i, fhp_pred_msg, &predecessors[i][0], predecessors[i].size());
          }
        }
        synchronize(pg);

        // Receive predecessor and successor messages and handle them
        while (optional<std::pair<process_id_type, int> > m = probe(pg)) {
          BOOST_ASSERT(m->second == fhp_succ_size_msg || m->second == fhp_pred_size_msg);
          std::size_t num_requests;
          receive(pg, m->first, m->second, num_requests);
          VertexPairVec requests(num_requests);
          if (m->second == fhp_succ_size_msg) {
            receive(pg, m->first, fhp_succ_msg, &requests[0],
                    num_requests);

            std::map<vertex_descriptor, int> added;
            for (std::size_t i = 0; i < requests.size(); ++i) {
              set_map[requests[i].first].succ.push_back(requests[i].second);
              added[requests[i].first]++;
            }

            // If order of vertex traversal in vertices() is std::less<vertex_descriptor>,
            // then the successor sets will be in order
            for (std::size_t i = 0; i < local_start.size(); ++i)
              if (added[local_start[i]] > 0)
                  std::inplace_merge(set_map[local_start[i]].succ.begin(),
                                     set_map[local_start[i]].succ.end() - added[local_start[i]],
                                     set_map[local_start[i]].succ.end(),
                                     std::less<vertex_descriptor>());

          } else {
            receive(pg, m->first, fhp_pred_msg, &requests[0],
                    num_requests);

            std::map<vertex_descriptor, int> added;
            for (std::size_t i = 0; i < requests.size(); ++i) {
              set_map[requests[i].first].pred.push_back(requests[i].second);
              added[requests[i].first]++;
            }

            if (boost::is_same<detail::vertex_identity_property_map<vertex_descriptor>, IsoMapRF>::value)
              for (std::size_t i = 0; i < local_start.size(); ++i)
                if (added[local_start[i]] > 0)
                  std::inplace_merge(set_map[local_start[i]].pred.begin(),
                                     set_map[local_start[i]].pred.end() - added[local_start[i]],
                                     set_map[local_start[i]].pred.end(),
                                     std::less<vertex_descriptor>());
          }
        }

#ifdef PBGL_SCC_DEBUG
  end = accounting::get_time();
  if(id == 0)
    std::cerr << "  All gather successors and predecessors time = " << accounting::print_time(end - start) << " seconds.\n";
  start = accounting::get_time();
#endif

        //
        // Filter predecessor and successor sets and perform set arithmetic
        //
        new_vertex_sets.clear();

        if( std::size_t(id) < vertex_sets.size() ) { //If this proc has one or more unique starting points

          for( std::size_t i = 0; i < local_start.size(); ++i ) {

            vertex_descriptor v = local_start[i];

            // Replace this sort with an in-place merges during receive step if possible
            if (!boost::is_same<detail::vertex_identity_property_map<vertex_descriptor>, IsoMapRF>::value) 
              std::sort(set_map[v].pred.begin(), set_map[v].pred.end(), std::less<vertex_descriptor>());

            // Limit predecessor and successor sets to members of the original set
            std::vector<vertex_descriptor> temp;

            std::set_intersection( vertex_sets[id + i*num_procs].begin(), vertex_sets[id + i*num_procs].end(),
                                   set_map[v].pred.begin(), set_map[v].pred.end(),
                                   back_inserter(temp),
                                   std::less<vertex_descriptor>());
            set_map[v].pred.clear();
            std::swap(set_map[v].pred, temp);

            std::set_intersection( vertex_sets[id + i*num_procs].begin(), vertex_sets[id + i*num_procs].end(),
                                   set_map[v].succ.begin(), set_map[v].succ.end(),
                                   back_inserter(temp),
                                   std::less<vertex_descriptor>());
            set_map[v].succ.clear();
            std::swap(set_map[v].succ, temp);

            // Intersection(pred, succ)
            std::set_intersection(set_map[v].pred.begin(), set_map[v].pred.end(),
                                    set_map[v].succ.begin(), set_map[v].succ.end(),
                                    back_inserter(set_map[v].intersect),
                                    std::less<vertex_descriptor>());

            // Union(pred, succ)
            std::set_union(set_map[v].pred.begin(), set_map[v].pred.end(),
                           set_map[v].succ.begin(), set_map[v].succ.end(),
                           back_inserter(set_map[v].ps_union),
                           std::less<vertex_descriptor>());

            new_vertex_sets.push_back(std::vector<vertex_descriptor>());
            // Original set - Union(pred, succ)
            std::set_difference(vertex_sets[id + i*num_procs].begin(), vertex_sets[id + i*num_procs].end(),
                                set_map[v].ps_union.begin(), set_map[v].ps_union.end(),
                                back_inserter(new_vertex_sets[new_vertex_sets.size() - 1]),
                                std::less<vertex_descriptor>());

            set_map[v].ps_union.clear();

            new_vertex_sets.push_back(std::vector<vertex_descriptor>());
            // Pred - Intersect(pred, succ)
            std::set_difference(set_map[v].pred.begin(), set_map[v].pred.end(),
                                set_map[v].intersect.begin(), set_map[v].intersect.end(),
                                back_inserter(new_vertex_sets[new_vertex_sets.size() - 1]),
                                std::less<vertex_descriptor>());

            set_map[v].pred.clear();

            new_vertex_sets.push_back(std::vector<vertex_descriptor>());
            // Succ - Intersect(pred, succ)
            std::set_difference(set_map[v].succ.begin(), set_map[v].succ.end(),
                                set_map[v].intersect.begin(), set_map[v].intersect.end(),
                                back_inserter(new_vertex_sets[new_vertex_sets.size() - 1]),
                                std::less<vertex_descriptor>());

            set_map[v].succ.clear();

            // Label SCC just identified with the 'first' vertex in that SCC
            for( std::size_t j = 0; j < set_map[v].intersect.size(); j++ )
              put(c, set_map[v].intersect[j], set_map[v].intersect[0]);

            set_map[v].intersect.clear();
          }
        }

#ifdef PBGL_SCC_DEBUG
  end = accounting::get_time();
  if(id == 0)
    std::cerr << "  Perform set arithemetic time = " << accounting::print_time(end - start) << " seconds.\n";
  start = accounting::get_time();
#endif

        // Remove sets of size 1 from new_vertex_sets
        typename std::vector<std::vector<vertex_descriptor> >::iterator vviter;
        for( vviter = new_vertex_sets.begin(); vviter != new_vertex_sets.end(); /*in loop*/ )
          if( (*vviter).size() < 2 )
            vviter = new_vertex_sets.erase( vviter );
          else
            vviter++;

        // All gather new sets and recur (gotta marshal and unmarshal sets first)
        vertex_sets.clear();
        std::vector<vertex_descriptor> serial_sets, all_serial_sets;
        detail::marshal_set<Graph>( new_vertex_sets, serial_sets );
        all_gather( pg, serial_sets.begin(), serial_sets.end(), all_serial_sets );
        detail::unmarshal_set<Graph>( all_serial_sets, vertex_sets );

#ifdef PBGL_SCC_DEBUG
  end = accounting::get_time();
  if(id == 0) {
    std::cerr << "  Serialize and gather new vertex sets time = " << accounting::print_time(end - start) << " seconds.\n\n\n";

    printf("Vertex sets: %d\n", (int)vertex_sets.size() );
    for( std::size_t i = 0; i < vertex_sets.size(); ++i )
      printf("  %d: %d\n", i, (int)vertex_sets[i].size() );
  }
  start = accounting::get_time();
#endif

        // HACK!?!  --  This would be more properly implemented as a topological sort
        // Remove vertices without an edge to another vertex in the set and an edge from another
        // vertex in the set
       typedef typename graph_traits<Graph>::out_edge_iterator out_edge_iterator;
       out_edge_iterator estart, eend;
       typedef typename graph_traits<ReverseGraph>::out_edge_iterator r_out_edge_iterator;
       r_out_edge_iterator restart, reend;
       for (std::size_t i = 0; i < vertex_sets.size(); ++i) {
         std::vector<vertex_descriptor> new_set;
         for (std::size_t j = 0; j < vertex_sets[i].size(); ++j) {
           vertex_descriptor v = vertex_sets[i][j];
           if (get(owner, v) == id) {
             boost::tie(estart, eend) = out_edges(v, g);
             while (estart != eend && find(vertex_sets[i].begin(), vertex_sets[i].end(),
                                           target(*estart,g)) == vertex_sets[i].end()) estart++;
             if (estart != eend) {
               boost::tie(restart, reend) = out_edges(get(fr, v), gr);
               while (restart != reend && find(vertex_sets[i].begin(), vertex_sets[i].end(),
                                               get(rf, target(*restart,gr))) == vertex_sets[i].end()) restart++;
               if (restart != reend)
                 new_set.push_back(v);
             }
           }
         }
         vertex_sets[i].clear();
         all_gather(pg, new_set.begin(), new_set.end(), vertex_sets[i]);
         std::sort(vertex_sets[i].begin(), vertex_sets[i].end(), std::less<vertex_descriptor>());
       }
#ifdef PBGL_SCC_DEBUG
  end = accounting::get_time();
  if(id == 0)
    std::cerr << "  Trim vertex sets time = " << accounting::print_time(end - start) << " seconds.\n\n\n";
  start = accounting::get_time();
#endif

      } while ( !vertex_sets.empty() );


      // Label vertices not in a SCC as their own SCC
      for( boost::tie(vstart, vend) = vertices(g); vstart != vend; vstart++ )
        if( get(c, *vstart) == graph_traits<Graph>::null_vertex() )
          put(c, *vstart, *vstart);

      synchronize(c);
    }


    template<typename Graph, typename ReverseGraph, typename IsoMap>
    void
    build_reverse_graph( const Graph& g, ReverseGraph& gr, IsoMap& fr, IsoMap& rf )
    {
      typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
      typedef typename graph_traits<Graph>::out_edge_iterator out_edge_iterator;
      typedef typename boost::graph::parallel::process_group_type<Graph>::type process_group_type;
      typedef typename process_group_type::process_id_type process_id_type;
      typedef std::vector<std::pair<vertex_descriptor, vertex_descriptor> > VertexPairVec;

      typedef typename graph_traits<Graph>::directed_category directed_category;

      typename property_map<Graph, vertex_owner_t>::const_type
        owner = get(vertex_owner, g);

      process_group_type pg = process_group(g);
      process_id_type id = process_id(pg);

      int n;
      vertex_iterator vstart, vend;
      int num_procs = num_processes(pg);

      vertex_descriptor v;
      out_edge_iterator oestart, oeend;
      for( boost::tie(vstart, vend) = vertices(g); vstart != vend; vstart++ )
        {
          v = add_vertex(gr);
          put(fr, *vstart, v);
          put(rf, v, *vstart);
        }

      gr.distribution() = g.distribution();

      int my_n = num_vertices(g);
      all_reduce(pg, &my_n, &my_n+1, &n, std::plus<int>());

      for (int i = 0; i < n; ++i)
        get(fr, vertex(i,g));
      synchronize(fr);

      // Add edges to gr
      std::vector<std::pair<vertex_descriptor, vertex_descriptor> > new_edges;
      for( boost::tie(vstart, vend) = vertices(g); vstart != vend; vstart++ )
        for( boost::tie(oestart, oeend) = out_edges(*vstart, g); oestart != oeend; oestart++ )
          new_edges.push_back( std::make_pair(get(fr, target(*oestart,g)), get(fr, source(*oestart, g))) );

      std::vector<VertexPairVec> edge_requests(num_procs);

      typename std::vector<std::pair<vertex_descriptor, vertex_descriptor> >::iterator iter;
      for( iter = new_edges.begin(); iter != new_edges.end(); iter++ ) {
        std::pair<vertex_descriptor, vertex_descriptor> p1 = *iter;
        if( get(owner,  p1.first ) == id )
          add_edge( p1.first, p1.second, gr );
        else
          edge_requests[get(owner, p1.first)].push_back(p1);
      }
      new_edges.clear();

      // Send edge addition requests
      for (process_id_type p = 0; p < num_procs; ++p) {
        if (!edge_requests[p].empty()) {
          VertexPairVec reqs(edge_requests[p].begin(), edge_requests[p].end());
          send(pg, p, fhp_edges_size_msg, reqs.size());
          send(pg, p, fhp_add_edges_msg, &reqs[0], reqs.size());
        }
      }
      synchronize(pg);

      // Receive edge addition requests and handle them
      while (optional<std::pair<process_id_type, int> > m = probe(pg)) {
        BOOST_ASSERT(m->second == fhp_edges_size_msg);
        std::size_t num_requests;
        receive(pg, m->first, m->second, num_requests);
        VertexPairVec requests(num_requests);
        receive(pg, m->first, fhp_add_edges_msg, &requests[0],
                num_requests);
        for( std::size_t i = 0; i < requests.size(); ++i )
          add_edge( requests[i].first, requests[i].second, gr );
      }
          synchronize(gr);
    }


    template<typename Graph, typename VertexComponentMap, typename ComponentMap>
    typename property_traits<ComponentMap>::value_type
    number_components(const Graph& g, VertexComponentMap r, ComponentMap c)
    {
      typedef typename boost::graph::parallel::process_group_type<Graph>::type process_group_type;
      typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
      typedef typename property_traits<ComponentMap>::value_type ComponentMapType;
      std::vector<vertex_descriptor> my_roots, all_roots;
      vertex_iterator vstart, vend;

      for( boost::tie(vstart, vend) = vertices(g); vstart != vend; vstart++ )
        if( find( my_roots.begin(), my_roots.end(), get(r, *vstart) ) == my_roots.end() )
          my_roots.push_back( get(r, *vstart) );

      all_gather( process_group(g), my_roots.begin(), my_roots.end(), all_roots );

      /* Number components */
      std::map<vertex_descriptor, ComponentMapType> comp_numbers;
      ComponentMapType c_num = 0;

      // Compute component numbers
      for (std::size_t i = 0; i < all_roots.size(); ++i )
        if ( comp_numbers.count(all_roots[i]) == 0 )
          comp_numbers[all_roots[i]] = c_num++;

      // Broadcast component numbers
      for( boost::tie(vstart, vend) = vertices(g); vstart != vend; vstart++ )
        put( c, *vstart, comp_numbers[get(r,*vstart)] );

      // Broadcast number of components
      if (process_id(process_group(g)) == 0) {
        typedef typename process_group_type::process_size_type
          process_size_type;
        for (process_size_type dest = 1, n = num_processes(process_group(g));
              dest != n; ++dest)
          send(process_group(g), dest, 0, c_num);
      }

      synchronize(process_group(g));

      if (process_id(process_group(g)) != 0) receive(process_group(g), 0, 0, c_num);

      synchronize(c);
      return c_num;
    }



    template<typename Graph, typename ComponentMap, typename VertexComponentMap,
             typename VertexIndexMap>
    typename property_traits<ComponentMap>::value_type
    fleischer_hendrickson_pinar_strong_components_impl
      (const Graph& g,
       ComponentMap c,
       VertexComponentMap r,
       VertexIndexMap vertex_index_map,
       incidence_graph_tag)
    {
      typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
      typedef iterator_property_map<typename std::vector<vertex_descriptor>::iterator,
                                    VertexIndexMap> IsoMap;
      typename boost::graph::parallel::process_group_type<Graph>::type pg = process_group(g);

#ifdef PBGL_SCC_DEBUG
  accounting::time_type start = accounting::get_time();
#endif

      typedef adjacency_list<listS,
                             distributedS<typename boost::graph::parallel::process_group_type<Graph>::type, vecS>,
                             directedS > ReverseGraph;

      ReverseGraph gr(0, pg);
      std::vector<vertex_descriptor> fr_s(num_vertices(g));
      std::vector<vertex_descriptor> rf_s(num_vertices(g));
      IsoMap fr(fr_s.begin(), vertex_index_map);  // fr = forward->reverse
      IsoMap rf(rf_s.begin(), vertex_index_map); // rf = reverse->forward

      build_reverse_graph(g, gr, fr, rf);

#ifdef PBGL_SCC_DEBUG
  accounting::time_type end = accounting::get_time();
  if(process_id(process_group(g)) == 0)
    std::cerr << "Reverse graph initialization time = " << accounting::print_time(end - start) << " seconds.\n";
#endif

  fleischer_hendrickson_pinar_strong_components(g, r, gr, fr, rf, 
                                                vertex_index_map);

      typename property_traits<ComponentMap>::value_type c_num = number_components(g, r, c);

      return c_num;
    }


    template<typename Graph, typename ComponentMap, typename VertexComponentMap,
             typename VertexIndexMap>
    typename property_traits<ComponentMap>::value_type
    fleischer_hendrickson_pinar_strong_components_impl
      (const Graph& g,
       ComponentMap c,
       VertexComponentMap r,
       VertexIndexMap vertex_index_map,
       bidirectional_graph_tag)
    {
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;

      reverse_graph<Graph> gr(g);
      detail::vertex_identity_property_map<vertex_descriptor> fr, rf;

      fleischer_hendrickson_pinar_strong_components(g, r, gr, fr, rf, 
                                                    vertex_index_map);

      typename property_traits<ComponentMap>::value_type c_num
        = number_components(g, r, c);

      return c_num;
    }


    template<typename Graph, typename ComponentMap, typename VertexIndexMap>
    inline typename property_traits<ComponentMap>::value_type
    fleischer_hendrickson_pinar_strong_components
      (const Graph& g,
       ComponentMap c,
       VertexIndexMap vertex_index_map)
    {
      typedef typename graph_traits<Graph>::vertex_descriptor
        vertex_descriptor;
      typedef iterator_property_map<typename std::vector<vertex_descriptor>::iterator,
                                    VertexIndexMap> VertexComponentMap;
      typename boost::graph::parallel::process_group_type<Graph>::type pg 
        = process_group(g);

      if (num_processes(pg) == 1) {
        local_subgraph<const Graph> ls(g);
        return boost::strong_components(ls, c);
      }

      // Create a VertexComponentMap for intermediate labeling of SCCs
      std::vector<vertex_descriptor> r_s(num_vertices(g), graph_traits<Graph>::null_vertex());
      VertexComponentMap r(r_s.begin(), vertex_index_map);

      return fleischer_hendrickson_pinar_strong_components_impl
               (g, c, r, vertex_index_map,
                typename graph_traits<Graph>::traversal_category());
    }


    template<typename Graph, typename ComponentMap>
    inline typename property_traits<ComponentMap>::value_type
    fleischer_hendrickson_pinar_strong_components(const Graph& g,
                                                  ComponentMap c)
    {
      return fleischer_hendrickson_pinar_strong_components(g, c, get(vertex_index, g));
    }


template<class Graph, class ComponentMap, class P, class T, class R>
inline typename property_traits<ComponentMap>::value_type
strong_components
 (const Graph& g, ComponentMap comp,
  const bgl_named_params<P, T, R>&
  BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, distributed_graph_tag))
{
  return graph::fleischer_hendrickson_pinar_strong_components(g, comp);
}


template<class Graph, class ComponentMap>
inline typename property_traits<ComponentMap>::value_type
strong_components
 (const Graph& g, ComponentMap comp
  BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph, distributed_graph_tag))
{
  return graph::fleischer_hendrickson_pinar_strong_components(g, comp);
}

  template <typename Graph, typename EdgePredicate, typename VertexPredicate>
  typename graph_traits<Graph>::vertex_descriptor
  vertex(typename graph_traits<Graph>::vertices_size_type i, 
         filtered_graph<Graph, EdgePredicate, VertexPredicate> const& g)
  { return vertex(i, g.m_g); }

  one_bit_color_map(std::size_t inital_size, 
                    const index_map_type& index = index_map_type())
    : inherited(index.process_group(),  index.global(),
                local_map(inital_size, index.base())) { }


  inherited&       base()       { return *this; }

  const inherited& base() const { return *this; }


template<typename ProcessGroup, typename GlobalMap, typename StorageMap>
inline one_bit_color_type
get(one_bit_color_map<local_property_map<ProcessGroup,GlobalMap,StorageMap> >
      const& pm,
    typename property_traits<GlobalMap>::key_type key)
{
  return get(pm.base(), key);
}


template<typename ProcessGroup, typename GlobalMap, typename StorageMap>
inline void
put(one_bit_color_map<local_property_map<ProcessGroup,GlobalMap,StorageMap> >
      const& pm, 
    typename property_traits<GlobalMap>::key_type key,
    one_bit_color_type value)
{
  put(pm.base(), key, value);
}

  one_bit_color_map(std::size_t inital_size, 
                    const index_map_type& index = index_map_type())
    : inherited(index.process_group(),  index.global(),
                local_map(inital_size, index.base())) { }


  inherited&       base()       { return *this; }

  const inherited& base() const { return *this; }


template<typename ProcessGroup, typename GlobalMap, typename StorageMap>
inline one_bit_color_type
get(one_bit_color_map<
      parallel::distributed_property_map<
        ProcessGroup, GlobalMap, one_bit_color_map<StorageMap> > > const& pm,
    typename property_traits<GlobalMap>::key_type key)
{
  return get(pm.base(), key);
}


template<typename ProcessGroup, typename GlobalMap, typename StorageMap>
inline void
put(one_bit_color_map<
      parallel::distributed_property_map<
        ProcessGroup, GlobalMap, one_bit_color_map<StorageMap> > > const& pm, 
    typename property_traits<GlobalMap>::key_type key,
    one_bit_color_type value)
{
  put(pm.base(), key, value);
}


template<typename DistributedGraph, typename ColorMap, typename OwnerMap>
bool 
st_connected(const DistributedGraph& g, 
             typename graph_traits<DistributedGraph>::vertex_descriptor s,
             typename graph_traits<DistributedGraph>::vertex_descriptor t,
             ColorMap color, OwnerMap owner)
{
  using boost::graph::parallel::process_group;
  using boost::graph::parallel::process_group_type;
  using boost::parallel::all_reduce;

  typedef typename property_traits<ColorMap>::value_type Color;
  typedef color_traits<Color> ColorTraits;
  typedef typename process_group_type<DistributedGraph>::type ProcessGroup;
  typedef typename ProcessGroup::process_id_type ProcessID;
  typedef typename graph_traits<DistributedGraph>::vertex_descriptor Vertex;

  // Set all vertices to white (unvisited)
  BGL_FORALL_VERTICES_T(v, g, DistributedGraph)
    put(color, v, ColorTraits::white());

  // "color" plays the role of a color map, with no synchronization.
  set_property_map_role(vertex_color, color);
  color.set_consistency_model(0);

  // Vertices found from the source are grey
  put(color, s, ColorTraits::gray());

  // Vertices found from the target are green
  put(color, t, ColorTraits::green());

  ProcessGroup pg = process_group(g);
  ProcessID rank = process_id(pg);

  // Build a local queue
  queue<Vertex> Q;
  if (get(owner, s) == rank) Q.push(s);
  if (get(owner, t) == rank) Q.push(t);

  queue<Vertex> other_Q;

  while (true) {
    bool found = false;

    // Process all vertices in the local queue
    while (!found && !Q.empty()) {
      Vertex u = Q.top(); Q.pop();
      Color u_color = get(color, u);

      BGL_FORALL_OUTEDGES_T(u, e, g, DistributedGraph) {
        Vertex v = target(e, g);
        Color v_color = get(color, v);
        if (v_color == ColorTraits::white()) {
          // We have not seen "v" before; mark it with the same color as u
          Color u_color = get(color, u);
          put(color, v, u_color);

          // Either push v into the local queue or send it off to its
          // owner.
          ProcessID v_owner = get(owner, v);
          if (v_owner == rank) 
            other_Q.push(v);
          else
            send(pg, v_owner, 0, 
                 std::make_pair(v, u_color == ColorTraits::gray()));
        } else if (v_color != ColorTraits::black() && u_color != v_color) {
          // Colors have collided. We're done!
          found = true;
          break;
        }
      }

      // u is done, so mark it black
      put(color, u, ColorTraits::black());
    }

    // Ensure that all transmitted messages have been received.
    synchronize(pg);

    // Move all of the send-to-self values into the local Q.
    other_Q.swap(Q);

    if (!found) {
      // Receive all messages
      while (optional<std::pair<ProcessID, int> > msg = probe(pg)) {
        std::pair<Vertex, bool> data;
        receive(pg, msg->first, msg->second, data);
        
        // Determine the colors of u and v, the source and target
        // vertices (v is local).
        Vertex v = data.first;
        Color v_color = get(color, v);
        Color u_color = data.second? ColorTraits::gray() : ColorTraits::green();
        if (v_color == ColorTraits::white()) {
          // v had no color before, so give it u's color and push it
          // into the queue.
          Q.push(v);
          put(color, v, u_color);
        } else if (v_color != ColorTraits::black() && u_color != v_color) {
          // Colors have collided. We're done!
          found = true;
          break;
        }
      }
    }

    // Check if either all queues are empty or 
    std::pair<bool, bool> results = all_reduce(pg, 
            boost::parallel::detail::make_untracked_pair(Q.empty(), found),
            detail::pair_and_or());

    // If someone found the answer, we're done!
    if (results.second)
      return true;

    // If all queues are empty, we're done.
    if (results.first)
      return false;
  }
}


template<typename DistributedGraph, typename ColorMap>
inline bool 
st_connected(const DistributedGraph& g, 
             typename graph_traits<DistributedGraph>::vertex_descriptor s,
             typename graph_traits<DistributedGraph>::vertex_descriptor t,
             ColorMap color)
{
  return st_connected(g, s, t, color, get(vertex_owner, g));
}


template<typename DistributedGraph>
inline bool 
st_connected(const DistributedGraph& g, 
             typename graph_traits<DistributedGraph>::vertex_descriptor s,
             typename graph_traits<DistributedGraph>::vertex_descriptor t)
{
  return st_connected(g, s, t, 
                      make_two_bit_color_map(num_vertices(g),
                                             get(vertex_index, g)));
}

  explicit graph_id_writer(const Graph& g) : g(g) { }


  void operator()(std::ostream& out)
  {
    out << "    label=\"p" << process_id(g.process_group()) << "\";\n";
  }

  explicit paint_by_number_writer(NumberMap number) : number(number) { }


  template<typename Descriptor>
  void operator()(std::ostream& out, Descriptor k)
  {
    static const char* color_names[] = {
      "blue",
      "brown",
      "cyan",
      "darkgreen",
      "darkorchid",
      "darksalmon",
      "darkviolet",
      "deeppink",
      "gold3",
      "green",
      "magenta",
      "navy",
      "red",
      "yellow",
      "palegreen",
      "gray65",
      "gray21",
      "bisque2",
      "greenyellow",
      "indianred4",
      "lightblue2",
      "mediumspringgreen",
      "orangered",
      "orange"
    };
    const int colors = sizeof(color_names) / sizeof(color_names[0]);
    if (get(number, k) < colors) {
      out << " [ style=\"filled\", fillcolor=\"" << color_names[get(number, k)]
          << "\" ]";
    } else {
      out << " [ label=\"(" << get(number, k) << ")\" ]";
    }
  }


template<typename NumberMap>
inline paint_by_number_writer<NumberMap>
paint_by_number(NumberMap number)
{ return paint_by_number_writer<NumberMap>(number); }
~DistributedVertexListGraph() {
      BOOST_CONCEPT_ASSERT((MultiPassInputIterator<vertex_iterator>));
      BOOST_CONCEPT_ASSERT((Convertible<traversal_category,
        distributed_vertex_list_graph_tag>));

#ifdef BOOST_VECTOR_AS_GRAPH_GRAPH_ADL_HACK
      // dwa 2003/7/11 -- This clearly shouldn't be necessary, but if
      // you want to use vector_as_graph, it is!  I'm sure the graph
      // library leaves these out all over the place.  Probably a
      // redesign involving specializing a template with a static
      // member function is in order :(
      using boost::vertices;
#endif      
      p = vertices(g);
      v = *p.first;
      const_constraints(g);
    }
void const_constraints(const G& cg) {
#ifdef BOOST_VECTOR_AS_GRAPH_GRAPH_ADL_HACK
      // dwa 2003/7/11 -- This clearly shouldn't be necessary, but if
      // you want to use vector_as_graph, it is!  I'm sure the graph
      // library leaves these out all over the place.  Probably a
      // redesign involving specializing a template with a static
      // member function is in order :(
      using boost::vertices;
#endif 
      
      p = vertices(cg);
      v = *p.first;
      V = num_vertices(cg);
    }
~DistributedEdgeListGraph() {
      BOOST_CONCEPT_ASSERT((MultiPassInputIterator<edge_iterator>));
      BOOST_CONCEPT_ASSERT((DefaultConstructible<edge_descriptor>));
      BOOST_CONCEPT_ASSERT((EqualityComparable<edge_descriptor>));
      BOOST_CONCEPT_ASSERT((Assignable<edge_descriptor>));
      BOOST_CONCEPT_ASSERT((Convertible<traversal_category,
        distributed_edge_list_graph_tag>));

      p = edges(g);
      e = *p.first;
      u = source(e, g);
      v = target(e, g);
      const_constraints(g);
    }
void const_constraints(const G& cg) {
      p = edges(cg);
      E = num_edges(cg);
      e = *p.first;
      u = source(e, cg);
      v = target(e, cg);
    }

      
  template<typename K>
  T operator()(const K&) const { return T(); }

      
  template<typename K>
  T operator()(const K&, const T& x, const T& y) const 
  { 
    T z(x.begin(), x.end());
    for (typename T::const_iterator iter = y.begin(); iter != y.end(); ++iter)
      if (std::find(z.begin(), z.end(), *iter) == z.end())
        z.push_back(*iter);
    
    return z;
  }

    
    get_owner_of_first_tuple_element(OwnerMap owner) : owner(owner) { }


    owner_type get_owner(Tuple t) { return get(owner, boost::tuples::get<0>(t)); }


  template <typename OwnerMap, typename Tuple>
  typename get_owner_of_first_tuple_element<OwnerMap, Tuple>::owner_type
  get(get_owner_of_first_tuple_element<OwnerMap, Tuple> o, Tuple t)
  { return o.get_owner(t); }

    
    get_owner_of_first_pair_element(OwnerMap owner) : owner(owner) { }


    template <typename Vertex, typename T>
    owner_type get_owner(std::pair<Vertex, T> p) { return get(owner, p.first); }

    
    static type create(distance_type dist, incoming_value_type source)
    { return std::make_pair(dist, source); }

    void synchronize()
    {
      using boost::graph::parallel::synchronize;
      synchronize(pg);
    }

    void setup_triggers()
    {
      using boost::graph::parallel::simple_trigger;
      simple_trigger(pg, msg_relax, this, 
                     &betweenness_centrality_delta_stepping_impl::handle_msg_relax);
    }


    void handle_msg_relax(int /*source*/, int /*tag*/,
                          const std::pair<Vertex, typename MessageValue::type>& data,
                          trigger_receive_context)
    { relax(data.second.second, data.first, data.second.first); }


  template<typename Graph, typename DistanceMap, typename IncomingMap, 
           typename EdgeWeightMap, typename PathCountMap
#ifdef COMPUTE_PATH_COUNTS_INLINE
           , typename IsSettledMap, typename VertexIndexMap
#endif
           >
  betweenness_centrality_delta_stepping_impl<
    Graph, DistanceMap, IncomingMap, EdgeWeightMap, PathCountMap
#ifdef COMPUTE_PATH_COUNTS_INLINE
           , IsSettledMap, VertexIndexMap
#endif
    >::
  betweenness_centrality_delta_stepping_impl(const Graph& g,
                                             DistanceMap distance,
                                             IncomingMap incoming,
                                             EdgeWeightMap weight,
                                             PathCountMap path_count,
#ifdef COMPUTE_PATH_COUNTS_INLINE
                                             IsSettledMap is_settled,
                                             VertexIndexMap vertex_index,
#endif
                                             Dist delta)
    : g(g),
      incoming(incoming),
      distance(distance),
      weight(weight),
      path_count(path_count),
#ifdef COMPUTE_PATH_COUNTS_INLINE
      is_settled(is_settled),
      vertex_index(vertex_index),
#endif
      delta(delta),
      pg(boost::graph::parallel::process_group_adl(g), attach_distributed_object()),
      owner(get(vertex_owner, g)),
      local(get(vertex_local, g))

  { setup_triggers(); }


  template<typename Graph, typename DistanceMap, typename IncomingMap, 
           typename EdgeWeightMap, typename PathCountMap
#ifdef COMPUTE_PATH_COUNTS_INLINE
           , typename IsSettledMap, typename VertexIndexMap
#endif
           >
  void
  betweenness_centrality_delta_stepping_impl<
    Graph, DistanceMap, IncomingMap, EdgeWeightMap, PathCountMap
#ifdef COMPUTE_PATH_COUNTS_INLINE
           , IsSettledMap, VertexIndexMap
#endif
    >::
  run(Vertex s)
  {
    typedef typename boost::graph::parallel::process_group_type<Graph>::type 
      process_group_type;
    typename process_group_type::process_id_type id = process_id(pg);

    Dist inf = (std::numeric_limits<Dist>::max)();
    
    // None of the vertices are stored in the bucket.
    position_in_bucket.clear();
    position_in_bucket.resize(num_vertices(g), dummy_list.end());
    
    // None of the vertices have been deleted
    vertex_was_deleted.clear();
    vertex_was_deleted.resize(num_vertices(g), false);
    
    // No path from s to any other vertex, yet
    BGL_FORALL_VERTICES_T(v, g, Graph)
      put(distance, v, inf);
    
    // The distance to the starting node is zero
    if (get(owner, s) == id) 
      // Put "s" into its bucket (bucket 0)
      relax(s, s, 0);
    else
      // Note that we know the distance to s is zero
      cache(distance, s, 0);
    
#ifdef COMPUTE_PATH_COUNTS_INLINE
    // Synchronize here to deliver initial relaxation since we don't
    // synchronize at the beginning of the inner loop any more
    synchronize(); 

    // Incoming edge count map is an implementation detail and should
    // be freed as soon as possible so build it here
    typedef typename graph_traits<Graph>::edges_size_type edges_size_type;

    std::vector<edges_size_type> incoming_edge_countS(num_vertices(g));
    iterator_property_map<typename std::vector<edges_size_type>::iterator, VertexIndexMap> 
      incoming_edge_count(incoming_edge_countS.begin(), vertex_index);
#endif

    BucketIndex max_bucket = (std::numeric_limits<BucketIndex>::max)();
    BucketIndex current_bucket = 0;
    do {
#ifdef COMPUTE_PATH_COUNTS_INLINE
      // We need to clear the outgoing map after every bucket so just build it here
      std::vector<IncomingType> outgoingS(num_vertices(g));
      IncomingMap outgoing(outgoingS.begin(), vertex_index);
      
      outgoing.set_reduce(append_reducer<IncomingType>());
#else
      // Synchronize with all of the other processes.
      synchronize();
#endif    
  
      // Find the next bucket that has something in it.
      while (current_bucket < buckets.size() 
             && (!buckets[current_bucket] || buckets[current_bucket]->empty()))
        ++current_bucket;
      if (current_bucket >= buckets.size())
        current_bucket = max_bucket;
      
      // Find the smallest bucket (over all processes) that has vertices
      // that need to be processed.
      using boost::parallel::all_reduce;
      using boost::parallel::minimum;
      current_bucket = all_reduce(pg, current_bucket, minimum<BucketIndex>());
      
      if (current_bucket == max_bucket)
        // There are no non-empty buckets in any process; exit. 
        break;
      
      // Contains the set of vertices that have been deleted in the
      // relaxation of "light" edges. Note that we keep track of which
      // vertices were deleted with the property map
      // "vertex_was_deleted".
      std::vector<Vertex> deleted_vertices;
      
      // Repeatedly relax light edges
      bool nonempty_bucket;
      do {
        // Someone has work to do in this bucket.
        
        if (current_bucket < buckets.size() && buckets[current_bucket]) {
          Bucket& bucket = *buckets[current_bucket];
          // For each element in the bucket
          while (!bucket.empty()) {
            Vertex u = bucket.front();
            
            // Remove u from the front of the bucket
            bucket.pop_front();
            
            // Insert u into the set of deleted vertices, if it hasn't
            // been done already.
            if (!vertex_was_deleted[get(local, u)]) {
              vertex_was_deleted[get(local, u)] = true;
              deleted_vertices.push_back(u);
            }
            
            // Relax each light edge. 
            Dist u_dist = get(distance, u);
            BGL_FORALL_OUTEDGES_T(u, e, g, Graph)
              if (get(weight, e) <= delta) // light edge 
                relax(u, target(e, g), u_dist + get(weight, e));
          }
        }

        // Synchronize with all of the other processes.
        synchronize();
        
        // Is the bucket empty now?
        nonempty_bucket = (current_bucket < buckets.size() 
                           && buckets[current_bucket]
                           && !buckets[current_bucket]->empty());
      } while (all_reduce(pg, nonempty_bucket, std::logical_or<bool>()));
      
      // Relax heavy edges for each of the vertices that we previously
      // deleted.
      for (typename std::vector<Vertex>::iterator iter = deleted_vertices.begin();
           iter != deleted_vertices.end(); ++iter) {
        // Relax each heavy edge. 
        Vertex u = *iter;
        Dist u_dist = get(distance, u);
        BGL_FORALL_OUTEDGES_T(u, e, g, Graph)
          if (get(weight, e) > delta) // heavy edge
            relax(u, target(e, g), u_dist + get(weight, e)); 

#ifdef COMPUTE_PATH_COUNTS_INLINE
        // Set outgoing paths
        IncomingType in = get(incoming, u);
        for (typename IncomingType::iterator pred = in.begin(); pred != in.end(); ++pred) 
          if (get(owner, *pred) == id) {
            IncomingType x = get(outgoing, *pred);
            if (std::find(x.begin(), x.end(), u) == x.end())
              x.push_back(u);
            put(outgoing, *pred, x);
          } else {
            IncomingType in;
            in.push_back(u);
            put(outgoing, *pred, in);
          }

        // Set incoming edge counts
        put(incoming_edge_count, u, in.size());
#endif
      }

#ifdef COMPUTE_PATH_COUNTS_INLINE
      synchronize();  // Deliver heavy edge relaxations and outgoing paths

      // Build Queue
      typedef typename property_traits<PathCountMap>::value_type PathCountType;
      typedef std::pair<Vertex, PathCountType> queue_value_type;
      typedef typename property_map<Graph, vertex_owner_t>::const_type OwnerMap;
      typedef typename get_owner_of_first_pair_element<OwnerMap> IndirectOwnerMap;

      typedef boost::queue<queue_value_type> local_queue_type;
      typedef boost::graph::distributed::distributed_queue<process_group_type,
                                                           IndirectOwnerMap,
                                                           local_queue_type> dist_queue_type;

      IndirectOwnerMap indirect_owner(owner);
      dist_queue_type Q(pg, indirect_owner);

      // Find sources to initialize queue
      BGL_FORALL_VERTICES_T(v, g, Graph) {
        if (get(is_settled, v) && !(get(outgoing, v).empty())) {
          put(incoming_edge_count, v, 1); 
          Q.push(std::make_pair(v, 0)); // Push this vertex with no additional path count
        }
      }

      // Set path counts for vertices in this bucket
      while (!Q.empty()) {
        queue_value_type t = Q.top(); Q.pop();
        Vertex v = t.first;
        PathCountType p = t.second;

        put(path_count, v, get(path_count, v) + p);
        put(incoming_edge_count, v, get(incoming_edge_count, v) - 1);

        if (get(incoming_edge_count, v) == 0) {
          IncomingType out = get(outgoing, v);
          for (typename IncomingType::iterator iter = out.begin(); iter != out.end(); ++iter)
            Q.push(std::make_pair(*iter, get(path_count, v)));
        }
      }

      // Mark the vertices in this bucket settled 
      for (typename std::vector<Vertex>::iterator iter = deleted_vertices.begin();
           iter != deleted_vertices.end(); ++iter) 
        put(is_settled, *iter, true);

      // No need to clear path count map as it is never read/written remotely
      // No need to clear outgoing map as it is re-alloced every bucket 
#endif
      
      // Go to the next bucket: the current bucket must already be empty.
      ++current_bucket;
    } while (true);
    
    // Delete all of the buckets.
    for (typename std::vector<Bucket*>::iterator iter = buckets.begin();
         iter != buckets.end(); ++iter) {
      if (*iter) {
        delete *iter;
        *iter = 0;
      }
    }
  }

        
  template<typename Graph, typename DistanceMap, typename IncomingMap, 
           typename EdgeWeightMap, typename PathCountMap
#ifdef COMPUTE_PATH_COUNTS_INLINE
           , typename IsSettledMap, typename VertexIndexMap
#endif
           >
  void
  betweenness_centrality_delta_stepping_impl<
    Graph, DistanceMap, IncomingMap, EdgeWeightMap, PathCountMap
#ifdef COMPUTE_PATH_COUNTS_INLINE
           , IsSettledMap, VertexIndexMap
#endif
    >::
  relax(Vertex u, Vertex v, Dist x)
  {

    if (x <= get(distance, v)) {
      
      // We're relaxing the edge to vertex v.
      if (get(owner, v) == process_id(pg)) {
        if (x < get(distance, v)) {
          // Compute the new bucket index for v
          BucketIndex new_index = static_cast<BucketIndex>(x / delta);
        
          // Make sure there is enough room in the buckets data structure.
          if (new_index >= buckets.size()) buckets.resize(new_index + 1, 0);
        
          // Make sure that we have allocated the bucket itself.
          if (!buckets[new_index]) buckets[new_index] = new Bucket;
          
          if (get(distance, v) != (std::numeric_limits<Dist>::max)()
              && !vertex_was_deleted[get(local, v)]) {
            // We're moving v from an old bucket into a new one. Compute
            // the old index, then splice it in.
            BucketIndex old_index 
              = static_cast<BucketIndex>(get(distance, v) / delta);
            buckets[new_index]->splice(buckets[new_index]->end(),
                                       *buckets[old_index],
                                       position_in_bucket[get(local, v)]);
          } else {
            // We're inserting v into a bucket for the first time. Put it
            // at the end.
            buckets[new_index]->push_back(v);
          }
          
          // v is now at the last position in the new bucket
          position_in_bucket[get(local, v)] = buckets[new_index]->end();
          --position_in_bucket[get(local, v)];
          
          // Update tentative distance information and incoming, path_count
          if (u != v) put(incoming, v, IncomingType(1, u));
          put(distance, v, x);
        }        // u != v covers initial source relaxation and self-loops
        else if (x == get(distance, v) && u != v) {

          // Add incoming edge if it's not already in the list
          IncomingType in = get(incoming, v);
          if (std::find(in.begin(), in.end(), u) == in.end()) {
            in.push_back(u);
            put(incoming, v, in);
          }
        }
      } else {
        // The vertex is remote: send a request to the vertex's owner
        send(pg, get(owner, v), msg_relax, 
             std::make_pair(v, MessageValue::create(x, u)));

        // Cache tentative distance information
        cache(distance, v, x);
      }
    }
  }


    brandes_shortest_paths() 
      : weight(1), delta(0)  { }

    brandes_shortest_paths(weight_type delta) 
      : weight(1), delta(delta)  { }

    brandes_shortest_paths(WeightMap w) 
      : weight(w), delta(0)  { }

    brandes_shortest_paths(WeightMap w, weight_type delta) 
      : weight(w), delta(delta)  { }


    template<typename Graph, typename IncomingMap, typename DistanceMap,
             typename PathCountMap
#ifdef COMPUTE_PATH_COUNTS_INLINE
             , typename IsSettledMap, typename VertexIndexMap
#endif

             > 
    void 
    operator()(Graph& g, 
               typename graph_traits<Graph>::vertex_descriptor s,
               IncomingMap incoming,
               DistanceMap distance,
               PathCountMap path_count
#ifdef COMPUTE_PATH_COUNTS_INLINE
               , IsSettledMap is_settled,
               VertexIndexMap vertex_index 
#endif
               )
    {  
      typedef typename property_traits<DistanceMap>::value_type 
        distance_type;

      typedef std::plus<distance_type> Combine;
      typedef std::less<distance_type> Compare;

      // The "distance" map needs to act like one, retrieving the default
      // value of infinity.
      set_property_map_role(vertex_distance, distance);
      
      // Only calculate delta the first time operator() is called
      // This presumes g is the same every time, but so does the fact
      // that we're reusing the weight map
      if (delta == 0)
        set_delta(g);
      
      // TODO (NGE): Restructure the code so we don't have to construct
      //             impl every time?
      betweenness_centrality_delta_stepping_impl<
          Graph, DistanceMap, IncomingMap, WeightMap, PathCountMap
#ifdef COMPUTE_PATH_COUNTS_INLINE
          , IsSettledMap, VertexIndexMap
#endif
            >
        impl(g, distance, incoming, weight, path_count, 
#ifdef COMPUTE_PATH_COUNTS_INLINE
             is_settled, vertex_index, 
#endif
             delta);

      impl.run(s);
    }


    template <typename Graph>
    void
    set_delta(const Graph& g)
    {
      using boost::parallel::all_reduce;
      using boost::parallel::maximum;
      using std::max;

      typedef typename graph_traits<Graph>::degree_size_type Degree;
      typedef weight_type Dist;

      // Compute the maximum edge weight and degree
      Dist max_edge_weight = 0;
      Degree max_degree = 0;
      BGL_FORALL_VERTICES_T(u, g, Graph) {
        max_degree = max BOOST_PREVENT_MACRO_SUBSTITUTION (max_degree, out_degree(u, g));
        BGL_FORALL_OUTEDGES_T(u, e, g, Graph)
          max_edge_weight = max BOOST_PREVENT_MACRO_SUBSTITUTION (max_edge_weight, get(weight, e));
      }
      
      max_edge_weight = all_reduce(process_group(g), max_edge_weight, maximum<Dist>());
      max_degree = all_reduce(process_group(g), max_degree, maximum<Degree>());
      
      // Take a guess at delta, based on what works well for random
      // graphs.
      delta = max_edge_weight / max_degree;
      if (delta == 0)
        delta = 1;
    }

  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
           typename IncomingMap, typename DistanceMap, typename DependencyMap, 
           typename PathCountMap, 
#ifdef COMPUTE_PATH_COUNTS_INLINE
           typename IsSettledMap,
#endif 
           typename VertexIndexMap, typename ShortestPaths> 
  void
  do_brandes_sssp(const Graph& g, 
                  CentralityMap centrality,     
                  EdgeCentralityMap edge_centrality_map,
                  IncomingMap incoming,
                  DistanceMap distance,
                  DependencyMap dependency,
                  PathCountMap path_count, 
#ifdef COMPUTE_PATH_COUNTS_INLINE
                  IsSettledMap is_settled,
#endif 
                  VertexIndexMap vertex_index,
                  ShortestPaths shortest_paths,
                  typename graph_traits<Graph>::vertex_descriptor s)
  {
    using boost::detail::graph::update_centrality;      
    using boost::graph::parallel::process_group;

    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
    typedef typename graph_traits<Graph>::edges_size_type edges_size_type;

    typedef typename property_traits<IncomingMap>::value_type incoming_type;
    typedef typename property_traits<DistanceMap>::value_type distance_type;
    typedef typename property_traits<DependencyMap>::value_type dependency_type;
    typedef typename property_traits<PathCountMap>::value_type path_count_type;

    typedef typename incoming_type::iterator incoming_iterator;

    typedef typename property_map<Graph, vertex_owner_t>::const_type OwnerMap;
    OwnerMap owner = get(vertex_owner, g);

    typedef typename boost::graph::parallel::process_group_type<Graph>::type 
      process_group_type;
    process_group_type pg = process_group(g);
    typename process_group_type::process_id_type id = process_id(pg);

    // TODO: Is it faster not to clear some of these maps?
    // Initialize for this iteration
    distance.clear();
    incoming.clear();
    path_count.clear();
    dependency.clear();
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      put(path_count, v, 0);
      put(dependency, v, 0);
    }

    if (get(owner, s) == id) {
      put(incoming, s, incoming_type());
#ifdef COMPUTE_PATH_COUNTS_INLINE
      put(path_count, s, 1);
      put(is_settled, s, true);
#endif
    }

    // Execute the shortest paths algorithm. This will be either
    // a weighted or unweighted customized breadth-first search,
    shortest_paths(g, s, incoming, distance, path_count
#ifdef COMPUTE_PATH_COUNTS_INLINE
                   , is_settled, vertex_index
#endif 
                   );

#ifndef COMPUTE_PATH_COUNTS_INLINE

    //
    // TODO: Optimize case where source has no out-edges
    //
 
    // Count of incoming edges to tell when all incoming edges have been relaxed in 
    // the induced shortest paths DAG 
    std::vector<edges_size_type> incoming_edge_countS(num_vertices(g));
    iterator_property_map<typename std::vector<edges_size_type>::iterator, VertexIndexMap> 
      incoming_edge_count(incoming_edge_countS.begin(), vertex_index);

    BGL_FORALL_VERTICES_T(v, g, Graph) {
      put(incoming_edge_count, v, get(incoming, v).size());
    }

    if (get(owner, s) == id) {
      put(incoming_edge_count, s, 1);
      put(incoming, s, incoming_type());
    }

    std::vector<incoming_type> outgoingS(num_vertices(g));
    iterator_property_map<typename std::vector<incoming_type>::iterator, VertexIndexMap> 
      outgoing(outgoingS.begin(), vertex_index);

    outgoing.set_reduce(append_reducer<incoming_type>());

    // Mark forward adjacencies in DAG of shortest paths

    // TODO: It's possible to do this using edge flags but it's not currently done this way
    //       because during traversal of the DAG we would have to examine all out edges
    //       which would lead to more memory accesses and a larger cache footprint.
    //
    //       In the bidirectional graph case edge flags would be an excellent way of marking
    //       edges in the DAG of shortest paths  
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      incoming_type i = get(incoming, v);
      for (typename incoming_type::iterator iter = i.begin(); iter != i.end(); ++iter) {
        if (get(owner, *iter) == id) {
          incoming_type x = get(outgoing, *iter);
          if (std::find(x.begin(), x.end(), v) == x.end())
            x.push_back(v);
          put(outgoing, *iter, x);
        } else {
          incoming_type in;
          in.push_back(v);
          put(outgoing, *iter, in);
        }
      }
    }

    synchronize(pg);

    // Traverse DAG induced by forward edges in dependency order and compute path counts
    {
      typedef std::pair<vertex_descriptor, path_count_type> queue_value_type;
      typedef get_owner_of_first_pair_element<OwnerMap> IndirectOwnerMap;

      typedef boost::queue<queue_value_type> local_queue_type;
      typedef boost::graph::distributed::distributed_queue<process_group_type,
                                                           IndirectOwnerMap,
                                                           local_queue_type> dist_queue_type;

      IndirectOwnerMap indirect_owner(owner);
      dist_queue_type Q(pg, indirect_owner);

      if (get(owner, s) == id)
        Q.push(std::make_pair(s, 1));

      while (!Q.empty()) {
        queue_value_type t = Q.top(); Q.pop();
        vertex_descriptor v = t.first;
        path_count_type p = t.second;

        put(path_count, v, get(path_count, v) + p);
        put(incoming_edge_count, v, get(incoming_edge_count, v) - 1);

        if (get(incoming_edge_count, v) == 0) {
          incoming_type out = get(outgoing, v);
          for (typename incoming_type::iterator iter = out.begin(); iter != out.end(); ++iter)
            Q.push(std::make_pair(*iter, get(path_count, v)));
        }
      }
    }

#endif // COMPUTE_PATH_COUNTS_INLINE

    //
    // Compute dependencies 
    //    


    // Build the distributed_queue
    // Value type consists of 1) target of update 2) source of update
    // 3) dependency of source 4) path count of source
    typedef boost::tuple<vertex_descriptor, vertex_descriptor, dependency_type, path_count_type>
      queue_value_type;
    typedef get_owner_of_first_tuple_element<OwnerMap, queue_value_type> IndirectOwnerMap;

    typedef boost::queue<queue_value_type> local_queue_type;
    typedef boost::graph::distributed::distributed_queue<process_group_type,
                                                         IndirectOwnerMap,
                                                         local_queue_type> dist_queue_type;

    IndirectOwnerMap indirect_owner(owner);
    dist_queue_type Q(pg, indirect_owner);

    // Calculate number of vertices each vertex depends on, when a vertex has been pushed
    // that number of times then we will update it
    // AND Request path counts of sources of incoming edges
    std::vector<dependency_type> dependency_countS(num_vertices(g), 0);
    iterator_property_map<typename std::vector<dependency_type>::iterator, VertexIndexMap> 
      dependency_count(dependency_countS.begin(), vertex_index);

    dependency_count.set_reduce(boost::graph::distributed::additive_reducer<dependency_type>());

    path_count.set_max_ghost_cells(0);

    BGL_FORALL_VERTICES_T(v, g, Graph) {
      if (get(distance, v) < (std::numeric_limits<distance_type>::max)()) {
        incoming_type el = get(incoming, v);
        for (incoming_iterator vw = el.begin(); vw != el.end(); ++vw) {
          if (get(owner, *vw) == id)
            put(dependency_count, *vw, get(dependency_count, *vw) + 1);
          else {
            put(dependency_count, *vw, 1);

            // Request path counts
            get(path_count, *vw); 
          }

          // request() doesn't work here, perhaps because we don't have a copy of this 
          // ghost cell already?
        }
      }
    }

    synchronize(pg);

    // Push vertices with non-zero distance/path count and zero dependency count
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      if (get(distance, v) < (std::numeric_limits<distance_type>::max)()
          && get(dependency_count, v) == 0) 
        Q.push(boost::make_tuple(v, v, get(dependency, v), get(path_count, v)));
    }

    dependency.set_max_ghost_cells(0);
    while(!Q.empty()) {

      queue_value_type x = Q.top(); Q.pop();
      vertex_descriptor w = boost::tuples::get<0>(x);
      vertex_descriptor source = boost::tuples::get<1>(x);
      dependency_type dep = boost::tuples::get<2>(x);
      path_count_type pc = boost::tuples::get<3>(x);

      cache(dependency, source, dep);
      cache(path_count, source, pc);

      if (get(dependency_count, w) != 0)
        put(dependency_count, w, get(dependency_count, w) - 1);

      if (get(dependency_count, w) == 0) { 

        // Update dependency and centrality of sources of incoming edges
        incoming_type el = get(incoming, w);
        for (incoming_iterator vw = el.begin(); vw != el.end(); ++vw) {
          vertex_descriptor v = *vw;

          BOOST_ASSERT(get(path_count, w) != 0);

          dependency_type factor = dependency_type(get(path_count, v))
            / dependency_type(get(path_count, w));
          factor *= (dependency_type(1) + get(dependency, w));
          
          if (get(owner, v) == id)
            put(dependency, v, get(dependency, v) + factor);
          else
            put(dependency, v, factor);
          
          update_centrality(edge_centrality_map, v, factor);
        }
        
        if (w != s)
          update_centrality(centrality, w, get(dependency, w));

        // Push sources of edges in incoming edge list
        for (incoming_iterator vw = el.begin(); vw != el.end(); ++vw)
          Q.push(boost::make_tuple(*vw, w, get(dependency, w), get(path_count, w)));
      }
    }
  }


  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
           typename IncomingMap, typename DistanceMap, typename DependencyMap, 
           typename PathCountMap, typename VertexIndexMap, typename ShortestPaths, 
           typename Buffer>
  void 
  brandes_betweenness_centrality_impl(const Graph& g, 
                                      CentralityMap centrality,     
                                      EdgeCentralityMap edge_centrality_map,
                                      IncomingMap incoming,
                                      DistanceMap distance,
                                      DependencyMap dependency,
                                      PathCountMap path_count, 
                                      VertexIndexMap vertex_index,
                                      ShortestPaths shortest_paths,
                                      Buffer sources)
  {
    using boost::detail::graph::init_centrality_map;
    using boost::detail::graph::divide_centrality_by_two;       
    using boost::graph::parallel::process_group;
    
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
    typedef typename graph_traits<Graph>::edge_iterator edge_iterator;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;

    typedef typename property_traits<DistanceMap>::value_type distance_type;
    typedef typename property_traits<DependencyMap>::value_type dependency_type;

    // Initialize centrality
    init_centrality_map(vertices(g), centrality);
    init_centrality_map(edges(g), edge_centrality_map);

    // Set the reduction operation on the dependency map to be addition
    dependency.set_reduce(boost::graph::distributed::additive_reducer<dependency_type>()); 
    distance.set_reduce(boost::graph::distributed::choose_min_reducer<distance_type>());

    // Don't allow remote procs to write incoming or path_count maps
    // updating them is handled inside the betweenness_centrality_queue
    incoming.set_consistency_model(0);
    path_count.set_consistency_model(0);

    typedef typename boost::graph::parallel::process_group_type<Graph>::type 
      process_group_type;
    process_group_type pg = process_group(g);

#ifdef COMPUTE_PATH_COUNTS_INLINE
    // Build is_settled maps
    std::vector<bool> is_settledS(num_vertices(g));
    typedef iterator_property_map<std::vector<bool>::iterator, VertexIndexMap> 
      IsSettledMap;

    IsSettledMap is_settled(is_settledS.begin(), vertex_index);
#endif

    if (!sources.empty()) {
      // DO SSSPs
      while (!sources.empty()) {
        do_brandes_sssp(g, centrality, edge_centrality_map, incoming, distance,
                        dependency, path_count, 
#ifdef COMPUTE_PATH_COUNTS_INLINE
                        is_settled,
#endif 
                        vertex_index, shortest_paths, sources.top());
        sources.pop();
      }
    } else { // Exact Betweenness Centrality
      typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
      vertices_size_type n = num_vertices(g);
      n = boost::parallel::all_reduce(pg, n, std::plus<vertices_size_type>());
      
      for (vertices_size_type i = 0; i < n; ++i) {
        vertex_descriptor v = vertex(i, g);

        do_brandes_sssp(g, centrality, edge_centrality_map, incoming, distance,
                        dependency, path_count, 
#ifdef COMPUTE_PATH_COUNTS_INLINE
                        is_settled,
#endif 
                        vertex_index, shortest_paths, v);
      }
    }

    typedef typename graph_traits<Graph>::directed_category directed_category;
    const bool is_undirected = 
      is_convertible<directed_category*, undirected_tag*>::value;
    if (is_undirected) {
      divide_centrality_by_two(vertices(g), centrality);
      divide_centrality_by_two(edges(g), edge_centrality_map);
    }
  }


  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
           typename IncomingMap, typename DistanceMap, typename DependencyMap, 
           typename PathCountMap, typename VertexIndexMap, typename ShortestPaths,
           typename Stack>
  void
  do_sequential_brandes_sssp(const Graph& g, 
                             CentralityMap centrality,     
                             EdgeCentralityMap edge_centrality_map,
                             IncomingMap incoming,
                             DistanceMap distance,
                             DependencyMap dependency,
                             PathCountMap path_count, 
                             VertexIndexMap vertex_index,
                             ShortestPaths shortest_paths,
                             Stack& ordered_vertices,
                             typename graph_traits<Graph>::vertex_descriptor v)
  {
    using boost::detail::graph::update_centrality;

    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;

    typedef typename property_traits<IncomingMap>::value_type incoming_type;

    // Initialize for this iteration
    BGL_FORALL_VERTICES_T(w, g, Graph) {
      // put(path_count, w, 0);
      incoming[w].clear();
      put(dependency, w, 0);
    }

    put(path_count, v, 1);
    incoming[v].clear();

    // Execute the shortest paths algorithm. This will be either
    // Dijkstra's algorithm or a customized breadth-first search,
    // depending on whether the graph is weighted or unweighted.
    shortest_paths(g, v, ordered_vertices, incoming, distance,
                   path_count, vertex_index);
    
    while (!ordered_vertices.empty()) {
      vertex_descriptor w = ordered_vertices.top();
      ordered_vertices.pop();
      
      typedef typename property_traits<IncomingMap>::value_type
            incoming_type;
      typedef typename incoming_type::iterator incoming_iterator;
      typedef typename property_traits<DependencyMap>::value_type 
        dependency_type;
      
      for (incoming_iterator vw = incoming[w].begin();
           vw != incoming[w].end(); ++vw) {
        vertex_descriptor v = source(*vw, g);
        dependency_type factor = dependency_type(get(path_count, v))
          / dependency_type(get(path_count, w));
        factor *= (dependency_type(1) + get(dependency, w));
        put(dependency, v, get(dependency, v) + factor);
        update_centrality(edge_centrality_map, *vw, factor);
      }
      
      if (w != v) {
        update_centrality(centrality, w, get(dependency, w));
      }
    }
  }

  template<typename ProcessGroup, typename Graph, 
           typename CentralityMap, typename EdgeCentralityMap,
           typename IncomingMap, typename DistanceMap, 
           typename DependencyMap, typename PathCountMap,
           typename VertexIndexMap, typename ShortestPaths,
           typename Buffer>
  void
  non_distributed_brandes_betweenness_centrality_impl(const ProcessGroup& pg,
                                                      const Graph& g,
                                                      CentralityMap centrality,
                                                      EdgeCentralityMap edge_centrality_map,
                                                      IncomingMap incoming, // P
                                                      DistanceMap distance,         // d
                                                      DependencyMap dependency,     // delta
                                                      PathCountMap path_count,      // sigma
                                                      VertexIndexMap vertex_index,
                                                      ShortestPaths shortest_paths,
                                                      Buffer sources)
  {
    using boost::detail::graph::init_centrality_map;
    using boost::detail::graph::divide_centrality_by_two;       
    using boost::graph::parallel::process_group;

    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
    typedef typename graph_traits<Graph>::edge_iterator edge_iterator;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;

    typedef typename property_traits<DistanceMap>::value_type distance_type;

    typedef ProcessGroup process_group_type;

    typename process_group_type::process_id_type id = process_id(pg);
    typename process_group_type::process_size_type p = num_processes(pg);

    // Initialize centrality
    init_centrality_map(vertices(g), centrality);
    init_centrality_map(edges(g), edge_centrality_map);

    std::stack<vertex_descriptor> ordered_vertices;

    if (!sources.empty()) {
      std::vector<vertex_descriptor> local_sources;

      for (int i = 0; i < id; ++i) if (!sources.empty()) sources.pop();
      while (!sources.empty()) {
        local_sources.push_back(sources.top());

        for (int i = 0; i < p; ++i) if (!sources.empty()) sources.pop();
      }

      // DO SSSPs
      for(size_t i = 0; i < local_sources.size(); ++i)
        do_sequential_brandes_sssp(g, centrality, edge_centrality_map, incoming,
                                   distance, dependency, path_count, vertex_index,
                                   shortest_paths, ordered_vertices, local_sources[i]);

    } else { // Exact Betweenness Centrality
      typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
      vertices_size_type n = num_vertices(g);
      
      for (vertices_size_type i = id; i < n; i += p) {
        vertex_descriptor v = vertex(i, g);

        do_sequential_brandes_sssp(g, centrality, edge_centrality_map, incoming,
                                   distance, dependency, path_count, vertex_index,
                                   shortest_paths, ordered_vertices, v);
      }
    }

    typedef typename graph_traits<Graph>::directed_category directed_category;
    const bool is_undirected = 
      is_convertible<directed_category*, undirected_tag*>::value;
    if (is_undirected) {
      divide_centrality_by_two(vertices(g), centrality);
      divide_centrality_by_two(edges(g), edge_centrality_map);
    }

    // Merge the centrality maps by summing the values at each vertex)
    // TODO(nge): this copy-out, reduce, copy-in is lame
    typedef typename property_traits<CentralityMap>::value_type centrality_type;
    typedef typename property_traits<EdgeCentralityMap>::value_type edge_centrality_type;

    std::vector<centrality_type> centrality_v(num_vertices(g));
    std::vector<edge_centrality_type> edge_centrality_v;
    edge_centrality_v.reserve(num_edges(g));

    BGL_FORALL_VERTICES_T(v, g, Graph) {
      centrality_v[get(vertex_index, v)] = get(centrality, v);
    }
    
    // Skip when EdgeCentralityMap is a dummy_property_map
    if (!is_same<EdgeCentralityMap, dummy_property_map>::value) {
      BGL_FORALL_EDGES_T(e, g, Graph) {
        edge_centrality_v.push_back(get(edge_centrality_map, e));
      }
      // NGE: If we trust that the order of elements in the vector isn't changed in the
      //      all_reduce below then this method avoids the need for an edge index map
    }

    using boost::parallel::all_reduce;

    all_reduce(pg, &centrality_v[0], &centrality_v[centrality_v.size()],
               &centrality_v[0], std::plus<centrality_type>());

    if (edge_centrality_v.size()) 
      all_reduce(pg, &edge_centrality_v[0], &edge_centrality_v[edge_centrality_v.size()],
                 &edge_centrality_v[0], std::plus<edge_centrality_type>());

    BGL_FORALL_VERTICES_T(v, g, Graph) {
      put(centrality, v, centrality_v[get(vertex_index, v)]);
    }

    // Skip when EdgeCentralityMap is a dummy_property_map
    if (!is_same<EdgeCentralityMap, dummy_property_map>::value) {
      int i = 0;
      BGL_FORALL_EDGES_T(e, g, Graph) {
        put(edge_centrality_map, e, edge_centrality_v[i]);
        ++i;
      }
    }
  }


template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
         typename IncomingMap, typename DistanceMap, typename DependencyMap, 
         typename PathCountMap, typename VertexIndexMap, typename Buffer>
void 
brandes_betweenness_centrality(const Graph& g, 
                               CentralityMap centrality,
                               EdgeCentralityMap edge_centrality_map,
                               IncomingMap incoming, 
                               DistanceMap distance, 
                               DependencyMap dependency,     
                               PathCountMap path_count,   
                               VertexIndexMap vertex_index,
                               Buffer sources,
                               typename property_traits<DistanceMap>::value_type delta
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,distributed_graph_tag))
{
  typedef typename property_traits<DistanceMap>::value_type distance_type;
  typedef static_property_map<distance_type> WeightMap;

  graph::parallel::detail::brandes_shortest_paths<WeightMap> 
    shortest_paths(delta);

  graph::parallel::detail::brandes_betweenness_centrality_impl(g, centrality, 
                                                               edge_centrality_map,
                                                               incoming, distance,
                                                               dependency, path_count,
                                                               vertex_index, 
                                                               shortest_paths,
                                                               sources);
}


template<typename Graph, typename CentralityMap, typename EdgeCentralityMap, 
         typename IncomingMap, typename DistanceMap, typename DependencyMap, 
         typename PathCountMap, typename VertexIndexMap, typename WeightMap, 
         typename Buffer>    
void 
brandes_betweenness_centrality(const Graph& g, 
                               CentralityMap centrality,
                               EdgeCentralityMap edge_centrality_map,
                               IncomingMap incoming, 
                               DistanceMap distance, 
                               DependencyMap dependency,
                               PathCountMap path_count, 
                               VertexIndexMap vertex_index,
                               Buffer sources,
                               typename property_traits<WeightMap>::value_type delta,
                               WeightMap weight_map
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,distributed_graph_tag))
{
  graph::parallel::detail::brandes_shortest_paths<WeightMap> shortest_paths(weight_map, delta);

  graph::parallel::detail::brandes_betweenness_centrality_impl(g, centrality, 
                                                               edge_centrality_map,
                                                               incoming, distance,
                                                               dependency, path_count,
                                                               vertex_index, 
                                                               shortest_paths,
                                                               sources);
}

  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
           typename WeightMap, typename VertexIndexMap, typename Buffer>
  void 
  brandes_betweenness_centrality_dispatch2(const Graph& g,
                                           CentralityMap centrality,
                                           EdgeCentralityMap edge_centrality_map,
                                           WeightMap weight_map,
                                           VertexIndexMap vertex_index,
                                           Buffer sources,
                                           typename property_traits<WeightMap>::value_type delta)
  {
    typedef typename graph_traits<Graph>::degree_size_type degree_size_type;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename mpl::if_c<(is_same<CentralityMap, 
                                        dummy_property_map>::value),
                                         EdgeCentralityMap, 
                               CentralityMap>::type a_centrality_map;
    typedef typename property_traits<a_centrality_map>::value_type 
      centrality_type;

    typename graph_traits<Graph>::vertices_size_type V = num_vertices(g);

    std::vector<std::vector<vertex_descriptor> > incoming(V);
    std::vector<centrality_type> distance(V);
    std::vector<centrality_type> dependency(V);
    std::vector<degree_size_type> path_count(V);

    brandes_betweenness_centrality(
      g, centrality, edge_centrality_map,
      make_iterator_property_map(incoming.begin(), vertex_index),
      make_iterator_property_map(distance.begin(), vertex_index),
      make_iterator_property_map(dependency.begin(), vertex_index),
      make_iterator_property_map(path_count.begin(), vertex_index),
      vertex_index, unwrap_ref(sources), delta,
      weight_map);
  }

  template<typename Graph, typename CentralityMap, typename EdgeCentralityMap,
           typename VertexIndexMap, typename Buffer>
  void 
  brandes_betweenness_centrality_dispatch2(const Graph& g,
                                           CentralityMap centrality,
                                           EdgeCentralityMap edge_centrality_map,
                                           VertexIndexMap vertex_index,
                                           Buffer sources,
                                           typename graph_traits<Graph>::edges_size_type delta)
  {
    typedef typename graph_traits<Graph>::degree_size_type degree_size_type;
    typedef typename graph_traits<Graph>::edges_size_type edges_size_type;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename mpl::if_c<(is_same<CentralityMap, 
                                        dummy_property_map>::value),
                                         EdgeCentralityMap, 
                               CentralityMap>::type a_centrality_map;

    typename graph_traits<Graph>::vertices_size_type V = num_vertices(g);
    
    std::vector<std::vector<vertex_descriptor> > incoming(V);
    std::vector<edges_size_type> distance(V);
    std::vector<edges_size_type> dependency(V);
    std::vector<degree_size_type> path_count(V);

    brandes_betweenness_centrality(
      g, centrality, edge_centrality_map,
      make_iterator_property_map(incoming.begin(), vertex_index),
      make_iterator_property_map(distance.begin(), vertex_index),
      make_iterator_property_map(dependency.begin(), vertex_index),
      make_iterator_property_map(path_count.begin(), vertex_index),
      vertex_index, unwrap_ref(sources), delta); 
  }

    template<typename Graph, typename CentralityMap, typename EdgeCentralityMap, 
             typename VertexIndexMap, typename Buffer>
    static void 
    run(const Graph& g, CentralityMap centrality, EdgeCentralityMap edge_centrality_map, 
        VertexIndexMap vertex_index, Buffer sources,
        typename property_traits<WeightMap>::value_type delta, WeightMap weight_map) 
    {
      boost::graph::parallel::detail::brandes_betweenness_centrality_dispatch2(
       g, centrality, edge_centrality_map, weight_map, vertex_index, sources, delta);
    }

    template<typename Graph, typename CentralityMap, typename EdgeCentralityMap, 
             typename VertexIndexMap, typename Buffer>
    static void 
    run(const Graph& g, CentralityMap centrality, EdgeCentralityMap edge_centrality_map, 
        VertexIndexMap vertex_index, Buffer sources,
        typename graph_traits<Graph>::edges_size_type delta,
        boost::param_not_found)
    {
      boost::graph::parallel::detail::brandes_betweenness_centrality_dispatch2(
       g, centrality, edge_centrality_map, vertex_index, sources, delta);
    }


template<typename Graph, typename Param, typename Tag, typename Rest>
void 
brandes_betweenness_centrality(const Graph& g, 
                               const bgl_named_params<Param,Tag,Rest>& params
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,distributed_graph_tag))
{
  typedef bgl_named_params<Param,Tag,Rest> named_params;

  typedef queue<typename graph_traits<Graph>::vertex_descriptor> queue_t;
  queue_t q;

  typedef typename get_param_type<edge_weight_t, named_params>::type ew_param;
  typedef typename detail::choose_impl_result<mpl::true_, Graph, ew_param, edge_weight_t>::type ew;
  graph::parallel::detail::brandes_betweenness_centrality_dispatch1<ew>::run(
    g, 
    choose_param(get_param(params, vertex_centrality), 
                 dummy_property_map()),
    choose_param(get_param(params, edge_centrality), 
                 dummy_property_map()),
    choose_const_pmap(get_param(params, vertex_index), g, vertex_index),
    choose_param(get_param(params, buffer_param_t()), boost::ref(q)),
    choose_param(get_param(params, lookahead_t()), 0),
    choose_const_pmap(get_param(params, edge_weight), g, edge_weight));
}


template<typename Graph, typename CentralityMap>
void 
brandes_betweenness_centrality(const Graph& g, CentralityMap centrality
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,distributed_graph_tag))
{
  typedef queue<typename graph_traits<Graph>::vertex_descriptor> queue_t;
  queue_t q;

  boost::graph::parallel::detail::brandes_betweenness_centrality_dispatch2(
    g, centrality, dummy_property_map(), get(vertex_index, g), boost::ref(q), 0);
}


template<typename Graph, typename CentralityMap, typename EdgeCentralityMap>
void 
brandes_betweenness_centrality(const Graph& g, CentralityMap centrality,
                               EdgeCentralityMap edge_centrality_map
                               BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,distributed_graph_tag))
{
  typedef queue<int> queue_t;
  queue_t q;

  boost::graph::parallel::detail::brandes_betweenness_centrality_dispatch2(
    g, centrality, edge_centrality_map, get(vertex_index, g), boost::ref(q), 0);
}

  
template<typename ProcessGroup, typename Graph, typename CentralityMap, 
         typename EdgeCentralityMap, typename IncomingMap, typename DistanceMap, 
         typename DependencyMap, typename PathCountMap, typename VertexIndexMap, 
         typename Buffer>
void 
non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg,
                                               const Graph& g, 
                                               CentralityMap centrality,
                                               EdgeCentralityMap edge_centrality_map,
                                               IncomingMap incoming, 
                                               DistanceMap distance, 
                                               DependencyMap dependency,     
                                               PathCountMap path_count,      
                                               VertexIndexMap vertex_index,
                                               Buffer sources)
{
  typedef typename property_traits<DistanceMap>::value_type distance_type;
  typedef static_property_map<distance_type> WeightMap;
  
  detail::graph::brandes_unweighted_shortest_paths shortest_paths;
  
  graph::parallel::detail::non_distributed_brandes_betweenness_centrality_impl(pg, g, centrality, 
                                                                               edge_centrality_map,
                                                                               incoming, distance,
                                                                               dependency, path_count,
                                                                               vertex_index, 
                                                                               shortest_paths,
                                                                               sources);
}

  
template<typename ProcessGroup, typename Graph, typename CentralityMap, 
         typename EdgeCentralityMap, typename IncomingMap, typename DistanceMap, 
         typename DependencyMap, typename PathCountMap, typename VertexIndexMap, 
         typename WeightMap, typename Buffer>
void 
non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg,
                                               const Graph& g, 
                                               CentralityMap centrality,
                                               EdgeCentralityMap edge_centrality_map,
                                               IncomingMap incoming, 
                                               DistanceMap distance, 
                                               DependencyMap dependency,
                                               PathCountMap path_count, 
                                               VertexIndexMap vertex_index,
                                               WeightMap weight_map,
                                               Buffer sources)
{
  detail::graph::brandes_dijkstra_shortest_paths<WeightMap> shortest_paths(weight_map);

  graph::parallel::detail::non_distributed_brandes_betweenness_centrality_impl(pg, g, centrality, 
                                                                               edge_centrality_map,
                                                                               incoming, distance,
                                                                               dependency, path_count,
                                                                               vertex_index, 
                                                                               shortest_paths,
                                                                               sources);
}

  template<typename ProcessGroup, typename Graph, typename CentralityMap, 
           typename EdgeCentralityMap, typename WeightMap, typename VertexIndexMap,
           typename Buffer>
  void 
  non_distributed_brandes_betweenness_centrality_dispatch2(const ProcessGroup& pg,
                                                           const Graph& g,
                                                           CentralityMap centrality,
                                                           EdgeCentralityMap edge_centrality_map,
                                                           WeightMap weight_map,
                                                           VertexIndexMap vertex_index,
                                                           Buffer sources)
  {
    typedef typename graph_traits<Graph>::degree_size_type degree_size_type;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
    typedef typename mpl::if_c<(is_same<CentralityMap, 
                                        dummy_property_map>::value),
                                         EdgeCentralityMap, 
                               CentralityMap>::type a_centrality_map;
    typedef typename property_traits<a_centrality_map>::value_type 
      centrality_type;

    typename graph_traits<Graph>::vertices_size_type V = num_vertices(g);
    
    std::vector<std::vector<edge_descriptor> > incoming(V);
    std::vector<centrality_type> distance(V);
    std::vector<centrality_type> dependency(V);
    std::vector<degree_size_type> path_count(V);

    non_distributed_brandes_betweenness_centrality(
      pg, g, centrality, edge_centrality_map,
      make_iterator_property_map(incoming.begin(), vertex_index),
      make_iterator_property_map(distance.begin(), vertex_index),
      make_iterator_property_map(dependency.begin(), vertex_index),
      make_iterator_property_map(path_count.begin(), vertex_index),
      vertex_index, weight_map, unwrap_ref(sources));
  }

  

  template<typename ProcessGroup, typename Graph, typename CentralityMap, 
           typename EdgeCentralityMap, typename VertexIndexMap, typename Buffer>
  void 
  non_distributed_brandes_betweenness_centrality_dispatch2(const ProcessGroup& pg,
                                                           const Graph& g,
                                                           CentralityMap centrality,
                                                           EdgeCentralityMap edge_centrality_map,
                                                           VertexIndexMap vertex_index,
                                                           Buffer sources)
  {
    typedef typename graph_traits<Graph>::degree_size_type degree_size_type;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;
    typedef typename mpl::if_c<(is_same<CentralityMap, 
                                        dummy_property_map>::value),
                                         EdgeCentralityMap, 
                               CentralityMap>::type a_centrality_map;
    typedef typename property_traits<a_centrality_map>::value_type 
      centrality_type;

    typename graph_traits<Graph>::vertices_size_type V = num_vertices(g);
    
    std::vector<std::vector<edge_descriptor> > incoming(V);
    std::vector<centrality_type> distance(V);
    std::vector<centrality_type> dependency(V);
    std::vector<degree_size_type> path_count(V);

    non_distributed_brandes_betweenness_centrality(
      pg, g, centrality, edge_centrality_map,
      make_iterator_property_map(incoming.begin(), vertex_index),
      make_iterator_property_map(distance.begin(), vertex_index),
      make_iterator_property_map(dependency.begin(), vertex_index),
      make_iterator_property_map(path_count.begin(), vertex_index),
      vertex_index, unwrap_ref(sources));
  }

    template<typename ProcessGroup, typename Graph, typename CentralityMap, 
             typename EdgeCentralityMap, typename VertexIndexMap, typename Buffer>
    static void 
    run(const ProcessGroup& pg, const Graph& g, CentralityMap centrality, 
        EdgeCentralityMap edge_centrality_map, VertexIndexMap vertex_index,
        Buffer sources, WeightMap weight_map)
    {
      non_distributed_brandes_betweenness_centrality_dispatch2(pg, g, centrality, edge_centrality_map,
                                                               weight_map, vertex_index, sources);
    }

    template<typename ProcessGroup, typename Graph, typename CentralityMap, 
             typename EdgeCentralityMap, typename VertexIndexMap, typename Buffer>
    static void 
    run(const ProcessGroup& pg, const Graph& g, CentralityMap centrality, 
        EdgeCentralityMap edge_centrality_map, VertexIndexMap vertex_index,
        Buffer sources, param_not_found)
    {
      non_distributed_brandes_betweenness_centrality_dispatch2(pg, g, centrality, edge_centrality_map,
                                                               vertex_index, sources);
    }


template<typename ProcessGroup, typename Graph, typename Param, typename Tag, typename Rest>
void 
non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg, const Graph& g, 
                                               const bgl_named_params<Param,Tag,Rest>& params)
{
  typedef bgl_named_params<Param,Tag,Rest> named_params;

  typedef queue<int> queue_t;
  queue_t q;

  typedef typename get_param_type<edge_weight_t, named_params>::type ew_param;
  typedef typename detail::choose_impl_result<mpl::true_, Graph, ew_param, edge_weight_t>::type ew;
  detail::graph::non_distributed_brandes_betweenness_centrality_dispatch1<ew>::run(
    pg, g, 
    choose_param(get_param(params, vertex_centrality), 
                 dummy_property_map()),
    choose_param(get_param(params, edge_centrality), 
                 dummy_property_map()),
    choose_const_pmap(get_param(params, vertex_index), g, vertex_index),
    choose_param(get_param(params, buffer_param_t()),  boost::ref(q)),
    choose_const_pmap(get_param(params, edge_weight), g, edge_weight));
}


template<typename ProcessGroup, typename Graph, typename CentralityMap>
void 
non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg, const Graph& g, 
                                               CentralityMap centrality)
{
  typedef queue<int> queue_t;
  queue_t q;

  detail::graph::non_distributed_brandes_betweenness_centrality_dispatch2(
    pg, g, centrality, dummy_property_map(), get(vertex_index, g), boost::ref(q));
}


template<typename ProcessGroup, typename Graph, typename CentralityMap, 
         typename Buffer>
void 
non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg, const Graph& g, 
                                               CentralityMap centrality, Buffer sources)
{
  detail::graph::non_distributed_brandes_betweenness_centrality_dispatch2(
    pg, g, centrality, dummy_property_map(), get(vertex_index, g), sources);
}


template<typename ProcessGroup, typename Graph, typename CentralityMap, 
         typename EdgeCentralityMap, typename Buffer>
void 
non_distributed_brandes_betweenness_centrality(const ProcessGroup& pg, const Graph& g, 
                                               CentralityMap centrality,
                                               EdgeCentralityMap edge_centrality_map, 
                                               Buffer sources)
{
  detail::graph::non_distributed_brandes_betweenness_centrality_dispatch2(
    pg, g, centrality, edge_centrality_map, get(vertex_index, g), sources);
}

template<typename Graph, typename CentralityMap>
typename property_traits<CentralityMap>::value_type
central_point_dominance(const Graph& g, CentralityMap centrality
                        BOOST_GRAPH_ENABLE_IF_MODELS_PARM(Graph,distributed_graph_tag))
{
  using std::max;

  typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
  typedef typename property_traits<CentralityMap>::value_type centrality_type;
  typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;

  typedef typename boost::graph::parallel::process_group_type<Graph>::type 
    process_group_type;
  process_group_type pg = boost::graph::parallel::process_group(g);

  vertices_size_type n = num_vertices(g);

  using boost::parallel::all_reduce;  
  n = all_reduce(pg, n, std::plus<vertices_size_type>());

  // Find max centrality
  centrality_type max_centrality(0);
  vertex_iterator v, v_end;
  for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
    max_centrality = (max)(max_centrality, get(centrality, *v));
  }

  // All reduce to get global max centrality
  max_centrality = all_reduce(pg, max_centrality, boost::parallel::maximum<centrality_type>());

  // Compute central point dominance
  centrality_type sum(0);
  for (boost::tie(v, v_end) = vertices(g); v != v_end; ++v) {
    sum += (max_centrality - get(centrality, *v));
  }

  sum = all_reduce(pg, sum, std::plus<centrality_type>());

  return sum/(n-1);
}


    do_has_same_supervertex(DisjointSets& dset, const Graph& g)
      : dset(dset), g(g) { }


    bool operator()(edge_descriptor e)
    { return dset.find_set(source(e, g)) == dset.find_set(target(e, g));    }

  template<typename DisjointSets, typename Graph>
  inline do_has_same_supervertex<DisjointSets, Graph>
  has_same_supervertex(DisjointSets& dset, const Graph& g)
  { return do_has_same_supervertex<DisjointSets, Graph>(dset, g); }

  template<typename ProcessGroup, typename Graph, typename WeightMap,
           typename OutputIterator, typename RankMap, typename ParentMap,
           typename SupervertexMap, typename Vertex, typename EdgeList>
  OutputIterator
  boruvka_merge_step(ProcessGroup pg, const Graph& g, WeightMap weight_map,
                     OutputIterator out,
                     disjoint_sets<RankMap, ParentMap>& dset,
                     SupervertexMap supervertex_map,
                     std::vector<Vertex>& supervertices,
                     EdgeList& edge_list)
  {
    typedef typename graph_traits<Graph>::vertex_descriptor
                                                           vertex_descriptor;
    typedef typename graph_traits<Graph>::vertices_size_type
                                                           vertices_size_type;
    typedef typename graph_traits<Graph>::edge_descriptor  edge_descriptor;
    typedef typename EdgeList::iterator                    edge_iterator;
    typedef typename property_traits<WeightMap>::value_type
                                                           weight_type;
    typedef boost::parallel::detail::untracked_pair<edge_descriptor, 
                                       weight_type>        w_edge;
    typedef typename property_traits<SupervertexMap>::value_type
                                                           supervertex_index;

    smaller_weighted_edge min_edge;
    weight_type inf = (std::numeric_limits<weight_type>::max)();

    // Renumber the supervertices
    for (std::size_t i = 0; i < supervertices.size(); ++i)
      put(supervertex_map, supervertices[i], i);

    // BSP-B1: Find local minimum-weight edges for each supervertex
    std::vector<w_edge> candidate_edges(supervertices.size(),
                                        w_edge(edge_descriptor(), inf));
    for (edge_iterator ei = edge_list.begin(); ei != edge_list.end(); ++ei) {
      weight_type w = get(weight_map, *ei);
      supervertex_index u =
        get(supervertex_map, dset.find_set(source(*ei, g)));
      supervertex_index v =
        get(supervertex_map, dset.find_set(target(*ei, g)));

      if (u != v) {
        candidate_edges[u] = min_edge(candidate_edges[u], w_edge(*ei, w));
        candidate_edges[v] = min_edge(candidate_edges[v], w_edge(*ei, w));
      }
    }

    // BSP-B2 (a): Compute global minimum edges for each supervertex
    all_reduce(pg,
               &candidate_edges[0],
               &candidate_edges[0] + candidate_edges.size(),
               &candidate_edges[0], min_edge);

    // BSP-B2 (b): Use the edges to compute sequentially the new
    // connected components and emit the edges.
    for (vertices_size_type i = 0; i < candidate_edges.size(); ++i) {
      if (candidate_edges[i].second != inf) {
        edge_descriptor e = candidate_edges[i].first;
        vertex_descriptor u = dset.find_set(source(e, g));
        vertex_descriptor v = dset.find_set(target(e, g));
        if (u != v) {
          // Emit the edge, but cache the weight so everyone knows it
          cache(weight_map, e, candidate_edges[i].second);
          *out++ = e;

          // Link the two supervertices
          dset.link(u, v);

          // Whichever vertex was reparented will be removed from the
          // list of supervertices.
          vertex_descriptor victim = u;
          if (dset.find_set(u) == u) victim = v;
          supervertices[get(supervertex_map, victim)] =
            graph_traits<Graph>::null_vertex();
        }
      }
    }

    // BSP-B3: Eliminate self-loops
    edge_list.erase(std::remove_if(edge_list.begin(), edge_list.end(),
                                   has_same_supervertex(dset, g)),
                    edge_list.end());

    // TBD: might also eliminate multiple edges between supervertices
    // when the edges do not have the best weight, but this is not
    // strictly necessary.

    // Eliminate supervertices that have been absorbed
    supervertices.erase(std::remove(supervertices.begin(),
                                    supervertices.end(),
                                    graph_traits<Graph>::null_vertex()),
                        supervertices.end());

    return out;
  }


    operator Edge() const { return e; }


  template<typename Graph>
  inline typename supervertex_edge_descriptor<Graph>::Vertex
  source(supervertex_edge_descriptor<Graph> se, const Graph&)
  { return se.source; }


  template<typename Graph>
  inline typename supervertex_edge_descriptor<Graph>::Vertex
  target(supervertex_edge_descriptor<Graph> se, const Graph&)
  { return se.target; }


    build_supervertex_edge_descriptor() : g(0), dsets(0) { }


    build_supervertex_edge_descriptor(const Graph& g, DisjointSets& dsets)
      : g(&g), dsets(&dsets) { }


    result_type operator()(argument_type e) const
    {
      result_type result;
      result.source = dsets->find_set(source(e, *g));
      result.target = dsets->find_set(target(e, *g));
      result.e = e;
      return result;
    }


  template<typename Graph, typename DisjointSets>
  inline build_supervertex_edge_descriptor<Graph, DisjointSets>
  make_supervertex_edge_descriptor(const Graph& g, DisjointSets& dsets)
  { return build_supervertex_edge_descriptor<Graph, DisjointSets>(g, dsets); }


    result_type operator()(argument_type x) const { return x; }

    is_not_msf_edge(const Graph& g, DisjointSets dset, EdgeMapper edge_mapper)
      : g(g), dset(dset), edge_mapper(edge_mapper) { }


    bool operator()(Edge e)
    {
      Vertex u = dset.find_set(source(edge_mapper(e), g));
      Vertex v = dset.find_set(target(edge_mapper(e), g));
      if (u == v) return true;
      else {
        dset.link(u, v);
        return false;
      }
    }


  template<typename Graph, typename ForwardIterator, typename EdgeList,
           typename EdgeMapper, typename RankMap, typename ParentMap>
  void
  sorted_mutating_kruskal(const Graph& g,
                          ForwardIterator first_vertex,
                          ForwardIterator last_vertex,
                          EdgeList& edge_list, EdgeMapper edge_mapper,
                          RankMap rank_map, ParentMap parent_map)
  {
    typedef disjoint_sets<RankMap, ParentMap> DisjointSets;

    // Build and initialize disjoint-sets data structure
    DisjointSets dset(rank_map, parent_map);
    for (ForwardIterator v = first_vertex; v != last_vertex; ++v)
      dset.make_set(*v);

    is_not_msf_edge<Graph, DisjointSets, EdgeMapper>
      remove_non_msf_edges(g, dset, edge_mapper);
    edge_list.erase(std::remove_if(edge_list.begin(), edge_list.end(),
                                   remove_non_msf_edges),
                    edge_list.end());
  }

  template<typename ProcessGroup, typename Graph, typename ForwardIterator,
           typename EdgeList, typename WeightMap, typename GlobalIndexMap,
           typename EdgeMapper>
  ProcessGroup
  merge_local_minimum_spanning_trees_step(ProcessGroup pg,
                                          const Graph& g,
                                          ForwardIterator first_vertex,
                                          ForwardIterator last_vertex,
                                          EdgeList& edge_list,
                                          WeightMap weight,
                                          GlobalIndexMap global_index,
                                          EdgeMapper edge_mapper,
                                          bool already_local_msf)
  {
    typedef typename ProcessGroup::process_id_type process_id_type;
    typedef typename EdgeList::value_type edge_descriptor;
    typedef typename property_traits<WeightMap>::value_type weight_type;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;

    // The tree factor, often called "D"
    process_id_type const tree_factor = 3;
    process_id_type num_procs = num_processes(pg);
    process_id_type id = process_id(pg);
    process_id_type procs_left = (num_procs + tree_factor - 1) / tree_factor;
    std::size_t n = std::size_t(last_vertex - first_vertex);

    if (!already_local_msf) {
      // Compute local minimum spanning forest. We only care about the
      // edges in the MSF, because only edges in the local MSF can be in
      // the global MSF.
      std::vector<std::size_t> ranks(n);
      std::vector<vertex_descriptor> parents(n);
      detail::sorted_mutating_kruskal
        (g, first_vertex, last_vertex,
         edge_list, edge_mapper,
         make_iterator_property_map(ranks.begin(), global_index),
         make_iterator_property_map(parents.begin(), global_index));
    }

    typedef std::pair<edge_descriptor, weight_type> w_edge;

    // Order edges based on their weights.
    indirect_cmp<WeightMap, std::less<weight_type> > cmp_edge_weight(weight);

    if (id < procs_left) {
      // The p/D processes that remain will receive local MSF edges from
      // D-1 other processes.
      synchronize(pg);
      for (process_id_type from_id = procs_left + id; from_id < num_procs;
           from_id += procs_left) {
        std::size_t num_incoming_edges;
        receive(pg, from_id, 0, num_incoming_edges);
        if (num_incoming_edges > 0) {
          std::vector<w_edge> incoming_edges(num_incoming_edges);
          receive(pg, from_id, 1, &incoming_edges[0], num_incoming_edges);

          edge_list.reserve(edge_list.size() + num_incoming_edges);
          for (std::size_t i = 0; i < num_incoming_edges; ++i) {
            cache(weight, incoming_edges[i].first, incoming_edges[i].second);
            edge_list.push_back(incoming_edges[i].first);
          }
          std::inplace_merge(edge_list.begin(),
                             edge_list.end() - num_incoming_edges,
                             edge_list.end(),
                             cmp_edge_weight);
        }
      }

      // Compute the local MSF from union of the edges in the MSFs of
      // all children.
      std::vector<std::size_t> ranks(n);
      std::vector<vertex_descriptor> parents(n);
      detail::sorted_mutating_kruskal
        (g, first_vertex, last_vertex,
         edge_list, edge_mapper,
         make_iterator_property_map(ranks.begin(), global_index),
         make_iterator_property_map(parents.begin(), global_index));
    } else {
      // The (D-1)p/D processes that are dropping out of further
      // computations merely send their MSF edges to their parent
      // process in the process tree.
      send(pg, id % procs_left, 0, edge_list.size());
      if (edge_list.size() > 0) {
        std::vector<w_edge> outgoing_edges;
        outgoing_edges.reserve(edge_list.size());
        for (std::size_t i = 0; i < edge_list.size(); ++i) {
          outgoing_edges.push_back(std::make_pair(edge_list[i],
                                                  get(weight, edge_list[i])));
        }
        send(pg, id % procs_left, 1, &outgoing_edges[0],
             outgoing_edges.size());
      }
      synchronize(pg);
    }

    // Return a process subgroup containing the p/D parent processes
    return process_subgroup(pg,
                            make_counting_iterator(process_id_type(0)),
                            make_counting_iterator(procs_left));
  }

template<typename Graph, typename WeightMap, typename OutputIterator,
         typename VertexIndexMap, typename RankMap, typename ParentMap,
         typename SupervertexMap>
OutputIterator
dense_boruvka_minimum_spanning_tree(const Graph& g, WeightMap weight_map,
                                    OutputIterator out,
                                    VertexIndexMap index_map,
                                    RankMap rank_map, ParentMap parent_map,
                                    SupervertexMap supervertex_map)
{
  using boost::graph::parallel::process_group;

  typedef typename graph_traits<Graph>::traversal_category traversal_category;

  BOOST_STATIC_ASSERT((is_convertible<traversal_category*,
                                      vertex_list_graph_tag*>::value));

  typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
  typedef typename graph_traits<Graph>::vertex_descriptor  vertex_descriptor;
  typedef typename graph_traits<Graph>::vertex_iterator    vertex_iterator;
  typedef typename graph_traits<Graph>::edge_descriptor    edge_descriptor;

  // Don't throw away cached edge weights
  weight_map.set_max_ghost_cells(0);

  // Initialize the disjoint sets structures
  disjoint_sets<RankMap, ParentMap> dset(rank_map, parent_map);
  vertex_iterator vi, vi_end;
  for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi)
    dset.make_set(*vi);

  std::vector<vertex_descriptor> supervertices;
  supervertices.assign(vertices(g).first, vertices(g).second);

  // Use Kruskal's algorithm to find the minimum spanning forest
  // considering only the local edges. The resulting edges are not
  // necessarily going to be in the final minimum spanning
  // forest. However, any edge not part of the local MSF cannot be a
  // part of the global MSF, so we should have eliminated some edges
  // from consideration.
  std::vector<edge_descriptor> edge_list;
  kruskal_minimum_spanning_tree
    (make_vertex_and_edge_range(g, vertices(g).first, vertices(g).second,
                                edges(g).first, edges(g).second),
     std::back_inserter(edge_list),
     boost::weight_map(weight_map).
     vertex_index_map(index_map));

  // While the number of supervertices is decreasing, keep executing
  // Boruvka steps to identify additional MSF edges. This loop will
  // execute log |V| times.
  vertices_size_type old_num_supervertices;
  do {
    old_num_supervertices = supervertices.size();
    out = detail::boruvka_merge_step(process_group(g), g,
                                     weight_map, out,
                                     dset, supervertex_map, supervertices,
                                     edge_list);
  } while (supervertices.size() < old_num_supervertices);

  return out;
}


template<typename Graph, typename WeightMap, typename OutputIterator,
         typename VertexIndex>
OutputIterator
dense_boruvka_minimum_spanning_tree(const Graph& g, WeightMap weight_map,
                                    OutputIterator out, VertexIndex i_map)
{
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;

  std::vector<std::size_t> ranks(num_vertices(g));
  std::vector<vertex_descriptor> parents(num_vertices(g));
  std::vector<std::size_t> supervertices(num_vertices(g));

  return dense_boruvka_minimum_spanning_tree
           (g, weight_map, out, i_map,
            make_iterator_property_map(ranks.begin(), i_map),
            make_iterator_property_map(parents.begin(), i_map),
            make_iterator_property_map(supervertices.begin(), i_map));
}


template<typename Graph, typename WeightMap, typename OutputIterator>
OutputIterator
dense_boruvka_minimum_spanning_tree(const Graph& g, WeightMap weight_map,
                                    OutputIterator out)
{
  return dense_boruvka_minimum_spanning_tree(g, weight_map, out,
                                             get(vertex_index, g));
}

template<typename Graph, typename WeightMap, typename OutputIterator,
         typename GlobalIndexMap>
OutputIterator
merge_local_minimum_spanning_trees(const Graph& g, WeightMap weight,
                                   OutputIterator out,
                                   GlobalIndexMap global_index)
{
  using boost::graph::parallel::process_group_type;
  using boost::graph::parallel::process_group;

  typedef typename graph_traits<Graph>::traversal_category traversal_category;

  BOOST_STATIC_ASSERT((is_convertible<traversal_category*,
                                      vertex_list_graph_tag*>::value));

  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  typedef typename graph_traits<Graph>::edge_descriptor edge_descriptor;

  // Don't throw away cached edge weights
  weight.set_max_ghost_cells(0);

  // Compute the initial local minimum spanning forests
  std::vector<edge_descriptor> edge_list;
  kruskal_minimum_spanning_tree
    (make_vertex_and_edge_range(g, vertices(g).first, vertices(g).second,
                                edges(g).first, edges(g).second),
     std::back_inserter(edge_list),
     boost::weight_map(weight).vertex_index_map(global_index));

  // Merge the local MSFs from p processes into p/D processes,
  // reducing the number of processes in each step. Continue looping
  // until either (a) the current process drops out or (b) only one
  // process remains in the group. This loop will execute log_D p
  // times.
  typename process_group_type<Graph>::type pg = process_group(g);
  while (pg && num_processes(pg) > 1) {
    pg = detail::merge_local_minimum_spanning_trees_step
           (pg, g, vertices(g).first, vertices(g).second,
            edge_list, weight, global_index,
            detail::identity_function<edge_descriptor>(), true);
  }

  // Only process 0 has the entire edge list, so emit it to the output
  // iterator.
  if (pg && process_id(pg) == 0) {
    out = std::copy(edge_list.begin(), edge_list.end(), out);
  }

  synchronize(process_group(g));
  return out;
}


template<typename Graph, typename WeightMap, typename OutputIterator>
inline OutputIterator
merge_local_minimum_spanning_trees(const Graph& g, WeightMap weight,
                                   OutputIterator out)
{
  return merge_local_minimum_spanning_trees(g, weight, out,
                                            get(vertex_index, g));
}

template<typename Graph, typename WeightMap, typename OutputIterator,
         typename GlobalIndexMap, typename RankMap, typename ParentMap,
         typename SupervertexMap>
OutputIterator
boruvka_then_merge(const Graph& g, WeightMap weight, OutputIterator out,
                   GlobalIndexMap index, RankMap rank_map,
                   ParentMap parent_map, SupervertexMap supervertex_map)
{
  using std::log;
  using boost::graph::parallel::process_group_type;
  using boost::graph::parallel::process_group;

  typedef typename graph_traits<Graph>::traversal_category traversal_category;

  BOOST_STATIC_ASSERT((is_convertible<traversal_category*,
                                      vertex_list_graph_tag*>::value));

  typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
  typedef typename graph_traits<Graph>::vertex_descriptor  vertex_descriptor;
  typedef typename graph_traits<Graph>::vertex_iterator    vertex_iterator;
  typedef typename graph_traits<Graph>::edge_descriptor    edge_descriptor;

  // Don't throw away cached edge weights
  weight.set_max_ghost_cells(0);

  // Compute the initial local minimum spanning forests
  std::vector<edge_descriptor> edge_list;
  kruskal_minimum_spanning_tree
    (make_vertex_and_edge_range(g, vertices(g).first, vertices(g).second,
                                edges(g).first, edges(g).second),
     std::back_inserter(edge_list),
     boost::weight_map(weight).
     vertex_index_map(index));

  // Initialize the disjoint sets structures for Boruvka steps
  disjoint_sets<RankMap, ParentMap> dset(rank_map, parent_map);
  vertex_iterator vi, vi_end;
  for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi)
    dset.make_set(*vi);

  // Construct the initial set of supervertices (all vertices)
  std::vector<vertex_descriptor> supervertices;
  supervertices.assign(vertices(g).first, vertices(g).second);

  // Continue performing Boruvka merge steps until the number of
  // supervertices reaches |V| / (log_D p)^2.
  const std::size_t tree_factor = 3; // TBD: same as above! should be param
  double log_d_p = log((double)num_processes(process_group(g)))
                 / log((double)tree_factor);
  vertices_size_type target_supervertices =
    vertices_size_type(num_vertices(g) / (log_d_p * log_d_p));
  vertices_size_type old_num_supervertices;
  while (supervertices.size() > target_supervertices) {
    old_num_supervertices = supervertices.size();
    out = detail::boruvka_merge_step(process_group(g), g,
                                     weight, out, dset,
                                     supervertex_map, supervertices,
                                     edge_list);
    if (supervertices.size() == old_num_supervertices)
      return out;
  }

  // Renumber the supervertices
  for (std::size_t i = 0; i < supervertices.size(); ++i)
    put(supervertex_map, supervertices[i], i);

  // Merge local MSFs on the supervertices. (D-1)p/D processors drop
  // out each iteration, so this loop executes log_D p times.
  typename process_group_type<Graph>::type pg = process_group(g);
  bool have_msf = false;
  while (pg && num_processes(pg) > 1) {
    pg = detail::merge_local_minimum_spanning_trees_step
           (pg, g, supervertices.begin(), supervertices.end(),
            edge_list, weight, supervertex_map,
            detail::make_supervertex_edge_descriptor(g, dset),
            have_msf);
    have_msf = true;
  }

  // Only process 0 has the complete list of _supervertex_ MST edges,
  // so emit those to the output iterator. This is not the complete
  // list of edges in the MSF, however: the Boruvka steps in the
  // beginning of the algorithm emitted any edges used to merge
  // supervertices.
  if (pg && process_id(pg) == 0)
    out = std::copy(edge_list.begin(), edge_list.end(), out);

  synchronize(process_group(g));
  return out;
}


template<typename Graph, typename WeightMap, typename OutputIterator,
         typename GlobalIndexMap>
inline OutputIterator
boruvka_then_merge(const Graph& g, WeightMap weight, OutputIterator out,
                    GlobalIndexMap index)
{
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
  std::vector<vertices_size_type> ranks(num_vertices(g));
  std::vector<vertex_descriptor> parents(num_vertices(g));
  std::vector<vertices_size_type> supervertex_indices(num_vertices(g));

  return boruvka_then_merge
           (g, weight, out, index,
            make_iterator_property_map(ranks.begin(), index),
            make_iterator_property_map(parents.begin(), index),
            make_iterator_property_map(supervertex_indices.begin(), index));
}


template<typename Graph, typename WeightMap, typename OutputIterator>
inline OutputIterator
boruvka_then_merge(const Graph& g, WeightMap weight, OutputIterator out)
{ return boruvka_then_merge(g, weight, out, get(vertex_index, g)); }

template<typename Graph, typename WeightMap, typename OutputIterator,
         typename GlobalIndexMap, typename RankMap, typename ParentMap,
         typename SupervertexMap>
OutputIterator
boruvka_mixed_merge(const Graph& g, WeightMap weight, OutputIterator out,
                    GlobalIndexMap index, RankMap rank_map,
                    ParentMap parent_map, SupervertexMap supervertex_map)
{
  using boost::graph::parallel::process_group_type;
  using boost::graph::parallel::process_group;

  typedef typename graph_traits<Graph>::traversal_category traversal_category;

  BOOST_STATIC_ASSERT((is_convertible<traversal_category*,
                                      vertex_list_graph_tag*>::value));

  typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
  typedef typename graph_traits<Graph>::vertex_descriptor  vertex_descriptor;
  typedef typename graph_traits<Graph>::vertex_iterator    vertex_iterator;
  typedef typename graph_traits<Graph>::edge_descriptor    edge_descriptor;

  // Don't throw away cached edge weights
  weight.set_max_ghost_cells(0);

  // Initialize the disjoint sets structures for Boruvka steps
  disjoint_sets<RankMap, ParentMap> dset(rank_map, parent_map);
  vertex_iterator vi, vi_end;
  for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi)
    dset.make_set(*vi);

  // Construct the initial set of supervertices (all vertices)
  std::vector<vertex_descriptor> supervertices;
  supervertices.assign(vertices(g).first, vertices(g).second);

  // Compute the initial local minimum spanning forests
  std::vector<edge_descriptor> edge_list;
  kruskal_minimum_spanning_tree
    (make_vertex_and_edge_range(g, vertices(g).first, vertices(g).second,
                                edges(g).first, edges(g).second),
     std::back_inserter(edge_list),
     boost::weight_map(weight).
     vertex_index_map(index));

  if (num_processes(process_group(g)) == 1) {
    return std::copy(edge_list.begin(), edge_list.end(), out);
  }

  // Like the merging local MSFs algorithm and the Boruvka-then-merge
  // algorithm, each iteration of this loop reduces the number of
  // processes by a constant factor D, and therefore we require log_D
  // p iterations. Note also that the number of edges in the edge list
  // decreases geometrically, giving us an efficient distributed MSF
  // algorithm.
  typename process_group_type<Graph>::type pg = process_group(g);
  vertices_size_type old_num_supervertices;
  while (pg && num_processes(pg) > 1) {
    // A single Boruvka step. If this doesn't change anything, we're done
    old_num_supervertices = supervertices.size();
    out = detail::boruvka_merge_step(pg, g, weight, out, dset,
                                     supervertex_map, supervertices,
                                     edge_list);
    if (old_num_supervertices == supervertices.size()) {
      edge_list.clear();
      break;
    }

    // Renumber the supervertices
    for (std::size_t i = 0; i < supervertices.size(); ++i)
      put(supervertex_map, supervertices[i], i);

    // A single merging of local MSTs, which reduces the number of
    // processes we're using by a constant factor D.
    pg = detail::merge_local_minimum_spanning_trees_step
           (pg, g, supervertices.begin(), supervertices.end(),
            edge_list, weight, supervertex_map,
            detail::make_supervertex_edge_descriptor(g, dset),
            true);

  }

  // Only process 0 has the complete edge list, so emit it for the
  // user. Note that list edge list only contains the MSF edges in the
  // final supervertex graph: all of the other edges were used to
  // merge supervertices and have been emitted by the Boruvka steps,
  // although only process 0 has received the complete set.
  if (pg && process_id(pg) == 0)
    out = std::copy(edge_list.begin(), edge_list.end(), out);

  synchronize(process_group(g));
  return out;
}


template<typename Graph, typename WeightMap, typename OutputIterator,
         typename GlobalIndexMap>
inline OutputIterator
boruvka_mixed_merge(const Graph& g, WeightMap weight, OutputIterator out,
                    GlobalIndexMap index)
{
  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
  typedef typename graph_traits<Graph>::vertices_size_type vertices_size_type;
  std::vector<vertices_size_type> ranks(num_vertices(g));
  std::vector<vertex_descriptor> parents(num_vertices(g));
  std::vector<vertices_size_type> supervertex_indices(num_vertices(g));

  return boruvka_mixed_merge
           (g, weight, out, index,
            make_iterator_property_map(ranks.begin(), index),
            make_iterator_property_map(parents.begin(), index),
            make_iterator_property_map(supervertex_indices.begin(), index));
}


template<typename Graph, typename WeightMap, typename OutputIterator>
inline OutputIterator
boruvka_mixed_merge(const Graph& g, WeightMap weight, OutputIterator out)
{ return boruvka_mixed_merge(g, weight, out, get(vertex_index, g)); }

      scalable_rmat_iterator()
        : gen(), done(true)
      { }


      reference operator*() const { return current; }

      pointer operator->() const { return &current; }

    
      scalable_rmat_iterator& operator++()
      {
          if (!values.empty()) {
              current = values.back();
              values.pop_back();
          } else 
              done = true;

          return *this;
      }


      scalable_rmat_iterator operator++(int)
      {
          scalable_rmat_iterator temp(*this);
          ++(*this);
          return temp;
      }


      bool operator==(const scalable_rmat_iterator& other) const
      {
          return values.empty() && other.values.empty() && done && other.done;
      }


      bool operator!=(const scalable_rmat_iterator& other) const
      { return !(*this == other); }

      parallel_dfs(const DistributedGraph& g, ColorMap color,
                   ParentMap parent, ExploreMap explore,
                   VertexIndexMap index_map, DFSVisitor vis)
        : g(g), color(color), parent(parent), explore(explore),
          index_map(index_map), vis(vis), pg(process_group(g)),
          owner(get(vertex_owner, g)), next_out_edge(num_vertices(g))
      { }


      void run(vertex_descriptor s)
      {
        vertex_iterator vi, vi_end;
        for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi) {
          put(color, *vi, Color::white());
          put(parent, *vi, *vi); 
          put(explore, *vi, *vi);
          next_out_edge[get(index_map, *vi)] = out_edges(*vi, g).first;
          vis.initialize_vertex(*vi, g);
        }

        vis.start_vertex(s, g);
        
        if (get(owner, s) == process_id(pg)) {
          send_oob(pg, get(owner, s), discover_msg, vertex_pair(s, s));
        }
        
        bool done = false;
        while (!done) {
          std::pair<process_id_type, int> msg = *pg.poll(true);

          switch (msg.second) {
          case discover_msg:
            {
              vertex_pair p;
              receive_oob(pg, msg.first, msg.second, p);

              if (p.first != p.second) {
                // delete j from nomessage(j)
                if (get(color, p.second) != Color::black())
                  local_put(color, p.second, Color::gray());

                if (recover(p)) break;
              }

              if (get(color, p.first) == Color::white()) {
                put(color, p.first, Color::gray());
                put(parent, p.first, p.second);

                vis.discover_vertex(p.first, g);

                if (shift_center_of_activity(p.first)) break;
                
                out_edge_iterator ei, ei_end;
                for (boost::tie(ei,ei_end) = out_edges(p.first, g); ei != ei_end; ++ei)
                {
                  // Notify everyone who may not know that the source
                  // vertex has been visited. They can then mark the
                  // corresponding color map entry gray.
                  if (get(parent, p.first) != target(*ei, g)
                      && get(explore, p.first) != target(*ei, g)) {
                    vertex_pair visit(target(*ei, g), p.first);
                    
                    send_oob(pg, get(owner, target(*ei, g)), visited_msg, visit);
                  }
                }
              }
            }
            break;
            
          case visited_msg:
            {
              vertex_pair p;
              receive_oob(pg, msg.first, msg.second, p);
              
              // delete j from nomessage(j)
              if (get(color, p.second) != Color::black())
                local_put(color, p.second, Color::gray());

              recover(p);
            }
            break;
            
          case return_msg:
            {
              vertex_pair p;
              receive_oob(pg, msg.first, msg.second, p);
              
              // delete j from nomessage(i)
              local_put(color, p.second, Color::black());

              shift_center_of_activity(p.first);
            }
            break;
            
          case done_msg:
            {
              receive_oob(pg, msg.first, msg.second, done);

              // Propagate done message downward in tree
              done = true;
              process_id_type id = process_id(pg);
              process_id_type left = 2*id + 1;
              process_id_type right = left + 1;
              if (left < num_processes(pg))
                send_oob(pg, left, done_msg, done);
              if (right < num_processes(pg))
                send_oob(pg, right, done_msg, done);
            }
            break;

          default:
            BOOST_ASSERT(false);
          }
        }
      }

      bool recover(const vertex_pair& p)
      {
        if (get(explore, p.first) == p.second) {
          return shift_center_of_activity(p.first);
        }
        else
          return false;
      }

      
      bool shift_center_of_activity(vertex_descriptor i)
      {
        for (out_edge_iterator ei = next_out_edge[get(index_map, i)],
                               ei_end = out_edges(i, g).second;
             ei != ei_end; ++ei) {
          vis.examine_edge(*ei, g);

          vertex_descriptor k = target(*ei, g);
          color_type target_color = get(color, k);
          if (target_color == Color::black()) vis.forward_or_cross_edge(*ei, g);
          else if (target_color == Color::gray()) vis.back_edge(*ei, g);
          else {
            put(explore, i, k);
            vis.tree_edge(*ei, g);
            vertex_pair p(k, i);
            send_oob(pg, get(owner, k), discover_msg, p);
            next_out_edge[get(index_map, i)] = ++ei;
            return false;
          } 
        }

        next_out_edge[get(index_map, i)] = out_edges(i, g).second;
        put(explore, i, i);
        put(color, i, Color::black());
        vis.finish_vertex(i, g);
          
        if (get(parent, i) == i) {
          send_oob(pg, 0, done_msg, true);
          return true;
        }
        else {
          vertex_pair ret(get(parent, i), i);
          send_oob(pg, get(owner, ret.first), return_msg, ret);
        }
        return false;
      }


  template<typename DistributedGraph, typename ColorMap, typename ParentMap,
           typename ExploreMap, typename VertexIndexMap, typename DFSVisitor>
  void
  tsin_depth_first_visit
    (const DistributedGraph& g,
     typename graph_traits<DistributedGraph>::vertex_descriptor s,
     DFSVisitor vis, ColorMap color, ParentMap parent, ExploreMap explore, 
     VertexIndexMap index_map)
  {
    typedef typename graph_traits<DistributedGraph>::directed_category
      directed_category;
    BOOST_STATIC_ASSERT(
      (is_convertible<directed_category, undirected_tag>::value));

    set_property_map_role(vertex_color, color);
    graph::distributed::detail::parallel_dfs
      <DistributedGraph, ColorMap, ParentMap, ExploreMap, VertexIndexMap, 
       DFSVisitor> do_dfs(g, color, parent, explore, index_map, vis);
    do_dfs.run(s);

    using boost::graph::parallel::process_group;
    synchronize(process_group(g));
  }

    
  template<typename DistributedGraph, typename DFSVisitor, 
           typename VertexIndexMap>
  void
  tsin_depth_first_visit
    (const DistributedGraph& g,
     typename graph_traits<DistributedGraph>::vertex_descriptor s,
     DFSVisitor vis,
     VertexIndexMap index_map)
  {
    typedef typename graph_traits<DistributedGraph>::vertex_descriptor
      vertex_descriptor;

    std::vector<default_color_type> colors(num_vertices(g));
    std::vector<vertex_descriptor> parent(num_vertices(g));
    std::vector<vertex_descriptor> explore(num_vertices(g));
    tsin_depth_first_visit
      (g, s,
       vis,
       make_iterator_property_map(colors.begin(), index_map),
       make_iterator_property_map(parent.begin(), index_map),
       make_iterator_property_map(explore.begin(), index_map),
       index_map);
  }


  template<typename DistributedGraph, typename DFSVisitor, 
           typename VertexIndexMap>
  void
  tsin_depth_first_visit
    (const DistributedGraph& g,
     typename graph_traits<DistributedGraph>::vertex_descriptor s,
     DFSVisitor vis)
  {
    tsin_depth_first_visit(g, s, vis, get(vertex_index, g));
  }


template<typename DistributedGraph, typename DFSVisitor>
void
depth_first_visit
  (const DistributedGraph& g,
   typename graph_traits<DistributedGraph>::vertex_descriptor s,
   DFSVisitor vis)
{
  graph::tsin_depth_first_visit(g, s, vis, get(vertex_index, g));
}

      template<typename DistributedGraph, typename DijkstraVisitor,
               typename PredecessorMap, typename DistanceMap, 
               typename WeightMap, typename IndexMap, typename ColorMap, 
               typename Compare, typename Combine, typename DistInf, 
               typename DistZero>
      static void 
      run(const DistributedGraph& g,
          typename graph_traits<DistributedGraph>::vertex_descriptor s,
          PredecessorMap predecessor, DistanceMap distance, 
          typename property_traits<DistanceMap>::value_type lookahead,
          WeightMap weight, IndexMap index_map, ColorMap color_map,
          Compare compare, Combine combine, DistInf inf, DistZero zero,
          DijkstraVisitor vis)
      {
        eager_dijkstra_shortest_paths(g, s, predecessor, distance, lookahead,
                                      weight, index_map, color_map, compare,
                                      combine, inf, zero, vis);
      }

      template<typename DistributedGraph, typename DijkstraVisitor,
               typename PredecessorMap, typename DistanceMap, 
               typename WeightMap, typename IndexMap, typename ColorMap, 
               typename Compare, typename Combine, typename DistInf, 
               typename DistZero>
      static void 
      run(const DistributedGraph& g,
          typename graph_traits<DistributedGraph>::vertex_descriptor s,
          PredecessorMap predecessor, DistanceMap distance, 
          ::boost::param_not_found,
          WeightMap weight, IndexMap index_map, ColorMap color_map,
          Compare compare, Combine combine, DistInf inf, DistZero zero,
          DijkstraVisitor vis)
      {
        crauser_et_al_shortest_paths(g, s, predecessor, distance, weight,
                                     index_map, color_map, compare, combine,
                                     inf, zero, vis);
      }

      template<typename DistributedGraph, typename DijkstraVisitor,
               typename PredecessorMap, typename DistanceMap, 
               typename Lookahead, typename WeightMap, typename IndexMap,
               typename Compare, typename Combine, 
               typename DistInf, typename DistZero>
      static void 
      run(const DistributedGraph& g,
          typename graph_traits<DistributedGraph>::vertex_descriptor s,
          PredecessorMap predecessor, DistanceMap distance, 
          Lookahead lookahead,
          WeightMap weight, IndexMap index_map, ColorMap color_map,
          Compare compare, Combine combine, DistInf inf, DistZero zero,
          DijkstraVisitor vis)
      {
        graph::detail::parallel_dijkstra_impl2<Lookahead>
          ::run(g, s, predecessor, distance, lookahead, weight, index_map,
                color_map, compare, combine, inf, zero, vis);
      }

      template<typename DistributedGraph, typename DijkstraVisitor,
               typename PredecessorMap, typename DistanceMap, 
               typename Lookahead, typename WeightMap, typename IndexMap,
               typename ColorMap, typename Compare, typename Combine, 
               typename DistInf, typename DistZero>
      static void 
      run_impl(const DistributedGraph& g,
               typename graph_traits<DistributedGraph>::vertex_descriptor s,
               PredecessorMap predecessor, DistanceMap distance, 
               Lookahead lookahead, WeightMap weight, IndexMap index_map, 
               ColorMap color_map, Compare compare, Combine combine, 
               DistInf inf, DistZero zero, DijkstraVisitor vis)
      {
        BGL_FORALL_VERTICES_T(u, g, DistributedGraph)
          BGL_FORALL_OUTEDGES_T(u, e, g, DistributedGraph)
            local_put(color_map, target(e, g), white_color);

        graph::detail::parallel_dijkstra_impl2<Lookahead>
          ::run(g, s, predecessor, distance, lookahead, weight, index_map,
                color_map, compare, combine, inf, zero, vis);
      }

      template<typename DistributedGraph, typename DijkstraVisitor,
               typename PredecessorMap, typename DistanceMap, 
               typename Lookahead, typename WeightMap, typename IndexMap,
               typename Compare, typename Combine, 
               typename DistInf, typename DistZero>
      static void 
      run(const DistributedGraph& g,
          typename graph_traits<DistributedGraph>::vertex_descriptor s,
          PredecessorMap predecessor, DistanceMap distance, 
          Lookahead lookahead, WeightMap weight, IndexMap index_map, 
          ::boost::param_not_found,
          Compare compare, Combine combine, DistInf inf, DistZero zero,
          DijkstraVisitor vis)
      {
        typedef typename graph_traits<DistributedGraph>::vertices_size_type
          vertices_size_type;

        vertices_size_type n = num_vertices(g);
        std::vector<default_color_type> colors(n, white_color);

        run_impl(g, s, predecessor, distance, lookahead, weight, index_map,
                 make_iterator_property_map(colors.begin(), index_map),
                 compare, combine, inf, zero, vis);
      }

  template<typename DistributedGraph, typename DijkstraVisitor,
           typename PredecessorMap, typename DistanceMap,
           typename WeightMap, typename IndexMap, typename Compare,
           typename Combine, typename DistInf, typename DistZero,
           typename T, typename Tag, typename Base>
  inline
  void
  dijkstra_shortest_paths
    (const DistributedGraph& g,
     typename graph_traits<DistributedGraph>::vertex_descriptor s,
     PredecessorMap predecessor, DistanceMap distance, WeightMap weight,
     IndexMap index_map,
     Compare compare, Combine combine, DistInf inf, DistZero zero,
     DijkstraVisitor vis,
     const bgl_named_params<T, Tag, Base>& params
     BOOST_GRAPH_ENABLE_IF_MODELS_PARM(DistributedGraph,distributed_graph_tag))
  {
    typedef typename graph_traits<DistributedGraph>::vertices_size_type
      vertices_size_type;

    // Build a distributed property map for vertex colors, if we need it
    bool use_default_color_map 
      = is_default_param(get_param(params, vertex_color));
    vertices_size_type n = use_default_color_map? num_vertices(g) : 1;
    std::vector<default_color_type> color(n, white_color);
    typedef iterator_property_map<std::vector<default_color_type>::iterator,
                                  IndexMap> DefColorMap;
    DefColorMap color_map(color.begin(), index_map);

    typedef typename get_param_type< vertex_color_t, bgl_named_params<T, Tag, Base> >::type color_map_type;

    graph::detail::parallel_dijkstra_impl<color_map_type>
      ::run(g, s, predecessor, distance, 
            get_param(params, lookahead_t()),
            weight, index_map,
            get_param(params, vertex_color),
            compare, combine, inf, zero, vis);
  }


  parallel_dijkstra_bfs_visitor(UniformCostVisitor vis, Queue& Q,
                                WeightMap w, PredecessorMap p, DistanceMap d,
                                BinaryFunction combine, BinaryPredicate compare,
                                distance_type zero)
    : m_vis(vis), m_Q(Q), m_weight(w), m_predecessor(p), m_distance(d),
      m_combine(combine), m_compare(compare), m_zero(zero)  { }


  template <class Vertex, class Graph>
  void initialize_vertex(Vertex u, Graph& g)
    { m_vis.initialize_vertex(u, g); }

  template <class Vertex, class Graph>
  void discover_vertex(Vertex u, Graph& g) { m_vis.discover_vertex(u, g); }

  template <class Vertex, class Graph>
  void examine_vertex(Vertex u, Graph& g) { m_vis.examine_vertex(u, g); }

  template <class Edge, class Graph>
  void examine_edge(Edge e, Graph& g) {
    if (m_compare(get(m_weight, e), m_zero))
        boost::throw_exception(negative_edge());

    m_vis.examine_edge(e, g);

    boost::parallel::caching_property_map<PredecessorMap> c_pred(m_predecessor);
    boost::parallel::caching_property_map<DistanceMap> c_dist(m_distance);

    distance_type old_distance = get(c_dist, target(e, g));

    bool m_decreased = relax(e, g, m_weight, c_pred, c_dist,
                             m_combine, m_compare);

    /* On x86 Linux with optimization, we sometimes get into a
       horrible case where m_decreased is true but the distance hasn't
       actually changed. This occurs when the comparison inside
       relax() occurs with the 80-bit precision of the x87 floating
       point unit, but the difference is lost when the resulting
       values are written back to lower-precision memory (e.g., a
       double). With the eager Dijkstra's implementation, this results
       in looping. */
    if (m_decreased && old_distance != get(c_dist, target(e, g))) {
      m_Q.update(target(e, g));
      m_vis.edge_relaxed(e, g);
    } else
      m_vis.edge_not_relaxed(e, g);
  }

  template <class Vertex, class Graph>
  void finish_vertex(Vertex u, Graph& g) { m_vis.finish_vertex(u, g); }


    lookahead_dijkstra_queue(const Graph& g,
                             const Combine& combine,
                             const Compare& compare,
                             const VertexIndexMap& id,
                             const DistanceMap& distance_map,
                             const PredecessorMap& predecessor_map,
                             distance_type lookahead)
      : inherited(boost::graph::parallel::process_group(g), get(vertex_owner, g)),
        queue(num_vertices(g), queue_compare_type(distance_map, compare), id),
        distance_map(distance_map),
        predecessor_map(predecessor_map),
        min_distance(0),
        lookahead(lookahead)
#ifdef PBGL_ACCOUNTING
        , local_deletions(0)
#endif
    { }


    void push(const value_type& x)
    {
      msg_value_type msg_value = 
        msg_value_creator::create(get(distance_map, x),
                                  predecessor_value(get(predecessor_map, x)));
      inherited::update(x, msg_value);
    }

    
    void update(const value_type& x) { push(x); }


    void pop() 
    { 
      queue.pop(); 
#ifdef PBGL_ACCOUNTING
      ++local_deletions;
#endif
    }


    value_type&       top()       { return queue.top(); }

    const value_type& top() const { return queue.top(); }


    bool empty()
    {
      inherited::collect();

      // If there are no suitable messages, wait until we get something
      while (!has_suitable_vertex()) {
        if (do_synchronize()) return true;
      }

      // Return true only if nobody has any messages; false if we
      // have suitable messages
      return false;
    }

    vertex_descriptor predecessor_value(vertex_descriptor v) const
    { return v; }


    bool has_suitable_vertex() const
    {
      return (!queue.empty() 
              && get(distance_map, queue.top()) <= min_distance + lookahead);
    }


    bool do_synchronize()
    {
      using boost::parallel::all_reduce;
      using boost::parallel::minimum;

      inherited::synchronize();

      // TBD: could use combine here, but then we need to stop using
      // minimum<distance_type>() as the function object.
      distance_type local_distance = 
        queue.empty()? (std::numeric_limits<distance_type>::max)()
        : get(distance_map, queue.top());

      all_reduce(this->process_group, &local_distance, &local_distance + 1,
                 &min_distance, minimum<distance_type>());

#ifdef PBGL_ACCOUNTING
      std::size_t deletions = 0;
      all_reduce(this->process_group, &local_deletions, &local_deletions + 1,
                 &deletions, std::plus<std::size_t>());
      if (process_id(this->process_group) == 0)
        eager_dijkstra_shortest_paths_stats.deleted_vertices
          .push_back(deletions);
      local_deletions = 0;
      BOOST_ASSERT(deletions > 0);
#endif

      return min_distance == (std::numeric_limits<distance_type>::max)();
    }

    void 
    receive_update(process_id_type source, vertex_descriptor vertex,
                   distance_type distance)
    {
      // Update the queue if the received distance is better than
      // the distance we know locally
      if (distance <= get(distance_map, vertex)) {

        // Update the local distance map
        put(distance_map, vertex, distance);

        bool is_in_queue = queue.contains(vertex);

        if (!is_in_queue) 
          queue.push(vertex);
        else 
          queue.update(vertex);
      }
    }


template<typename DistributedGraph, typename DijkstraVisitor,
         typename PredecessorMap, typename DistanceMap, typename WeightMap,
         typename IndexMap, typename ColorMap, typename Compare,
         typename Combine, typename DistInf, typename DistZero>
void
eager_dijkstra_shortest_paths
  (const DistributedGraph& g,
   typename graph_traits<DistributedGraph>::vertex_descriptor s,
   PredecessorMap predecessor, DistanceMap distance, 
   typename property_traits<DistanceMap>::value_type lookahead,
   WeightMap weight, IndexMap index_map, ColorMap color_map,
   Compare compare, Combine combine, DistInf inf, DistZero zero,
   DijkstraVisitor vis)
{
  typedef typename boost::graph::parallel::process_group_type<DistributedGraph>::type
    process_group_type;
  typedef typename graph_traits<DistributedGraph>::vertex_descriptor
    Vertex;
  typedef typename graph_traits<DistributedGraph>::vertices_size_type
    vertices_size_type;

#ifdef PBGL_ACCOUNTING
  eager_dijkstra_shortest_paths_stats.deleted_vertices.clear();
  eager_dijkstra_shortest_paths_stats.lookahead = lookahead;
  eager_dijkstra_shortest_paths_stats.execution_time = accounting::get_time();
#endif

  // Initialize local portion of property maps
  typename graph_traits<DistributedGraph>::vertex_iterator ui, ui_end;
  for (boost::tie(ui, ui_end) = vertices(g); ui != ui_end; ++ui) {
    put(distance, *ui, inf);
    put(predecessor, *ui, *ui);
  }
  put(distance, s, zero);

  // Dijkstra Queue
  typedef detail::lookahead_dijkstra_queue
            <DistributedGraph, Combine, Compare, IndexMap, DistanceMap,
             PredecessorMap> Queue;

  Queue Q(g, combine, compare, index_map, distance, 
          predecessor, lookahead);

  // Parallel Dijkstra visitor
  detail::parallel_dijkstra_bfs_visitor
    <DijkstraVisitor, Queue, WeightMap, PredecessorMap, DistanceMap, Combine, 
     Compare> bfs_vis(vis, Q, weight, predecessor, distance, combine, compare,
                      zero);

  set_property_map_role(vertex_color, color_map);
  set_property_map_role(vertex_distance, distance);

  breadth_first_search(g, s, Q, bfs_vis, color_map);

#ifdef PBGL_ACCOUNTING
  eager_dijkstra_shortest_paths_stats.execution_time = 
    accounting::get_time() 
    - eager_dijkstra_shortest_paths_stats.execution_time;
#endif
}


template<typename DistributedGraph, typename DijkstraVisitor,
         typename PredecessorMap, typename DistanceMap, typename WeightMap>
void
eager_dijkstra_shortest_paths
  (const DistributedGraph& g,
   typename graph_traits<DistributedGraph>::vertex_descriptor s,
   PredecessorMap predecessor, DistanceMap distance, 
   typename property_traits<DistanceMap>::value_type lookahead,
   WeightMap weight)
{
  typedef typename property_traits<DistanceMap>::value_type distance_type;

  std::vector<default_color_type> colors(num_vertices(g), white_color);

  eager_dijkstra_shortest_paths(g, s, predecessor, distance, lookahead, weight,
                                get(vertex_index, g),
                                make_iterator_property_map(&colors[0],
                                                           get(vertex_index, 
                                                               g)),
                                std::less<distance_type>(),
                                closed_plus<distance_type>(),
                                distance_type(),
                                (std::numeric_limits<distance_type>::max)(),
                                dijkstra_visitor<>());
}


template<typename DistributedGraph, typename DijkstraVisitor,
         typename PredecessorMap, typename DistanceMap>
void
eager_dijkstra_shortest_paths
  (const DistributedGraph& g,
   typename graph_traits<DistributedGraph>::vertex_descriptor s,
   PredecessorMap predecessor, DistanceMap distance,
   typename property_traits<DistanceMap>::value_type lookahead)
{
  eager_dijkstra_shortest_paths(g, s, predecessor, distance, lookahead,
                               get(edge_weight, g));
}

      component_value_allocator(int num, int size) :
        last(0), num(num), size(size)
      {
      }


      component_value_type allocate(void)
      {
        component_value_type ret = num + (last * size);
        last++;
        return ret;
      }

      collision_map() : num_unique(0)
      {
      }

      void add(const component_value_type &a) 
      {
        BOOST_ASSERT(collisions.count(a) == 0);
        collisions[a] = a;
      }

      void add(const component_value_type &a, const component_value_type &b)
      {
        component_value_type high, low, tmp;
        if (a > b) {
          high = a;
          low = b;
        } else {
          high = b;
          low = a;
        }

        if (collisions.count(high) != 0 && collisions[high] != low) {
          tmp = collisions[high];
          if (tmp > low) {
            collisions[tmp] = low;
            collisions[high] = low;
          } else {
            collisions[low] = tmp;
            collisions[high] = tmp;
          }
        } else {
          collisions[high] = low;
        }

      }

      component_value_type update(component_value_type a)
      {
        BOOST_ASSERT(num_unique > 0);
        BOOST_ASSERT(collisions.count(a) != 0);
        return collisions[a];
      }

      void uniqify(void)
      {
        typename std::map<component_value_type, component_value_type>::iterator i, end;

        end = collisions.end();
        for (i = collisions.begin() ; i != end ; ++i) {
          if (i->first == i->second) {
            num_unique++;
          } else {
            i->second = collisions[i->second];
          }
        }
      }

      int unique(void)
      {
        BOOST_ASSERT(num_unique > 0);
        return num_unique;
      }


      update_reducer(work_queue *q,
                     cc_ps_detail::collision_map<component_value_type> *collisions, 
                     processor_id_type pg_id) :
        q(q), collisions(collisions), pg_id(pg_id)
      {
      }

      template<typename K>
      component_value_type operator()(const K&) const
      { 
        return component_value_type(0); 
      }

      component_value_type operator()(const vertex_descriptor &v,
                                      const component_value_type& current,
                                      const component_value_type& update) const
      {
        const component_value_type max = (std::numeric_limits<component_value_type>::max)();
        component_value_type ret = current;

        if (max == current) {
          q->push(v);
          ret = update;
        } else if (current != update) {
          collisions->add(current, update);
        }

        return ret;
      }

      template<typename K>
      component_value_type operator()(const K& v, 
                                      const component_value_type& current, 
                                      const component_value_type& update) const
      {
          return (*this)(vertex_descriptor(pg_id, v), current, update);
      }



  template<typename Graph, typename ComponentMap>
  typename property_traits<ComponentMap>::value_type
  connected_components_ps(const Graph& g, ComponentMap c)
  {
    using boost::graph::parallel::process_group;

    typedef typename property_traits<ComponentMap>::value_type component_value_type;
    typedef typename graph_traits<Graph>::vertex_iterator vertex_iterator;
    typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;
    typedef typename boost::graph::parallel::process_group_type<Graph>
      ::type process_group_type;
    typedef typename process_group_type::process_id_type process_id_type;
    typedef typename property_map<Graph, vertex_owner_t>
      ::const_type vertex_owner_map;
    typedef std::queue<vertex_descriptor> work_queue;

    static const component_value_type max_component = 
      (std::numeric_limits<component_value_type>::max)();
    typename property_map<Graph, vertex_owner_t>::const_type
      owner = get(vertex_owner, g);

    // standard who am i? stuff
    process_group_type pg = process_group(g);
    process_id_type id = process_id(pg);

    // Initialize every vertex to have infinite component number
    BGL_FORALL_VERTICES_T(v, g, Graph) put(c, v, max_component);

    vertex_iterator current, end;
    boost::tie(current, end) = vertices(g);

    cc_ps_detail::component_value_allocator<component_value_type> cva(process_id(pg), num_processes(pg));
    cc_ps_detail::collision_map<component_value_type> collisions;
    work_queue q;  // this is intentionally a local data structure
    c.set_reduce(cc_ps_detail::update_reducer<ComponentMap, work_queue>(&q, &collisions, id));

    // add starting work
    while (true) {
        bool useful_found = false;
        component_value_type val = cva.allocate();
        put(c, *current, val);
        collisions.add(val);
        q.push(*current);
        if (0 != out_degree(*current, g)) useful_found = true;
        ++current;
        if (useful_found) break;
    }

    // Run the loop until everyone in the system is done
    bool global_done = false;
    while (!global_done) {

      // drain queue of work for this superstep
      while (!q.empty()) {
        vertex_descriptor v = q.front();
        q.pop();
        // iterate through outedges of the vertex currently being
        // examined, setting their component to our component.  There
        // is no way to end up in the queue without having a component
        // number already.

        BGL_FORALL_ADJ_T(v, peer, g, Graph) {
          component_value_type my_component = get(c, v);

          // update other vertex with our component information.
          // Resolver will handle remote collisions as well as whether
          // to put the vertex on the work queue or not.  We have to
          // handle local collisions and work queue management
          if (id == get(owner, peer)) {
            if (max_component == get(c, peer)) {
              put(c, peer, my_component);
              q.push(peer);
            } else if (my_component != get(c, peer)) {
              collisions.add(my_component, get(c, peer));
            }
          } else {
            put(c, peer, my_component);
          }
        }
      }

      // synchronize / start a new superstep.
      synchronize(pg);
      global_done = all_reduce(pg, (q.empty() && (current == end)), boost::parallel::minimum<bool>());

      // If the queue is currently empty, add something to do to start
      // the current superstep (supersteps start at the sync, not at
      // the top of the while loop as one might expect).  Down at the
      // bottom of the while loop so that not everyone starts the
      // algorithm with something to do, to try to reduce component
      // name conflicts
      if (q.empty()) {
        bool useful_found = false;
        for ( ; current != end && !useful_found ; ++current) {
          if (max_component == get(c, *current)) {
            component_value_type val = cva.allocate();
            put(c, *current, val);
            collisions.add(val);
            q.push(*current);
            if (0 != out_degree(*current, g)) useful_found = true;
          }
        }
      }
    }

    // share component mappings
    std::vector<component_value_type> global;
    std::vector<component_value_type> mine = collisions.serialize();
    all_gather(pg, mine.begin(), mine.end(), global);
    for (size_t i = 0 ; i < global.size() ; i += 2) {
      collisions.add(global[i], global[i + 1]);
    }
    collisions.uniqify();

    // update the component mappings
    BGL_FORALL_VERTICES_T(v, g, Graph) {
      put(c, v, collisions.update(get(c, v)));
    }

    return collisions.unique();
  }

  explicit
  filtered_queue(const buffer_type& buffer = buffer_type(),
                 const predicate_type& pred = predicate_type())
    : buffer(buffer), pred(pred) {}

  void push(const value_type& x)  { if (pred(x)) buffer.push(x); }

  void pop()                      { buffer.pop(); }

  value_type& top()               { return buffer.top(); }

  const value_type& top() const   { return buffer.top(); }

  size_type size() const          { return buffer.size(); }

  bool empty() const              { return buffer.empty(); }

  buffer_type& base()             { return buffer; }

  const buffer_type& base() const { return buffer; }

  void swap(filtered_queue& other)
  {
    using std::swap;
    swap(buffer, other.buffer);
    swap(pred, other.pred);
  }

template<typename Buffer, typename Predicate>
inline filtered_queue<Buffer, Predicate>
make_filtered_queue(const Buffer& buffer, const Predicate& pred)
{ return filtered_queue<Buffer, Predicate>(buffer, pred); }

template<typename Buffer, typename Predicate>
inline void
swap(filtered_queue<Buffer, Predicate>& x,
     filtered_queue<Buffer, Predicate>& y)
{
  x.swap(y);
}


template<typename ProcessGroup>
void do_synchronize(ProcessGroup& pg)
{ 
  using boost::parallel::synchronize;
  synchronize(pg);
}

    explicit 
    handle_messages(remote_update_set* self, const ProcessGroup& pg)
      : self(self), update_sizes(num_processes(pg), 0) { }


    void operator()(process_id_type source, int tag) 
    { 
      switch(tag) {
      case msg_num_updates:
        {
          // Receive the # of updates
          updates_size_type num_updates;
          receive(self->process_group, source, tag, num_updates);

          update_sizes[source] = num_updates;
        }
        break;

      case msg_updates:
        {
          updates_size_type num_updates = update_sizes[source];
          BOOST_ASSERT(num_updates);

          // Receive the actual updates
          std::vector<updates_pair_type> updates(num_updates);
          receive(self->process_group, source, msg_updates, &updates[0],
                  num_updates);
          
          // Send updates to derived "receive_update" member
          Derived* derived = static_cast<Derived*>(self);
          for (updates_size_type u = 0; u < num_updates; ++u)
            derived->receive_update(source, updates[u].first, updates[u].second);

          update_sizes[source] = 0;
        }
        break;
      };
    }

  remote_update_set(const ProcessGroup& pg, const OwnerMap& owner)
    : process_group(pg, handle_messages(this, pg)),
      updates(num_processes(pg)), owner(owner) { 
    }



  void update(const Key& key, const Value& value)
  { 
    if (get(owner, key) == process_id(process_group)) {
      Derived* derived = static_cast<Derived*>(this);
      derived->receive_update(get(owner, key), key, value);
    }
    else {
      updates[get(owner, key)].push_back(std::make_pair(key, value));
    }
  }


  void collect() { }


  void synchronize()
  {
    // Emit all updates and then remove them
    process_id_type num_processes = updates.size();
    for (process_id_type p = 0; p < num_processes; ++p) {
      if (!updates[p].empty()) {
        send(process_group, p, msg_num_updates, updates[p].size());
        send(process_group, p, msg_updates, 
             &updates[p].front(), updates[p].size());
        updates[p].clear();
      }
    }
    
    do_synchronize(process_group);
  }

    explicit handle_messages(remote_update_set* self, const ProcessGroup& pg) 
      : self(self)
    { update_sizes.resize(num_processes(pg), 0); }


    void operator()(process_id_type source, int tag) 
    { 
      // Receive the # of updates
      BOOST_ASSERT(tag == msg_update);
      update_pair_type update;
      receive(self->process_group, source, tag, update);
      
      // Send update to derived "receive_update" member
      Derived* derived = static_cast<Derived*>(self);
      derived->receive_update(source, update.first, update.second);
    }

  remote_update_set(const ProcessGroup& pg, const OwnerMap& owner)
    : process_group(pg, handle_messages(this, pg)), owner(owner) { }


  void update(const Key& key, const Value& value)
  { 
    if (get(owner, key) == process_id(process_group)) {
      Derived* derived = static_cast<Derived*>(this);
      derived->receive_update(get(owner, key), key, value);
    }
    else
      send(process_group, get(owner, key), msg_update, 
           update_pair_type(key, value));
  }


  void collect() 
  { 
    typedef std::pair<process_id_type, int> probe_type;
    handle_messages handler(this, process_group);
    while (optional<probe_type> stp = probe(process_group))
      if (stp->second == msg_update) handler(stp->first, stp->second);
  }


  void synchronize()
  {
    do_synchronize(process_group);
  }

  explicit tag_allocator(int top_tag) : bottom(top_tag) { }

  operator int() const { return tag_; }

  token(tag_allocator* allocator, int tag) 
    : allocator(allocator), tag_(tag) { }


  static type create(distance_type dist, predecessor_type pred)
  { return std::make_pair(dist, pred); }


  static type create(type dist, vertex_descriptor) { return dist; }


  redistributed_descriptor() { }


  redistributed_descriptor(const Descriptor& v, const DescriptorProperty& p)
    : inherited(p), descriptor(v) { }


  template<typename Archiver>
  void serialize(Archiver& ar, unsigned int /*version*/)
  {
    ar & boost::serialization::base_object<inherited>(*this) 
       & unsafe_serialize(descriptor);
  }


  target_migrated_t(VertexProcessorMap vertex_to_processor, const Graph& g)
    : vertex_to_processor(vertex_to_processor), g(g) { }


  bool operator()(Edge e) const
  {
    typedef global_descriptor<Vertex> DVertex;
    processor_id_type owner = get(edge_target_processor_id, g, e);
    return get(vertex_to_processor, DVertex(owner, target(e, g))) != owner;
  }


template<typename VertexProcessorMap, typename Graph>
inline target_migrated_t<VertexProcessorMap, Graph>
target_migrated(VertexProcessorMap vertex_to_processor, const Graph& g)
{ return target_migrated_t<VertexProcessorMap, Graph>(vertex_to_processor, g); }


  source_migrated_t(VertexProcessorMap vertex_to_processor, const Graph& g)
    : vertex_to_processor(vertex_to_processor), g(g) { }


  bool operator()(stored_in_edge<Edge> e) const
  {
    return get(vertex_to_processor, DVertex(e.source_processor, source(e.e, g)))
      != e.source_processor;
  }


template<typename VertexProcessorMap, typename Graph>
inline source_migrated_t<VertexProcessorMap, Graph>
source_migrated(VertexProcessorMap vertex_to_processor, const Graph& g)
{ return source_migrated_t<VertexProcessorMap, Graph>(vertex_to_processor, g); }


  source_or_target_migrated_t(VertexProcessorMap vertex_to_processor,
                              const Graph& g)
    : vertex_to_processor(vertex_to_processor), g(g) { }


  bool operator()(Edge e) const
  {
    return get(vertex_to_processor, source(e, g)) != source(e, g).owner
      || get(vertex_to_processor, target(e, g)) != target(e, g).owner;
  }


template<typename VertexProcessorMap, typename Graph>
inline source_or_target_migrated_t<VertexProcessorMap, Graph>
source_or_target_migrated(VertexProcessorMap vertex_to_processor,
const Graph& g)
{
  typedef source_or_target_migrated_t<VertexProcessorMap, Graph> result_type;
  return result_type(vertex_to_processor, g);
}

      serializable_local_descriptor()
      {}


      serializable_local_descriptor(Local local)
        : local(local)
      {}


      operator Local const&() const
      {
          return local;
      }


      bool operator==(serializable_local_descriptor const& other) const
      {
          return local == other.local;
      }


      bool operator<(serializable_local_descriptor const& other) const
      {
          return local < other.local;
      }


      template <class Archive>
      void serialize(Archive& ar, const unsigned int /*version*/)
      {
          ar & unsafe_serialize(local);
      }

      pending_edge(
          Vertex source, Vertex target
        , Properties properties, void* property_ptr
      )
        : source(source)
        , target(target)
        , properties(properties)
        , property_ptr(property_ptr)
      {}


  inline bool is_digit(char c)
  {
      return (bool)std::isdigit(c);
  }


  template <class Archive, class Tag, class T, class Base>
  void maybe_load_properties(
      Archive& ar, char const* name, property<Tag, T, Base>& properties)
  {
      ar >> serialization::make_nvp(name, get_property_value(properties, Tag()));
      maybe_load_properties(ar, name, static_cast<Base&>(properties));
  }


  template <class Archive, typename Bundle>
  void maybe_load_properties(
      Archive& ar, char const* name, Bundle& bundle)
  {
    ar >> serialization::make_nvp(name, bundle);
    no_property prop;
    maybe_load_properties(ar, name, prop);
  }


      graph_loader(Graph& g, Archive& ar)
        : m_g(g)
        , m_ar(ar)
        , m_pg(g.process_group())
        , m_requested_vertices(num_processes(m_pg))
        , m_remote_vertices(num_processes(m_pg))
        , m_property_ptrs(num_processes(m_pg))
      {
          g.clear();
          load_prefix();
          load_vertices();
          load_edges();
          ar >> make_nvp("distribution", m_g.distribution());
      }

          pending_in_edge(
              vertex_descriptor u, vertex_descriptor v, void* property_ptr
          )
            : u(u)
            , v(v)
            , property_ptr(property_ptr)
          {}


      bool is_root() const
      {
          return process_id(m_pg) == 0;
      }


      void* maybe_load_property_ptr(directedS) { return 0; }


  template <class Graph, class Archive, class VertexListS>
  void graph_loader<Graph, Archive, VertexListS>::load_prefix()
  {
      typename process_group_type::process_size_type num_processes_;
      m_ar >> make_nvp("num_processes", num_processes_);

      if (num_processes_ != num_processes(m_pg))
          boost::throw_exception(std::runtime_error("number of processes mismatch"));

      process_id_type old_id;
      m_ar >> make_nvp("id", old_id);

      std::vector<typename Graph::distribution_type::size_type> mapping;
      m_ar >> make_nvp("mapping", mapping);

      // Fetch all the old id's from the other processes.
      std::vector<process_id_type> old_ids;
      all_gather(m_pg, &old_id, &old_id+1, old_ids);

      m_id_mapping.resize(num_processes(m_pg), -1);

      for (process_id_type i = 0; i < num_processes(m_pg); ++i)
      {
# ifdef PBGL_SERIALIZE_DEBUG
          if (is_root())
              std::cout << i << " used to be " << old_ids[i] << "\n"; 
# endif
          BOOST_ASSERT(m_id_mapping[old_ids[i]] == -1);
          m_id_mapping[old_ids[i]] = i;
      }

      std::vector<typename Graph::distribution_type::size_type> new_mapping(
          mapping.size());

      for (int i = 0; i < num_processes(m_pg); ++i)
      {
          new_mapping[mapping[old_ids[i]]] = i;
      }

      m_g.distribution().assign_mapping(
          new_mapping.begin(), new_mapping.end());
  }


  template <class Graph, class Archive, class VertexListS>
  void graph_loader<Graph, Archive, VertexListS>::load_vertices()
  {
      int V;
      m_ar >> BOOST_SERIALIZATION_NVP(V); 

# ifdef PBGL_SERIALIZE_DEBUG
      if (is_root())
          std::cout << "Loading vertices\n";
# endif

      for (int i = 0; i < V; ++i)
      {
          maybe_load_and_store_local_vertex(vertex_list_selector());
      }
  }

  template <class Anything>
  void graph_loader<Graph, Archive, VertexListS>::maybe_load_and_store_local_vertex(Anything)
  {
      // Load the original vertex descriptor
      local_vertex_descriptor local;
      m_ar >> make_nvp("local", unsafe_serialize(local)); 

      // Load the properties
      vertex_property_type property;
      detail::parallel::maybe_load_properties(m_ar, "vertex_property",
                          property);

      // Add the vertex
      vertex_descriptor v(process_id(m_pg), add_vertex(property, m_g.base()));

      if (m_g.on_add_vertex)
        m_g.on_add_vertex(v, m_g);

      // Create the mapping from the "old" local descriptor to the new
      // local descriptor.
      m_local_vertices[local] = v.local;
  }


  template <class Graph, class Archive, class VertexListS>
  void graph_loader<Graph, Archive, VertexListS>::load_edges()
  {
      int E;
      m_ar >> BOOST_SERIALIZATION_NVP(E);

# ifdef PBGL_SERIALIZE_DEBUG
      if (is_root())
          std::cout << "Loading edges\n";
# endif

      for (int i = 0; i < E; ++i)
      {
          local_vertex_descriptor local_src;
          process_id_type target_owner;
          local_vertex_descriptor local_tgt;

          m_ar >> make_nvp("source", unsafe_serialize(local_src)); 
          m_ar >> make_nvp("target_owner", target_owner); 
          m_ar >> make_nvp("target", unsafe_serialize(local_tgt)); 

          process_id_type new_src_owner = process_id(m_pg);
          process_id_type new_tgt_owner = m_id_mapping[target_owner];

          vertex_descriptor source(new_src_owner, local_src);
          vertex_descriptor target(new_tgt_owner, local_tgt);

          edge_property_type properties;
          detail::parallel::maybe_load_properties(m_ar, "edge_property", properties);

          void* property_ptr = maybe_load_property_ptr(directed_selector());
          add_edge(source, target, properties, property_ptr, vertex_list_selector());
      }

      load_in_edges(directed_selector());
      commit_pending_edges(vertex_list_selector());
  }

  template <class Anything>
  void graph_loader<Graph, Archive, VertexListS>::add_pending_in_edge(
      vertex_descriptor u, vertex_descriptor v, void* property_ptr, Anything)
  {
      // u and v represent the out-edge here, meaning v is local
      // to us, and u is always remote.
      m_pending_in_edges.push_back(pending_in_edge(u,v,property_ptr));
      add_remote_vertex_request(v, u, bidirectionalS());
  }
 
  template <class Anything>
  void graph_loader<Graph, Archive, VertexListS>::add_edge(
      vertex_descriptor u, vertex_descriptor v
    , edge_property_type const& property, void* property_ptr, Anything)
  {
      m_pending_edges.push_back(pending_edge_type(u, v, property, property_ptr));
      add_remote_vertex_request(u, v, directed_selector());
  }


  template <class Graph, class Archive, class VertexListS>
  void graph_loader<Graph, Archive, VertexListS>::resolve_property_ptrs()
  {
# ifdef PBGL_SERIALIZE_DEBUG
      if (is_root())
          std::cout << "Resolving property pointers\n";
# endif

      for (int i = 0; i < num_processes(m_pg); ++i)
      {
          std::sort(
              m_property_ptrs[i].begin(), m_property_ptrs[i].end());
      }

      boost::parallel::inplace_all_to_all(m_pg, m_property_ptrs);
  }

  template <class Anything>
  void graph_loader<Graph, Archive, VertexListS>::commit_pending_edges(Anything)
  {
      resolve_remote_vertices(directed_selector());

      BOOST_FOREACH(pending_edge_type const& e, m_pending_edges)
      {
          vertex_descriptor u = resolve_remote_vertex(e.source);
          vertex_descriptor v = resolve_remote_vertex(e.target);
          add_edge(u, v, e.properties, e.property_ptr, vecS());
      }

      commit_pending_in_edges(directed_selector());
  }


  template <class Graph, class Archive, class VertexListS>
  typename graph_loader<Graph, Archive, VertexListS>::vertex_descriptor 
  graph_loader<Graph, Archive, VertexListS>::resolve_remote_vertex(
      vertex_descriptor u) const
  {
      if (owner(u) == process_id(m_pg))
      { 
          return vertex_descriptor(
              process_id(m_pg), m_local_vertices.find(local(u))->second);
      }

      typename std::vector<serializable_vertex_descriptor>::const_iterator 
          i = std::lower_bound(
              m_requested_vertices[owner(u)].begin()
            , m_requested_vertices[owner(u)].end()
            , serializable_vertex_descriptor(local(u))
          );

      if (i == m_requested_vertices[owner(u)].end()
          || *i != local(u))
      {
          BOOST_ASSERT(false);
      }

      local_vertex_descriptor local =
          m_remote_vertices[owner(u)][m_requested_vertices[owner(u)].end() - i];
      return vertex_descriptor(owner(u), local);
  }

  template <class Anything>
  typename graph_loader<Graph, Archive, VertexListS>::vertex_descriptor 
  graph_loader<Graph, Archive, VertexListS>::resolve_remote_vertex(
      vertex_descriptor u, Anything) const
  {
      return resolve_remote_vertex(u);
  }


template <class Archive, class D>
void maybe_save_local_descriptor(Archive& ar, D const&, vecS)
{}


template <class Archive, class D, class NotVecS>
void maybe_save_local_descriptor(Archive& ar, D const& d, NotVecS)
{
    ar << serialization::make_nvp(
        "local", unsafe_serialize(const_cast<D&>(d)));
}


template <class Archive>
void maybe_save_properties(
    Archive&, char const*, no_property const&)
{}


template <class Archive, class Graph>
void save_in_edges(Archive& ar, Graph const& g, directedS)
{}


template <class Archive, class Edge>
void maybe_save_property_ptr(Archive&, Edge const&, directedS)
{}


template <class Archive, class Graph, class DirectedS>
void save_edges(Archive& ar, Graph const& g, DirectedS)
{
    typedef typename Graph::process_group_type
        process_group_type;
    typedef typename process_group_type::process_id_type
        process_id_type;
    typedef typename graph_traits<
        Graph>::vertex_descriptor vertex_descriptor;
    typedef typename graph_traits<
        Graph>::edge_descriptor edge_descriptor;

    typedef typename Graph::edge_property_type edge_property_type;

    int E = num_edges(g);
    ar << BOOST_SERIALIZATION_NVP(E);

    // For *directed* graphs, we can just save
    // the edge list and be done.
    //
    // For *bidirectional* graphs, we need to also
    // save the "vertex_in_edges" property map,
    // because it might contain in-edges that
    // are not locally owned.
    BGL_FORALL_EDGES_T(e, g, Graph) 
    {
        vertex_descriptor src(source(e, g));
        vertex_descriptor tgt(target(e, g));

        typename vertex_descriptor::local_descriptor_type
            local_u(local(src));
        typename vertex_descriptor::local_descriptor_type
            local_v(local(tgt));

        process_id_type target_owner = owner(tgt);

        using serialization::make_nvp;

        ar << make_nvp("source", unsafe_serialize(local_u)); 
        ar << make_nvp("target_owner", target_owner); 
        ar << make_nvp("target", unsafe_serialize(local_v)); 

        maybe_save_properties(
            ar, "edge_property"
          , static_cast<edge_property_type const&>(get(edge_all_t(), g, e))
        );

        maybe_save_property_ptr(ar, e, DirectedS());
    }

    save_in_edges(ar, g, DirectedS());
}


      template<typename Key>
      Color operator()(const Key&) const { return traits::white(); }

      
      template<typename Key>
      Color operator()(const Key&, Color local, Color remote) const {
        if (local == traits::white()) return remote;
        else if (remote == traits::black()) return remote;
        else return local;
      }


      template<typename Key>
      T operator()(const Key&) const { return (std::numeric_limits<T>::max)(); }


      template<typename Key>
      T operator()(const Key&, T x, T y) const { return x < y? x : y; }


      T operator()(T key) const { return key; }

      T operator()(T key, T, T y) const { return y; }


  template<typename Property, typename PropertyMap>
  inline void set_property_map_role(Property p, PropertyMap pm)
  {
    typedef typename property_traits<PropertyMap>::value_type value_type;
    typedef property_reduce<Property> property_red;
    typedef typename property_red::template apply<value_type> reduce;

    pm.set_reduce(reduce());
  }

    const T& operator()(const T& x, const T& y) const { return x < y? x : y; }

    const T& operator()(const T& x, const T& y) const { return x < y? y : x; }

    const T operator()(const T& x, const T& y) const { return x + y; }


  template<typename ProcessGroup, typename T, typename BinaryOperation>
  inline T
  all_reduce(ProcessGroup pg, const T& value, BinaryOperation bin_op)
  {
    T result;
    all_reduce(pg,
               const_cast<T*>(&value), const_cast<T*>(&value+1),
               &result, bin_op);
    return result;
  }


  template<typename ProcessGroup, typename T, typename BinaryOperation>
  inline T
  scan(ProcessGroup pg, const T& value, BinaryOperation bin_op)
  {
    T result;
    scan(pg,
         const_cast<T*>(&value), const_cast<T*>(&value+1),
         &result, bin_op);
    return result;
  }


template<typename T>
inline typename process_group_type<T>::type
process_group(const T& x)
{ return x.process_group(); }

template<typename Container>
inline typename process_group_type<Container>::type
process_group_adl(const Container& container)
{
  return process_group(container);
}

    virtual ~basic_distribution() {}

    explicit poly_distribution(const Distribution& distribution)
      : distribution_(distribution) { }


    virtual size_type block_size(process_id_type id, size_type n) const
    { return distribution_.block_size(id, n); }


    virtual process_id_type in_process(size_type i) const
    { return distribution_(i); }


    virtual size_type local(size_type i) const
    { return distribution_.local(i); }


    virtual size_type global(size_type n) const
    { return distribution_.global(n); }


    virtual size_type global(process_id_type id, size_type n) const
    { return distribution_.global(id, n); }


    virtual void* address() { return &distribution_; }

    virtual const void* address() const { return &distribution_; }

    virtual const std::type_info& type() const { return typeid(Distribution); }

  variant_distribution() { }


  template<typename Distribution>
  variant_distribution(const Distribution& distribution)
    : distribution_(new poly_distribution<Distribution>(distribution)) { }


  size_type block_size(process_id_type id, size_type n) const
  { return distribution_->block_size(id, n); }

  
  process_id_type operator()(size_type i) const
  { return distribution_->in_process(i); }

  
  size_type local(size_type i) const
  { return distribution_->local(i); }

  
  size_type global(size_type n) const
  { return distribution_->global(n); }


  size_type global(process_id_type id, size_type n) const
  { return distribution_->global(id, n); }


  operator bool() const { return distribution_; }


  void clear() { distribution_.reset(); }


  template<typename T>
  T* as()
  {
    if (distribution_->type() == typeid(T))
      return static_cast<T*>(distribution_->address());
    else
      return 0;
  }


  template<typename T>
  const T* as() const
  {
    if (distribution_->type() == typeid(T))
      return static_cast<T*>(distribution_->address());
    else
      return 0;
  }

  template<typename LinearProcessGroup>
  explicit block(const LinearProcessGroup& pg, std::size_t n) 
    : id(process_id(pg)), p(num_processes(pg)), n(n) { }

  template<typename SizeType>
  SizeType block_size(SizeType n) const
  { return (n / p) + ((std::size_t)(n % p) > id? 1 : 0); }

  template<typename SizeType, typename ProcessID>
  SizeType block_size(ProcessID id, SizeType n) const
  { return (n / p) + ((ProcessID)(n % p) > id? 1 : 0); }

  template<typename SizeType>
  SizeType operator()(SizeType i) const
  { 
    SizeType cutoff_processor = n % p;
    SizeType cutoff = cutoff_processor * (n / p + 1);

    if (i < cutoff) return i / (n / p + 1);
    else return cutoff_processor + (i - cutoff) / (n / p);
  }

  template<typename ID>
  std::size_t start(ID id) const
  {
    std::size_t estimate = id * (n / p + 1);
    ID cutoff_processor = n % p;
    if (id < cutoff_processor) return estimate;
    else return estimate - (id - cutoff_processor);
  }

  template<typename SizeType>
  SizeType local(SizeType i) const
  { 
    SizeType owner = (*this)(i);
    return i - start(owner);
  }

  template<typename SizeType>
  SizeType global(SizeType i) const
  { return global(id, i); }

  template<typename ProcessID, typename SizeType>
  SizeType global(ProcessID id, SizeType i) const
  { return i + start(id); }


  template<typename LinearProcessGroup>
  explicit uneven_block(const LinearProcessGroup& pg, const std::vector<std::size_t>& local_sizes) 
    : id(process_id(pg)), p(num_processes(pg)), local_sizes(local_sizes)
  { 
    BOOST_ASSERT(local_sizes.size() == p);
    local_starts.resize(p + 1);
    local_starts[0] = 0;
    std::partial_sum(local_sizes.begin(), local_sizes.end(), &local_starts[1]);
    n = local_starts[p];
  }

  template<typename SizeType>
  SizeType block_size(SizeType) const
  { return local_sizes[id]; }

  template<typename SizeType, typename ProcessID>
  SizeType block_size(ProcessID id, SizeType) const
  { return local_sizes[id]; }

  template<typename SizeType>
  SizeType operator()(SizeType i) const
  {
    BOOST_ASSERT (i >= (SizeType) 0 && i < (SizeType) n); // check for valid range
    size_vector::const_iterator lb = std::lower_bound(local_starts.begin(), local_starts.end(), (std::size_t) i);
    return ((SizeType)(*lb) == i ? lb : --lb) - local_starts.begin();
  }

  template<typename ID>
  std::size_t start(ID id) const 
  {
    return local_starts[id];
  }

  template<typename SizeType>
  SizeType local(SizeType i) const
  { 
    SizeType owner = (*this)(i);
    return i - start(owner);
  }

  template<typename SizeType>
  SizeType global(SizeType i) const
  { return global(id, i); }

  template<typename ProcessID, typename SizeType>
  SizeType global(ProcessID id, SizeType i) const
  { return i + start(id); }

  template<typename LinearProcessGroup>
  explicit oned_block_cyclic(const LinearProcessGroup& pg, std::size_t size)
    : id(process_id(pg)), p(num_processes(pg)), size(size) { }

      
  template<typename SizeType>
  SizeType block_size(SizeType n) const
  { 
    return block_size(id, n);
  }


  template<typename SizeType, typename ProcessID>
  SizeType block_size(ProcessID id, SizeType n) const
  {
    SizeType all_blocks = n / size;
    SizeType extra_elements = n % size;
    SizeType everyone_gets = all_blocks / p;
    SizeType extra_blocks = all_blocks % p;
    SizeType my_blocks = everyone_gets + (p < extra_blocks? 1 : 0);
    SizeType my_elements = my_blocks * size 
                         + (p == extra_blocks? extra_elements : 0);
    return my_elements;
  }


  template<typename SizeType>
  SizeType operator()(SizeType i) const
  { 
    return (i / size) % p;
  }


  template<typename SizeType>
  SizeType local(SizeType i) const
  { 
    return ((i / size) / p) * size + i % size;
  }


  template<typename SizeType>
  SizeType global(SizeType i) const
  { return global(id, i); }


  template<typename ProcessID, typename SizeType>
  SizeType global(ProcessID id, SizeType i) const
  { 
    return ((i / size) * p + id) * size + i % size;
  }

  template<typename LinearProcessGroup>
  explicit twod_block_cyclic(const LinearProcessGroup& pg,
                             std::size_t block_rows, std::size_t block_columns,
                             std::size_t data_columns_per_row)
    : id(process_id(pg)), p(num_processes(pg)), 
      block_rows(block_rows), block_columns(block_columns), 
      data_columns_per_row(data_columns_per_row)
  { }

      
  template<typename SizeType>
  SizeType block_size(SizeType n) const
  { 
    return block_size(id, n);
  }


  template<typename SizeType, typename ProcessID>
  SizeType block_size(ProcessID id, SizeType n) const
  {
    // TBD: This is really lame :)
    int result = -1;
    while (n > 0) {
      --n;
      if ((*this)(n) == id && (int)local(n) > result) result = local(n);
    }
    ++result;

    //    std::cerr << "Block size of id " << id << " is " << result << std::endl;
    return result;
  }


  template<typename SizeType>
  SizeType operator()(SizeType i) const
  { 
    SizeType result = get_block_num(i) % p;
    //    std::cerr << "Item " << i << " goes on processor " << result << std::endl;
    return result;
  }


  template<typename SizeType>
  SizeType local(SizeType i) const
  { 
    // Compute the start of the block
    std::size_t block_num = get_block_num(i);
    //    std::cerr << "Item " << i << " is in block #" << block_num << std::endl;

    std::size_t local_block_num = block_num / p;
    std::size_t block_start = local_block_num * block_rows * block_columns;

    // Compute the offset into the block 
    std::size_t data_row = i / data_columns_per_row;
    std::size_t data_col = i % data_columns_per_row;
    std::size_t block_offset = (data_row % block_rows) * block_columns 
                             + (data_col % block_columns);    

    //    std::cerr << "Item " << i << " maps to local index " << block_start+block_offset << std::endl;
    return block_start + block_offset;
  }


  template<typename SizeType>
  SizeType global(SizeType i) const
  { 
    // Compute the (global) block in which this element resides
    SizeType local_block_num = i / (block_rows * block_columns);
    SizeType block_offset = i % (block_rows * block_columns);
    SizeType block_num = local_block_num * p + id;

    // Compute the position of the start of the block (globally)
    SizeType block_start = block_num * block_rows * block_columns;

    std::cerr << "Block " << block_num << " starts at index " << block_start
              << std::endl;

    // Compute the row and column of this block
    SizeType block_row = block_num / (data_columns_per_row / block_columns);
    SizeType block_col = block_num % (data_columns_per_row / block_columns);

    SizeType row_in_block = block_offset / block_columns;
    SizeType col_in_block = block_offset % block_columns;

    std::cerr << "Local index " << i << " is in block at row " << block_row
              << ", column " << block_col << ", in-block row " << row_in_block
              << ", in-block col " << col_in_block << std::endl;

    SizeType result = block_row * block_rows + block_col * block_columns
                    + row_in_block * block_rows + col_in_block;


    std::cerr << "global(" << i << "@" << id << ") = " << result 
              << " =? " << local(result) << std::endl;
    BOOST_ASSERT(i == local(result));
    return result;
  }

  template<typename SizeType>
  std::size_t get_block_num(SizeType i) const
  {
    std::size_t data_row = i / data_columns_per_row;
    std::size_t data_col = i % data_columns_per_row;
    std::size_t block_row = data_row / block_rows;
    std::size_t block_col = data_col / block_columns;
    std::size_t blocks_in_row = data_columns_per_row / block_columns;
    std::size_t block_num = block_col * blocks_in_row + block_row;
    return block_num;
  }

    explicit random_int(RandomNumberGen& gen) : gen(gen) { }


    template<typename T>
    T operator()(T n) const
    {
      uniform_int<T> distrib(0, n-1);
      return distrib(gen);
    }

  template<typename LinearProcessGroup, typename RandomNumberGen>
  explicit twod_random(const LinearProcessGroup& pg,
                       std::size_t block_rows, std::size_t block_columns,
                       std::size_t data_columns_per_row,
                       std::size_t n,
                       RandomNumberGen& gen)
    : id(process_id(pg)), p(num_processes(pg)), 
      block_rows(block_rows), block_columns(block_columns), 
      data_columns_per_row(data_columns_per_row),
      global_to_local(n / (block_rows * block_columns))
  { 
    std::copy(make_counting_iterator(std::size_t(0)),
              make_counting_iterator(global_to_local.size()),
              global_to_local.begin());

    random_int<RandomNumberGen> rand(gen);
    std::random_shuffle(global_to_local.begin(), global_to_local.end(), rand);
  }

      
  template<typename SizeType>
  SizeType block_size(SizeType n) const
  { 
    return block_size(id, n);
  }


  template<typename SizeType, typename ProcessID>
  SizeType block_size(ProcessID id, SizeType n) const
  {
    // TBD: This is really lame :)
    int result = -1;
    while (n > 0) {
      --n;
      if ((*this)(n) == id && (int)local(n) > result) result = local(n);
    }
    ++result;

    //    std::cerr << "Block size of id " << id << " is " << result << std::endl;
    return result;
  }


  template<typename SizeType>
  SizeType operator()(SizeType i) const
  { 
    SizeType result = get_block_num(i) % p;
    //    std::cerr << "Item " << i << " goes on processor " << result << std::endl;
    return result;
  }


  template<typename SizeType>
  SizeType local(SizeType i) const
  { 
    // Compute the start of the block
    std::size_t block_num = get_block_num(i);
    //    std::cerr << "Item " << i << " is in block #" << block_num << std::endl;

    std::size_t local_block_num = block_num / p;
    std::size_t block_start = local_block_num * block_rows * block_columns;

    // Compute the offset into the block 
    std::size_t data_row = i / data_columns_per_row;
    std::size_t data_col = i % data_columns_per_row;
    std::size_t block_offset = (data_row % block_rows) * block_columns 
                             + (data_col % block_columns);    

    //    std::cerr << "Item " << i << " maps to local index " << block_start+block_offset << std::endl;
    return block_start + block_offset;
  }

  template<typename SizeType>
  std::size_t get_block_num(SizeType i) const
  {
    std::size_t data_row = i / data_columns_per_row;
    std::size_t data_col = i % data_columns_per_row;
    std::size_t block_row = data_row / block_rows;
    std::size_t block_col = data_col / block_columns;
    std::size_t blocks_in_row = data_columns_per_row / block_columns;
    std::size_t block_num = block_col * blocks_in_row + block_row;
    return global_to_local[block_num];
  }

    explicit random_int(RandomNumberGen& gen) : gen(gen) { }


    template<typename T>
    T operator()(T n) const
    {
      uniform_int<T> distrib(0, n-1);
      return distrib(gen);
    }

  template<typename LinearProcessGroup, typename RandomNumberGen>
  random_distribution(const LinearProcessGroup& pg, RandomNumberGen& gen,
                      std::size_t n)
    : base(pg, n), local_to_global(n), global_to_local(n)
  {
    std::copy(make_counting_iterator(std::size_t(0)),
              make_counting_iterator(n),
              local_to_global.begin());

    random_int<RandomNumberGen> rand(gen);
    std::random_shuffle(local_to_global.begin(), local_to_global.end(), rand);
                        

    for (std::vector<std::size_t>::size_type i = 0; i < n; ++i)
      global_to_local[local_to_global[i]] = i;
  }


  template<typename SizeType>
  SizeType block_size(SizeType n) const
  { return base.block_size(n); }


  template<typename SizeType, typename ProcessID>
  SizeType block_size(ProcessID id, SizeType n) const
  { return base.block_size(id, n); }


  template<typename SizeType>
  SizeType operator()(SizeType i) const
  {
    return base(global_to_local[i]);
  }


  template<typename SizeType>
  SizeType local(SizeType i) const
  { 
    return base.local(global_to_local[i]);
  }


  template<typename ProcessID, typename SizeType>
  SizeType global(ProcessID p, SizeType i) const
  { 
    return local_to_global[base.global(p, i)];
  }


  template<typename SizeType>
  SizeType global(SizeType i) const
  { 
    return local_to_global[base.global(i)];
  }

  simple_trigger_t(Class* self, 
                   Result (Class::*pmf)(int, int, const T&, 
                                        trigger_receive_context))
    : self(self), pmf(pmf) { }


  Result 
  operator()(int source, int tag, const T& data, 
             trigger_receive_context context) const
  {
    return (self->*pmf)(source, tag, data, context);
  }

template<typename ProcessGroup, typename Class, typename T>
inline void 
simple_trigger(ProcessGroup& pg, int tag, Class* self, 
               void (Class::*pmf)(int source, int tag, const T& data, 
                                  trigger_receive_context context), int)
{
  pg.template trigger<T>(tag, 
                         detail::simple_trigger_t<Class, T, void>(self, pmf));
}

template<typename ProcessGroup, typename Class, typename T, typename Result>
inline void 
simple_trigger(ProcessGroup& pg, int tag, Class* self, 
               Result (Class::*pmf)(int source, int tag, const T& data, 
                                    trigger_receive_context context), long)
{
  pg.template trigger_with_reply<T>
    (tag, detail::simple_trigger_t<Class, T, Result>(self, pmf));
}

template<typename ProcessGroup, typename Class, typename T, typename Result>
inline void 
simple_trigger(ProcessGroup& pg, int tag, Class* self, 
               Result (Class::*pmf)(int source, int tag, const T& data, 
                                    trigger_receive_context context))
{
        // We pass 0 (an int) to help VC++ disambiguate calls to simple_trigger 
        // with Result=void.
        simple_trigger(pg, tag, self, pmf, 0); 
}

  template<typename Key>
  T operator()(const Key&) const { return T(); }

  template<typename Key>
  const T& operator()(const Key&, const T&, const T& remote) const 
  { return remote; }
 

template<typename ProcessGroup, typename T>
// where {LinearProcessGroup<ProcessGroup>, MessagingProcessGroup<ProcessGroup>}
void 
inplace_all_to_all(ProcessGroup pg, 
                   const std::vector<std::vector<T> >& outgoing,
                   std::vector<std::vector<T> >& incoming)
{
  typedef typename std::vector<T>::size_type size_type;

  typedef typename ProcessGroup::process_size_type process_size_type;
  typedef typename ProcessGroup::process_id_type process_id_type;

  process_size_type p = num_processes(pg);

  // Make sure there are no straggling messages
  synchronize(pg);

  // Send along the count (always) and the data (if count > 0)
  for (process_id_type dest = 0; dest < p; ++dest) {
    if (dest != process_id(pg)) {
      send(pg, dest, 0, outgoing[dest].size());
      if (!outgoing[dest].empty())
        send(pg, dest, 1, &outgoing[dest].front(), outgoing[dest].size());
    }
  }

  // Make sure all of the data gets transferred
  synchronize(pg);

  // Receive the sizes and data
  for (process_id_type source = 0; source < p; ++source) {
    if (source != process_id(pg)) {
      size_type size;
      receive(pg, source, 0, size);
      incoming[source].resize(size);
      if (size > 0)
        receive(pg, source, 1, &incoming[source].front(), size);
    } else if (&incoming != &outgoing) {
      incoming[source] = outgoing[source];
    }
  }
}

  maybe_store_property() {}

  maybe_store_property(const Property& p) : p(p) {}


  Property&       get_property()       { return p; }

  const Property& get_property() const { return p; }


  template<typename Archiver>
  void serialize(Archiver& ar, const unsigned int /*version*/)
  {
    ar & p;
  }


  pair_with_property() { }


  pair_with_property(const T& t, const U& u, const Property& property)
    : pair_base(t, u), property_base(property) { }


  template<typename Archiver>
  void serialize(Archiver& ar, const unsigned int /*version*/) 
  { 
    ar & boost::serialization::base_object<pair_base>(*this)
       & boost::serialization::base_object<property_base>(*this);
  }


template<typename T, typename U, typename Property>
inline pair_with_property<T, U, Property>
make_pair_with_property(const T& t, const U& u, const Property& property)
{
  return pair_with_property<T, U, Property>(t, u, property);
}

  untracked_pair() {}


  untracked_pair(const T& t, const U& u)
  : std::pair<T,U>(t,u) {}


template<typename T, typename U>
inline untracked_pair<T, U>
make_untracked_pair(const T& t, const U& u)
{
  return untracked_pair<T,U>(t,u);
}

template<class Archive, class F, class S>
inline void serialize(
    Archive & ar,
    boost::parallel::detail::untracked_pair<F, S> & p,
    const unsigned int /* file_version */
){
    ar & boost::serialization::make_nvp("first", p.first);
    ar & boost::serialization::make_nvp("second", p.second);
}


    lazy_list_node(const DataType& data) :
      m_reversed(false),
      m_data(data),
      m_has_data(true)
    {}

    
    lazy_list_node(ptr_t left_child, ptr_t right_child) :
      m_reversed(false),
      m_has_data(false),
      m_left_child(left_child),
      m_right_child(right_child)
    {}


    void push_back(Edge) {}

    void push_front(Edge) {}

    void reverse() {}

    void concat_front(edge_list_storage<no_embedding,Edge>) {}

    void concat_back(edge_list_storage<no_embedding,Edge>) {}

    template <typename OutputIterator>
    void get_list(OutputIterator) {}


    void push_back(Edge e)
    {
      type new_node(new node_type(e));
      value = type(new node_type(value, new_node));
    }


    void push_front(Edge e)
    {
      type new_node(new node_type(e));
      value = type(new node_type(new_node, value));
    }


    void reverse()
    {
      value->m_reversed = !value->m_reversed;
    }


    void concat_front(edge_list_storage<recursive_lazy_list, Edge> other)
    {
      value = type(new node_type(other.value, value));
    }


    void concat_back(edge_list_storage<recursive_lazy_list, Edge> other)
    {
      value = type(new node_type(value, other.value));
    }


    template <typename OutputIterator>
    void get_list(OutputIterator out)
    {
      get_list_helper(out, value);
    }


    template <typename OutputIterator>
    void get_list_helper(OutputIterator o_itr, 
                         type root,
                         bool flipped = false
                         )
    {
      if (!root)
        return;
      
      if (root->m_has_data)
        *o_itr = root->m_data;
      
      if ((flipped && !root->m_reversed) ||
          (!flipped && root->m_reversed)
          )
        {
          get_list_helper(o_itr, root->m_right_child, true);
          get_list_helper(o_itr, root->m_left_child, true);
        }
      else
        {
          get_list_helper(o_itr, root->m_left_child, false);
          get_list_helper(o_itr, root->m_right_child, false);
        }
      
    }


    void push_back(Edge e)
    {
      value.push_back(e);
    }


    void push_front(Edge e)
    {
      value.push_front(e);
    }


    void reverse()
    {
      value.reverse();
    }


    void concat_front(edge_list_storage<std_list,Edge> other)
    {
      value.splice(value.begin(), other.value);
    }


    void concat_back(edge_list_storage<std_list, Edge> other)
    {
      value.splice(value.end(), other.value);
    }


    template <typename OutputIterator>
    void get_list(OutputIterator out)
    {
      std::copy(value.begin(), value.end(), out);
    }



    face_handle_impl() : 
      cached_first_vertex(graph_traits<Graph>::null_vertex()),
      cached_second_vertex(graph_traits<Graph>::null_vertex()),
      true_first_vertex(graph_traits<Graph>::null_vertex()),
      true_second_vertex(graph_traits<Graph>::null_vertex()),
      anchor(graph_traits<Graph>::null_vertex())
    {
      initialize_old_vertices_dispatch(StoreOldHandlesPolicy());
    }


    void initialize_old_vertices_dispatch(store_old_handles)
    {
      old_handles.first_vertex = graph_traits<Graph>::null_vertex();
      old_handles.second_vertex = graph_traits<Graph>::null_vertex();
    }


    void initialize_old_vertices_dispatch(no_old_handles) {}


    face_handle(vertex_t anchor = graph_traits<Graph>::null_vertex()) :
      pimpl(new impl_t())
    {
      pimpl->anchor = anchor;
    }


    face_handle(vertex_t anchor, edge_t initial_edge, const Graph& g) :
      pimpl(new impl_t())
    {
      vertex_t s(source(initial_edge,g));
      vertex_t t(target(initial_edge,g));
      vertex_t other_vertex = s == anchor ? t : s;
      pimpl->anchor = anchor;
      pimpl->cached_first_edge = initial_edge;
      pimpl->cached_second_edge = initial_edge;
      pimpl->cached_first_vertex = other_vertex;
      pimpl->cached_second_vertex = other_vertex;
      pimpl->true_first_vertex = other_vertex;
      pimpl->true_second_vertex = other_vertex;

      pimpl->edge_list.push_back(initial_edge);
      store_old_face_handles_dispatch(StoreOldHandlesPolicy());
    }

    
    void push_first(edge_t e, const Graph& g) 
    { 
      pimpl->edge_list.push_front(e);
      pimpl->cached_first_vertex = pimpl->true_first_vertex = 
        source(e, g) == pimpl->anchor ? target(e,g) : source(e,g);
      pimpl->cached_first_edge = e;
    }

  
    void push_second(edge_t e, const Graph& g) 
    { 
      pimpl->edge_list.push_back(e);
      pimpl->cached_second_vertex = pimpl->true_second_vertex = 
        source(e, g) == pimpl->anchor ? target(e,g) : source(e,g);
      pimpl->cached_second_edge = e;
    }


    inline void store_old_face_handles()
    {
      store_old_face_handles_dispatch(StoreOldHandlesPolicy());
    }


    inline vertex_t first_vertex() const
    { 
      return pimpl->cached_first_vertex;
    }

    
    inline vertex_t second_vertex() const 
    { 
      return pimpl->cached_second_vertex;
    }


    inline vertex_t true_first_vertex() const 
    { 
      return pimpl->true_first_vertex;
    }


    inline vertex_t true_second_vertex() const 
    { 
      return pimpl->true_second_vertex;
    }


    inline vertex_t old_first_vertex() const
    {
      return pimpl->old_handles.first_vertex;
    }


    inline vertex_t old_second_vertex() const
    {
      return pimpl->old_handles.second_vertex;
    }


    inline edge_t old_first_edge() const
    {
      return pimpl->old_handles.first_edge;
    }


    inline edge_t old_second_edge() const
    {
      return pimpl->old_handles.second_edge;
    }


    inline edge_t first_edge() const
    {
      return pimpl->cached_first_edge;
    }

  
    inline edge_t second_edge() const
    {
      return pimpl->cached_second_edge;
    }

    
    inline vertex_t get_anchor() const
    {
      return pimpl->anchor;
    }

  
    void glue_first_to_second
      (face_handle<Graph,StoreOldHandlesPolicy,StoreEmbeddingPolicy>& bottom)
    {
      pimpl->edge_list.concat_front(bottom.pimpl->edge_list);
      pimpl->true_first_vertex = bottom.pimpl->true_first_vertex;
      pimpl->cached_first_vertex = bottom.pimpl->cached_first_vertex;
      pimpl->cached_first_edge = bottom.pimpl->cached_first_edge;
    }

    
    void glue_second_to_first
      (face_handle<Graph,StoreOldHandlesPolicy,StoreEmbeddingPolicy>& bottom)
    {
      pimpl->edge_list.concat_back(bottom.pimpl->edge_list);
      pimpl->true_second_vertex = bottom.pimpl->true_second_vertex;
      pimpl->cached_second_vertex = bottom.pimpl->cached_second_vertex;
      pimpl->cached_second_edge = bottom.pimpl->cached_second_edge;
    }

  
    void flip()
    {
      pimpl->edge_list.reverse();
      std::swap(pimpl->true_first_vertex, pimpl->true_second_vertex);
      std::swap(pimpl->cached_first_vertex, pimpl->cached_second_vertex);
      std::swap(pimpl->cached_first_edge, pimpl->cached_second_edge);
    }

    
    template <typename OutputIterator>
    void get_list(OutputIterator o_itr)
    {
      pimpl->edge_list.get_list(o_itr);
    }


    void reset_vertex_cache()
    {
      pimpl->cached_first_vertex = pimpl->true_first_vertex;
      pimpl->cached_second_vertex = pimpl->true_second_vertex;
    }


    inline void set_first_vertex(vertex_t v)
    {
      pimpl->cached_first_vertex = v;
    }


    inline void set_second_vertex(vertex_t v)
    {
      pimpl->cached_second_vertex = v;
    }


    void store_old_face_handles_dispatch(store_old_handles)
    {
      pimpl->old_handles.first_vertex = pimpl->true_first_vertex;
      pimpl->old_handles.second_vertex = pimpl->true_second_vertex;
      pimpl->old_handles.first_edge = pimpl->cached_first_edge;
      pimpl->old_handles.second_edge = pimpl->cached_second_edge;
    }

  
    void store_old_face_handles_dispatch(no_old_handles) {}

    rank_comparison(ItemToRankMap arg_itrm) : itrm(arg_itrm) {}


    template <typename Item>
    bool operator() (Item x, Item y) const
    {
      return get(itrm, x) < get(itrm, y);
    }


    property_map_tuple_adaptor() {}

    
    property_map_tuple_adaptor(PropertyMapWrapper wrapper_map) :
      m_wrapper_map(wrapper_map)
    {}


    inline value_type operator[](const key_type& x) const
    {
      return get(m_wrapper_map, get<n>(x));
    }

  template <typename ForwardIterator, 
            typename ItemToRankMap, 
            typename SizeType>
  void bucket_sort(ForwardIterator begin, 
                   ForwardIterator end, 
                   ItemToRankMap rank,
                   SizeType range = 0)  
  {
#ifdef BOOST_GRAPH_PREFER_STD_LIB
    std::stable_sort(begin, end, rank_comparison<ItemToRankMap>(rank));
#else
    typedef std::vector
      < typename boost::property_traits<ItemToRankMap>::key_type >
      vector_of_values_t;
    typedef std::vector< vector_of_values_t > vector_of_vectors_t;

    if (!range)
      {
        rank_comparison<ItemToRankMap> cmp(rank);
        ForwardIterator max_by_rank = std::max_element(begin, end, cmp);
        if (max_by_rank == end)
          return;
        range = get(rank, *max_by_rank) + 1;
      }

    vector_of_vectors_t temp_values(range);

    for(ForwardIterator itr = begin; itr != end; ++itr)
      {
        temp_values[get(rank, *itr)].push_back(*itr);
      }

    ForwardIterator orig_seq_itr = begin;
    typename vector_of_vectors_t::iterator itr_end = temp_values.end();
    for(typename vector_of_vectors_t::iterator itr = temp_values.begin(); 
        itr != itr_end; ++itr
        )
      {
        typename vector_of_values_t::iterator jtr_end = itr->end();
        for(typename vector_of_values_t::iterator jtr = itr->begin(); 
            jtr != jtr_end; ++jtr
            )
        {
          *orig_seq_itr = *jtr;
          ++orig_seq_itr;
        }
      }
#endif
  }


  
  template <typename ForwardIterator, typename ItemToRankMap>
  void bucket_sort(ForwardIterator begin, 
                   ForwardIterator end, 
                   ItemToRankMap rank)  
  {
    bucket_sort(begin, end, rank, 0);
  }


  template <typename ForwardIterator>
  void bucket_sort(ForwardIterator begin, 
                   ForwardIterator end 
                   )  
  {
    bucket_sort(begin, end, identity_property_map());
  }


    face_iterator() : 
      m_lead(graph_traits<Graph>::null_vertex()),
      m_follow(graph_traits<Graph>::null_vertex())
    {}


    template <typename TraversalSubType>
    face_iterator(face_handle_t anchor_handle, 
                  FaceHandlesMap face_handles, 
                  TraversalSubType traversal_type):
      m_follow(anchor_handle.get_anchor()), 
      m_face_handles(face_handles)
    {
      set_lead_dispatch(anchor_handle, traversal_type);
    }


    template <typename TraversalSubType>
    face_iterator(vertex_t anchor, 
                  FaceHandlesMap face_handles, 
                  TraversalSubType traversal_type):
      m_follow(anchor), 
      m_face_handles(face_handles)
    {
      set_lead_dispatch(m_face_handles[anchor], traversal_type);
    }

    



    inline vertex_t get_first_vertex(face_handle_t anchor_handle, 
                                     current_iteration
                                     )
    {
      return anchor_handle.first_vertex();
    }


    inline vertex_t get_second_vertex(face_handle_t anchor_handle, 
                                      current_iteration
                                      )
    {
      return anchor_handle.second_vertex();
    }


    inline vertex_t get_first_vertex(face_handle_t anchor_handle, 
                                     previous_iteration
                                     )
    {
      return anchor_handle.old_first_vertex();
    }


    inline vertex_t get_second_vertex(face_handle_t anchor_handle, 
                                      previous_iteration
                                      )
    {
      return anchor_handle.old_second_vertex();
    }






    inline void set_lead_dispatch(face_handle_t anchor_handle, first_side)
    {
      m_lead = get_first_vertex(anchor_handle, Time());
      set_edge_to_first_dispatch(anchor_handle, ValueType(), Time());
    }

    
    inline void set_lead_dispatch(face_handle_t anchor_handle, second_side)
    {
      m_lead = get_second_vertex(anchor_handle, Time());
      set_edge_to_second_dispatch(anchor_handle, ValueType(), Time());
    }






    inline void set_edge_to_first_dispatch(face_handle_t anchor_handle, 
                                           edge_t, 
                                           current_iteration
                                           )
    {
      m_edge.value = anchor_handle.first_edge();
    }


    inline void set_edge_to_second_dispatch(face_handle_t anchor_handle, 
                                            edge_t, 
                                            current_iteration
                                            )
    {
      m_edge.value = anchor_handle.second_edge();
    }


    inline void set_edge_to_first_dispatch(face_handle_t anchor_handle, 
                                           edge_t, 
                                           previous_iteration
                                           )
    {
      m_edge.value = anchor_handle.old_first_edge();
    }


    inline void set_edge_to_second_dispatch(face_handle_t anchor_handle, 
                                            edge_t, 
                                            previous_iteration
                                            )
    {
      m_edge.value = anchor_handle.old_second_edge();
    }

    
    template<typename T>
    inline void set_edge_to_first_dispatch(face_handle_t, vertex_t, T)
    {}


    template<typename T>
    inline void set_edge_to_second_dispatch(face_handle_t, vertex_t, T)
    {}


    void increment()
    {
      face_handle_t curr_face_handle(m_face_handles[m_lead]);
      vertex_t first = get_first_vertex(curr_face_handle, Time());
      vertex_t second = get_second_vertex(curr_face_handle, Time());
      if (first == m_follow)
        {
          m_follow = m_lead;
          set_edge_to_second_dispatch(curr_face_handle, ValueType(), Time());
          m_lead = second;
        }
      else if (second == m_follow)
        {
          m_follow = m_lead;
          set_edge_to_first_dispatch(curr_face_handle, ValueType(), Time());
          m_lead = first;
        }
      else
        m_lead = m_follow = graph_traits<Graph>::null_vertex();
    }

    
    bool equal(self const& other) const
    {
      return m_lead == other.m_lead && m_follow == other.m_follow;
    }

    
    ValueType dereference() const 
    { 
      return dereference_dispatch(VisitorType(), ValueType());
    }

    
    inline ValueType dereference_dispatch(lead_visitor, vertex_t) const 
    { return m_lead; }

    
    inline ValueType dereference_dispatch(follow_visitor, vertex_t) const 
    { return m_follow; }


    inline ValueType dereference_dispatch(lead_visitor, edge_t) const 
    { return m_edge.value; }


    inline ValueType dereference_dispatch(follow_visitor, edge_t) const 
    { return m_edge.value; }


    face_iterator() {}


    face_iterator(face_handle_t anchor_handle, FaceHandlesMap face_handles):
      first_itr(anchor_handle, face_handles, first_side()),
      second_itr(anchor_handle, face_handles, second_side()),
      first_is_active(true),
      first_increment(true)
    {}


    face_iterator(vertex_t anchor, FaceHandlesMap face_handles):
      first_itr(face_handles[anchor], face_handles, first_side()),
      second_itr(face_handles[anchor], face_handles, second_side()),
      first_is_active(true),
      first_increment(true)
    {}

    
    void increment()
    {
      if (first_increment)
        {
          ++first_itr;
          ++second_itr;
          first_increment = false;
        }
      else if (first_is_active)
        ++first_itr;
      else
        ++second_itr;
      first_is_active = !first_is_active;
    }

    
    bool equal(self const& other) const
    {
      //Want this iterator to be equal to the "end" iterator when at least
      //one of the iterators has reached the root of the current bicomp.
      //This isn't ideal, but it works.

      return (first_itr == other.first_itr || second_itr == other.second_itr);
    }

    
    ValueType dereference() const 
    { 
      return first_is_active ? *first_itr : *second_itr;
    }


    template <typename Graph, typename Vertex>
    void visit_vertex_pair(Vertex u, Vertex v, Graph& g)
    {
      add_edge(u,v,g);
    }


    edge_index_update_visitor(EdgeIndexMap em, 
                              edge_index_value_t next_index_available
                              ) : 
      m_em(em),
      m_next_index(next_index_available)
    {}

    
    template <typename Graph, typename Vertex>
    void visit_vertex_pair(Vertex u, Vertex v, Graph& g)
    {
      typedef typename graph_traits<Graph>::edge_descriptor edge_t;
      std::pair<edge_t, bool> return_value = add_edge(u,v,g);
      if (return_value.second)
        put( m_em, return_value.first, m_next_index++);
    }

    planar_dfs_visitor(LowPointMap lpm, DFSParentMap dfs_p, 
                       DFSNumberMap dfs_n, LeastAncestorMap lam,
                       DFSParentEdgeMap dfs_edge) 
      : low(lpm),
        parent(dfs_p),
        df_number(dfs_n),
        least_ancestor(lam),
        df_edge(dfs_edge),
        count(0) 
    {}

    
    
    template <typename Vertex, typename Graph>
    void start_vertex(const Vertex& u, Graph&)
    {
      put(parent, u, u);
      put(least_ancestor, u, count);
    }

    
    
    template <typename Vertex, typename Graph>
    void discover_vertex(const Vertex& u, Graph&)
    {
      put(low, u, count);
      put(df_number, u, count);
      ++count;
    }

    
    template <typename Edge, typename Graph>
    void tree_edge(const Edge& e, Graph& g)
    {
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
      vertex_t s(source(e,g));
      vertex_t t(target(e,g));

      put(parent, t, s);
      put(df_edge, t, e);
      put(least_ancestor, t, get(df_number, s));
    }

    
    template <typename Edge, typename Graph>
    void back_edge(const Edge& e, Graph& g)
    {
      typedef typename graph_traits<Graph>::vertex_descriptor vertex_t;
      typedef typename graph_traits<Graph>::vertices_size_type v_size_t;
      
      vertex_t s(source(e,g));
      vertex_t t(target(e,g));
      BOOST_USING_STD_MIN();

      if ( t != get(parent, s) ) {
        v_size_t s_low_df_number = get(low, s);
        v_size_t t_df_number = get(df_number, t);
        v_size_t s_least_ancestor_df_number = get(least_ancestor, s);

        put(low, s, 
            min BOOST_PREVENT_MACRO_SUBSTITUTION(s_low_df_number,
                                                 t_df_number)
            );
        
        put(least_ancestor, s, 
            min BOOST_PREVENT_MACRO_SUBSTITUTION(s_least_ancestor_df_number, 
                                                 t_df_number
                                                 )
            );

      }
    }

    
    template <typename Vertex, typename Graph>
    void finish_vertex(const Vertex& u, Graph&)
    {
      typedef typename graph_traits<Graph>::vertices_size_type v_size_t;

      Vertex u_parent = get(parent, u);
      v_size_t u_parent_lowpoint = get(low, u_parent);
      v_size_t u_lowpoint = get(low, u);
      BOOST_USING_STD_MIN();

      if (u_parent != u)
        {
          put(low, u_parent, 
              min BOOST_PREVENT_MACRO_SUBSTITUTION(u_lowpoint, 
                                                   u_parent_lowpoint
                                                   )
              );
        }
    }


 

    boyer_myrvold_impl(const Graph& arg_g, VertexIndexMap arg_vm):
      g(arg_g),
      vm(arg_vm),

      low_point_vector(num_vertices(g)),
      dfs_parent_vector(num_vertices(g)),
      dfs_number_vector(num_vertices(g)),
      least_ancestor_vector(num_vertices(g)),
      pertinent_roots_vector(num_vertices(g)),
      backedge_flag_vector(num_vertices(g), num_vertices(g) + 1),
      visited_vector(num_vertices(g), num_vertices(g) + 1),
      face_handles_vector(num_vertices(g)),
      dfs_child_handles_vector(num_vertices(g)),
      separated_dfs_child_list_vector(num_vertices(g)),
      separated_node_in_parent_list_vector(num_vertices(g)),
      canonical_dfs_child_vector(num_vertices(g)),
      flipped_vector(num_vertices(g), false),
      backedges_vector(num_vertices(g)),
      dfs_parent_edge_vector(num_vertices(g)),
                        
      vertices_by_dfs_num(num_vertices(g)),

      low_point(low_point_vector.begin(), vm),
      dfs_parent(dfs_parent_vector.begin(), vm),
      dfs_number(dfs_number_vector.begin(), vm),
      least_ancestor(least_ancestor_vector.begin(), vm),
      pertinent_roots(pertinent_roots_vector.begin(), vm),
      backedge_flag(backedge_flag_vector.begin(), vm),
      visited(visited_vector.begin(), vm),
      face_handles(face_handles_vector.begin(), vm),
      dfs_child_handles(dfs_child_handles_vector.begin(), vm),
      separated_dfs_child_list(separated_dfs_child_list_vector.begin(), vm),
      separated_node_in_parent_list
          (separated_node_in_parent_list_vector.begin(), vm),
      canonical_dfs_child(canonical_dfs_child_vector.begin(), vm),
      flipped(flipped_vector.begin(), vm),
      backedges(backedges_vector.begin(), vm),
      dfs_parent_edge(dfs_parent_edge_vector.begin(), vm)

    {

      planar_dfs_visitor
        <vertex_to_v_size_map_t, vertex_to_vertex_map_t,
        vertex_to_v_size_map_t, vertex_to_v_size_map_t,
        vertex_to_edge_map_t, v_size_t> vis
        (low_point, dfs_parent, dfs_number, least_ancestor, dfs_parent_edge);

      // Perform a depth-first search to find each vertex's low point, least
      // ancestor, and dfs tree information
      depth_first_search(g, visitor(vis).vertex_index_map(vm));

      // Sort vertices by their lowpoint - need this later in the constructor
      vertex_vector_t vertices_by_lowpoint(num_vertices(g));
      std::copy( vertices(g).first, vertices(g).second, 
                 vertices_by_lowpoint.begin()
                 );
      bucket_sort(vertices_by_lowpoint.begin(), 
                  vertices_by_lowpoint.end(), 
                  low_point,
                  num_vertices(g)
                  );

      // Sort vertices by their dfs number - need this to iterate by reverse 
      // DFS number in the main loop.
      std::copy( vertices(g).first, vertices(g).second, 
                 vertices_by_dfs_num.begin()
                 );
      bucket_sort(vertices_by_dfs_num.begin(), 
                  vertices_by_dfs_num.end(), 
                  dfs_number,
                  num_vertices(g)
                  );

      // Initialize face handles. A face handle is an abstraction that serves 
      // two uses in our implementation - it allows us to efficiently move 
      // along the outer face of embedded bicomps in a partially embedded 
      // graph, and it provides storage for the planar embedding. Face 
      // handles are implemented by a sequence of edges and are associated 
      // with a particular vertex - the sequence of edges represents the 
      // current embedding of edges around that vertex, and the first and 
      // last edges in the sequence represent the pair of edges on the outer 
      // face that are adjacent to the associated vertex. This lets us embed 
      // edges in the graph by just pushing them on the front or back of the 
      // sequence of edges held by the face handles.
      // 
      // Our algorithm starts with a DFS tree of edges (where every vertex is
      // an articulation point and every edge is a singleton bicomp) and 
      // repeatedly merges bicomps by embedding additional edges. Note that 
      // any bicomp at any point in the algorithm can be associated with a 
      // unique edge connecting the vertex of that bicomp with the lowest DFS
      // number (which we refer to as the "root" of the bicomp) with its DFS 
      // child in the bicomp: the existence of two such edges would contradict
      // the properties of a DFS tree. We refer to the DFS child of the root 
      // of a bicomp as the "canonical DFS child" of the bicomp. Note that a 
      // vertex can be the root of more than one bicomp.
      //
      // We move around the external faces of a bicomp using a few property 
      // maps, which we'll initialize presently:
      //
      // - face_handles: maps a vertex to a face handle that can be used to 
      //   move "up" a bicomp. For a vertex that isn't an articulation point, 
      //   this holds the face handles that can be used to move around that 
      //   vertex's unique bicomp. For a vertex that is an articulation point,
      //   this holds the face handles associated with the unique bicomp that 
      //   the vertex is NOT the root of. These handles can therefore be used 
      //   to move from any point on the outer face of the tree of bicomps 
      //   around the current outer face towards the root of the DFS tree.
      //
      // - dfs_child_handles: these are used to hold face handles for 
      //   vertices that are articulation points - dfs_child_handles[v] holds
      //   the face handles corresponding to vertex u in the bicomp with root
      //   u and canonical DFS child v.
      //
      // - canonical_dfs_child: this property map allows one to determine the
      //   canonical DFS child of a bicomp while traversing the outer face.
      //   This property map is only valid when applied to one of the two 
      //   vertices adjacent to the root of the bicomp on the outer face. To
      //   be more precise, if v is the canonical DFS child of a bicomp,
      //   canonical_dfs_child[dfs_child_handles[v].first_vertex()] == v and 
      //   canonical_dfs_child[dfs_child_handles[v].second_vertex()] == v.
      //
      // - pertinent_roots: given a vertex v, pertinent_roots[v] contains a
      //   list of face handles pointing to the top of bicomps that need to
      //   be visited by the current walkdown traversal (since they lead to
      //   backedges that need to be embedded). These lists are populated by
      //   the walkup and consumed by the walkdown.

      vertex_iterator_t vi, vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        {
          vertex_t v(*vi);
          vertex_t parent = dfs_parent[v];

          if (parent != v)
            {
              edge_t parent_edge = dfs_parent_edge[v];
              add_to_embedded_edges(parent_edge, StoreOldHandlesPolicy());
              face_handles[v] = face_handle_t(v, parent_edge, g);
              dfs_child_handles[v] = face_handle_t(parent, parent_edge, g);
            }
          else
            {
              face_handles[v] = face_handle_t(v);
              dfs_child_handles[v] = face_handle_t(parent);
            }

          canonical_dfs_child[v] = v;
          pertinent_roots[v] = face_handle_list_ptr_t(new face_handle_list_t); 
          separated_dfs_child_list[v] = vertex_list_ptr_t(new vertex_list_t);

        }

      // We need to create a list of not-yet-merged depth-first children for
      // each vertex that will be updated as bicomps get merged. We sort each 
      // list by ascending lowpoint, which allows the externally_active 
      // function to run in constant time, and we keep a pointer to each 
      // vertex's representation in its parent's list, which allows merging 
      //in constant time.

      for(typename vertex_vector_t::iterator itr = 
            vertices_by_lowpoint.begin();
          itr != vertices_by_lowpoint.end(); ++itr)
        {
          vertex_t v(*itr);
          vertex_t parent(dfs_parent[v]);
          if (v != parent)
            {
              separated_node_in_parent_list[v] =
                separated_dfs_child_list[parent]->insert
                (separated_dfs_child_list[parent]->end(), v);
            }
        }    

      // The merge stack holds path information during a walkdown iteration
      merge_stack.reserve(num_vertices(g));

    }







    bool is_planar()
    {

      // This is the main algorithm: starting with a DFS tree of embedded 
      // edges (which, since it's a tree, is planar), iterate through all 
      // vertices by reverse DFS number, attempting to embed all backedges
      // connecting the current vertex to vertices with higher DFS numbers.
      // 
      // The walkup is a procedure that examines all such backedges and sets
      // up the required data structures so that they can be searched by the
      // walkdown in linear time. The walkdown does the actual work of
      // embedding edges and flipping bicomps, and can identify when it has
      // come across a kuratowski subgraph.
      //
      // store_old_face_handles caches face handles from the previous
      // iteration - this is used only for the kuratowski subgraph isolation,
      // and is therefore dispatched based on the StoreOldHandlesPolicy.
      //
      // clean_up_embedding does some clean-up and fills in values that have
      // to be computed lazily during the actual execution of the algorithm
      // (for instance, whether or not a bicomp is flipped in the final
      // embedding). It's dispatched on the the StoreEmbeddingPolicy, since
      // it's not needed if an embedding isn't desired.

      typename vertex_vector_t::reverse_iterator vi, vi_end;

      vi_end = vertices_by_dfs_num.rend();
      for(vi = vertices_by_dfs_num.rbegin(); vi != vi_end; ++vi)
        {

          store_old_face_handles(StoreOldHandlesPolicy());

          vertex_t v(*vi);
          
          walkup(v);

          if (!walkdown(v))
            return false;

        }

      clean_up_embedding(StoreEmbeddingPolicy());

      return true;
      
    }






    void walkup(vertex_t v)
    {

      // The point of the walkup is to follow all backedges from v to 
      // vertices with higher DFS numbers, and update pertinent_roots
      // for the bicomp roots on the path from backedge endpoints up
      // to v. This will set the stage for the walkdown to efficiently
      // traverse the graph of bicomps down from v.

      typedef typename face_vertex_iterator<both_sides>::type walkup_iterator_t;
      
      out_edge_iterator_t oi, oi_end;
      for(boost::tie(oi,oi_end) = out_edges(v,g); oi != oi_end; ++oi)
        {
          edge_t e(*oi);
          vertex_t e_source(source(e,g));
          vertex_t e_target(target(e,g));

          if (e_source == e_target)
            {
              self_loops.push_back(e);
              continue;
            }

          vertex_t w(e_source == v ? e_target : e_source);

          //continue if not a back edge or already embedded
          if (dfs_number[w] < dfs_number[v] || e == dfs_parent_edge[w])
            continue;

          backedges[w].push_back(e);

          v_size_t timestamp = dfs_number[v];         
          backedge_flag[w] = timestamp;

          walkup_iterator_t walkup_itr(w, face_handles);
          walkup_iterator_t walkup_end;
          vertex_t lead_vertex = w;

          while (true)
            {
              
              // Move to the root of the current bicomp or the first visited
              // vertex on the bicomp by going up each side in parallel
              
              while(walkup_itr != walkup_end && 
                    visited[*walkup_itr] != timestamp
                    )
                {
                  lead_vertex = *walkup_itr;
                  visited[lead_vertex] = timestamp;
                  ++walkup_itr;
                }

              // If we've found the root of a bicomp through a path we haven't
              // seen before, update pertinent_roots with a handle to the
              // current bicomp. Otherwise, we've just seen a path we've been 
              // up before, so break out of the main while loop.
              
              if (walkup_itr == walkup_end)
                {
                  vertex_t dfs_child = canonical_dfs_child[lead_vertex];
                  vertex_t parent = dfs_parent[dfs_child];

                  visited[dfs_child_handles[dfs_child].first_vertex()] 
                    = timestamp;
                  visited[dfs_child_handles[dfs_child].second_vertex()] 
                    = timestamp;

                  if (low_point[dfs_child] < dfs_number[v] || 
                      least_ancestor[dfs_child] < dfs_number[v]
                      )
                    {
                      pertinent_roots[parent]->push_back
                        (dfs_child_handles[dfs_child]);
                    }
                  else
                    {
                      pertinent_roots[parent]->push_front
                        (dfs_child_handles[dfs_child]);
                    }

                  if (parent != v && visited[parent] != timestamp)
                    {
                      walkup_itr = walkup_iterator_t(parent, face_handles);
                      lead_vertex = parent;
                    }
                  else
                    break;
                }
              else
                break;
            }

        }      
      
    }

    






    bool walkdown(vertex_t v)
    {
      // This procedure is where all of the action is - pertinent_roots
      // has already been set up by the walkup, so we just need to move
      // down bicomps from v until we find vertices that have been
      // labeled as backedge endpoints. Once we find such a vertex, we
      // embed the corresponding edge and glue together the bicomps on
      // the path connecting the two vertices in the edge. This may
      // involve flipping bicomps along the way.

      vertex_t w; //the other endpoint of the edge we're embedding

      while (!pertinent_roots[v]->empty())
        {
          
          face_handle_t root_face_handle = pertinent_roots[v]->front();
          face_handle_t curr_face_handle = root_face_handle;
          pertinent_roots[v]->pop_front();      

          merge_stack.clear();

          while(true)
            {

              typename face_vertex_iterator<>::type 
                first_face_itr, second_face_itr, face_end;
              vertex_t first_side_vertex 
                = graph_traits<Graph>::null_vertex();
              vertex_t second_side_vertex;
              vertex_t first_tail, second_tail;

              first_tail = second_tail = curr_face_handle.get_anchor();
              first_face_itr = typename face_vertex_iterator<>::type
                (curr_face_handle, face_handles, first_side());
              second_face_itr = typename face_vertex_iterator<>::type
                (curr_face_handle, face_handles, second_side());

              for(; first_face_itr != face_end; ++first_face_itr)
                {
                  vertex_t face_vertex(*first_face_itr);
                  if (pertinent(face_vertex, v) || 
                      externally_active(face_vertex, v)
                      )
                    {
                      first_side_vertex = face_vertex;
                      second_side_vertex = face_vertex;
                      break;
                    }
                  first_tail = face_vertex;
                }

              if (first_side_vertex == graph_traits<Graph>::null_vertex() || 
                  first_side_vertex == curr_face_handle.get_anchor()
                  )
                break;

              for(;second_face_itr != face_end; ++second_face_itr)
                {
                  vertex_t face_vertex(*second_face_itr);
                  if (pertinent(face_vertex, v) || 
                      externally_active(face_vertex, v)
                      )
                    {
                      second_side_vertex = face_vertex;
                      break;
                    }
                  second_tail = face_vertex;
                }

              vertex_t chosen;
              bool chose_first_upper_path;
              if (internally_active(first_side_vertex, v))
                {
                  chosen = first_side_vertex;
                  chose_first_upper_path = true;
                }
              else if (internally_active(second_side_vertex, v))
                {
                  chosen = second_side_vertex;
                  chose_first_upper_path = false;
                }
              else if (pertinent(first_side_vertex, v))
                {
                  chosen = first_side_vertex;
                  chose_first_upper_path = true;
                }
              else if (pertinent(second_side_vertex, v))
                {
                  chosen = second_side_vertex;
                  chose_first_upper_path = false;
                }
              else 
                {

                  // If there's a pertinent vertex on the lower face 
                  // between the first_face_itr and the second_face_itr, 
                  // this graph isn't planar.
                  for(; 
                      *first_face_itr != second_side_vertex; 
                      ++first_face_itr
                      )
                    {
                      vertex_t p(*first_face_itr);
                      if (pertinent(p,v))
                        {
                          //Found a Kuratowski subgraph
                          kuratowski_v = v;
                          kuratowski_x = first_side_vertex;
                          kuratowski_y = second_side_vertex;
                          return false;
                        }
                    }
                  
                  // Otherwise, the fact that we didn't find a pertinent 
                  // vertex on this face is fine - we should set the 
                  // short-circuit edges and break out of this loop to 
                  // start looking at a different pertinent root.
                                    
                  if (first_side_vertex == second_side_vertex)
                    {
                      if (first_tail != v)
                        {
                          vertex_t first 
                            = face_handles[first_tail].first_vertex();
                          vertex_t second 
                            = face_handles[first_tail].second_vertex();
                          boost::tie(first_side_vertex, first_tail) 
                            = make_tuple(first_tail, 
                                         first == first_side_vertex ? 
                                         second : first
                                         );
                        }
                      else if (second_tail != v)
                        {
                          vertex_t first 
                            = face_handles[second_tail].first_vertex();
                          vertex_t second 
                            = face_handles[second_tail].second_vertex();
                          boost::tie(second_side_vertex, second_tail) 
                            = make_tuple(second_tail,
                                         first == second_side_vertex ? 
                                         second : first);
                        }
                      else
                        break;
                    }
                  
                  canonical_dfs_child[first_side_vertex] 
                    = canonical_dfs_child[root_face_handle.first_vertex()];
                  canonical_dfs_child[second_side_vertex] 
                    = canonical_dfs_child[root_face_handle.second_vertex()];
                  root_face_handle.set_first_vertex(first_side_vertex);
                  root_face_handle.set_second_vertex(second_side_vertex);

                  if (face_handles[first_side_vertex].first_vertex() == 
                      first_tail
                      )
                    face_handles[first_side_vertex].set_first_vertex(v);
                  else
                    face_handles[first_side_vertex].set_second_vertex(v);

                  if (face_handles[second_side_vertex].first_vertex() == 
                      second_tail
                      )
                    face_handles[second_side_vertex].set_first_vertex(v);
                  else
                    face_handles[second_side_vertex].set_second_vertex(v);
                    
                  break;
                  
                }


              // When we unwind the stack, we need to know which direction 
              // we came down from on the top face handle
              
              bool chose_first_lower_path = 
                (chose_first_upper_path && 
                 face_handles[chosen].first_vertex() == first_tail) 
                ||
                (!chose_first_upper_path && 
                 face_handles[chosen].first_vertex() == second_tail);

              //If there's a backedge at the chosen vertex, embed it now
              if (backedge_flag[chosen] == dfs_number[v])
                {
                  w = chosen;
                  
                  backedge_flag[chosen] = num_vertices(g) + 1;
                  add_to_merge_points(chosen, StoreOldHandlesPolicy());
                  
                  typename edge_vector_t::iterator ei, ei_end;
                  ei_end = backedges[chosen].end();
                  for(ei = backedges[chosen].begin(); ei != ei_end; ++ei)
                    {
                      edge_t e(*ei);
                      add_to_embedded_edges(e, StoreOldHandlesPolicy());

                      if (chose_first_lower_path)
                        face_handles[chosen].push_first(e, g);
                      else
                        face_handles[chosen].push_second(e, g);
                    }

                }
              else
                {
                  merge_stack.push_back(make_tuple
                     (chosen, chose_first_upper_path, chose_first_lower_path)
                                        );
                  curr_face_handle = *pertinent_roots[chosen]->begin();
                  continue;
                }

              //Unwind the merge stack to the root, merging all bicomps
      
              bool bottom_path_follows_first;
              bool top_path_follows_first;
              bool next_bottom_follows_first = chose_first_upper_path;
              face_handle_t top_handle, bottom_handle;

              vertex_t merge_point = chosen;

              while(!merge_stack.empty())
                {

                  bottom_path_follows_first = next_bottom_follows_first;
                  boost::tie(merge_point, 
                             next_bottom_follows_first, 
                             top_path_follows_first
                             ) = merge_stack.back();
                  merge_stack.pop_back();

                  face_handle_t top_handle(face_handles[merge_point]);
                  face_handle_t bottom_handle
                    (*pertinent_roots[merge_point]->begin());
                  
                  vertex_t bottom_dfs_child = canonical_dfs_child
                    [pertinent_roots[merge_point]->begin()->first_vertex()];

                  remove_vertex_from_separated_dfs_child_list(
                       canonical_dfs_child
                       [pertinent_roots[merge_point]->begin()->first_vertex()]
                       );

                  pertinent_roots[merge_point]->pop_front();

                  add_to_merge_points(top_handle.get_anchor(), 
                                      StoreOldHandlesPolicy()
                                      );
                  
                  if (top_path_follows_first && bottom_path_follows_first)
                    {
                      bottom_handle.flip();
                      top_handle.glue_first_to_second(bottom_handle);
                    }          
                  else if (!top_path_follows_first && 
                           bottom_path_follows_first
                           )
                    {
                      flipped[bottom_dfs_child] = true;
                      top_handle.glue_second_to_first(bottom_handle);
                    }
                  else if (top_path_follows_first && 
                           !bottom_path_follows_first
                           )
                    {
                      flipped[bottom_dfs_child] = true;
                      top_handle.glue_first_to_second(bottom_handle);
                    }
                  else //!top_path_follows_first && !bottom_path_follows_first
                    {
                      bottom_handle.flip();
                      top_handle.glue_second_to_first(bottom_handle);
                    }

                }

              //Finally, embed all edges (v,w) at their upper end points
              canonical_dfs_child[w] 
                = canonical_dfs_child[root_face_handle.first_vertex()];
              
              add_to_merge_points(root_face_handle.get_anchor(), 
                                  StoreOldHandlesPolicy()
                                  );
              
              typename edge_vector_t::iterator ei, ei_end;
              ei_end = backedges[chosen].end();
              for(ei = backedges[chosen].begin(); ei != ei_end; ++ei)
                {              
                  if (next_bottom_follows_first)
                    root_face_handle.push_first(*ei, g);
                  else
                    root_face_handle.push_second(*ei, g);
                }

              backedges[chosen].clear();
              curr_face_handle = root_face_handle;

            }//while(true)
          
        }//while(!pertinent_roots[v]->empty())

      return true;

    }







    void store_old_face_handles(graph::detail::no_old_handles) {}


    void store_old_face_handles(graph::detail::store_old_handles)
    {
      for(typename std::vector<vertex_t>::iterator mp_itr 
            = current_merge_points.begin();
          mp_itr != current_merge_points.end(); ++mp_itr)
        {
          face_handles[*mp_itr].store_old_face_handles();
        }
      current_merge_points.clear();
    }
          


    void add_to_merge_points(vertex_t, graph::detail::no_old_handles) {}


    void add_to_merge_points(vertex_t v, graph::detail::store_old_handles)
    {
      current_merge_points.push_back(v);
    }


    
    void add_to_embedded_edges(edge_t, graph::detail::no_old_handles) {}


    void add_to_embedded_edges(edge_t e, graph::detail::store_old_handles)
    {
      embedded_edges.push_back(e);
    }





    void clean_up_embedding(graph::detail::no_embedding) {}


    void clean_up_embedding(graph::detail::store_embedding)
    {

      // If the graph isn't biconnected, we'll still have entries
      // in the separated_dfs_child_list for some vertices. Since
      // these represent articulation points, we can obtain a
      // planar embedding no matter what order we embed them in.

      vertex_iterator_t xi, xi_end;
      for(boost::tie(xi,xi_end) = vertices(g); xi != xi_end; ++xi)
        {
          if (!separated_dfs_child_list[*xi]->empty())
            {
              typename vertex_list_t::iterator yi, yi_end;
              yi_end = separated_dfs_child_list[*xi]->end();
              for(yi = separated_dfs_child_list[*xi]->begin(); 
                  yi != yi_end; ++yi
                  )
                {
                  dfs_child_handles[*yi].flip();
                  face_handles[*xi].glue_first_to_second
                    (dfs_child_handles[*yi]);
                }
            }
        }      

      // Up until this point, we've flipped bicomps lazily by setting
      // flipped[v] to true if the bicomp rooted at v was flipped (the
      // lazy aspect of this flip is that all descendents of that vertex
      // need to have their orientations reversed as well). Now, we
      // traverse the DFS tree by DFS number and perform the actual
      // flipping as needed

      typedef typename vertex_vector_t::iterator vertex_vector_itr_t;
      vertex_vector_itr_t vi_end = vertices_by_dfs_num.end();
      for(vertex_vector_itr_t vi = vertices_by_dfs_num.begin(); 
          vi != vi_end; ++vi
          )
        {
          vertex_t v(*vi);
          bool v_flipped = flipped[v];
          bool p_flipped = flipped[dfs_parent[v]];
          if (v_flipped && !p_flipped)
            {
              face_handles[v].flip();
            }
          else if (p_flipped && !v_flipped)
            {
              face_handles[v].flip();
              flipped[v] = true;
            }
          else
            {
              flipped[v] = false;
            }
        }

      // If there are any self-loops in the graph, they were flagged
      // during the walkup, and we should add them to the embedding now.
      // Adding a self loop anywhere in the embedding could never 
      // invalidate the embedding, but they would complicate the traversal
      // if they were added during the walkup/walkdown.

      typename edge_vector_t::iterator ei, ei_end;
      ei_end = self_loops.end();
      for(ei = self_loops.begin(); ei != ei_end; ++ei)
        {
          edge_t e(*ei);
          face_handles[source(e,g)].push_second(e,g);
        }
      
    }





    
    bool pertinent(vertex_t w, vertex_t v)
    {
      // w is pertinent with respect to v if there is a backedge (v,w) or if
      // w is the root of a bicomp that contains a pertinent vertex.

      return backedge_flag[w] == dfs_number[v] || !pertinent_roots[w]->empty();
    }

    


    bool externally_active(vertex_t w, vertex_t v)
    {
      // Let a be any proper depth-first search ancestor of v. w is externally
      // active with respect to v if there exists a backedge (a,w) or a 
      // backedge (a,w_0) for some w_0 in a descendent bicomp of w.

      v_size_t dfs_number_of_v = dfs_number[v];
      return (least_ancestor[w] < dfs_number_of_v) ||
        (!separated_dfs_child_list[w]->empty() &&
         low_point[separated_dfs_child_list[w]->front()] < dfs_number_of_v); 
   }

    

      
    bool internally_active(vertex_t w, vertex_t v)
    {
      return pertinent(w,v) && !externally_active(w,v);
    }
    
      



    void remove_vertex_from_separated_dfs_child_list(vertex_t v)
    {
      typename vertex_list_t::iterator to_delete 
        = separated_node_in_parent_list[v];
      garbage.splice(garbage.end(), 
                     *separated_dfs_child_list[dfs_parent[v]], 
                     to_delete, 
                     boost::next(to_delete)
                     );
    }





    template <typename EdgeToBoolPropertyMap, typename EdgeContainer>
    vertex_t kuratowski_walkup(vertex_t v, 
                               EdgeToBoolPropertyMap forbidden_edge,
                               EdgeToBoolPropertyMap goal_edge,
                               EdgeToBoolPropertyMap is_embedded,
                               EdgeContainer& path_edges
                               )
    {
      vertex_t current_endpoint;
      bool seen_goal_edge = false;
      out_edge_iterator_t oi, oi_end;
      
      for(boost::tie(oi,oi_end) = out_edges(v,g); oi != oi_end; ++oi)
        forbidden_edge[*oi] = true;
      
      for(boost::tie(oi,oi_end) = out_edges(v,g); oi != oi_end; ++oi)
        {
          path_edges.clear();
          
          edge_t e(*oi);
          current_endpoint = target(*oi,g) == v ? 
            source(*oi,g) : target(*oi,g);
          
          if (dfs_number[current_endpoint] < dfs_number[v] || 
              is_embedded[e] ||
              v == current_endpoint //self-loop
              )
            {
              //Not a backedge
              continue;
            }
          
          path_edges.push_back(e);
          if (goal_edge[e])
            {
              return current_endpoint;
            }

          typedef typename face_edge_iterator<>::type walkup_itr_t;
          
          walkup_itr_t 
            walkup_itr(current_endpoint, face_handles, first_side());
          walkup_itr_t walkup_end;
          
          seen_goal_edge = false;
          
          while (true)
            {      
              
              if (walkup_itr != walkup_end && forbidden_edge[*walkup_itr])
                break;
              
              while(walkup_itr != walkup_end && 
                    !goal_edge[*walkup_itr] && 
                    !forbidden_edge[*walkup_itr]
                    )
                {
                  edge_t f(*walkup_itr);
                  forbidden_edge[f] = true;
                  path_edges.push_back(f);
                  current_endpoint = 
                    source(f, g) == current_endpoint ? 
                    target(f, g) : 
                    source(f,g);
                  ++walkup_itr;
                }

              if (walkup_itr != walkup_end && goal_edge[*walkup_itr])
                {
                  path_edges.push_back(*walkup_itr);
                  seen_goal_edge = true;
                  break;
                }

              walkup_itr 
                = walkup_itr_t(current_endpoint, face_handles, first_side());
              
            }
          
          if (seen_goal_edge)
            break;
          
        }

      if (seen_goal_edge)
        return current_endpoint;
      else
        return graph_traits<Graph>::null_vertex();

    }









    template <typename OutputIterator, typename EdgeIndexMap>
    void extract_kuratowski_subgraph(OutputIterator o_itr, EdgeIndexMap em)
    {

      // If the main algorithm has failed to embed one of the back-edges from
      // a vertex v, we can use the current state of the algorithm to isolate
      // a Kuratowksi subgraph. The isolation process breaks down into five
      // cases, A - E. The general configuration of all five cases is shown in
      //                  figure 1. There is a vertex v from which the planar
      //         v        embedding process could not proceed. This means that
      //         |        there exists some bicomp containing three vertices
      //       -----      x,y, and z as shown such that x and y are externally
      //      |     |     active with respect to v (which means that there are
      //      x     y     two vertices x_0 and y_0 such that (1) both x_0 and  
      //      |     |     y_0 are proper depth-first search ancestors of v and 
      //       --z--      (2) there are two disjoint paths, one connecting x 
      //                  and x_0 and one connecting y and y_0, both consisting
      //       fig. 1     entirely of unembedded edges). Furthermore, there
      //                  exists a vertex z_0 such that z is a depth-first
      // search ancestor of z_0 and (v,z_0) is an unembedded back-edge from v.
      // x,y and z all exist on the same bicomp, which consists entirely of
      // embedded edges. The five subcases break down as follows, and are
      // handled by the algorithm logically in the order A-E: First, if v is
      // not on the same bicomp as x,y, and z, a K_3_3 can be isolated - this
      // is case A. So, we'll assume that v is on the same bicomp as x,y, and
      // z. If z_0 is on a different bicomp than x,y, and z, a K_3_3 can also
      // be isolated - this is a case B - so we'll assume from now on that v
      // is on the same bicomp as x, y, and z=z_0. In this case, one can use
      // properties of the Boyer-Myrvold algorithm to show the existence of an
      // "x-y path" connecting some vertex on the "left side" of the x,y,z
      // bicomp with some vertex on the "right side" of the bicomp (where the
      // left and right are split by a line drawn through v and z.If either of 
      // the endpoints of the x-y path is above x or y on the bicomp, a K_3_3 
      // can be isolated - this is a case C. Otherwise, both endpoints are at 
      // or below x and y on the bicomp. If there is a vertex alpha on the x-y 
      // path such that alpha is not x or y and there's a path from alpha to v
      // that's disjoint from any of the edges on the bicomp and the x-y path,
      // a K_3_3 can be isolated - this is a case D. Otherwise, properties of
      // the Boyer-Myrvold algorithm can be used to show that another vertex
      // w exists on the lower half of the bicomp such that w is externally
      // active with respect to v. w can then be used to isolate a K_5 - this
      // is the configuration of case E.

      vertex_iterator_t vi, vi_end;
      edge_iterator_t ei, ei_end;
      out_edge_iterator_t oei, oei_end;
      typename std::vector<edge_t>::iterator xi, xi_end;

      // Clear the short-circuit edges - these are needed for the planar 
      // testing/embedding algorithm to run in linear time, but they'll 
      // complicate the kuratowski subgraph isolation
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        {
          face_handles[*vi].reset_vertex_cache();
          dfs_child_handles[*vi].reset_vertex_cache();
        }

      vertex_t v = kuratowski_v;
      vertex_t x = kuratowski_x;
      vertex_t y = kuratowski_y;

      typedef iterator_property_map
        <typename std::vector<bool>::iterator, EdgeIndexMap>
        edge_to_bool_map_t;

      std::vector<bool> is_in_subgraph_vector(num_edges(g), false);
      edge_to_bool_map_t is_in_subgraph(is_in_subgraph_vector.begin(), em);

      std::vector<bool> is_embedded_vector(num_edges(g), false);
      edge_to_bool_map_t is_embedded(is_embedded_vector.begin(), em);

      typename std::vector<edge_t>::iterator embedded_itr, embedded_end;
      embedded_end = embedded_edges.end();
      for(embedded_itr = embedded_edges.begin(); 
          embedded_itr != embedded_end; ++embedded_itr
          )
        is_embedded[*embedded_itr] = true;

      // upper_face_vertex is true for x,y, and all vertices above x and y in 
      // the bicomp
      std::vector<bool> upper_face_vertex_vector(num_vertices(g), false);
      vertex_to_bool_map_t upper_face_vertex
        (upper_face_vertex_vector.begin(), vm);

      std::vector<bool> lower_face_vertex_vector(num_vertices(g), false);
      vertex_to_bool_map_t lower_face_vertex
        (lower_face_vertex_vector.begin(), vm);

      // These next few variable declarations are all things that we need
      // to find.
      vertex_t z; 
      vertex_t bicomp_root;
      vertex_t w = graph_traits<Graph>::null_vertex();
      face_handle_t w_handle;
      face_handle_t v_dfchild_handle;
      vertex_t first_x_y_path_endpoint = graph_traits<Graph>::null_vertex();
      vertex_t second_x_y_path_endpoint = graph_traits<Graph>::null_vertex();
      vertex_t w_ancestor = v;

      detail::bm_case_t chosen_case = detail::BM_NO_CASE_CHOSEN;

      std::vector<edge_t> x_external_path;
      std::vector<edge_t> y_external_path;
      std::vector<edge_t> case_d_edges;

      std::vector<edge_t> z_v_path;
      std::vector<edge_t> w_path;

      //first, use a walkup to find a path from V that starts with a
      //backedge from V, then goes up until it hits either X or Y
      //(but doesn't find X or Y as the root of a bicomp)

      typename face_vertex_iterator<>::type 
        x_upper_itr(x, face_handles, first_side());
      typename face_vertex_iterator<>::type 
        x_lower_itr(x, face_handles, second_side());
      typename face_vertex_iterator<>::type face_itr, face_end;

      // Don't know which path from x is the upper or lower path - 
      // we'll find out here
      for(face_itr = x_upper_itr; face_itr != face_end; ++face_itr)
        {
          if (*face_itr == y)
            {
              std::swap(x_upper_itr, x_lower_itr);
              break;
            }
        }

      upper_face_vertex[x] = true;

      vertex_t current_vertex = x;
      vertex_t previous_vertex;
      for(face_itr = x_upper_itr; face_itr != face_end; ++face_itr)
        {
          previous_vertex = current_vertex;
          current_vertex = *face_itr;
          upper_face_vertex[current_vertex] = true;
        }

      v_dfchild_handle 
        = dfs_child_handles[canonical_dfs_child[previous_vertex]];
      
      for(face_itr = x_lower_itr; *face_itr != y; ++face_itr)
        {
          vertex_t current_vertex(*face_itr);
          lower_face_vertex[current_vertex] = true;

          typename face_handle_list_t::iterator roots_itr, roots_end;

          if (w == graph_traits<Graph>::null_vertex()) //haven't found a w yet
            {
              roots_end = pertinent_roots[current_vertex]->end();
              for(roots_itr = pertinent_roots[current_vertex]->begin(); 
                  roots_itr != roots_end; ++roots_itr
                  )
                {
                  if (low_point[canonical_dfs_child[roots_itr->first_vertex()]]
                      < dfs_number[v]
                      )
                    {
                      w = current_vertex;
                      w_handle = *roots_itr;
                      break;
                    }
                }
            }

        }

      for(; face_itr != face_end; ++face_itr)
        {
          vertex_t current_vertex(*face_itr);
          upper_face_vertex[current_vertex] = true;
          bicomp_root = current_vertex;
        }

      typedef typename face_edge_iterator<>::type walkup_itr_t;

      std::vector<bool> outer_face_edge_vector(num_edges(g), false);
      edge_to_bool_map_t outer_face_edge(outer_face_edge_vector.begin(), em);

      walkup_itr_t walkup_end;
      for(walkup_itr_t walkup_itr(x, face_handles, first_side()); 
          walkup_itr != walkup_end; ++walkup_itr
          )
        {
          outer_face_edge[*walkup_itr] = true;
          is_in_subgraph[*walkup_itr] = true;
        }

      for(walkup_itr_t walkup_itr(x, face_handles, second_side()); 
          walkup_itr != walkup_end; ++walkup_itr
          )
        {
          outer_face_edge[*walkup_itr] = true;
          is_in_subgraph[*walkup_itr] = true;
        }

      std::vector<bool> forbidden_edge_vector(num_edges(g), false);
      edge_to_bool_map_t forbidden_edge(forbidden_edge_vector.begin(), em);

      std::vector<bool> goal_edge_vector(num_edges(g), false);
      edge_to_bool_map_t goal_edge(goal_edge_vector.begin(), em);


      //Find external path to x and to y

      for(boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
        {
          edge_t e(*ei);
          goal_edge[e] 
            = !outer_face_edge[e] && (source(e,g) == x || target(e,g) == x);
          forbidden_edge[*ei] = outer_face_edge[*ei];
        }

      vertex_t x_ancestor = v;
      vertex_t x_endpoint = graph_traits<Graph>::null_vertex();
      
      while(x_endpoint == graph_traits<Graph>::null_vertex())
        { 
          x_ancestor = dfs_parent[x_ancestor];
          x_endpoint = kuratowski_walkup(x_ancestor, 
                                         forbidden_edge, 
                                         goal_edge,
                                         is_embedded,
                                         x_external_path
                                         );
          
        }            


      for(boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
        {
          edge_t e(*ei);
          goal_edge[e] 
            = !outer_face_edge[e] && (source(e,g) == y || target(e,g) == y);
          forbidden_edge[*ei] = outer_face_edge[*ei];
        }

      vertex_t y_ancestor = v;
      vertex_t y_endpoint = graph_traits<Graph>::null_vertex();
      
      while(y_endpoint == graph_traits<Graph>::null_vertex())
        { 
          y_ancestor = dfs_parent[y_ancestor];
          y_endpoint = kuratowski_walkup(y_ancestor, 
                                         forbidden_edge, 
                                         goal_edge,
                                         is_embedded,
                                         y_external_path
                                         );
          
        }            
      

      vertex_t parent, child;
      
      //If v isn't on the same bicomp as x and y, it's a case A
      if (bicomp_root != v)
        {
          chosen_case = detail::BM_CASE_A;

          for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
            if (lower_face_vertex[*vi])
              for(boost::tie(oei,oei_end) = out_edges(*vi,g); oei != oei_end; ++oei)
                if(!outer_face_edge[*oei])
                  goal_edge[*oei] = true;
          
          for(boost::tie(ei,ei_end) = edges(g); ei != ei_end; ++ei)
            forbidden_edge[*ei] = outer_face_edge[*ei];
          
          z = kuratowski_walkup
            (v, forbidden_edge, goal_edge, is_embedded, z_v_path);
          
        }
      else if (w != graph_traits<Graph>::null_vertex())
        {
          chosen_case = detail::BM_CASE_B;

          for(boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
            {
              edge_t e(*ei);
              goal_edge[e] = false;
              forbidden_edge[e] = outer_face_edge[e];
            }
          
          goal_edge[w_handle.first_edge()] = true;
          goal_edge[w_handle.second_edge()] = true;

          z = kuratowski_walkup(v,
                                forbidden_edge, 
                                goal_edge,
                                is_embedded,
                                z_v_path
                                );
              

          for(boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
            {
              forbidden_edge[*ei] = outer_face_edge[*ei];
            }

          typename std::vector<edge_t>::iterator pi, pi_end;
          pi_end = z_v_path.end();
          for(pi = z_v_path.begin(); pi != pi_end; ++pi)
            {
              goal_edge[*pi] = true;
            }
          
          w_ancestor = v;
          vertex_t w_endpoint = graph_traits<Graph>::null_vertex();
          
          while(w_endpoint == graph_traits<Graph>::null_vertex())
            { 
              w_ancestor = dfs_parent[w_ancestor];
              w_endpoint = kuratowski_walkup(w_ancestor, 
                                             forbidden_edge, 
                                             goal_edge,
                                             is_embedded,
                                             w_path
                                             );
              
            }            
          
          // We really want both the w walkup and the z walkup to finish on 
          // exactly the same edge, but for convenience (since we don't have 
          // control over which side of a bicomp a walkup moves up) we've 
          // defined the walkup to either end at w_handle.first_edge() or 
          // w_handle.second_edge(). If both walkups ended at different edges, 
          // we'll do a little surgery on the w walkup path to make it follow 
          // the other side of the final bicomp.

          if ((w_path.back() == w_handle.first_edge() && 
               z_v_path.back() == w_handle.second_edge()) 
              ||
              (w_path.back() == w_handle.second_edge() && 
               z_v_path.back() == w_handle.first_edge())
              )
            {
              walkup_itr_t wi, wi_end;
              edge_t final_edge = w_path.back();
              vertex_t anchor 
                = source(final_edge, g) == w_handle.get_anchor() ? 
                target(final_edge, g) : source(final_edge, g);
              if (face_handles[anchor].first_edge() == final_edge)
                wi = walkup_itr_t(anchor, face_handles, second_side());
              else
                wi = walkup_itr_t(anchor, face_handles, first_side());

              w_path.pop_back();

              for(; wi != wi_end; ++wi)
                {
                  edge_t e(*wi);
                  if (w_path.back() == e)
                    w_path.pop_back();
                  else
                    w_path.push_back(e);
                }
            }

          
        }
      else 
        {

          //We need to find a valid z, since the x-y path re-defines the lower
          //face, and the z we found earlier may now be on the upper face.

          chosen_case = detail::BM_CASE_E;


          // The z we've used so far is just an externally active vertex on the
          // lower face path, but may not be the z we need for a case C, D, or
          // E subgraph. the z we need now is any externally active vertex on 
          // the lower face path with both old_face_handles edges on the outer
          // face. Since we know an x-y path exists, such a z must also exist.

          //TODO: find this z in the first place.

          //find the new z

          for(face_itr = x_lower_itr; *face_itr != y; ++face_itr)
            {
              vertex_t possible_z(*face_itr);
              if (pertinent(possible_z,v) && 
                  outer_face_edge[face_handles[possible_z].old_first_edge()] &&
                  outer_face_edge[face_handles[possible_z].old_second_edge()]
                  )
                {
                  z = possible_z;
                  break;
                }
            }

          //find x-y path, and a w if one exists.

          if (externally_active(z,v))
            w = z;
          

          typedef typename face_edge_iterator
            <single_side, previous_iteration>::type old_face_iterator_t; 

          old_face_iterator_t 
            first_old_face_itr(z, face_handles, first_side());
          old_face_iterator_t 
            second_old_face_itr(z, face_handles, second_side());
          old_face_iterator_t old_face_itr, old_face_end;

          std::vector<old_face_iterator_t> old_face_iterators;
          old_face_iterators.push_back(first_old_face_itr);
          old_face_iterators.push_back(second_old_face_itr);

          std::vector<bool> x_y_path_vertex_vector(num_vertices(g), false);
          vertex_to_bool_map_t x_y_path_vertex
            (x_y_path_vertex_vector.begin(), vm);

          typename std::vector<old_face_iterator_t>::iterator 
            of_itr, of_itr_end;
          of_itr_end = old_face_iterators.end(); 
          for(of_itr = old_face_iterators.begin(); 
              of_itr != of_itr_end; ++of_itr
              )
            {

              old_face_itr = *of_itr;

              vertex_t previous_vertex;
              bool seen_x_or_y = false;
              vertex_t current_vertex = z;
              for(; old_face_itr != old_face_end; ++old_face_itr)
                {
                  edge_t e(*old_face_itr);
                  previous_vertex = current_vertex;
                  current_vertex = source(e,g) == current_vertex ? 
                    target(e,g) : source(e,g);
                  
                  if (current_vertex == x || current_vertex == y)
                    seen_x_or_y = true;

                  if (w == graph_traits<Graph>::null_vertex() && 
                      externally_active(current_vertex,v) &&
                      outer_face_edge[e] &&
                      outer_face_edge[*boost::next(old_face_itr)] &&
                      !seen_x_or_y
                      )
                    {
                      w = current_vertex;
                    }
                  
                  if (!outer_face_edge[e])
                    {
                      if (!upper_face_vertex[current_vertex] && 
                          !lower_face_vertex[current_vertex]
                          )
                        {
                          x_y_path_vertex[current_vertex] = true;
                        }

                      is_in_subgraph[e] = true;
                      if (upper_face_vertex[source(e,g)] || 
                          lower_face_vertex[source(e,g)]
                          )
                        {
                          if (first_x_y_path_endpoint == 
                              graph_traits<Graph>::null_vertex()
                              )
                            first_x_y_path_endpoint = source(e,g);
                          else
                            second_x_y_path_endpoint = source(e,g);
                        }
                      if (upper_face_vertex[target(e,g)] || 
                          lower_face_vertex[target(e,g)]
                          )
                        {
                          if (first_x_y_path_endpoint == 
                              graph_traits<Graph>::null_vertex()
                              )
                            first_x_y_path_endpoint = target(e,g);
                          else
                            second_x_y_path_endpoint = target(e,g);
                        }


                    }
                  else if (previous_vertex == x || previous_vertex == y)
                    {
                      chosen_case = detail::BM_CASE_C;
                    }
              
                }

            }

          // Look for a case D - one of v's embedded edges will connect to the 
          // x-y path along an inner face path.

          //First, get a list of all of v's embedded child edges

          out_edge_iterator_t v_edge_itr, v_edge_end;
          for(boost::tie(v_edge_itr,v_edge_end) = out_edges(v,g); 
              v_edge_itr != v_edge_end; ++v_edge_itr
              )
            {
              edge_t embedded_edge(*v_edge_itr);
             
              if (!is_embedded[embedded_edge] || 
                  embedded_edge == dfs_parent_edge[v]
                  )
                continue;

              case_d_edges.push_back(embedded_edge);

              vertex_t current_vertex 
                = source(embedded_edge,g) == v ? 
                target(embedded_edge,g) : source(embedded_edge,g);

              typename face_edge_iterator<>::type 
                internal_face_itr, internal_face_end;
              if (face_handles[current_vertex].first_vertex() == v)
                {
                  internal_face_itr = typename face_edge_iterator<>::type
                    (current_vertex, face_handles, second_side());
                }
              else
                {
                  internal_face_itr = typename face_edge_iterator<>::type
                    (current_vertex, face_handles, first_side());
                }

              while(internal_face_itr != internal_face_end &&
                    !outer_face_edge[*internal_face_itr] && 
                    !x_y_path_vertex[current_vertex]
                    )
                {
                  edge_t e(*internal_face_itr);
                  case_d_edges.push_back(e);
                  current_vertex = 
                    source(e,g) == current_vertex ? target(e,g) : source(e,g);
                  ++internal_face_itr;
                }

              if (x_y_path_vertex[current_vertex])
                {
                  chosen_case = detail::BM_CASE_D;
                  break;
                }
              else
                {
                  case_d_edges.clear();
                }

            }
          

        }




      if (chosen_case != detail::BM_CASE_B && chosen_case != detail::BM_CASE_A)
        {

          //Finding z and w.

          for(boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
            {
              edge_t e(*ei);
              goal_edge[e] = !outer_face_edge[e] && 
                (source(e,g) == z || target(e,g) == z);
              forbidden_edge[e] = outer_face_edge[e];
            }

          kuratowski_walkup(v,
                            forbidden_edge, 
                            goal_edge,
                            is_embedded,
                            z_v_path
                            );
              
          if (chosen_case == detail::BM_CASE_E)
            {

              for(boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
                {
                  forbidden_edge[*ei] = outer_face_edge[*ei];
                  goal_edge[*ei] = !outer_face_edge[*ei] && 
                    (source(*ei,g) == w || target(*ei,g) == w);
                }

              for(boost::tie(oei, oei_end) = out_edges(w,g); oei != oei_end; ++oei)
                {
                  if (!outer_face_edge[*oei])
                    goal_edge[*oei] = true;
                }

              typename std::vector<edge_t>::iterator pi, pi_end;
              pi_end = z_v_path.end();
              for(pi = z_v_path.begin(); pi != pi_end; ++pi)
                {
                  goal_edge[*pi] = true;
                }
          
              w_ancestor = v;
              vertex_t w_endpoint = graph_traits<Graph>::null_vertex();
          
              while(w_endpoint == graph_traits<Graph>::null_vertex())
                { 
                  w_ancestor = dfs_parent[w_ancestor];
                  w_endpoint = kuratowski_walkup(w_ancestor, 
                                                 forbidden_edge, 
                                                 goal_edge,
                                                 is_embedded,
                                                 w_path
                                                 );
                  
                }            
 
            }


        }


      //We're done isolating the Kuratowski subgraph at this point -
      //but there's still some cleaning up to do.

      //Update is_in_subgraph with the paths we just found

      xi_end = x_external_path.end();
      for(xi = x_external_path.begin(); xi != xi_end; ++xi)
        is_in_subgraph[*xi] = true;

      xi_end = y_external_path.end();
      for(xi = y_external_path.begin(); xi != xi_end; ++xi)
        is_in_subgraph[*xi] = true;

      xi_end = z_v_path.end();
      for(xi = z_v_path.begin(); xi != xi_end; ++xi)
        is_in_subgraph[*xi] = true;

      xi_end = case_d_edges.end();
      for(xi = case_d_edges.begin(); xi != xi_end; ++xi)
        is_in_subgraph[*xi] = true;

      xi_end = w_path.end();
      for(xi = w_path.begin(); xi != xi_end; ++xi)
        is_in_subgraph[*xi] = true;
      
      child = bicomp_root;
      parent = dfs_parent[child];
      while(child != parent)
        {
          is_in_subgraph[dfs_parent_edge[child]] = true;
          boost::tie(parent, child) = std::make_pair( dfs_parent[parent], parent );
        }




      // At this point, we've already isolated the Kuratowski subgraph and 
      // collected all of the edges that compose it in the is_in_subgraph 
      // property map. But we want the verification of such a subgraph to be 
      // a deterministic process, and we can simplify the function 
      // is_kuratowski_subgraph by cleaning up some edges here.

      if (chosen_case == detail::BM_CASE_B)
        {
          is_in_subgraph[dfs_parent_edge[v]] = false;
        }
      else if (chosen_case == detail::BM_CASE_C)
        {
          // In a case C subgraph, at least one of the x-y path endpoints
          // (call it alpha) is above either x or y on the outer face. The
          // other endpoint may be attached at x or y OR above OR below. In
          // any of these three cases, we can form a K_3_3 by removing the 
          // edge attached to v on the outer face that is NOT on the path to 
          // alpha.

          typename face_vertex_iterator<single_side, follow_visitor>::type 
            face_itr, face_end;
          if (face_handles[v_dfchild_handle.first_vertex()].first_edge() == 
              v_dfchild_handle.first_edge()
              )
            {
              face_itr = typename face_vertex_iterator
                <single_side, follow_visitor>::type
                (v_dfchild_handle.first_vertex(), face_handles, second_side());
            }
          else
            {
              face_itr = typename face_vertex_iterator
                <single_side, follow_visitor>::type
                (v_dfchild_handle.first_vertex(), face_handles, first_side());
            }

          for(; true; ++face_itr)
            {
              vertex_t current_vertex(*face_itr);
              if (current_vertex == x || current_vertex == y)
                {
                  is_in_subgraph[v_dfchild_handle.first_edge()] = false;
                  break;
                }
              else if (current_vertex == first_x_y_path_endpoint ||
                       current_vertex == second_x_y_path_endpoint)
                {
                  is_in_subgraph[v_dfchild_handle.second_edge()] = false;
                  break;
                }
            }
          
        }
      else if (chosen_case == detail::BM_CASE_D)
        {
          // Need to remove both of the edges adjacent to v on the outer face.
          // remove the connecting edges from v to bicomp, then
          // is_kuratowski_subgraph will shrink vertices of degree 1 
          // automatically...

          is_in_subgraph[v_dfchild_handle.first_edge()] = false;
          is_in_subgraph[v_dfchild_handle.second_edge()] = false;

        }
      else if (chosen_case == detail::BM_CASE_E)
        {
          // Similarly to case C, if the endpoints of the x-y path are both 
          // below x and y, we should remove an edge to allow the subgraph to 
          // contract to a K_3_3.


          if ((first_x_y_path_endpoint != x && first_x_y_path_endpoint != y) ||
              (second_x_y_path_endpoint != x && second_x_y_path_endpoint != y)
              )
            {
              is_in_subgraph[dfs_parent_edge[v]] = false;              

              vertex_t deletion_endpoint, other_endpoint;
              if (lower_face_vertex[first_x_y_path_endpoint])
                {
                  deletion_endpoint = second_x_y_path_endpoint;
                  other_endpoint = first_x_y_path_endpoint;
                }
              else
                {                
                  deletion_endpoint = first_x_y_path_endpoint;
                  other_endpoint = second_x_y_path_endpoint;
                }

              typename face_edge_iterator<>::type face_itr, face_end;
              
              bool found_other_endpoint = false;
              for(face_itr = typename face_edge_iterator<>::type
                    (deletion_endpoint, face_handles, first_side());
                  face_itr != face_end; ++face_itr
                  )
                {
                  edge_t e(*face_itr);
                  if (source(e,g) == other_endpoint || 
                      target(e,g) == other_endpoint
                      )
                    {
                      found_other_endpoint = true;
                      break;
                    }
                }

              if (found_other_endpoint)
                {
                  is_in_subgraph[face_handles[deletion_endpoint].first_edge()] 
                    = false;
                }
              else
                {
                  is_in_subgraph[face_handles[deletion_endpoint].second_edge()]
                    = false;
                }
            }
          
        }


      for(boost::tie(ei, ei_end) = edges(g); ei != ei_end; ++ei)
        if (is_in_subgraph[*ei])
          *o_itr = *ei;
      
    }




    template<typename EdgePermutation>
    void make_edge_permutation(EdgePermutation perm)
    {
      vertex_iterator_t vi, vi_end;
      for(boost::tie(vi,vi_end) = vertices(g); vi != vi_end; ++vi)
        {
          vertex_t v(*vi);
          perm[v].clear();
          face_handles[v].get_list(std::back_inserter(perm[v]));
        }
    }
